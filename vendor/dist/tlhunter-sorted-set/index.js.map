{"version":3,"file":"tlhunter-sorted-set/index.js","sources":["webpack:///./tlhunter-sorted-set/lib/intersect.js","webpack:///./tlhunter-sorted-set/lib/set.js"],"sourcesContent":["function binaryIntersect(a, b) {\n  let lookup = Object.create(null), result = [];\n  for (; a; a = a.next[0].next)\n    lookup[a.key] = true;\n  for (; b; b = b.next[0].next)\n    if (lookup[b.key])\n      result.push(b.key);\n  return result;\n}\n\nfunction ternaryIntersect(a, b, c) {\n  let lookup = Object.create(null), result = [];\n  for (; a; a = a.next[0].next)\n    lookup[a.key] = 0;\n  for (; b; b = b.next[0].next)\n    if (lookup[b.key] === 0)\n      lookup[b.key] = 1;\n  for (; c; c = c.next[0].next)\n    if (lookup[c.key] === 1)\n      result.push(c.key);\n  return result;\n}\n\nfunction intersect(nodes) {\n  let result, node, lookup, x, i, j, n;\n  if (!nodes.length)\n    return [];\n  for (i = nodes.length - 1; i >= 0; i--) {\n    if (!nodes[i].length) // abort\n      return [];\n    nodes[i] = nodes[i]._head.next[0].next;\n  }\n  if (nodes.length === 1)\n    return nodes[0].toArray({field: 'key'});\n  if (nodes.length === 2)\n    return binaryIntersect(nodes[0], nodes[1]);\n  if (nodes.length === 3)\n    return ternaryIntersect(nodes[0], nodes[1], nodes[2]);\n    /*return nodes[0].length <= nodes[1].length ?\n      binaryIntersect(nodes[0], nodes[1]) :\n      binaryIntersect(nodes[1], nodes[0]);*/\n  lookup = Object.create(null);\n  for (node = nodes.shift(); node; node = node.next[0].next)\n    lookup[node.key] = 0;\n  for (i = 0, n = nodes.length - 1; i < n; i++) {\n    x = 0;\n    j = i + 1;\n    for (node = nodes[i]; node; node = node.next[0].next) {\n      if (lookup[node.key] === i) {\n        lookup[node.key] = j;\n        x++;\n      }\n    }\n    if (!x) // useful?\n      return [];\n  }\n  result = [];\n  for (node = nodes[i]; node; node = node.next[0].next)\n    if (lookup[node.key] === i)\n      result.push(node.key);\n  return result;\n}\n\nmodule.exports = intersect;\n","'use strict';\n\n/*\n * TODO\n * rename most instances of \"key\" to \"member\"\n * rename most instances of \"value\" to \"score\"\n * rename private _foo methods to #foo\n */\n\nconst intersect = require('./intersect.js');\n\nconst slice = Array.prototype.slice;\nconst P = 1 / Math.E;\n\nclass SortedSet {\n  constructor(options = {}) {\n    this._unique = !!options.unique;\n    this.empty();\n  }\n\n  static intersect () {\n    return intersect.call(SortedSet, slice.call(arguments));\n  }\n\n  add(key, value) {\n    let current;\n\n    if (value == null) {\n      return this.rem(key);\n    }\n\n    current = this._map.get(key);\n\n    if (current !== undefined) {\n      if (value === current) {\n        return current;\n      }\n      this._remove(key, current);\n    }\n\n    let node = this._insert(key, value);\n    if (!node) {\n      current === undefined || this._insert(key, current);\n      // TODO: can we defer _remove until after insert?\n      throw new Error('unique constraint violated');\n    }\n\n    this._map.set(key, value);\n    return current === undefined ? null : current;\n  }\n\n  card() {\n    // Returns the sorted set cardinality (number of elements)\n    if (this.length) {\n      return this.length;\n    }\n    return 0;\n  }\n\n  count(min, max) {\n    if (!this.length) {\n      return 0;\n    }\n\n    if (min == null) {\n      min = -Infinity;\n    }\n    if (max == null) {\n      max = Infinity;\n    }\n\n    if (min <= this._head.next[0].next.value && max >= this._tail.value) {\n      return this.length;\n    }\n\n    if (max < min || min > this._tail.value || max < this._head.next[0].next.value) {\n      return 0;\n    }\n\n    let i;\n    let node = this._first(min);\n    let count = 0;\n\n    if (!node) {\n      return 0;\n    }\n\n    for (i = node.next.length - 1; i >= 0; i -= 1) {\n      while (node.next[i].next && node.next[i].next.value <= max) {\n        count += node.next[i].span;\n        node = node.next[i].next;\n      }\n    }\n\n    // feels hacky and error prone\n    return count && count + 1;\n  }\n\n  del(key) {\n    // Alias for .rem\n    return this.rem(key);\n  }\n\n  empty() {\n    this.length = 0;\n    this._level = 1;\n    this._map = new Map();\n    this._head = new Node(32, null, 0);\n    this._tail = null;\n\n    for (let i = 0; i < 32; i += 1) {\n      // hrm\n      this._head.next[i] = new Level(null, 0);\n    }\n  }\n\n  get(key) {\n    // Alias for\n    return this.score(key);\n  }\n\n  has(key) {\n    return this._map.has(key)\n  }\n\n  incrBy(increment, key) {\n    // Increases the score of the member specified by key.\n    // If member does not exist, a new member is created with\n    // the increment as its score.\n    //\n    // Parameters:\n    //   increment\n    //     number\n    //   key\n    //     string\n    //\n    // Return\n    //   number, the new score of the member\n    //\n    // TODO: Shortcut, could optimize to half\n\n    let score = this.score(key);\n\n    if (score) {\n      this.add(key, score + increment);\n      return score + increment;\n    }\n\n    this.add(key, increment);\n    return increment;\n  }\n\n  intersect() {\n    // intersect values\n    let maps = slice.call(arguments);\n    maps.unshift(this);\n    return intersect.call(this, maps);\n  }\n\n  intersectKeys() {\n    let maps = slice.call(arguments);\n    maps.unshift(this);\n    return intersectKeys.call(this, maps);\n  }\n\n  keys() {\n    if (!this.length) {\n      return [];\n    }\n\n    let i;\n    let array = new Array(this.length);\n    let node = this._head.next[0].next;\n\n    for (i = 0; node; node = node.next[0].next) {\n      array[i] = node.key;\n      i += 1;\n    }\n\n    return array;\n  }\n\n  range (start, stop, options) {\n    // Parameters:\n    //   start\n    //     inclusive\n    //   stop\n    //     inclusive\n    //   options (optional)\n    //     withScores (optional, default to false)\n    //\n    // Return:\n    //   an array\n\n    if (this.length === 0) {\n      return [];\n    }\n\n    if (start == null) {\n      start = 0;\n    } else if (start < 0) {\n      start = Math.max(this.length + start, 0);\n    }\n\n    if (stop == null) {\n      stop = this.length - 1;\n    } else if (stop < 0) {\n      stop = this.length + stop;\n    }\n\n    if (start > stop || start >= this.length) {\n      return [];\n    }\n\n    if (stop >= this.length) {\n      stop = this.length - 1;\n    }\n\n    if (typeof options !== 'object') {\n      options = {\n        withScores: false,\n      };\n    }\n\n    let i = 0;\n    let length = stop - start + 1;\n    let result\n    try {\n      result = new Array(length);\n    } catch(e) {\n      console.log('start', start);\n      console.log('stop', stop);\n      console.log('Invalid length', length);\n      throw e;\n    }\n\n    let node = start > 0 ? this._get(start) : this._head.next[0].next;\n\n    if (options.withScores) {\n      for (; length--; node = node.next[0].next) {\n        result[i] = [node.key, node.value];\n        i += 1;\n      }\n    } else {\n      for (; length--; node = node.next[0].next) {\n        result[i] = node.key;\n        i += 1;\n      }\n    }\n\n    return result;\n  };\n\n  rangeByScore(min, max, options) {\n    // Return members with score within inclusive range [min, max].\n    //\n    // Parameters:\n    //   min (number)\n    //   max (number)\n    //   options (object, optional)\n    //     withScores (bool, optional, default false)\n\n    if (!this.length) {\n      return [];\n    }\n\n    if (typeof options !== 'object') {\n      options = {\n        withScores: false,\n      };\n    }\n\n    if (min == null) {\n      min = -Infinity;\n    }\n    if (max == null) {\n      max = Infinity;\n    }\n\n    if (min <= this._head.next[0].next.value && max >= this._tail.value) {\n      return this.toArray({ withScores: options.withScores });\n    }\n\n    if (max < min || min > this._tail.value || max < this._head.next[0].next.value) {\n      return [];\n    }\n\n    let node = this._first(min);\n    let result = [];\n\n    if (options.withScores) {\n      for (; node && node.value <= max; node = node.next[0].next) {\n        result.push([node.key, node.value]);\n      }\n    } else {\n      for (; node && node.value <= max; node = node.next[0].next) {\n        result.push(node.key);\n      }\n    }\n\n    return result;\n  }\n\n  rank(key) {\n    // Rank of key, ordered by value.\n    //\n    // Return\n    //   integer\n    //     if member exists\n    ///  null\n    //     if member does not exist\n\n    let value = this._map.get(key);\n\n    if (value === undefined) {\n      return null;\n    }\n\n    let i;\n    let node = this._head;\n    let next = null;\n    let rank = -1;\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && (next.value < value || (next.value === value && next.key <= key))) {\n        rank += node.next[i].span;\n        node = next;\n      }\n      if (node.key && node.key === key) {\n        return rank;\n      }\n    }\n\n    return null;\n  }\n\n  rem(key) {\n    // Remove single member by key.\n    //\n    // Return\n    //   value of the removed key\n    //   or null if key does not exist.\n\n    let value = this._map.get(key);\n    if (value !== undefined) {\n      this._remove(key, value);\n      this._map.delete(key);\n      return value;\n    }\n    return null;\n  }\n\n  remRangeByRank (start, end) {\n    // Parameters:\n    //   start\n    //     inclusive\n    //   end\n    //     exclusive\n    //\n    // Return\n    //   positive integer, the number of removed keys.\n\n    let len = this.length;\n\n    if (!len) {\n      return 0;\n    }\n\n    if (start == null) {\n      start = 0;\n    } else if (start < 0) {\n      start = Math.max(len + start, 0);\n    }\n\n    if (end == null) {\n      end = len;\n    } else if (end < 0) {\n      end = len + end;\n    }\n\n    if (start > end || start >= len) {\n      return 0;\n    }\n    if (end > len) {\n      end = len;\n    }\n\n    if (start === 0 && end === len) {\n      this.empty();\n      return len;\n    }\n\n    let node = this._head;\n    let update = new Array(32)\n    let result, i, next;\n    let traversed = -1;\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && (traversed + node.next[i].span) < start) {\n        traversed += node.next[i].span;\n        node = next;\n      }\n      update[i] = node;\n    }\n\n    let removed = 0;\n    traversed += 1;\n    node = node.next[0].next;\n\n    while (node && traversed < end) {\n      next = node.next[0].next;\n      this._removeNode(node, update);\n      this._map.delete(node.key);\n      removed += 1;\n      traversed += 1;\n      node = next;\n    }\n\n    this.length -= removed;\n    return removed;\n  }\n\n  remRangeByScore(min, max) {\n    // Remove members with value between min and max (inclusive).\n    //\n    // Return\n    //   positive integer, the number of removed elements.\n\n    let result;\n    let removed = 0;\n\n    if (!this.length) {\n      return 0;\n    }\n\n    if (min == null) {\n      min = -Infinity;\n    }\n    if (max == null) {\n      max = Infinity;\n    }\n\n    if (min <= this._head.next[0].next.value && max >= this._tail.value) {\n      removed = this.length;\n      this.empty();\n      return removed;\n    }\n\n    let next, i;\n    let node = this._head;\n    let update = new Array(32);\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && next.value < min) {\n        node = next;\n      }\n      update[i] = node;\n    }\n    node = node.next[0].next;\n\n    while (node && node.value <= max) {\n      next = node.next[0].next;\n      this._removeNode(node, update);\n      this._map.delete(node.key);\n      removed += 1;\n      node = next;\n    }\n\n    this.length -= removed;\n    return removed;\n  }\n\n  score (member) {\n    // Return\n    //   number, the score of member in the sorted set.\n    //   null, if member does not exist in the sorted set.\n    let score = this._map.get(member);\n    return score === undefined ? null : score;\n  }\n\n  set(key, value) {\n    // Alias for\n    return this.add(key, value);\n  }\n\n  slice(start, end, options) {\n    // Almost alias for range. Only difference is that\n    // the end is exclusive i.e. not included in the range.\n    if (typeof end === 'number' && end !== 0) {\n      end -= 1;\n    }\n    return this.range(start, end, options);\n  }\n\n  toArray(options) {\n    // The whole set, ordered from smallest to largest.\n    //\n    // Parameters\n    //   options (optional)\n    //     withScores (optional, default false)\n    //       bool\n\n    if (!this.length) {\n      return [];\n    }\n\n    if (typeof options !== 'object') {\n      options = {\n        withScores: false,\n      };\n    }\n\n    let i;\n    let array = new Array(this.length);\n    let node = this._head.next[0].next;\n\n    if (options.withScores) {\n      for (i = 0; node; node = node.next[0].next) {\n        array[i] = [node.key, node.value];\n        i += 1;\n      }\n    } else {\n      for (i = 0; node; node = node.next[0].next) {\n        array[i] = node.key;\n        i += 1;\n      }\n    }\n\n    return array;\n  }\n\n  values() {\n    // Return values as an array, the smallest value first.\n\n    if (!this.length) {\n      return [];\n    }\n\n    let i;\n    let array = new Array(this.length);\n    let node = this._head.next[0].next;\n\n    for (i = 0; node; node = node.next[0].next) {\n      array[i] = node.value;\n      i += 1;\n    }\n\n    return array;\n  }\n\n  _first(min) {\n    let node = this._tail;\n\n    if (!node || node.value < min) {\n      return null;\n    }\n\n    node = this._head;\n    for (let next = null, i = this._level - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && next.value < min) {\n        node = next;\n      }\n    }\n\n    return node.next[0].next;\n  }\n\n  _get(index) {\n    // Find and return the node at index.\n    // Return null if not found.\n    //\n    // TODO: optimize when index is less than log(N) from the end\n    let i;\n    let node = this._head;\n    let distance = -1;\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      while (node.next[i].next && (distance + node.next[i].span) <= index) {\n        distance += node.next[i].span;\n        node = node.next[i].next;\n      }\n      if (distance === index) {\n        return node;\n      }\n    }\n    return null;\n  }\n\n  _insert(key, value) {\n    // precondition: does not already have key\n    // in unique mode, returns null if the value already exists\n    let update = new Array(32);\n    let rank = new Array(32);\n    let node = this._head;\n    let next = null;\n    let i;\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      rank[i] = (i === (this._level - 1) ? 0 : rank[i + 1]);\n      // TODO: optimize some more?\n      while ((next = node.next[i].next) && next.value <= value) {\n        if (next.value === value) {\n          if (this._unique) {\n            return null;\n          }\n          if (next.key >= key) {\n            break;\n          }\n        }\n        rank[i] += node.next[i].span;\n        node = next;\n      }\n      if (this._unique && node.value === value) {\n        return null;\n      }\n      update[i] = node;\n    }\n\n    if (this._unique && node.value === value) {\n      return null;\n    }\n\n    let level = randomLevel();\n    if (level > this._level) {\n      // TODO: optimize\n      for (i = this._level; i < level; i += 1) {\n        rank[i] = 0;\n        update[i] = this._head;\n        update[i].next[i].span = this.length;\n      }\n      this._level = level;\n    }\n\n    node = new Node(level, key, value);\n    for (i = 0; i < level; i += 1) {\n      node.next[i] = new Level(update[i].next[i].next, update[i].next[i].span - (rank[0] - rank[i]));\n      update[i].next[i].next = node;\n      update[i].next[i].span = (rank[0] - rank[i]) + 1;\n    }\n\n    for (i = level; i < this._level; i += 1) {\n      update[i].next[i].span++;\n    }\n\n    node.prev = (update[0] === this._head) ? null : update[0];\n    if (node.next[0].next) {\n      node.next[0].next.prev = node;\n    } else {\n      this._tail = node;\n    }\n\n    this.length += 1;\n    return node;\n  }\n\n  _next(value, node) {\n    // find node after node when value >= specified value\n    //\n    let next, i;\n\n    if (!this._tail || this._tail.value < value) {\n      return null;\n    }\n\n    // search upwards\n    for (next = null; (next = node.next[node.next.length - 1].next) && next.value < value; ) {\n      node = next;\n    }\n    if (node.value === value) {\n      return node;\n    }\n\n    // search downwards\n    for (i = node.next.length - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && next.value < value) {\n        node = next;\n      }\n\n      if (node.value === value) {\n        return node;\n      }\n    }\n    return node.next[0].next;\n  }\n\n  _remove(key, value) {\n    let update = new Array(32);\n    let node = this._head;\n    let i, next;\n\n    for (i = this._level - 1; i >= 0; i -= 1) {\n      while ((next = node.next[i].next) && (next.value < value || (next.value === value && next.key < key))) {\n        node = next;\n      }\n      update[i] = node;\n    }\n\n    node = node.next[0].next;\n\n    if (!node || value !== node.value || node.key !== key) {\n      return false;\n    }\n\n    // delete\n    this._removeNode(node, update);\n    this.length -= 1;\n  }\n\n  _removeNode(node, update) {\n    let next = null;\n    let i = 0;\n    let n = this._level;\n\n    for (; i < n; i += 1) {\n      if (update[i].next[i].next === node) {\n        update[i].next[i].span += node.next[i].span - 1;\n        update[i].next[i].next = node.next[i].next;\n      } else {\n        update[i].next[i].span -= 1;\n      }\n    }\n    if (next = node.next[0].next) {\n      next.prev = node.prev;\n    } else {\n      this._tail = node.prev;\n    }\n\n    while (this._level > 1 && !this._head.next[this._level - 1].next) {\n      this._level -= 1;\n    }\n  }\n}\n\nfunction randomLevel() {\n  let level = 1;\n  while (Math.random() < P) {\n    level += 1;\n  }\n  return level < 32 ? level : 32;\n}\n\nfunction Level(next, span) {\n  this.next = next;\n  this.span = span;\n}\n\n// value is score, sorted\n// key is obj, unique\nfunction Node(level, key, value) {\n  this.key = key;\n  this.value = value;\n  this.next = new Array(level);\n  this.prev = null;\n}\n\nfunction Entry(key, value) {\n  this.key = key;\n  this.value = value;\n}\n\nmodule.exports = SortedSet;\n"],"names":["binaryIntersect","Object","r","ternaryIntersect","n","i","Array","Math","SortedSet","arguments","Error","Map","Node","Level","intersectKeys","console","l","randomLevel"],"mappings":"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"}