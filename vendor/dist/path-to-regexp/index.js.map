{"version":3,"file":"path-to-regexp/index.js","sources":["webpack:///./path-to-regexp/index.js"],"sourcesContent":["/**\n * Expose `pathToRegexp`.\n */\n\nmodule.exports = pathToRegexp;\n\n/**\n * Match matching groups in a regular expression.\n */\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n/**\n * Normalize the given path string,\n * returning a regular expression.\n *\n * An empty array should be passed,\n * which will contain the placeholder\n * key names. For example \"/user/:id\" will\n * then contain [\"id\"].\n *\n * @param  {String|RegExp|Array} path\n * @param  {Array} keys\n * @param  {Object} options\n * @return {RegExp}\n * @api private\n */\n\nfunction pathToRegexp(path, keys, options) {\n  options = options || {};\n  keys = keys || [];\n  var strict = options.strict;\n  var end = options.end !== false;\n  var flags = options.sensitive ? '' : 'i';\n  var lookahead = options.lookahead !== false;\n  var extraOffset = 0;\n  var keysOffset = keys.length;\n  var i = 0;\n  var name = 0;\n  var pos = 0;\n  var backtrack = '';\n  var m;\n\n  if (path instanceof RegExp) {\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\n      if (m[0][0] === '\\\\') continue;\n\n      keys.push({\n        name: m[1] || name++,\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    return path;\n  }\n\n  if (Array.isArray(path)) {\n    // Map array parts into regexps and return their source. We also pass\n    // the same keys and options instance into every generation to get\n    // consistent matching groups before we join the sources together.\n    path = path.map(function (value) {\n      return pathToRegexp(value, keys, options).source;\n    });\n\n    return new RegExp(path.join('|'), flags);\n  }\n\n  if (typeof path !== 'string') {\n    throw new TypeError('path must be a string, array of strings, or regular expression');\n  }\n\n  path = path.replace(\n    /\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g,\n    function (match, slash, format, key, capture, star, optional, offset) {\n      if (match[0] === '\\\\') {\n        backtrack += match;\n        pos += 2;\n        return match;\n      }\n\n      if (match === '.') {\n        backtrack += '\\\\.';\n        extraOffset += 1;\n        pos += 1;\n        return '\\\\.';\n      }\n\n      if (slash || format) {\n        backtrack = '';\n      } else {\n        backtrack += path.slice(pos, offset);\n      }\n\n      pos = offset + match.length;\n\n      if (match === '*') {\n        extraOffset += 3;\n        return '(.*)';\n      }\n\n      if (match === '/(') {\n        backtrack += '/';\n        extraOffset += 2;\n        return '/(?:';\n      }\n\n      slash = slash || '';\n      format = format ? '\\\\.' : '';\n      optional = optional || '';\n      capture = capture ?\n        capture.replace(/\\\\.|\\*/, function (m) { return m === '*' ? '(.*)' : m; }) :\n        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');\n\n      keys.push({\n        name: key,\n        optional: !!optional,\n        offset: offset + extraOffset\n      });\n\n      var result = '(?:'\n        + format + slash + capture\n        + (star ? '((?:[/' + format + '].+?)?)' : '')\n        + ')'\n        + optional;\n\n      extraOffset += result.length - match.length;\n\n      return result;\n    });\n\n  // This is a workaround for handling unnamed matching groups.\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\n    if (m[0][0] === '\\\\') continue;\n\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\n      keys.splice(keysOffset + i, 0, {\n        name: name++, // Unnamed matching groups must be consistently linear.\n        optional: false,\n        offset: m.index\n      });\n    }\n\n    i++;\n  }\n\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\n\n  // If the path is non-ending, match until the end or a slash.\n  if (end) {\n    path += '$';\n  } else if (path[path.length - 1] !== '/') {\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\n  }\n\n  return new RegExp('^' + path, flags);\n};\n"],"names":["pathToRegexp","RegExp","Array","TypeError"],"mappings":"qDAIA,EAAO,OAAO,CAAGA,aAKjB,IAAI,EAAwB,8BAkB5B,SAASA,aAAa,CAAI,CAAE,CAAI,CAAE,CAAO,EAEvC,EAAO,GAAQ,EAAE,CACjB,IAUI,EAVA,EAAS,AAFb,GAAU,GAAW,CAAC,GAED,MAAM,CACvB,EAAM,AAAgB,KAAhB,EAAQ,GAAG,CACjB,EAAQ,EAAQ,SAAS,CAAG,GAAK,IACjC,EAAY,AAAsB,KAAtB,EAAQ,SAAS,CAC7B,EAAc,EACd,EAAa,EAAK,MAAM,CACxB,EAAI,EACJ,EAAO,EACP,EAAM,EACN,EAAY,GAGhB,GAAI,aAAgBC,OAAQ,CAC1B,KAAO,EAAI,EAAsB,IAAI,CAAC,EAAK,MAAM,GAC/B,OAAZ,CAAC,CAAC,EAAE,CAAC,EAAE,EAEX,EAAK,IAAI,CAAC,CACR,KAAM,CAAC,CAAC,EAAE,EAAI,IACd,SAAU,GACV,OAAQ,EAAE,KAAK,AACjB,GAGF,OAAO,CACT,CAEA,GAAIC,MAAM,OAAO,CAAC,GAQhB,OAAO,IAAID,OAAO,AAJlB,GAAO,EAAK,GAAG,CAAC,SAAU,CAAK,EAC7B,OAAOD,aAAa,EAAO,EAAM,GAAS,MAAM,AAClD,EAAC,EAEsB,IAAI,CAAC,KAAM,GAGpC,GAAI,AAAgB,UAAhB,OAAO,EACT,MAAM,AAAIG,UAAU,kEA+DtB,IA5DA,EAAO,EAAK,OAAO,CACjB,sDACA,SAAU,CAAK,CAAE,CAAK,CAAE,CAAM,CAAE,CAAG,CAAE,CAAO,CAAE,CAAI,CAAE,CAAQ,CAAE,CAAM,EAClE,GAAI,AAAa,OAAb,CAAK,CAAC,EAAE,CAGV,OAFA,GAAa,EACb,GAAO,EACA,EAGT,GAAI,AAAU,MAAV,EAIF,OAHA,GAAa,MACb,GAAe,EACf,GAAO,EACA,MAWT,GARI,GAAS,EACX,EAAY,GAEZ,GAAa,EAAK,KAAK,CAAC,EAAK,GAG/B,EAAM,EAAS,EAAM,MAAM,CAEvB,AAAU,MAAV,EAEF,OADA,GAAe,EACR,OAGT,GAAI,AAAU,OAAV,EAGF,OAFA,GAAa,IACb,GAAe,EACR,OAGT,EAAQ,GAAS,GACjB,EAAS,EAAS,MAAQ,GAC1B,EAAW,GAAY,GACvB,EAAU,EACR,EAAQ,OAAO,CAAC,SAAU,SAAU,CAAC,EAAI,MAAO,AAAM,MAAN,EAAY,OAAS,CAAG,GACvE,EAAY,YAAc,EAAY,SAAW,OAAS,EAAS,OAEtE,EAAK,IAAI,CAAC,CACR,KAAM,EACN,SAAU,CAAC,CAAC,EACZ,OAAQ,EAAS,CACnB,GAEA,IAAI,EAAS,MACT,EAAS,EAAQ,EAChB,GAAO,SAAW,EAAS,UAAY,EAAC,EACzC,IACA,EAIJ,OAFA,GAAe,EAAO,MAAM,CAAG,EAAM,MAAM,CAEpC,CACT,GAGK,EAAI,EAAsB,IAAI,CAAC,IACpB,OAAZ,CAAC,CAAC,EAAE,CAAC,EAAE,GAEP,GAAa,IAAM,EAAK,MAAM,EAAI,CAAI,CAAC,EAAa,EAAE,CAAC,MAAM,CAAG,EAAE,KAAK,AAAD,GACxE,EAAK,MAAM,CAAC,EAAa,EAAG,EAAG,CAC7B,KAAM,IACN,SAAU,GACV,OAAQ,EAAE,KAAK,AACjB,GAGF,KAYF,OATA,GAAQ,EAAS,GAAK,AAA0B,MAA1B,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,CAAW,IAAM,KAGxD,EACF,GAAQ,IACC,AAA0B,MAA1B,CAAI,CAAC,EAAK,MAAM,CAAG,EAAE,EAC9B,IAAQ,EAAY,UAAY,SAAQ,EAGnC,AAAIF,OAAO,IAAM,EAAM,EAChC,C"}