{"version":3,"file":"ignore/index.js","sources":["webpack:///./ignore/index.js"],"sourcesContent":["// A simple implementation of make-array\nfunction makeArray (subject) {\n  return Array.isArray(subject)\n    ? subject\n    : [subject]\n}\n\nconst UNDEFINED = undefined\nconst EMPTY = ''\nconst SPACE = ' '\nconst ESCAPE = '\\\\'\nconst REGEX_TEST_BLANK_LINE = /^\\s+$/\nconst REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\\\]|^)\\\\$/\nconst REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\\\!/\nconst REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\\\#/\nconst REGEX_SPLITALL_CRLF = /\\r?\\n/g\n\n// Invalid:\n// - /foo,\n// - ./foo,\n// - ../foo,\n// - .\n// - ..\n// Valid:\n// - .foo\nconst REGEX_TEST_INVALID_PATH = /^\\.{0,2}\\/|^\\.{1,2}$/\n\nconst REGEX_TEST_TRAILING_SLASH = /\\/$/\n\nconst SLASH = '/'\n\n// Do not use ternary expression here, since \"istanbul ignore next\" is buggy\nlet TMP_KEY_IGNORE = 'node-ignore'\n/* istanbul ignore else */\nif (typeof Symbol !== 'undefined') {\n  TMP_KEY_IGNORE = Symbol.for('node-ignore')\n}\nconst KEY_IGNORE = TMP_KEY_IGNORE\n\nconst define = (object, key, value) => {\n  Object.defineProperty(object, key, {value})\n  return value\n}\n\nconst REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g\n\nconst RETURN_FALSE = () => false\n\n// Sanitize the range of a regular expression\n// The cases are complicated, see test cases for details\nconst sanitizeRange = range => range.replace(\n  REGEX_REGEXP_RANGE,\n  (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0)\n    ? match\n    // Invalid range (out of order) which is ok for gitignore rules but\n    //   fatal for JavaScript regular expression, so eliminate it.\n    : EMPTY\n)\n\n// See fixtures #59\nconst cleanRangeBackSlash = slashes => {\n  const {length} = slashes\n  return slashes.slice(0, length - length % 2)\n}\n\n// > If the pattern ends with a slash,\n// > it is removed for the purpose of the following description,\n// > but it would only find a match with a directory.\n// > In other words, foo/ will match a directory foo and paths underneath it,\n// > but will not match a regular file or a symbolic link foo\n// >  (this is consistent with the way how pathspec works in general in Git).\n// '`foo/`' will not match regular file '`foo`' or symbolic link '`foo`'\n// -> ignore-rules will not deal with it, because it costs extra `fs.stat` call\n//      you could use option `mark: true` with `glob`\n\n// '`foo/`' should not continue with the '`..`'\nconst REPLACERS = [\n\n  [\n    // Remove BOM\n    // TODO:\n    // Other similar zero-width characters?\n    /^\\uFEFF/,\n    () => EMPTY\n  ],\n\n  // > Trailing spaces are ignored unless they are quoted with backslash (\"\\\")\n  [\n    // (a\\ ) -> (a )\n    // (a  ) -> (a)\n    // (a ) -> (a)\n    // (a \\ ) -> (a  )\n    /((?:\\\\\\\\)*?)(\\\\?\\s+)$/,\n    (_, m1, m2) => m1 + (\n      m2.indexOf('\\\\') === 0\n        ? SPACE\n        : EMPTY\n    )\n  ],\n\n  // Replace (\\ ) with ' '\n  // (\\ ) -> ' '\n  // (\\\\ ) -> '\\\\ '\n  // (\\\\\\ ) -> '\\\\ '\n  [\n    /(\\\\+?)\\s/g,\n    (_, m1) => {\n      const {length} = m1\n      return m1.slice(0, length - length % 2) + SPACE\n    }\n  ],\n\n  // Escape metacharacters\n  // which is written down by users but means special for regular expressions.\n\n  // > There are 12 characters with special meanings:\n  // > - the backslash \\,\n  // > - the caret ^,\n  // > - the dollar sign $,\n  // > - the period or dot .,\n  // > - the vertical bar or pipe symbol |,\n  // > - the question mark ?,\n  // > - the asterisk or star *,\n  // > - the plus sign +,\n  // > - the opening parenthesis (,\n  // > - the closing parenthesis ),\n  // > - and the opening square bracket [,\n  // > - the opening curly brace {,\n  // > These special characters are often called \"metacharacters\".\n  [\n    /[\\\\$.|*+(){^]/g,\n    match => `\\\\${match}`\n  ],\n\n  [\n    // > a question mark (?) matches a single character\n    /(?!\\\\)\\?/g,\n    () => '[^/]'\n  ],\n\n  // leading slash\n  [\n\n    // > A leading slash matches the beginning of the pathname.\n    // > For example, \"/*.c\" matches \"cat-file.c\" but not \"mozilla-sha1/sha1.c\".\n    // A leading slash matches the beginning of the pathname\n    /^\\//,\n    () => '^'\n  ],\n\n  // replace special metacharacter slash after the leading slash\n  [\n    /\\//g,\n    () => '\\\\/'\n  ],\n\n  [\n    // > A leading \"**\" followed by a slash means match in all directories.\n    // > For example, \"**/foo\" matches file or directory \"foo\" anywhere,\n    // > the same as pattern \"foo\".\n    // > \"**/foo/bar\" matches file or directory \"bar\" anywhere that is directly\n    // >   under directory \"foo\".\n    // Notice that the '*'s have been replaced as '\\\\*'\n    /^\\^*\\\\\\*\\\\\\*\\\\\\//,\n\n    // '**/foo' <-> 'foo'\n    () => '^(?:.*\\\\/)?'\n  ],\n\n  // starting\n  [\n    // there will be no leading '/'\n    //   (which has been replaced by section \"leading slash\")\n    // If starts with '**', adding a '^' to the regular expression also works\n    /^(?=[^^])/,\n    function startingReplacer () {\n      // If has a slash `/` at the beginning or middle\n      return !/\\/(?!$)/.test(this)\n        // > Prior to 2.22.1\n        // > If the pattern does not contain a slash /,\n        // >   Git treats it as a shell glob pattern\n        // Actually, if there is only a trailing slash,\n        //   git also treats it as a shell glob pattern\n\n        // After 2.22.1 (compatible but clearer)\n        // > If there is a separator at the beginning or middle (or both)\n        // > of the pattern, then the pattern is relative to the directory\n        // > level of the particular .gitignore file itself.\n        // > Otherwise the pattern may also match at any level below\n        // > the .gitignore level.\n        ? '(?:^|\\\\/)'\n\n        // > Otherwise, Git treats the pattern as a shell glob suitable for\n        // >   consumption by fnmatch(3)\n        : '^'\n    }\n  ],\n\n  // two globstars\n  [\n    // Use lookahead assertions so that we could match more than one `'/**'`\n    /\\\\\\/\\\\\\*\\\\\\*(?=\\\\\\/|$)/g,\n\n    // Zero, one or several directories\n    // should not use '*', or it will be replaced by the next replacer\n\n    // Check if it is not the last `'/**'`\n    (_, index, str) => index + 6 < str.length\n\n      // case: /**/\n      // > A slash followed by two consecutive asterisks then a slash matches\n      // >   zero or more directories.\n      // > For example, \"a/**/b\" matches \"a/b\", \"a/x/b\", \"a/x/y/b\" and so on.\n      // '/**/'\n      ? '(?:\\\\/[^\\\\/]+)*'\n\n      // case: /**\n      // > A trailing `\"/**\"` matches everything inside.\n\n      // #21: everything inside but it should not include the current folder\n      : '\\\\/.+'\n  ],\n\n  // normal intermediate wildcards\n  [\n    // Never replace escaped '*'\n    // ignore rule '\\*' will match the path '*'\n\n    // 'abc.*/' -> go\n    // 'abc.*'  -> skip this rule,\n    //    coz trailing single wildcard will be handed by [trailing wildcard]\n    /(^|[^\\\\]+)(\\\\\\*)+(?=.+)/g,\n\n    // '*.js' matches '.js'\n    // '*.js' doesn't match 'abc'\n    (_, p1, p2) => {\n      // 1.\n      // > An asterisk \"*\" matches anything except a slash.\n      // 2.\n      // > Other consecutive asterisks are considered regular asterisks\n      // > and will match according to the previous rules.\n      const unescaped = p2.replace(/\\\\\\*/g, '[^\\\\/]*')\n      return p1 + unescaped\n    }\n  ],\n\n  [\n    // unescape, revert step 3 except for back slash\n    // For example, if a user escape a '\\\\*',\n    // after step 3, the result will be '\\\\\\\\\\\\*'\n    /\\\\\\\\\\\\(?=[$.|*+(){^])/g,\n    () => ESCAPE\n  ],\n\n  [\n    // '\\\\\\\\' -> '\\\\'\n    /\\\\\\\\/g,\n    () => ESCAPE\n  ],\n\n  [\n    // > The range notation, e.g. [a-zA-Z],\n    // > can be used to match one of the characters in a range.\n\n    // `\\` is escaped by step 3\n    /(\\\\)?\\[([^\\]/]*?)(\\\\*)($|\\])/g,\n    (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE\n      // '\\\\[bar]' -> '\\\\\\\\[bar\\\\]'\n      ? `\\\\[${range}${cleanRangeBackSlash(endEscape)}${close}`\n      : close === ']'\n        ? endEscape.length % 2 === 0\n          // A normal case, and it is a range notation\n          // '[bar]'\n          // '[bar\\\\\\\\]'\n          ? `[${sanitizeRange(range)}${endEscape}]`\n          // Invalid range notaton\n          // '[bar\\\\]' -> '[bar\\\\\\\\]'\n          : '[]'\n        : '[]'\n  ],\n\n  // ending\n  [\n    // 'js' will not match 'js.'\n    // 'ab' will not match 'abc'\n    /(?:[^*])$/,\n\n    // WTF!\n    // https://git-scm.com/docs/gitignore\n    // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)\n    // which re-fixes #24, #38\n\n    // > If there is a separator at the end of the pattern then the pattern\n    // > will only match directories, otherwise the pattern can match both\n    // > files and directories.\n\n    // 'js*' will not match 'a.js'\n    // 'js/' will not match 'a.js'\n    // 'js' will match 'a.js' and 'a.js/'\n    match => /\\/$/.test(match)\n      // foo/ will not match 'foo'\n      ? `${match}$`\n      // foo matches 'foo' and 'foo/'\n      : `${match}(?=$|\\\\/$)`\n  ]\n]\n\nconst REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\\\\/)?\\\\\\*$/\nconst MODE_IGNORE = 'regex'\nconst MODE_CHECK_IGNORE = 'checkRegex'\nconst UNDERSCORE = '_'\n\nconst TRAILING_WILD_CARD_REPLACERS = {\n  [MODE_IGNORE] (_, p1) {\n    const prefix = p1\n      // '\\^':\n      // '/*' does not match EMPTY\n      // '/*' does not match everything\n\n      // '\\\\\\/':\n      // 'abc/*' does not match 'abc/'\n      ? `${p1}[^/]+`\n\n      // 'a*' matches 'a'\n      // 'a*' matches 'aa'\n      : '[^/]*'\n\n    return `${prefix}(?=$|\\\\/$)`\n  },\n\n  [MODE_CHECK_IGNORE] (_, p1) {\n    // When doing `git check-ignore`\n    const prefix = p1\n      // '\\\\\\/':\n      // 'abc/*' DOES match 'abc/' !\n      ? `${p1}[^/]*`\n\n      // 'a*' matches 'a'\n      // 'a*' matches 'aa'\n      : '[^/]*'\n\n    return `${prefix}(?=$|\\\\/$)`\n  }\n}\n\n// @param {pattern}\nconst makeRegexPrefix = pattern => REPLACERS.reduce(\n  (prev, [matcher, replacer]) =>\n    prev.replace(matcher, replacer.bind(pattern)),\n  pattern\n)\n\nconst isString = subject => typeof subject === 'string'\n\n// > A blank line matches no files, so it can serve as a separator for readability.\nconst checkPattern = pattern => pattern\n  && isString(pattern)\n  && !REGEX_TEST_BLANK_LINE.test(pattern)\n  && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern)\n\n  // > A line starting with # serves as a comment.\n  && pattern.indexOf('#') !== 0\n\nconst splitPattern = pattern => pattern\n.split(REGEX_SPLITALL_CRLF)\n.filter(Boolean)\n\nclass IgnoreRule {\n  constructor (\n    pattern,\n    mark,\n    body,\n    ignoreCase,\n    negative,\n    prefix\n  ) {\n    this.pattern = pattern\n    this.mark = mark\n    this.negative = negative\n\n    define(this, 'body', body)\n    define(this, 'ignoreCase', ignoreCase)\n    define(this, 'regexPrefix', prefix)\n  }\n\n  get regex () {\n    const key = UNDERSCORE + MODE_IGNORE\n\n    if (this[key]) {\n      return this[key]\n    }\n\n    return this._make(MODE_IGNORE, key)\n  }\n\n  get checkRegex () {\n    const key = UNDERSCORE + MODE_CHECK_IGNORE\n\n    if (this[key]) {\n      return this[key]\n    }\n\n    return this._make(MODE_CHECK_IGNORE, key)\n  }\n\n  _make (mode, key) {\n    const str = this.regexPrefix.replace(\n      REGEX_REPLACE_TRAILING_WILDCARD,\n\n      // It does not need to bind pattern\n      TRAILING_WILD_CARD_REPLACERS[mode]\n    )\n\n    const regex = this.ignoreCase\n      ? new RegExp(str, 'i')\n      : new RegExp(str)\n\n    return define(this, key, regex)\n  }\n}\n\nconst createRule = ({\n  pattern,\n  mark\n}, ignoreCase) => {\n  let negative = false\n  let body = pattern\n\n  // > An optional prefix \"!\" which negates the pattern;\n  if (body.indexOf('!') === 0) {\n    negative = true\n    body = body.substr(1)\n  }\n\n  body = body\n  // > Put a backslash (\"\\\") in front of the first \"!\" for patterns that\n  // >   begin with a literal \"!\", for example, `\"\\!important!.txt\"`.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, '!')\n  // > Put a backslash (\"\\\") in front of the first hash for patterns that\n  // >   begin with a hash.\n  .replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, '#')\n\n  const regexPrefix = makeRegexPrefix(body)\n\n  return new IgnoreRule(\n    pattern,\n    mark,\n    body,\n    ignoreCase,\n    negative,\n    regexPrefix\n  )\n}\n\nclass RuleManager {\n  constructor (ignoreCase) {\n    this._ignoreCase = ignoreCase\n    this._rules = []\n  }\n\n  _add (pattern) {\n    // #32\n    if (pattern && pattern[KEY_IGNORE]) {\n      this._rules = this._rules.concat(pattern._rules._rules)\n      this._added = true\n      return\n    }\n\n    if (isString(pattern)) {\n      pattern = {\n        pattern\n      }\n    }\n\n    if (checkPattern(pattern.pattern)) {\n      const rule = createRule(pattern, this._ignoreCase)\n      this._added = true\n      this._rules.push(rule)\n    }\n  }\n\n  // @param {Array<string> | string | Ignore} pattern\n  add (pattern) {\n    this._added = false\n\n    makeArray(\n      isString(pattern)\n        ? splitPattern(pattern)\n        : pattern\n    ).forEach(this._add, this)\n\n    return this._added\n  }\n\n  // Test one single path without recursively checking parent directories\n  //\n  // - checkUnignored `boolean` whether should check if the path is unignored,\n  //   setting `checkUnignored` to `false` could reduce additional\n  //   path matching.\n  // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`\n\n  // @returns {TestResult} true if a file is ignored\n  test (path, checkUnignored, mode) {\n    let ignored = false\n    let unignored = false\n    let matchedRule\n\n    this._rules.forEach(rule => {\n      const {negative} = rule\n\n      //          |           ignored : unignored\n      // -------- | ---------------------------------------\n      // negative |   0:0   |   0:1   |   1:0   |   1:1\n      // -------- | ------- | ------- | ------- | --------\n      //     0    |  TEST   |  TEST   |  SKIP   |    X\n      //     1    |  TESTIF |  SKIP   |  TEST   |    X\n\n      // - SKIP: always skip\n      // - TEST: always test\n      // - TESTIF: only test if checkUnignored\n      // - X: that never happen\n      if (\n        unignored === negative && ignored !== unignored\n        || negative && !ignored && !unignored && !checkUnignored\n      ) {\n        return\n      }\n\n      const matched = rule[mode].test(path)\n\n      if (!matched) {\n        return\n      }\n\n      ignored = !negative\n      unignored = negative\n\n      matchedRule = negative\n        ? UNDEFINED\n        : rule\n    })\n\n    const ret = {\n      ignored,\n      unignored\n    }\n\n    if (matchedRule) {\n      ret.rule = matchedRule\n    }\n\n    return ret\n  }\n}\n\nconst throwError = (message, Ctor) => {\n  throw new Ctor(message)\n}\n\nconst checkPath = (path, originalPath, doThrow) => {\n  if (!isString(path)) {\n    return doThrow(\n      `path must be a string, but got \\`${originalPath}\\``,\n      TypeError\n    )\n  }\n\n  // We don't know if we should ignore EMPTY, so throw\n  if (!path) {\n    return doThrow(`path must not be empty`, TypeError)\n  }\n\n  // Check if it is a relative path\n  if (checkPath.isNotRelative(path)) {\n    const r = '`path.relative()`d'\n    return doThrow(\n      `path should be a ${r} string, but got \"${originalPath}\"`,\n      RangeError\n    )\n  }\n\n  return true\n}\n\nconst isNotRelative = path => REGEX_TEST_INVALID_PATH.test(path)\n\ncheckPath.isNotRelative = isNotRelative\n\n// On windows, the following function will be replaced\n/* istanbul ignore next */\ncheckPath.convert = p => p\n\n\nclass Ignore {\n  constructor ({\n    ignorecase = true,\n    ignoreCase = ignorecase,\n    allowRelativePaths = false\n  } = {}) {\n    define(this, KEY_IGNORE, true)\n\n    this._rules = new RuleManager(ignoreCase)\n    this._strictPathCheck = !allowRelativePaths\n    this._initCache()\n  }\n\n  _initCache () {\n    // A cache for the result of `.ignores()`\n    this._ignoreCache = Object.create(null)\n\n    // A cache for the result of `.test()`\n    this._testCache = Object.create(null)\n  }\n\n  add (pattern) {\n    if (this._rules.add(pattern)) {\n      // Some rules have just added to the ignore,\n      //   making the behavior changed,\n      //   so we need to re-initialize the result cache\n      this._initCache()\n    }\n\n    return this\n  }\n\n  // legacy\n  addPattern (pattern) {\n    return this.add(pattern)\n  }\n\n  // @returns {TestResult}\n  _test (originalPath, cache, checkUnignored, slices) {\n    const path = originalPath\n      // Supports nullable path\n      && checkPath.convert(originalPath)\n\n    checkPath(\n      path,\n      originalPath,\n      this._strictPathCheck\n        ? throwError\n        : RETURN_FALSE\n    )\n\n    return this._t(path, cache, checkUnignored, slices)\n  }\n\n  checkIgnore (path) {\n    // If the path doest not end with a slash, `.ignores()` is much equivalent\n    //   to `git check-ignore`\n    if (!REGEX_TEST_TRAILING_SLASH.test(path)) {\n      return this.test(path)\n    }\n\n    const slices = path.split(SLASH).filter(Boolean)\n    slices.pop()\n\n    if (slices.length) {\n      const parent = this._t(\n        slices.join(SLASH) + SLASH,\n        this._testCache,\n        true,\n        slices\n      )\n\n      if (parent.ignored) {\n        return parent\n      }\n    }\n\n    return this._rules.test(path, false, MODE_CHECK_IGNORE)\n  }\n\n  _t (\n    // The path to be tested\n    path,\n\n    // The cache for the result of a certain checking\n    cache,\n\n    // Whether should check if the path is unignored\n    checkUnignored,\n\n    // The path slices\n    slices\n  ) {\n    if (path in cache) {\n      return cache[path]\n    }\n\n    if (!slices) {\n      // path/to/a.js\n      // ['path', 'to', 'a.js']\n      slices = path.split(SLASH).filter(Boolean)\n    }\n\n    slices.pop()\n\n    // If the path has no parent directory, just test it\n    if (!slices.length) {\n      return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE)\n    }\n\n    const parent = this._t(\n      slices.join(SLASH) + SLASH,\n      cache,\n      checkUnignored,\n      slices\n    )\n\n    // If the path contains a parent directory, check the parent first\n    return cache[path] = parent.ignored\n      // > It is not possible to re-include a file if a parent directory of\n      // >   that file is excluded.\n      ? parent\n      : this._rules.test(path, checkUnignored, MODE_IGNORE)\n  }\n\n  ignores (path) {\n    return this._test(path, this._ignoreCache, false).ignored\n  }\n\n  createFilter () {\n    return path => !this.ignores(path)\n  }\n\n  filter (paths) {\n    return makeArray(paths).filter(this.createFilter())\n  }\n\n  // @returns {TestResult}\n  test (path) {\n    return this._test(path, this._testCache, true)\n  }\n}\n\nconst factory = options => new Ignore(options)\n\nconst isPathValid = path =>\n  checkPath(path && checkPath.convert(path), path, RETURN_FALSE)\n\n/* istanbul ignore next */\nconst setupWindows = () => {\n  /* eslint no-control-regex: \"off\" */\n  const makePosix = str => /^\\\\\\\\\\?\\\\/.test(str)\n  || /[\"<>|\\u0000-\\u001F]+/u.test(str)\n    ? str\n    : str.replace(/\\\\/g, '/')\n\n  checkPath.convert = makePosix\n\n  // 'C:\\\\foo'     <- 'C:\\\\foo' has been converted to 'C:/'\n  // 'd:\\\\foo'\n  const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\\//i\n  checkPath.isNotRelative = path =>\n    REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path)\n    || isNotRelative(path)\n}\n\n\n// Windows\n// --------------------------------------------------------------\n/* istanbul ignore next */\nif (\n  // Detect `process` so that it can run in browsers.\n  typeof process !== 'undefined'\n  && process.platform === 'win32'\n) {\n  setupWindows()\n}\n\n// COMMONJS_EXPORTS ////////////////////////////////////////////////////////////\n\nmodule.exports = factory\n\n// Although it is an anti-pattern,\n//   it is still widely misused by a lot of libraries in github\n// Ref: https://github.com/search?q=ignore.default%28%29&type=code\nfactory.default = factory\n\nmodule.exports.isPathValid = isPathValid\n\n// For testing purposes\ndefine(module.exports, Symbol.for('setupWindows'), setupWindows)\n"],"names":["makeArray","Array","Symbol","define","Object","RETURN_FALSE","r","IgnoreRule","i","RegExp","RuleManager","Boolean","throwError","checkPath","TypeError","RangeError","isNotRelative","Ignore","factory","setupWindows","process"],"mappings":"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"}