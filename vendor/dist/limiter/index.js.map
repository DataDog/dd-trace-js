{"version":3,"file":"limiter/index.js","sources":["webpack:///./limiter/lib/clock.js","webpack:///./limiter/lib/rateLimiter.js","webpack:///./limiter/lib/tokenBucket.js","webpack:///./limiter/index.js"],"sourcesContent":["var getMilliseconds = function() {\r\n  if (typeof process !== 'undefined' && process.hrtime) {\r\n    var hrtime = process.hrtime();\r\n    var seconds = hrtime[0];\r\n    var nanoseconds = hrtime[1];\r\n\r\n    return seconds * 1e3 +  Math.floor(nanoseconds / 1e6);\r\n  }\r\n\r\n  return new Date().getTime();\r\n}\r\n\r\nmodule.exports = getMilliseconds;\r\n","var TokenBucket = require('./tokenBucket');\r\nvar getMilliseconds = require('./clock');\r\n\r\n/**\r\n * A generic rate limiter. Underneath the hood, this uses a token bucket plus\r\n * an additional check to limit how many tokens we can remove each interval.\r\n * @author John Hurliman <jhurliman@jhurliman.org>\r\n *\r\n * @param {Number} tokensPerInterval Maximum number of tokens that can be\r\n *  removed at any given moment and over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {Boolean} fireImmediately Optional. Whether or not the callback\r\n *  will fire immediately when rate limiting is in effect (default is false).\r\n */\r\nvar RateLimiter = function(tokensPerInterval, interval, fireImmediately) {\r\n  this.tokenBucket = new TokenBucket(tokensPerInterval, tokensPerInterval,\r\n    interval, null);\r\n\r\n  // Fill the token bucket to start\r\n  this.tokenBucket.content = tokensPerInterval;\r\n\r\n  this.curIntervalStart = getMilliseconds();\r\n  this.tokensThisInterval = 0;\r\n  this.fireImmediately = fireImmediately;\r\n};\r\n\r\nRateLimiter.prototype = {\r\n  tokenBucket: null,\r\n  curIntervalStart: 0,\r\n  tokensThisInterval: 0,\r\n  fireImmediately: false,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * rate limiter contains enough tokens and we haven't spent too many tokens\r\n   * in this interval already, this will happen immediately. Otherwise, the\r\n   * removal and callback will happen when enough tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count +\r\n        ' exceeds maximum tokens per interval ' + this.tokenBucket.bucketSize,\r\n        null));\r\n      return false;\r\n    }\r\n\r\n    var self = this;\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, wait until the\r\n    // next interval\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {\r\n      if (this.fireImmediately) {\r\n        process.nextTick(callback.bind(null, null, -1));\r\n      } else {\r\n        var waitInterval = Math.ceil(\r\n          this.curIntervalStart + this.tokenBucket.interval - now);\r\n\r\n        setTimeout(function() {\r\n          self.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n        }, waitInterval);\r\n      }\r\n      return false;\r\n    }\r\n\r\n    // Remove the requested number of tokens from the token bucket\r\n    return this.tokenBucket.removeTokens(count, afterTokensRemoved);\r\n\r\n    function afterTokensRemoved(err, tokensRemaining) {\r\n      if (err) return callback(err, null);\r\n\r\n      self.tokensThisInterval += count;\r\n      callback(null, tokensRemaining);\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens and we\r\n   * haven't spent too many tokens in this interval already, this will return\r\n   * true. Otherwise, false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Make sure the request isn't for more than we can handle\r\n    if (count > this.tokenBucket.bucketSize)\r\n      return false;\r\n\r\n    var now = getMilliseconds();\r\n\r\n    // Advance the current interval and reset the current interval token count\r\n    // if needed\r\n    if (now < this.curIntervalStart\r\n      || now - this.curIntervalStart >= this.tokenBucket.interval) {\r\n      this.curIntervalStart = now;\r\n      this.tokensThisInterval = 0;\r\n    }\r\n\r\n    // If we don't have enough tokens left in this interval, return false\r\n    if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)\r\n      return false;\r\n\r\n    // Try to remove the requested number of tokens from the token bucket\r\n    var removed = this.tokenBucket.tryRemoveTokens(count);\r\n    if (removed) {\r\n      this.tokensThisInterval += count;\r\n    }\r\n    return removed;\r\n  },\r\n\r\n  /**\r\n   * Returns the number of tokens remaining in the TokenBucket.\r\n   * @returns {Number} The number of tokens remaining.\r\n   */\r\n  getTokensRemaining: function () {\r\n    this.tokenBucket.drip();\r\n    return this.tokenBucket.content;\r\n  }\r\n};\r\n\r\nmodule.exports = RateLimiter;\r\n","\r\n/**\r\n * A hierarchical token bucket for rate limiting. See\r\n * http://en.wikipedia.org/wiki/Token_bucket for more information.\r\n * @author John Hurliman <jhurliman@cull.tv>\r\n *\r\n * @param {Number} bucketSize Maximum number of tokens to hold in the bucket.\r\n *  Also known as the burst rate.\r\n * @param {Number} tokensPerInterval Number of tokens to drip into the bucket\r\n *  over the course of one interval.\r\n * @param {String|Number} interval The interval length in milliseconds, or as\r\n *  one of the following strings: 'second', 'minute', 'hour', day'.\r\n * @param {TokenBucket} parentBucket Optional. A token bucket that will act as\r\n *  the parent of this bucket.\r\n */\r\nvar TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {\r\n  this.bucketSize = bucketSize;\r\n  this.tokensPerInterval = tokensPerInterval;\r\n\r\n  if (typeof interval === 'string') {\r\n    switch (interval) {\r\n      case 'sec': case 'second':\r\n        this.interval = 1000; break;\r\n      case 'min': case 'minute':\r\n        this.interval = 1000 * 60; break;\r\n      case 'hr': case 'hour':\r\n        this.interval = 1000 * 60 * 60; break;\r\n      case 'day':\r\n        this.interval = 1000 * 60 * 60 * 24; break;\r\n      default:\r\n        throw new Error('Invaid interval ' + interval);\r\n    }\r\n  } else {\r\n    this.interval = interval;\r\n  }\r\n\r\n  this.parentBucket = parentBucket;\r\n  this.content = 0;\r\n  this.lastDrip = +new Date();\r\n};\r\n\r\nTokenBucket.prototype = {\r\n  bucketSize: 1,\r\n  tokensPerInterval: 1,\r\n  interval: 1000,\r\n  parentBucket: null,\r\n  content: 0,\r\n  lastDrip: 0,\r\n\r\n  /**\r\n   * Remove the requested number of tokens and fire the given callback. If the\r\n   * bucket (and any parent buckets) contains enough tokens this will happen\r\n   * immediately. Otherwise, the removal and callback will happen when enough\r\n   * tokens become available.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Function} callback(err, remainingTokens)\r\n   * @returns {Boolean} True if the callback was fired immediately, otherwise\r\n   *  false.\r\n   */\r\n  removeTokens: function(count, callback) {\r\n    var self = this;\r\n\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize) {\r\n      process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));\r\n      return true;\r\n    }\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize) {\r\n      process.nextTick(callback.bind(null, 'Requested tokens ' + count + ' exceeds bucket size ' +\r\n        this.bucketSize, null));\r\n      return false;\r\n    }\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, come back later\r\n    if (count > this.content)\r\n      return comeBackLater();\r\n\r\n    if (this.parentBucket) {\r\n      // Remove the requested from the parent bucket first\r\n      return this.parentBucket.removeTokens(count, function(err, remainingTokens) {\r\n        if (err) return callback(err, null);\r\n\r\n        // Check that we still have enough tokens in this bucket\r\n        if (count > self.content)\r\n          return comeBackLater();\r\n\r\n        // Tokens were removed from the parent bucket, now remove them from\r\n        // this bucket and fire the callback. Note that we look at the current\r\n        // bucket and parent bucket's remaining tokens and return the smaller\r\n        // of the two values\r\n        self.content -= count;\r\n        callback(null, Math.min(remainingTokens, self.content));\r\n      });\r\n    } else {\r\n      // Remove the requested tokens from this bucket and fire the callback\r\n      this.content -= count;\r\n      process.nextTick(callback.bind(null, null, this.content));\r\n      return true;\r\n    }\r\n\r\n    function comeBackLater() {\r\n      // How long do we need to wait to make up the difference in tokens?\r\n      var waitInterval = Math.ceil(\r\n        (count - self.content) * (self.interval / self.tokensPerInterval));\r\n      setTimeout(function() { self.removeTokens(count, callback); }, waitInterval);\r\n      return false;\r\n    }\r\n  },\r\n\r\n  /**\r\n   * Attempt to remove the requested number of tokens and return immediately.\r\n   * If the bucket (and any parent buckets) contains enough tokens this will\r\n   * return true, otherwise false is returned.\r\n   * @param {Number} count The number of tokens to remove.\r\n   * @param {Boolean} True if the tokens were successfully removed, otherwise\r\n   *  false.\r\n   */\r\n  tryRemoveTokens: function(count) {\r\n    // Is this an infinite size bucket?\r\n    if (!this.bucketSize)\r\n      return true;\r\n\r\n    // Make sure the bucket can hold the requested number of tokens\r\n    if (count > this.bucketSize)\r\n      return false;\r\n\r\n    // Drip new tokens into this bucket\r\n    this.drip();\r\n\r\n    // If we don't have enough tokens in this bucket, return false\r\n    if (count > this.content)\r\n      return false;\r\n\r\n    // Try to remove the requested tokens from the parent bucket\r\n    if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))\r\n      return false;\r\n\r\n    // Remove the requested tokens from this bucket and return\r\n    this.content -= count;\r\n    return true;\r\n  },\r\n\r\n  /**\r\n   * Add any new tokens to the bucket since the last drip.\r\n   * @returns {Boolean} True if new tokens were added, otherwise false.\r\n   */\r\n  drip: function() {\r\n    if (!this.tokensPerInterval) {\r\n      this.content = this.bucketSize;\r\n      return;\r\n    }\r\n\r\n    var now = +new Date();\r\n    var deltaMS = Math.max(now - this.lastDrip, 0);\r\n    this.lastDrip = now;\r\n\r\n    var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);\r\n    this.content = Math.min(this.content + dripAmount, this.bucketSize);\r\n  }\r\n};\r\n\r\nmodule.exports = TokenBucket;\r\n","\r\nexports.RateLimiter = require('./lib/rateLimiter');\r\nexports.TokenBucket = require('./lib/tokenBucket');\r\n"],"names":["process","Math","Date","RateLimiter","t","setTimeout","afterTokensRemoved","TokenBucket","Error","comeBackLater","r"],"mappings":"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"}