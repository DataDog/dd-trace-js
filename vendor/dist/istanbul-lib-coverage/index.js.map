{"version":3,"file":"istanbul-lib-coverage/index.js","sources":["webpack:///./istanbul-lib-coverage/index.js","webpack:///./istanbul-lib-coverage/lib/coverage-map.js","webpack:///./istanbul-lib-coverage/lib/coverage-summary.js","webpack:///./istanbul-lib-coverage/lib/data-properties.js","webpack:///./istanbul-lib-coverage/lib/file-coverage.js","webpack:///./istanbul-lib-coverage/lib/percent.js"],"sourcesContent":["/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\n/**\n * istanbul-lib-coverage exports an API that allows you to create and manipulate\n * file coverage, coverage maps (a set of file coverage objects) and summary\n * coverage objects. File coverage for the same file can be merged as can\n * entire coverage maps.\n *\n * @module Exports\n */\nconst { FileCoverage } = require('./lib/file-coverage');\nconst { CoverageMap } = require('./lib/coverage-map');\nconst { CoverageSummary } = require('./lib/coverage-summary');\n\nmodule.exports = {\n    /**\n     * creates a coverage summary object\n     * @param {Object} obj an argument with the same semantics\n     *  as the one passed to the `CoverageSummary` constructor\n     * @returns {CoverageSummary}\n     */\n    createCoverageSummary(obj) {\n        if (obj && obj instanceof CoverageSummary) {\n            return obj;\n        }\n        return new CoverageSummary(obj);\n    },\n    /**\n     * creates a CoverageMap object\n     * @param {Object} obj optional - an argument with the same semantics\n     *  as the one passed to the CoverageMap constructor.\n     * @returns {CoverageMap}\n     */\n    createCoverageMap(obj) {\n        if (obj && obj instanceof CoverageMap) {\n            return obj;\n        }\n        return new CoverageMap(obj);\n    },\n    /**\n     * creates a FileCoverage object\n     * @param {Object} obj optional - an argument with the same semantics\n     *  as the one passed to the FileCoverage constructor.\n     * @returns {FileCoverage}\n     */\n    createFileCoverage(obj) {\n        if (obj && obj instanceof FileCoverage) {\n            return obj;\n        }\n        return new FileCoverage(obj);\n    }\n};\n\n/** classes exported for reuse */\nmodule.exports.classes = {\n    /**\n     * the file coverage constructor\n     */\n    FileCoverage\n};\n","/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst { FileCoverage } = require('./file-coverage');\nconst { CoverageSummary } = require('./coverage-summary');\n\nfunction maybeConstruct(obj, klass) {\n    if (obj instanceof klass) {\n        return obj;\n    }\n\n    return new klass(obj);\n}\n\nfunction loadMap(source) {\n    const data = Object.create(null);\n    if (!source) {\n        return data;\n    }\n\n    Object.entries(source).forEach(([k, cov]) => {\n        data[k] = maybeConstruct(cov, FileCoverage);\n    });\n\n    return data;\n}\n\n/** CoverageMap is a map of `FileCoverage` objects keyed by file paths. */\nclass CoverageMap {\n    /**\n     * @constructor\n     * @param {Object} [obj=undefined] obj A coverage map from which to initialize this\n     * map's contents. This can be the raw global coverage object.\n     */\n    constructor(obj) {\n        if (obj instanceof CoverageMap) {\n            this.data = obj.data;\n        } else {\n            this.data = loadMap(obj);\n        }\n    }\n\n    /**\n     * merges a second coverage map into this one\n     * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged\n     *  correctly for the same files and additional file coverage keys are created\n     *  as needed.\n     */\n    merge(obj) {\n        const other = maybeConstruct(obj, CoverageMap);\n        Object.values(other.data).forEach(fc => {\n            this.addFileCoverage(fc);\n        });\n    }\n\n    /**\n     * filter the coveragemap based on the callback provided\n     * @param {Function (filename)} callback - Returns true if the path\n     *  should be included in the coveragemap. False if it should be\n     *  removed.\n     */\n    filter(callback) {\n        Object.keys(this.data).forEach(k => {\n            if (!callback(k)) {\n                delete this.data[k];\n            }\n        });\n    }\n\n    /**\n     * returns a JSON-serializable POJO for this coverage map\n     * @returns {Object}\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * returns an array for file paths for which this map has coverage\n     * @returns {Array{string}} - array of files\n     */\n    files() {\n        return Object.keys(this.data);\n    }\n\n    /**\n     * returns the file coverage for the specified file.\n     * @param {String} file\n     * @returns {FileCoverage}\n     */\n    fileCoverageFor(file) {\n        const fc = this.data[file];\n        if (!fc) {\n            throw new Error(`No file coverage available for: ${file}`);\n        }\n        return fc;\n    }\n\n    /**\n     * adds a file coverage object to this map. If the path for the object,\n     * already exists in the map, it is merged with the existing coverage\n     * otherwise a new key is added to the map.\n     * @param {FileCoverage} fc the file coverage to add\n     */\n    addFileCoverage(fc) {\n        const cov = new FileCoverage(fc);\n        const { path } = cov;\n        if (this.data[path]) {\n            this.data[path].merge(cov);\n        } else {\n            this.data[path] = cov;\n        }\n    }\n\n    /**\n     * returns the coverage summary for all the file coverage objects in this map.\n     * @returns {CoverageSummary}\n     */\n    getCoverageSummary() {\n        const ret = new CoverageSummary();\n        Object.values(this.data).forEach(fc => {\n            ret.merge(fc.toSummary());\n        });\n\n        return ret;\n    }\n}\n\nmodule.exports = {\n    CoverageMap\n};\n","/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\n\nfunction blankSummary() {\n    const empty = () => ({\n        total: 0,\n        covered: 0,\n        skipped: 0,\n        pct: 'Unknown'\n    });\n\n    return {\n        lines: empty(),\n        statements: empty(),\n        functions: empty(),\n        branches: empty(),\n        branchesTrue: empty()\n    };\n}\n\n// asserts that a data object \"looks like\" a summary coverage object\nfunction assertValidSummary(obj) {\n    const valid =\n        obj && obj.lines && obj.statements && obj.functions && obj.branches;\n    if (!valid) {\n        throw new Error(\n            'Invalid summary coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\n/**\n * CoverageSummary provides a summary of code coverage . It exposes 4 properties,\n * `lines`, `statements`, `branches`, and `functions`. Each of these properties\n * is an object that has 4 keys `total`, `covered`, `skipped` and `pct`.\n * `pct` is a percentage number (0-100).\n */\nclass CoverageSummary {\n    /**\n     * @constructor\n     * @param {Object|CoverageSummary} [obj=undefined] an optional data object or\n     * another coverage summary to initialize this object with.\n     */\n    constructor(obj) {\n        if (!obj) {\n            this.data = blankSummary();\n        } else if (obj instanceof CoverageSummary) {\n            this.data = obj.data;\n        } else {\n            this.data = obj;\n        }\n        assertValidSummary(this.data);\n    }\n\n    /**\n     * merges a second summary coverage object into this one\n     * @param {CoverageSummary} obj - another coverage summary object\n     */\n    merge(obj) {\n        const keys = [\n            'lines',\n            'statements',\n            'branches',\n            'functions',\n            'branchesTrue'\n        ];\n        keys.forEach(key => {\n            if (obj[key]) {\n                this[key].total += obj[key].total;\n                this[key].covered += obj[key].covered;\n                this[key].skipped += obj[key].skipped;\n                this[key].pct = percent(this[key].covered, this[key].total);\n            }\n        });\n\n        return this;\n    }\n\n    /**\n     * returns a POJO that is JSON serializable. May be used to get the raw\n     * summary object.\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * return true if summary has no lines of code\n     */\n    isEmpty() {\n        return this.lines.total === 0;\n    }\n}\n\ndataProperties(CoverageSummary, [\n    'lines',\n    'statements',\n    'functions',\n    'branches',\n    'branchesTrue'\n]);\n\nmodule.exports = {\n    CoverageSummary\n};\n","'use strict';\n\nmodule.exports = function dataProperties(klass, properties) {\n    properties.forEach(p => {\n        Object.defineProperty(klass.prototype, p, {\n            enumerable: true,\n            get() {\n                return this.data[p];\n            }\n        });\n    });\n};\n","/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nconst percent = require('./percent');\nconst dataProperties = require('./data-properties');\nconst { CoverageSummary } = require('./coverage-summary');\n\n// returns a data object that represents empty coverage\nfunction emptyCoverage(filePath, reportLogic) {\n    const cov = {\n        path: filePath,\n        statementMap: {},\n        fnMap: {},\n        branchMap: {},\n        s: {},\n        f: {},\n        b: {}\n    };\n    if (reportLogic) cov.bT = {};\n    return cov;\n}\n\n// asserts that a data object \"looks like\" a coverage object\nfunction assertValidObject(obj) {\n    const valid =\n        obj &&\n        obj.path &&\n        obj.statementMap &&\n        obj.fnMap &&\n        obj.branchMap &&\n        obj.s &&\n        obj.f &&\n        obj.b;\n    if (!valid) {\n        throw new Error(\n            'Invalid file coverage object, missing keys, found:' +\n                Object.keys(obj).join(',')\n        );\n    }\n}\n\nconst keyFromLoc = ({ start, end }) =>\n    `${start.line}|${start.column}|${end.line}|${end.column}`;\n\nconst isObj = o => !!o && typeof o === 'object';\nconst isLineCol = o =>\n    isObj(o) && typeof o.line === 'number' && typeof o.column === 'number';\nconst isLoc = o => isObj(o) && isLineCol(o.start) && isLineCol(o.end);\nconst getLoc = o => (isLoc(o) ? o : isLoc(o.loc) ? o.loc : null);\n\n// When merging, we can have a case where two ranges cover\n// the same block of code with `hits=1`, and each carve out a\n// different range with `hits=0` to indicate it's uncovered.\n// Find the nearest container so that we can properly indicate\n// that both sections are hit.\n// Returns null if no containing item is found.\nconst findNearestContainer = (item, map) => {\n    const itemLoc = getLoc(item);\n    if (!itemLoc) return null;\n    // the B item is not an identified range in the A set, BUT\n    // it may be contained by an identified A range. If so, then\n    // any hit of that containing A range counts as a hit of this\n    // B range as well. We have to find the *narrowest* containing\n    // range to be accurate, since ranges can be hit and un-hit\n    // in a nested fashion.\n    let nearestContainingItem = null;\n    let containerDistance = null;\n    let containerKey = null;\n    for (const [i, mapItem] of Object.entries(map)) {\n        const mapLoc = getLoc(mapItem);\n        if (!mapLoc) continue;\n        // contained if all of line distances are > 0\n        // or line distance is 0 and col dist is >= 0\n        const distance = [\n            itemLoc.start.line - mapLoc.start.line,\n            itemLoc.start.column - mapLoc.start.column,\n            mapLoc.end.line - itemLoc.end.line,\n            mapLoc.end.column - itemLoc.end.column\n        ];\n        if (\n            distance[0] < 0 ||\n            distance[2] < 0 ||\n            (distance[0] === 0 && distance[1] < 0) ||\n            (distance[2] === 0 && distance[3] < 0)\n        ) {\n            continue;\n        }\n        if (nearestContainingItem === null) {\n            containerDistance = distance;\n            nearestContainingItem = mapItem;\n            containerKey = i;\n            continue;\n        }\n        // closer line more relevant than closer column\n        const closerBefore =\n            distance[0] < containerDistance[0] ||\n            (distance[0] === 0 && distance[1] < containerDistance[1]);\n        const closerAfter =\n            distance[2] < containerDistance[2] ||\n            (distance[2] === 0 && distance[3] < containerDistance[3]);\n        if (closerBefore || closerAfter) {\n            // closer\n            containerDistance = distance;\n            nearestContainingItem = mapItem;\n            containerKey = i;\n        }\n    }\n    return containerKey;\n};\n\n// either add two numbers, or all matching entries in a number[]\nconst addHits = (aHits, bHits) => {\n    if (typeof aHits === 'number' && typeof bHits === 'number') {\n        return aHits + bHits;\n    } else if (Array.isArray(aHits) && Array.isArray(bHits)) {\n        return aHits.map((a, i) => (a || 0) + (bHits[i] || 0));\n    }\n    return null;\n};\n\nconst addNearestContainerHits = (item, itemHits, map, mapHits) => {\n    const container = findNearestContainer(item, map);\n    if (container) {\n        return addHits(itemHits, mapHits[container]);\n    } else {\n        return itemHits;\n    }\n};\n\nconst mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {\n    const aItems = {};\n    for (const [key, itemHits] of Object.entries(aHits)) {\n        const item = aMap[key];\n        aItems[itemKey(item)] = [itemHits, item];\n    }\n    const bItems = {};\n    for (const [key, itemHits] of Object.entries(bHits)) {\n        const item = bMap[key];\n        bItems[itemKey(item)] = [itemHits, item];\n    }\n    const mergedItems = {};\n    for (const [key, aValue] of Object.entries(aItems)) {\n        let aItemHits = aValue[0];\n        const aItem = aValue[1];\n        const bValue = bItems[key];\n        if (!bValue) {\n            // not an identified range in b, but might be contained by one\n            aItemHits = addNearestContainerHits(aItem, aItemHits, bMap, bHits);\n        } else {\n            // is an identified range in b, so add the hits together\n            aItemHits = addHits(aItemHits, bValue[0]);\n        }\n        mergedItems[key] = [aItemHits, aItem];\n    }\n    // now find the items in b that are not in a. already added matches.\n    for (const [key, bValue] of Object.entries(bItems)) {\n        let bItemHits = bValue[0];\n        const bItem = bValue[1];\n        if (mergedItems[key]) continue;\n        // not an identified range in b, but might be contained by one\n        bItemHits = addNearestContainerHits(bItem, bItemHits, aMap, aHits);\n        mergedItems[key] = [bItemHits, bItem];\n    }\n\n    const hits = {};\n    const map = {};\n\n    Object.values(mergedItems).forEach(([itemHits, item], i) => {\n        hits[i] = itemHits;\n        map[i] = item;\n    });\n\n    return [hits, map];\n};\n\n/**\n * provides a read-only view of coverage for a single file.\n * The deep structure of this object is documented elsewhere. It has the following\n * properties:\n *\n * * `path` - the file path for which coverage is being tracked\n * * `statementMap` - map of statement locations keyed by statement index\n * * `fnMap` - map of function metadata keyed by function index\n * * `branchMap` - map of branch metadata keyed by branch index\n * * `s` - hit counts for statements\n * * `f` - hit count for functions\n * * `b` - hit count for branches\n */\nclass FileCoverage {\n    /**\n     * @constructor\n     * @param {Object|FileCoverage|String} pathOrObj is a string that initializes\n     * and empty coverage object with the specified file path or a data object that\n     * has all the required properties for a file coverage object.\n     */\n    constructor(pathOrObj, reportLogic = false) {\n        if (!pathOrObj) {\n            throw new Error(\n                'Coverage must be initialized with a path or an object'\n            );\n        }\n        if (typeof pathOrObj === 'string') {\n            this.data = emptyCoverage(pathOrObj, reportLogic);\n        } else if (pathOrObj instanceof FileCoverage) {\n            this.data = pathOrObj.data;\n        } else if (typeof pathOrObj === 'object') {\n            this.data = pathOrObj;\n        } else {\n            throw new Error('Invalid argument to coverage constructor');\n        }\n        assertValidObject(this.data);\n    }\n\n    /**\n     * returns computed line coverage from statement coverage.\n     * This is a map of hits keyed by line number in the source.\n     */\n    getLineCoverage() {\n        const statementMap = this.data.statementMap;\n        const statements = this.data.s;\n        const lineMap = Object.create(null);\n\n        Object.entries(statements).forEach(([st, count]) => {\n            /* istanbul ignore if: is this even possible? */\n            if (!statementMap[st]) {\n                return;\n            }\n            const { line } = statementMap[st].start;\n            const prevVal = lineMap[line];\n            if (prevVal === undefined || prevVal < count) {\n                lineMap[line] = count;\n            }\n        });\n        return lineMap;\n    }\n\n    /**\n     * returns an array of uncovered line numbers.\n     * @returns {Array} an array of line numbers for which no hits have been\n     *  collected.\n     */\n    getUncoveredLines() {\n        const lc = this.getLineCoverage();\n        const ret = [];\n        Object.entries(lc).forEach(([l, hits]) => {\n            if (hits === 0) {\n                ret.push(l);\n            }\n        });\n        return ret;\n    }\n\n    /**\n     * returns a map of branch coverage by source line number.\n     * @returns {Object} an object keyed by line number. Each object\n     * has a `covered`, `total` and `coverage` (percentage) property.\n     */\n    getBranchCoverageByLine() {\n        const branchMap = this.branchMap;\n        const branches = this.b;\n        const ret = {};\n        Object.entries(branchMap).forEach(([k, map]) => {\n            const line = map.line || map.loc.start.line;\n            const branchData = branches[k];\n            ret[line] = ret[line] || [];\n            ret[line].push(...branchData);\n        });\n        Object.entries(ret).forEach(([k, dataArray]) => {\n            const covered = dataArray.filter(item => item > 0);\n            const coverage = (covered.length / dataArray.length) * 100;\n            ret[k] = {\n                covered: covered.length,\n                total: dataArray.length,\n                coverage\n            };\n        });\n        return ret;\n    }\n\n    /**\n     * return a JSON-serializable POJO for this file coverage object\n     */\n    toJSON() {\n        return this.data;\n    }\n\n    /**\n     * merges a second coverage object into this one, updating hit counts\n     * @param {FileCoverage} other - the coverage object to be merged into this one.\n     *  Note that the other object should have the same structure as this one (same file).\n     */\n    merge(other) {\n        if (other.all === true) {\n            return;\n        }\n\n        if (this.all === true) {\n            this.data = other.data;\n            return;\n        }\n\n        let [hits, map] = mergeProp(\n            this.s,\n            this.statementMap,\n            other.s,\n            other.statementMap\n        );\n        this.data.s = hits;\n        this.data.statementMap = map;\n\n        const keyFromLocProp = x => keyFromLoc(x.loc);\n        const keyFromLocationsProp = x => keyFromLoc(x.locations[0]);\n\n        [hits, map] = mergeProp(\n            this.f,\n            this.fnMap,\n            other.f,\n            other.fnMap,\n            keyFromLocProp\n        );\n        this.data.f = hits;\n        this.data.fnMap = map;\n\n        [hits, map] = mergeProp(\n            this.b,\n            this.branchMap,\n            other.b,\n            other.branchMap,\n            keyFromLocationsProp\n        );\n        this.data.b = hits;\n        this.data.branchMap = map;\n\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT && other.bT) {\n            [hits, map] = mergeProp(\n                this.bT,\n                this.branchMap,\n                other.bT,\n                other.branchMap,\n                keyFromLocationsProp\n            );\n            this.data.bT = hits;\n        }\n    }\n\n    computeSimpleTotals(property) {\n        let stats = this[property];\n\n        if (typeof stats === 'function') {\n            stats = stats.call(this);\n        }\n\n        const ret = {\n            total: Object.keys(stats).length,\n            covered: Object.values(stats).filter(v => !!v).length,\n            skipped: 0\n        };\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    computeBranchTotals(property) {\n        const stats = this[property];\n        const ret = { total: 0, covered: 0, skipped: 0 };\n\n        Object.values(stats).forEach(branches => {\n            ret.covered += branches.filter(hits => hits > 0).length;\n            ret.total += branches.length;\n        });\n        ret.pct = percent(ret.covered, ret.total);\n        return ret;\n    }\n\n    /**\n     * resets hit counts for all statements, functions and branches\n     * in this coverage object resulting in zero coverage.\n     */\n    resetHits() {\n        const statements = this.s;\n        const functions = this.f;\n        const branches = this.b;\n        const branchesTrue = this.bT;\n        Object.keys(statements).forEach(s => {\n            statements[s] = 0;\n        });\n        Object.keys(functions).forEach(f => {\n            functions[f] = 0;\n        });\n        Object.keys(branches).forEach(b => {\n            branches[b].fill(0);\n        });\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (branchesTrue) {\n            Object.keys(branchesTrue).forEach(bT => {\n                branchesTrue[bT].fill(0);\n            });\n        }\n    }\n\n    /**\n     * returns a CoverageSummary for this file coverage object\n     * @returns {CoverageSummary}\n     */\n    toSummary() {\n        const ret = {};\n        ret.lines = this.computeSimpleTotals('getLineCoverage');\n        ret.functions = this.computeSimpleTotals('f', 'fnMap');\n        ret.statements = this.computeSimpleTotals('s', 'statementMap');\n        ret.branches = this.computeBranchTotals('b');\n        // Tracking additional information about branch truthiness\n        // can be optionally enabled:\n        if (this.bT) {\n            ret.branchesTrue = this.computeBranchTotals('bT');\n        }\n        return new CoverageSummary(ret);\n    }\n}\n\n// expose coverage data attributes\ndataProperties(FileCoverage, [\n    'path',\n    'statementMap',\n    'fnMap',\n    'branchMap',\n    's',\n    'f',\n    'b',\n    'bT',\n    'all'\n]);\n\nmodule.exports = {\n    FileCoverage,\n    // exported for testing\n    findNearestContainer,\n    addHits,\n    addNearestContainerHits\n};\n","/*\n Copyright 2012-2015, Yahoo Inc.\n Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.\n */\n'use strict';\n\nmodule.exports = function percent(covered, total) {\n    let tmp;\n    if (total > 0) {\n        tmp = (1000 * 100 * covered) / total;\n        return Math.floor(tmp / 10) / 100;\n    } else {\n        return 100.0;\n    }\n};\n"],"names":["maybeConstruct","loadMap","Object","CoverageMap","Error","blankSummary","empty","assertValidSummary","CoverageSummary","emptyCoverage","assertValidObject","keyFromLoc","isObj","isLineCol","isLoc","getLoc","findNearestContainer","c","addHits","Array","addNearestContainerHits","mergeProp","FileCoverage","keyFromLocationsProp","t","Math"],"mappings":"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"}