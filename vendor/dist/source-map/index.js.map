{"version":3,"file":"source-map/index.js","sources":["webpack:///./source-map/lib/array-set.js","webpack:///./source-map/lib/base64-vlq.js","webpack:///./source-map/lib/base64.js","webpack:///./source-map/lib/binary-search.js","webpack:///./source-map/lib/mapping-list.js","webpack:///./source-map/lib/read-wasm.js","webpack:///./source-map/lib/source-map-consumer.js","webpack:///./source-map/lib/source-map-generator.js","webpack:///./source-map/lib/source-node.js","webpack:///./source-map/lib/url.js","webpack:///./source-map/lib/util.js","webpack:///./source-map/lib/wasm.js","webpack:///./source-map/source-map.js"],"sourcesContent":["/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n/**\n * A data structure which is a combination of an array and a set. Adding a new\n * member is O(1), testing for membership is O(1), and finding the index of an\n * element is O(1). Removing elements from the set is not supported. Only\n * strings are supported for membership.\n */\nclass ArraySet {\n  constructor() {\n    this._array = [];\n    this._set = new Map();\n  }\n\n  /**\n   * Static method for creating ArraySet instances from an existing array.\n   */\n  static fromArray(aArray, aAllowDuplicates) {\n    const set = new ArraySet();\n    for (let i = 0, len = aArray.length; i < len; i++) {\n      set.add(aArray[i], aAllowDuplicates);\n    }\n    return set;\n  }\n\n  /**\n   * Return how many unique items are in this ArraySet. If duplicates have been\n   * added, than those do not count towards the size.\n   *\n   * @returns Number\n   */\n  size() {\n    return this._set.size;\n  }\n\n  /**\n   * Add the given string to this set.\n   *\n   * @param String aStr\n   */\n  add(aStr, aAllowDuplicates) {\n    const isDuplicate = this.has(aStr);\n    const idx = this._array.length;\n    if (!isDuplicate || aAllowDuplicates) {\n      this._array.push(aStr);\n    }\n    if (!isDuplicate) {\n      this._set.set(aStr, idx);\n    }\n  }\n\n  /**\n   * Is the given string a member of this set?\n   *\n   * @param String aStr\n   */\n  has(aStr) {\n    return this._set.has(aStr);\n  }\n\n  /**\n   * What is the index of the given string in the array?\n   *\n   * @param String aStr\n   */\n  indexOf(aStr) {\n    const idx = this._set.get(aStr);\n    if (idx >= 0) {\n      return idx;\n    }\n    throw new Error('\"' + aStr + '\" is not in the set.');\n  }\n\n  /**\n   * What is the element at the given index?\n   *\n   * @param Number aIdx\n   */\n  at(aIdx) {\n    if (aIdx >= 0 && aIdx < this._array.length) {\n      return this._array[aIdx];\n    }\n    throw new Error(\"No element indexed by \" + aIdx);\n  }\n\n  /**\n   * Returns the array representation of this set (which has the proper indices\n   * indicated by indexOf). Note that this is a copy of the internal array used\n   * for storing the members so that no one can mess with internal state.\n   */\n  toArray() {\n    return this._array.slice();\n  }\n}\nexports.ArraySet = ArraySet;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n *\n * Based on the Base 64 VLQ implementation in Closure Compiler:\n * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java\n *\n * Copyright 2011 The Closure Compiler Authors. All rights reserved.\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above\n *    copyright notice, this list of conditions and the following\n *    disclaimer in the documentation and/or other materials provided\n *    with the distribution.\n *  * Neither the name of Google Inc. nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst base64 = require(\"./base64\");\n\n// A single base 64 digit can contain 6 bits of data. For the base 64 variable\n// length quantities we use in the source map spec, the first bit is the sign,\n// the next four bits are the actual value, and the 6th bit is the\n// continuation bit. The continuation bit tells us whether there are more\n// digits in this value following this digit.\n//\n//   Continuation\n//   |    Sign\n//   |    |\n//   V    V\n//   101011\n\nconst VLQ_BASE_SHIFT = 5;\n\n// binary: 100000\nconst VLQ_BASE = 1 << VLQ_BASE_SHIFT;\n\n// binary: 011111\nconst VLQ_BASE_MASK = VLQ_BASE - 1;\n\n// binary: 100000\nconst VLQ_CONTINUATION_BIT = VLQ_BASE;\n\n/**\n * Converts from a two-complement value to a value where the sign bit is\n * placed in the least significant bit.  For example, as decimals:\n *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)\n *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)\n */\nfunction toVLQSigned(aValue) {\n  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;\n}\n\n/**\n * Returns the base 64 VLQ encoded value.\n */\nexports.encode = function base64VLQ_encode(aValue) {\n  let encoded = \"\";\n  let digit;\n\n  let vlq = toVLQSigned(aValue);\n\n  do {\n    digit = vlq & VLQ_BASE_MASK;\n    vlq >>>= VLQ_BASE_SHIFT;\n    if (vlq > 0) {\n      // There are still more digits in this value, so we must make sure the\n      // continuation bit is marked.\n      digit |= VLQ_CONTINUATION_BIT;\n    }\n    encoded += base64.encode(digit);\n  } while (vlq > 0);\n\n  return encoded;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst intToCharMap =\n  \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n\n/**\n * Encode an integer in the range of 0 to 63 to a single base 64 digit.\n */\nexports.encode = function (number) {\n  if (0 <= number && number < intToCharMap.length) {\n    return intToCharMap[number];\n  }\n  throw new TypeError(\"Must be between 0 and 63: \" + number);\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nexports.GREATEST_LOWER_BOUND = 1;\nexports.LEAST_UPPER_BOUND = 2;\n\n/**\n * Recursive implementation of binary search.\n *\n * @param aLow Indices here and lower do not contain the needle.\n * @param aHigh Indices here and higher do not contain the needle.\n * @param aNeedle The element being searched for.\n * @param aHaystack The non-empty array being searched.\n * @param aCompare Function which takes two elements and returns -1, 0, or 1.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n */\nfunction recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {\n  // This function terminates when one of the following is true:\n  //\n  //   1. We find the exact element we are looking for.\n  //\n  //   2. We did not find the exact element, but we can return the index of\n  //      the next-closest element.\n  //\n  //   3. We did not find the exact element, and there is no next-closest\n  //      element than the one we are searching for, so we return -1.\n  const mid = Math.floor((aHigh - aLow) / 2) + aLow;\n  const cmp = aCompare(aNeedle, aHaystack[mid], true);\n  if (cmp === 0) {\n    // Found the element we are looking for.\n    return mid;\n  } else if (cmp > 0) {\n    // Our needle is greater than aHaystack[mid].\n    if (aHigh - mid > 1) {\n      // The element is in the upper half.\n      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);\n    }\n\n    // The exact needle element was not found in this haystack. Determine if\n    // we are in termination case (3) or (2) and return the appropriate thing.\n    if (aBias === exports.LEAST_UPPER_BOUND) {\n      return aHigh < aHaystack.length ? aHigh : -1;\n    }\n    return mid;\n  }\n\n  // Our needle is less than aHaystack[mid].\n  if (mid - aLow > 1) {\n    // The element is in the lower half.\n    return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);\n  }\n\n  // we are in termination case (3) or (2) and return the appropriate thing.\n  if (aBias == exports.LEAST_UPPER_BOUND) {\n    return mid;\n  }\n  return aLow < 0 ? -1 : aLow;\n}\n\n/**\n * This is an implementation of binary search which will always try and return\n * the index of the closest element if there is no exact hit. This is because\n * mappings between original and generated line/col pairs are single points,\n * and there is an implicit region between each of them, so a miss just means\n * that you aren't on the very start of a region.\n *\n * @param aNeedle The element you are looking for.\n * @param aHaystack The array that is being searched.\n * @param aCompare A function which takes the needle and an element in the\n *     array and returns -1, 0, or 1 depending on whether the needle is less\n *     than, equal to, or greater than the element, respectively.\n * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or\n *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the\n *     closest element that is smaller than or greater than the one we are\n *     searching for, respectively, if the exact element cannot be found.\n *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.\n */\nexports.search = function search(aNeedle, aHaystack, aCompare, aBias) {\n  if (aHaystack.length === 0) {\n    return -1;\n  }\n\n  let index = recursiveSearch(\n    -1,\n    aHaystack.length,\n    aNeedle,\n    aHaystack,\n    aCompare,\n    aBias || exports.GREATEST_LOWER_BOUND\n  );\n  if (index < 0) {\n    return -1;\n  }\n\n  // We have found either the exact element, or the next-closest element to\n  // the one we are searching for. However, there may be more than one such\n  // element. Make sure we always return the smallest of these.\n  while (index - 1 >= 0) {\n    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {\n      break;\n    }\n    --index;\n  }\n\n  return index;\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2014 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\n\n/**\n * Determine whether mappingB is after mappingA with respect to generated\n * position.\n */\nfunction generatedPositionAfter(mappingA, mappingB) {\n  // Optimized for most common case\n  const lineA = mappingA.generatedLine;\n  const lineB = mappingB.generatedLine;\n  const columnA = mappingA.generatedColumn;\n  const columnB = mappingB.generatedColumn;\n  return (\n    lineB > lineA ||\n    (lineB == lineA && columnB >= columnA) ||\n    util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0\n  );\n}\n\n/**\n * A data structure to provide a sorted view of accumulated mappings in a\n * performance conscious manner. It trades a negligible overhead in general\n * case for a large speedup in case of mappings being added in order.\n */\nclass MappingList {\n  constructor() {\n    this._array = [];\n    this._sorted = true;\n    // Serves as infimum\n    this._last = { generatedLine: -1, generatedColumn: 0 };\n  }\n\n  /**\n   * Iterate through internal items. This method takes the same arguments that\n   * `Array.prototype.forEach` takes.\n   *\n   * NOTE: The order of the mappings is NOT guaranteed.\n   */\n  unsortedForEach(aCallback, aThisArg) {\n    this._array.forEach(aCallback, aThisArg);\n  }\n\n  /**\n   * Add the given source mapping.\n   *\n   * @param Object aMapping\n   */\n  add(aMapping) {\n    if (generatedPositionAfter(this._last, aMapping)) {\n      this._last = aMapping;\n      this._array.push(aMapping);\n    } else {\n      this._sorted = false;\n      this._array.push(aMapping);\n    }\n  }\n\n  /**\n   * Returns the flat, sorted array of mappings. The mappings are sorted by\n   * generated position.\n   *\n   * WARNING: This method returns internal data without copying, for\n   * performance. The return value must NOT be mutated, and should be treated as\n   * an immutable borrow. If you want to take ownership, you must make your own\n   * copy.\n   */\n  toArray() {\n    if (!this._sorted) {\n      this._array.sort(util.compareByGeneratedPositionsInflated);\n      this._sorted = true;\n    }\n    return this._array;\n  }\n}\n\nexports.MappingList = MappingList;\n","\"use strict\";\n\n// Note: This file is replaced with \"read-wasm-browser.js\" when this module is\n// bundled with a packager that takes package.json#browser fields into account.\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nmodule.exports = function readWasm() {\n  return new Promise((resolve, reject) => {\n    const wasmPath = path.join(__dirname, \"mappings.wasm\");\n    fs.readFile(wasmPath, null, (error, data) => {\n      if (error) {\n        reject(error);\n        return;\n      }\n\n      resolve(data.buffer);\n    });\n  });\n};\n\nmodule.exports.initialize = _ => {\n  console.debug(\n    \"SourceMapConsumer.initialize is a no-op when running in node.js\"\n  );\n};\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst util = require(\"./util\");\nconst binarySearch = require(\"./binary-search\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst base64VLQ = require(\"./base64-vlq\"); // eslint-disable-line no-unused-vars\nconst readWasm = require(\"../lib/read-wasm\");\nconst wasm = require(\"./wasm\");\n\nconst INTERNAL = Symbol(\"smcInternal\");\n\nclass SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    // If the constructor was called by super(), just return Promise<this>.\n    // Yes, this is a hack to retain the pre-existing API of the base-class\n    // constructor also being an async factory function.\n    if (aSourceMap == INTERNAL) {\n      return Promise.resolve(this);\n    }\n\n    return _factory(aSourceMap, aSourceMapURL);\n  }\n\n  static initialize(opts) {\n    readWasm.initialize(opts[\"lib/mappings.wasm\"]);\n  }\n\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return _factoryBSM(aSourceMap, aSourceMapURL);\n  }\n\n  /**\n   * Construct a new `SourceMapConsumer` from `rawSourceMap` and `sourceMapUrl`\n   * (see the `SourceMapConsumer` constructor for details. Then, invoke the `async\n   * function f(SourceMapConsumer) -> T` with the newly constructed consumer, wait\n   * for `f` to complete, call `destroy` on the consumer, and return `f`'s return\n   * value.\n   *\n   * You must not use the consumer after `f` completes!\n   *\n   * By using `with`, you do not have to remember to manually call `destroy` on\n   * the consumer, since it will be called automatically once `f` completes.\n   *\n   * ```js\n   * const xSquared = await SourceMapConsumer.with(\n   *   myRawSourceMap,\n   *   null,\n   *   async function (consumer) {\n   *     // Use `consumer` inside here and don't worry about remembering\n   *     // to call `destroy`.\n   *\n   *     const x = await whatever(consumer);\n   *     return x * x;\n   *   }\n   * );\n   *\n   * // You may not use that `consumer` anymore out here; it has\n   * // been destroyed. But you can use `xSquared`.\n   * console.log(xSquared);\n   * ```\n   */\n  static async with(rawSourceMap, sourceMapUrl, f) {\n    const consumer = await new SourceMapConsumer(rawSourceMap, sourceMapUrl);\n    try {\n      return await f(consumer);\n    } finally {\n      consumer.destroy();\n    }\n  }\n\n  /**\n   * Iterate over each mapping between an original source/line/column and a\n   * generated line/column in this source map.\n   *\n   * @param Function aCallback\n   *        The function that is called with each mapping.\n   * @param Object aContext\n   *        Optional. If specified, this object will be the value of `this` every\n   *        time that `aCallback` is called.\n   * @param aOrder\n   *        Either `SourceMapConsumer.GENERATED_ORDER` or\n   *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to\n   *        iterate over the mappings sorted by the generated file's line/column\n   *        order or the original's source/line/column order, respectively. Defaults to\n   *        `SourceMapConsumer.GENERATED_ORDER`.\n   */\n  eachMapping(aCallback, aContext, aOrder) {\n    throw new Error(\"Subclasses must implement eachMapping\");\n  }\n\n  /**\n   * Returns all generated line and column information for the original source,\n   * line, and column provided. If no column is provided, returns all mappings\n   * corresponding to a either the line we are searching for or the next\n   * closest line that has any mappings. Otherwise, returns all mappings\n   * corresponding to the given line and either the column we are searching for\n   * or the next closest column that has any offsets.\n   *\n   * The only argument is an object with the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number is 1-based.\n   *   - column: Optional. the column number in the original source.\n   *    The column number is 0-based.\n   *\n   * and an array of objects is returned, each with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *    line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *    The column number is 0-based.\n   */\n  allGeneratedPositionsFor(aArgs) {\n    throw new Error(\"Subclasses must implement allGeneratedPositionsFor\");\n  }\n\n  destroy() {\n    throw new Error(\"Subclasses must implement destroy\");\n  }\n}\n\n/**\n * The version of the source mapping spec that we are consuming.\n */\nSourceMapConsumer.prototype._version = 3;\nSourceMapConsumer.GENERATED_ORDER = 1;\nSourceMapConsumer.ORIGINAL_ORDER = 2;\n\nSourceMapConsumer.GREATEST_LOWER_BOUND = 1;\nSourceMapConsumer.LEAST_UPPER_BOUND = 2;\n\nexports.SourceMapConsumer = SourceMapConsumer;\n\n/**\n * A BasicSourceMapConsumer instance represents a parsed source map which we can\n * query for information about the original file positions by giving it a file\n * position in the generated source.\n *\n * The first parameter is the raw source map (either as a JSON string, or\n * already parsed to an object). According to the spec, source maps have the\n * following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - sources: An array of URLs to the original source files.\n *   - names: An array of identifiers which can be referenced by individual mappings.\n *   - sourceRoot: Optional. The URL root from which all sources are relative.\n *   - sourcesContent: Optional. An array of contents of the original source files.\n *   - mappings: A string of base64 VLQs which contain the actual mappings.\n *   - file: Optional. The generated file this source map is associated with.\n *\n * Here is an example source map, taken from the source map spec[0]:\n *\n *     {\n *       version : 3,\n *       file: \"out.js\",\n *       sourceRoot : \"\",\n *       sources: [\"foo.js\", \"bar.js\"],\n *       names: [\"src\", \"maps\", \"are\", \"fun\"],\n *       mappings: \"AA,AB;;ABCDE;\"\n *     }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#\n */\nclass BasicSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sources = util.getArg(sourceMap, \"sources\").map(String);\n      // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which\n      // requires the array) to play nice here.\n      const names = util.getArg(sourceMap, \"names\", []);\n      const sourceRoot = util.getArg(sourceMap, \"sourceRoot\", null);\n      const sourcesContent = util.getArg(sourceMap, \"sourcesContent\", null);\n      const mappings = util.getArg(sourceMap, \"mappings\");\n      const file = util.getArg(sourceMap, \"file\", null);\n      const x_google_ignoreList = util.getArg(\n        sourceMap,\n        \"x_google_ignoreList\",\n        null\n      );\n\n      // Once again, Sass deviates from the spec and supplies the version as a\n      // string rather than a number, so we use loose equality checking here.\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      that._sourceLookupCache = new Map();\n\n      // Pass `true` below to allow duplicate names and sources. While source maps\n      // are intended to be compressed and deduplicated, the TypeScript compiler\n      // sometimes generates source maps with duplicates in them. See Github issue\n      // #72 and bugzil.la/889492.\n      that._names = ArraySet.fromArray(names.map(String), true);\n      that._sources = ArraySet.fromArray(sources, true);\n\n      that._absoluteSources = ArraySet.fromArray(\n        that._sources.toArray().map(function (s) {\n          return util.computeSourceURL(sourceRoot, s, aSourceMapURL);\n        }),\n        true\n      );\n\n      that.sourceRoot = sourceRoot;\n      that.sourcesContent = sourcesContent;\n      that._mappings = mappings;\n      that._sourceMapURL = aSourceMapURL;\n      that.file = file;\n      that.x_google_ignoreList = x_google_ignoreList;\n\n      that._computedColumnSpans = false;\n      that._mappingsPtr = 0;\n      that._wasm = null;\n\n      return wasm().then(w => {\n        that._wasm = w;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * Utility function to find the index of a source.  Returns -1 if not\n   * found.\n   */\n  _findSourceIndex(aSource) {\n    // In the most common usecases, we'll be constantly looking up the index for the same source\n    // files, so we cache the index lookup to avoid constantly recomputing the full URLs.\n    const cachedIndex = this._sourceLookupCache.get(aSource);\n    if (typeof cachedIndex === \"number\") {\n      return cachedIndex;\n    }\n\n    // Treat the source as map-relative overall by default.\n    const sourceAsMapRelative = util.computeSourceURL(\n      null,\n      aSource,\n      this._sourceMapURL\n    );\n    if (this._absoluteSources.has(sourceAsMapRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsMapRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // Fall back to treating the source as sourceRoot-relative.\n    const sourceAsSourceRootRelative = util.computeSourceURL(\n      this.sourceRoot,\n      aSource,\n      this._sourceMapURL\n    );\n    if (this._absoluteSources.has(sourceAsSourceRootRelative)) {\n      const index = this._absoluteSources.indexOf(sourceAsSourceRootRelative);\n      this._sourceLookupCache.set(aSource, index);\n      return index;\n    }\n\n    // To avoid this cache growing forever, we do not cache lookup misses.\n    return -1;\n  }\n\n  /**\n   * Create a BasicSourceMapConsumer from a SourceMapGenerator.\n   *\n   * @param SourceMapGenerator aSourceMap\n   *        The source map that will be consumed.\n   * @param String aSourceMapURL\n   *        The URL at which the source map can be found (optional)\n   * @returns BasicSourceMapConsumer\n   */\n  static fromSourceMap(aSourceMap, aSourceMapURL) {\n    return new BasicSourceMapConsumer(aSourceMap.toString());\n  }\n\n  get sources() {\n    return this._absoluteSources.toArray();\n  }\n\n  _getMappingsPtr() {\n    if (this._mappingsPtr === 0) {\n      this._parseMappings();\n    }\n\n    return this._mappingsPtr;\n  }\n\n  /**\n   * Parse the mappings in a string in to a data structure which we can easily\n   * query (the ordered arrays in the `this.__generatedMappings` and\n   * `this.__originalMappings` properties).\n   */\n  _parseMappings() {\n    const aStr = this._mappings;\n    const size = aStr.length;\n\n    // Interpret signed result of allocate_mappings as unsigned, otherwise\n    // addresses higher than 2GB will be negative.\n    const mappingsBufPtr = this._wasm.exports.allocate_mappings(size) >>> 0;\n    const mappingsBuf = new Uint8Array(\n      this._wasm.exports.memory.buffer,\n      mappingsBufPtr,\n      size\n    );\n    for (let i = 0; i < size; i++) {\n      mappingsBuf[i] = aStr.charCodeAt(i);\n    }\n\n    const mappingsPtr = this._wasm.exports.parse_mappings(mappingsBufPtr);\n\n    if (!mappingsPtr) {\n      const error = this._wasm.exports.get_last_error();\n      let msg = `Error parsing mappings (code ${error}): `;\n\n      // XXX: keep these error codes in sync with `wasm-mappings`.\n      switch (error) {\n        case 1:\n          msg +=\n            \"the mappings contained a negative line, column, source index, or name index\";\n          break;\n        case 2:\n          msg += \"the mappings contained a number larger than 2**32\";\n          break;\n        case 3:\n          msg += \"reached EOF while in the middle of parsing a VLQ\";\n          break;\n        case 4:\n          msg += \"invalid base 64 character while parsing a VLQ\";\n          break;\n        default:\n          msg += \"unknown error code\";\n          break;\n      }\n\n      throw new Error(msg);\n    }\n\n    this._mappingsPtr = mappingsPtr;\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    const context = aContext || null;\n    const order = aOrder || SourceMapConsumer.GENERATED_ORDER;\n\n    this._wasm.withMappingCallback(\n      mapping => {\n        if (mapping.source !== null) {\n          mapping.source = this._absoluteSources.at(mapping.source);\n\n          if (mapping.name !== null) {\n            mapping.name = this._names.at(mapping.name);\n          }\n        }\n        if (this._computedColumnSpans && mapping.lastGeneratedColumn === null) {\n          mapping.lastGeneratedColumn = Infinity;\n        }\n\n        aCallback.call(context, mapping);\n      },\n      () => {\n        switch (order) {\n          case SourceMapConsumer.GENERATED_ORDER:\n            this._wasm.exports.by_generated_location(this._getMappingsPtr());\n            break;\n          case SourceMapConsumer.ORIGINAL_ORDER:\n            this._wasm.exports.by_original_location(this._getMappingsPtr());\n            break;\n          default:\n            throw new Error(\"Unknown order of iteration.\");\n        }\n      }\n    );\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    const originalLine = util.getArg(aArgs, \"line\");\n    const originalColumn = aArgs.column || 0;\n\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return [];\n    }\n\n    if (originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    const mappings = [];\n\n    this._wasm.withMappingCallback(\n      m => {\n        let lastColumn = m.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        mappings.push({\n          line: m.generatedLine,\n          column: m.generatedColumn,\n          lastColumn,\n        });\n      },\n      () => {\n        this._wasm.exports.all_generated_locations_for(\n          this._getMappingsPtr(),\n          source,\n          originalLine - 1,\n          \"column\" in aArgs,\n          originalColumn\n        );\n      }\n    );\n\n    return mappings;\n  }\n\n  destroy() {\n    if (this._mappingsPtr !== 0) {\n      this._wasm.exports.free_mappings(this._mappingsPtr);\n      this._mappingsPtr = 0;\n    }\n  }\n\n  /**\n   * Compute the last column for each generated mapping. The last column is\n   * inclusive.\n   */\n  computeColumnSpans() {\n    if (this._computedColumnSpans) {\n      return;\n    }\n\n    this._wasm.exports.compute_column_spans(this._getMappingsPtr());\n    this._computedColumnSpans = true;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    if (needle.generatedLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.generatedColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(\n      aArgs,\n      \"bias\",\n      SourceMapConsumer.GREATEST_LOWER_BOUND\n    );\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(\n      m => (mapping = m),\n      () => {\n        this._wasm.exports.original_location_for(\n          this._getMappingsPtr(),\n          needle.generatedLine - 1,\n          needle.generatedColumn,\n          bias\n        );\n      }\n    );\n\n    if (mapping) {\n      if (mapping.generatedLine === needle.generatedLine) {\n        let source = util.getArg(mapping, \"source\", null);\n        if (source !== null) {\n          source = this._absoluteSources.at(source);\n        }\n\n        let name = util.getArg(mapping, \"name\", null);\n        if (name !== null) {\n          name = this._names.at(name);\n        }\n\n        return {\n          source,\n          line: util.getArg(mapping, \"originalLine\", null),\n          column: util.getArg(mapping, \"originalColumn\", null),\n          name,\n        };\n      }\n    }\n\n    return {\n      source: null,\n      line: null,\n      column: null,\n      name: null,\n    };\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    if (!this.sourcesContent) {\n      return false;\n    }\n    return (\n      this.sourcesContent.length >= this._sources.size() &&\n      !this.sourcesContent.some(function (sc) {\n        return sc == null;\n      })\n    );\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    if (!this.sourcesContent) {\n      return null;\n    }\n\n    const index = this._findSourceIndex(aSource);\n    if (index >= 0) {\n      return this.sourcesContent[index];\n    }\n\n    // This function is used recursively from\n    // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we\n    // don't want to throw if we can't find the source - we just want to\n    // return null, so we provide a flag to exit gracefully.\n    if (nullOnMissing) {\n      return null;\n    }\n\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or\n   *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the\n   *     closest element that is smaller than or greater than the one we are\n   *     searching for, respectively, if the exact element cannot be found.\n   *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    let source = util.getArg(aArgs, \"source\");\n    source = this._findSourceIndex(source);\n    if (source < 0) {\n      return {\n        line: null,\n        column: null,\n        lastColumn: null,\n      };\n    }\n\n    const needle = {\n      source,\n      originalLine: util.getArg(aArgs, \"line\"),\n      originalColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    if (needle.originalLine < 1) {\n      throw new Error(\"Line numbers must be >= 1\");\n    }\n\n    if (needle.originalColumn < 0) {\n      throw new Error(\"Column numbers must be >= 0\");\n    }\n\n    let bias = util.getArg(\n      aArgs,\n      \"bias\",\n      SourceMapConsumer.GREATEST_LOWER_BOUND\n    );\n    if (bias == null) {\n      bias = SourceMapConsumer.GREATEST_LOWER_BOUND;\n    }\n\n    let mapping;\n    this._wasm.withMappingCallback(\n      m => (mapping = m),\n      () => {\n        this._wasm.exports.generated_location_for(\n          this._getMappingsPtr(),\n          needle.source,\n          needle.originalLine - 1,\n          needle.originalColumn,\n          bias\n        );\n      }\n    );\n\n    if (mapping) {\n      if (mapping.source === needle.source) {\n        let lastColumn = mapping.lastGeneratedColumn;\n        if (this._computedColumnSpans && lastColumn === null) {\n          lastColumn = Infinity;\n        }\n        return {\n          line: util.getArg(mapping, \"generatedLine\", null),\n          column: util.getArg(mapping, \"generatedColumn\", null),\n          lastColumn,\n        };\n      }\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null,\n    };\n  }\n}\n\nBasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;\nexports.BasicSourceMapConsumer = BasicSourceMapConsumer;\n\n/**\n * An IndexedSourceMapConsumer instance represents a parsed source map which\n * we can query for information. It differs from BasicSourceMapConsumer in\n * that it takes \"indexed\" source maps (i.e. ones with a \"sections\" field) as\n * input.\n *\n * The first parameter is a raw source map (either as a JSON string, or already\n * parsed to an object). According to the spec for indexed source maps, they\n * have the following attributes:\n *\n *   - version: Which version of the source map spec this map is following.\n *   - file: Optional. The generated file this source map is associated with.\n *   - sections: A list of section definitions.\n *\n * Each value under the \"sections\" field has two fields:\n *   - offset: The offset into the original specified at which this section\n *       begins to apply, defined as an object with a \"line\" and \"column\"\n *       field.\n *   - map: A source map definition. This source map could also be indexed,\n *       but doesn't have to be.\n *\n * Instead of the \"map\" field, it's also possible to have a \"url\" field\n * specifying a URL to retrieve a source map from, but that's currently\n * unsupported.\n *\n * Here's an example source map, taken from the source map spec[0], but\n * modified to omit a section which uses the \"url\" field.\n *\n *  {\n *    version : 3,\n *    file: \"app.js\",\n *    sections: [{\n *      offset: {line:100, column:10},\n *      map: {\n *        version : 3,\n *        file: \"section.js\",\n *        sources: [\"foo.js\", \"bar.js\"],\n *        names: [\"src\", \"maps\", \"are\", \"fun\"],\n *        mappings: \"AAAA,E;;ABCDE;\"\n *      }\n *    }],\n *  }\n *\n * The second parameter, if given, is a string whose value is the URL\n * at which the source map was found.  This URL is used to compute the\n * sources array.\n *\n * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt\n */\nclass IndexedSourceMapConsumer extends SourceMapConsumer {\n  constructor(aSourceMap, aSourceMapURL) {\n    return super(INTERNAL).then(that => {\n      let sourceMap = aSourceMap;\n      if (typeof aSourceMap === \"string\") {\n        sourceMap = util.parseSourceMapInput(aSourceMap);\n      }\n\n      const version = util.getArg(sourceMap, \"version\");\n      const sections = util.getArg(sourceMap, \"sections\");\n\n      if (version != that._version) {\n        throw new Error(\"Unsupported version: \" + version);\n      }\n\n      let lastOffset = {\n        line: -1,\n        column: 0,\n      };\n      return Promise.all(\n        sections.map(s => {\n          if (s.url) {\n            // The url field will require support for asynchronicity.\n            // See https://github.com/mozilla/source-map/issues/16\n            throw new Error(\n              \"Support for url field in sections not implemented.\"\n            );\n          }\n          const offset = util.getArg(s, \"offset\");\n          const offsetLine = util.getArg(offset, \"line\");\n          const offsetColumn = util.getArg(offset, \"column\");\n\n          if (\n            offsetLine < lastOffset.line ||\n            (offsetLine === lastOffset.line && offsetColumn < lastOffset.column)\n          ) {\n            throw new Error(\n              \"Section offsets must be ordered and non-overlapping.\"\n            );\n          }\n          lastOffset = offset;\n\n          const cons = new SourceMapConsumer(\n            util.getArg(s, \"map\"),\n            aSourceMapURL\n          );\n          return cons.then(consumer => {\n            return {\n              generatedOffset: {\n                // The offset fields are 0-based, but we use 1-based indices when\n                // encoding/decoding from VLQ.\n                generatedLine: offsetLine + 1,\n                generatedColumn: offsetColumn + 1,\n              },\n              consumer,\n            };\n          });\n        })\n      ).then(s => {\n        that._sections = s;\n        return that;\n      });\n    });\n  }\n\n  /**\n   * The list of original sources.\n   */\n  get sources() {\n    const sources = [];\n    for (let i = 0; i < this._sections.length; i++) {\n      for (let j = 0; j < this._sections[i].consumer.sources.length; j++) {\n        sources.push(this._sections[i].consumer.sources[j]);\n      }\n    }\n    return sources;\n  }\n\n  /**\n   * Returns the original source, line, and column information for the generated\n   * source's line and column positions provided. The only argument is an object\n   * with the following properties:\n   *\n   *   - line: The line number in the generated source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the generated source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - source: The original source file, or null.\n   *   - line: The line number in the original source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the original source, or null.  The\n   *     column number is 0-based.\n   *   - name: The original identifier, or null.\n   */\n  originalPositionFor(aArgs) {\n    const needle = {\n      generatedLine: util.getArg(aArgs, \"line\"),\n      generatedColumn: util.getArg(aArgs, \"column\"),\n    };\n\n    // Find the section containing the generated position we're trying to map\n    // to an original position.\n    const sectionIndex = binarySearch.search(\n      needle,\n      this._sections,\n      function (aNeedle, section) {\n        const cmp =\n          aNeedle.generatedLine - section.generatedOffset.generatedLine;\n        if (cmp) {\n          return cmp;\n        }\n\n        // The generated column is 0-based, but the section offset column is\n        // stored 1-based.\n        return (\n          aNeedle.generatedColumn -\n          (section.generatedOffset.generatedColumn - 1)\n        );\n      }\n    );\n    const section = this._sections[sectionIndex];\n\n    if (!section) {\n      return {\n        source: null,\n        line: null,\n        column: null,\n        name: null,\n      };\n    }\n\n    return section.consumer.originalPositionFor({\n      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),\n      column:\n        needle.generatedColumn -\n        (section.generatedOffset.generatedLine === needle.generatedLine\n          ? section.generatedOffset.generatedColumn - 1\n          : 0),\n      bias: aArgs.bias,\n    });\n  }\n\n  /**\n   * Return true if we have the source content for every source in the source\n   * map, false otherwise.\n   */\n  hasContentsOfAllSources() {\n    return this._sections.every(function (s) {\n      return s.consumer.hasContentsOfAllSources();\n    });\n  }\n\n  /**\n   * Returns the original source content. The only argument is the url of the\n   * original source file. Returns null if no original source content is\n   * available.\n   */\n  sourceContentFor(aSource, nullOnMissing) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const section = this._sections[i];\n\n      const content = section.consumer.sourceContentFor(aSource, true);\n      if (content) {\n        return content;\n      }\n    }\n    if (nullOnMissing) {\n      return null;\n    }\n    throw new Error('\"' + aSource + '\" is not in the SourceMap.');\n  }\n\n  _findSectionIndex(source) {\n    for (let i = 0; i < this._sections.length; i++) {\n      const { consumer } = this._sections[i];\n      if (consumer._findSourceIndex(source) !== -1) {\n        return i;\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the generated line and column information for the original source,\n   * line, and column positions provided. The only argument is an object with\n   * the following properties:\n   *\n   *   - source: The filename of the original source.\n   *   - line: The line number in the original source.  The line number\n   *     is 1-based.\n   *   - column: The column number in the original source.  The column\n   *     number is 0-based.\n   *\n   * and an object is returned with the following properties:\n   *\n   *   - line: The line number in the generated source, or null.  The\n   *     line number is 1-based.\n   *   - column: The column number in the generated source, or null.\n   *     The column number is 0-based.\n   */\n  generatedPositionFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    const generatedPosition =\n      section && section.consumer.generatedPositionFor(aArgs);\n    if (generatedPosition && generatedPosition.line !== null) {\n      const lineShift = section.generatedOffset.generatedLine - 1;\n      const columnShift = section.generatedOffset.generatedColumn - 1;\n\n      if (generatedPosition.line === 1) {\n        generatedPosition.column += columnShift;\n        if (typeof generatedPosition.lastColumn === \"number\") {\n          generatedPosition.lastColumn += columnShift;\n        }\n      }\n\n      if (\n        generatedPosition.lastColumn === Infinity &&\n        nextSection &&\n        generatedPosition.line === nextSection.generatedOffset.generatedLine\n      ) {\n        generatedPosition.lastColumn =\n          nextSection.generatedOffset.generatedColumn - 2;\n      }\n      generatedPosition.line += lineShift;\n\n      return generatedPosition;\n    }\n\n    return {\n      line: null,\n      column: null,\n      lastColumn: null,\n    };\n  }\n\n  allGeneratedPositionsFor(aArgs) {\n    const index = this._findSectionIndex(util.getArg(aArgs, \"source\"));\n    const section = index >= 0 ? this._sections[index] : null;\n    const nextSection =\n      index >= 0 && index + 1 < this._sections.length\n        ? this._sections[index + 1]\n        : null;\n\n    if (!section) return [];\n\n    return section.consumer\n      .allGeneratedPositionsFor(aArgs)\n      .map(generatedPosition => {\n        const lineShift = section.generatedOffset.generatedLine - 1;\n        const columnShift = section.generatedOffset.generatedColumn - 1;\n\n        if (generatedPosition.line === 1) {\n          generatedPosition.column += columnShift;\n          if (typeof generatedPosition.lastColumn === \"number\") {\n            generatedPosition.lastColumn += columnShift;\n          }\n        }\n\n        if (\n          generatedPosition.lastColumn === Infinity &&\n          nextSection &&\n          generatedPosition.line === nextSection.generatedOffset.generatedLine\n        ) {\n          generatedPosition.lastColumn =\n            nextSection.generatedOffset.generatedColumn - 2;\n        }\n        generatedPosition.line += lineShift;\n\n        return generatedPosition;\n      });\n  }\n\n  eachMapping(aCallback, aContext, aOrder) {\n    this._sections.forEach((section, index) => {\n      const nextSection =\n        index + 1 < this._sections.length ? this._sections[index + 1] : null;\n      const { generatedOffset } = section;\n\n      const lineShift = generatedOffset.generatedLine - 1;\n      const columnShift = generatedOffset.generatedColumn - 1;\n\n      section.consumer.eachMapping(\n        function (mapping) {\n          if (mapping.generatedLine === 1) {\n            mapping.generatedColumn += columnShift;\n\n            if (typeof mapping.lastGeneratedColumn === \"number\") {\n              mapping.lastGeneratedColumn += columnShift;\n            }\n          }\n\n          if (\n            mapping.lastGeneratedColumn === Infinity &&\n            nextSection &&\n            mapping.generatedLine === nextSection.generatedOffset.generatedLine\n          ) {\n            mapping.lastGeneratedColumn =\n              nextSection.generatedOffset.generatedColumn - 2;\n          }\n          mapping.generatedLine += lineShift;\n\n          aCallback.call(this, mapping);\n        },\n        aContext,\n        aOrder\n      );\n    });\n  }\n\n  computeColumnSpans() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.computeColumnSpans();\n    }\n  }\n\n  destroy() {\n    for (let i = 0; i < this._sections.length; i++) {\n      this._sections[i].consumer.destroy();\n    }\n  }\n}\nexports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;\n\n/*\n * Cheat to get around inter-twingled classes.  `factory()` can be at the end\n * where it has access to non-hoisted classes, but it gets hoisted itself.\n */\nfunction _factory(aSourceMap, aSourceMapURL) {\n  let sourceMap = aSourceMap;\n  if (typeof aSourceMap === \"string\") {\n    sourceMap = util.parseSourceMapInput(aSourceMap);\n  }\n\n  const consumer =\n    sourceMap.sections != null\n      ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL)\n      : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);\n  return Promise.resolve(consumer);\n}\n\nfunction _factoryBSM(aSourceMap, aSourceMapURL) {\n  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);\n}\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst base64VLQ = require(\"./base64-vlq\");\nconst util = require(\"./util\");\nconst ArraySet = require(\"./array-set\").ArraySet;\nconst MappingList = require(\"./mapping-list\").MappingList;\n\n/**\n * An instance of the SourceMapGenerator represents a source map which is\n * being built incrementally. You may pass an object with the following\n * properties:\n *\n *   - file: The filename of the generated source.\n *   - sourceRoot: A root for all relative URLs in this source map.\n */\nclass SourceMapGenerator {\n  constructor(aArgs) {\n    if (!aArgs) {\n      aArgs = {};\n    }\n    this._file = util.getArg(aArgs, \"file\", null);\n    this._sourceRoot = util.getArg(aArgs, \"sourceRoot\", null);\n    this._skipValidation = util.getArg(aArgs, \"skipValidation\", false);\n    this._sources = new ArraySet();\n    this._names = new ArraySet();\n    this._mappings = new MappingList();\n    this._sourcesContents = null;\n  }\n\n  /**\n   * Creates a new SourceMapGenerator based on a SourceMapConsumer\n   *\n   * @param aSourceMapConsumer The SourceMap.\n   */\n  static fromSourceMap(aSourceMapConsumer) {\n    const sourceRoot = aSourceMapConsumer.sourceRoot;\n    const generator = new SourceMapGenerator({\n      file: aSourceMapConsumer.file,\n      sourceRoot,\n    });\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      const newMapping = {\n        generated: {\n          line: mapping.generatedLine,\n          column: mapping.generatedColumn,\n        },\n      };\n\n      if (mapping.source != null) {\n        newMapping.source = mapping.source;\n        if (sourceRoot != null) {\n          newMapping.source = util.relative(sourceRoot, newMapping.source);\n        }\n\n        newMapping.original = {\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        };\n\n        if (mapping.name != null) {\n          newMapping.name = mapping.name;\n        }\n      }\n\n      generator.addMapping(newMapping);\n    });\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      let sourceRelative = sourceFile;\n      if (sourceRoot != null) {\n        sourceRelative = util.relative(sourceRoot, sourceFile);\n      }\n\n      if (!generator._sources.has(sourceRelative)) {\n        generator._sources.add(sourceRelative);\n      }\n\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        generator.setSourceContent(sourceFile, content);\n      }\n    });\n    return generator;\n  }\n\n  /**\n   * Add a single mapping from original source line and column to the generated\n   * source's line and column for this source map being created. The mapping\n   * object should have the following properties:\n   *\n   *   - generated: An object with the generated line and column positions.\n   *   - original: An object with the original line and column positions.\n   *   - source: The original source file (relative to the sourceRoot).\n   *   - name: An optional original token name for this mapping.\n   */\n  addMapping(aArgs) {\n    const generated = util.getArg(aArgs, \"generated\");\n    const original = util.getArg(aArgs, \"original\", null);\n    let source = util.getArg(aArgs, \"source\", null);\n    let name = util.getArg(aArgs, \"name\", null);\n\n    if (!this._skipValidation) {\n      this._validateMapping(generated, original, source, name);\n    }\n\n    if (source != null) {\n      source = String(source);\n      if (!this._sources.has(source)) {\n        this._sources.add(source);\n      }\n    }\n\n    if (name != null) {\n      name = String(name);\n      if (!this._names.has(name)) {\n        this._names.add(name);\n      }\n    }\n\n    this._mappings.add({\n      generatedLine: generated.line,\n      generatedColumn: generated.column,\n      originalLine: original && original.line,\n      originalColumn: original && original.column,\n      source,\n      name,\n    });\n  }\n\n  /**\n   * Set the source content for a source file.\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    let source = aSourceFile;\n    if (this._sourceRoot != null) {\n      source = util.relative(this._sourceRoot, source);\n    }\n\n    if (aSourceContent != null) {\n      // Add the source content to the _sourcesContents map.\n      // Create a new _sourcesContents map if the property is null.\n      if (!this._sourcesContents) {\n        this._sourcesContents = Object.create(null);\n      }\n      this._sourcesContents[util.toSetString(source)] = aSourceContent;\n    } else if (this._sourcesContents) {\n      // Remove the source file from the _sourcesContents map.\n      // If the _sourcesContents map is empty, set the property to null.\n      delete this._sourcesContents[util.toSetString(source)];\n      if (Object.keys(this._sourcesContents).length === 0) {\n        this._sourcesContents = null;\n      }\n    }\n  }\n\n  /**\n   * Applies the mappings of a sub-source-map for a specific source file to the\n   * source map being generated. Each mapping to the supplied source file is\n   * rewritten using the supplied source map. Note: The resolution for the\n   * resulting mappings is the minimium of this map and the supplied map.\n   *\n   * @param aSourceMapConsumer The source map to be applied.\n   * @param aSourceFile Optional. The filename of the source file.\n   *        If omitted, SourceMapConsumer's file property will be used.\n   * @param aSourceMapPath Optional. The dirname of the path to the source map\n   *        to be applied. If relative, it is relative to the SourceMapConsumer.\n   *        This parameter is needed when the two source maps aren't in the same\n   *        directory, and the source map to be applied contains relative source\n   *        paths. If so, those relative source paths need to be rewritten\n   *        relative to the SourceMapGenerator.\n   */\n  applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {\n    let sourceFile = aSourceFile;\n    // If aSourceFile is omitted, we will use the file property of the SourceMap\n    if (aSourceFile == null) {\n      if (aSourceMapConsumer.file == null) {\n        throw new Error(\n          \"SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, \" +\n            'or the source map\\'s \"file\" property. Both were omitted.'\n        );\n      }\n      sourceFile = aSourceMapConsumer.file;\n    }\n    const sourceRoot = this._sourceRoot;\n    // Make \"sourceFile\" relative if an absolute Url is passed.\n    if (sourceRoot != null) {\n      sourceFile = util.relative(sourceRoot, sourceFile);\n    }\n    // Applying the SourceMap can add and remove items from the sources and\n    // the names array.\n    const newSources =\n      this._mappings.toArray().length > 0 ? new ArraySet() : this._sources;\n    const newNames = new ArraySet();\n\n    // Find mappings for the \"sourceFile\"\n    this._mappings.unsortedForEach(function (mapping) {\n      if (mapping.source === sourceFile && mapping.originalLine != null) {\n        // Check if it can be mapped by the source map, then update the mapping.\n        const original = aSourceMapConsumer.originalPositionFor({\n          line: mapping.originalLine,\n          column: mapping.originalColumn,\n        });\n        if (original.source != null) {\n          // Copy mapping\n          mapping.source = original.source;\n          if (aSourceMapPath != null) {\n            mapping.source = util.join(aSourceMapPath, mapping.source);\n          }\n          if (sourceRoot != null) {\n            mapping.source = util.relative(sourceRoot, mapping.source);\n          }\n          mapping.originalLine = original.line;\n          mapping.originalColumn = original.column;\n          if (original.name != null) {\n            mapping.name = original.name;\n          }\n        }\n      }\n\n      const source = mapping.source;\n      if (source != null && !newSources.has(source)) {\n        newSources.add(source);\n      }\n\n      const name = mapping.name;\n      if (name != null && !newNames.has(name)) {\n        newNames.add(name);\n      }\n    }, this);\n    this._sources = newSources;\n    this._names = newNames;\n\n    // Copy sourcesContents of applied map.\n    aSourceMapConsumer.sources.forEach(function (srcFile) {\n      const content = aSourceMapConsumer.sourceContentFor(srcFile);\n      if (content != null) {\n        if (aSourceMapPath != null) {\n          srcFile = util.join(aSourceMapPath, srcFile);\n        }\n        if (sourceRoot != null) {\n          srcFile = util.relative(sourceRoot, srcFile);\n        }\n        this.setSourceContent(srcFile, content);\n      }\n    }, this);\n  }\n\n  /**\n   * A mapping can have one of the three levels of data:\n   *\n   *   1. Just the generated position.\n   *   2. The Generated position, original position, and original source.\n   *   3. Generated and original position, original source, as well as a name\n   *      token.\n   *\n   * To maintain consistency, we validate that any new mapping being added falls\n   * in to one of these categories.\n   */\n  _validateMapping(aGenerated, aOriginal, aSource, aName) {\n    // When aOriginal is truthy but has empty values for .line and .column,\n    // it is most likely a programmer error. In this case we throw a very\n    // specific error message to try to guide them the right way.\n    // For example: https://github.com/Polymer/polymer-bundler/pull/519\n    if (\n      aOriginal &&\n      typeof aOriginal.line !== \"number\" &&\n      typeof aOriginal.column !== \"number\"\n    ) {\n      throw new Error(\n        \"original.line and original.column are not numbers -- you probably meant to omit \" +\n          \"the original mapping entirely and only map the generated position. If so, pass \" +\n          \"null for the original mapping instead of an object with empty or null values.\"\n      );\n    }\n\n    if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      !aOriginal &&\n      !aSource &&\n      !aName\n    ) {\n      // Case 1.\n    } else if (\n      aGenerated &&\n      \"line\" in aGenerated &&\n      \"column\" in aGenerated &&\n      aOriginal &&\n      \"line\" in aOriginal &&\n      \"column\" in aOriginal &&\n      aGenerated.line > 0 &&\n      aGenerated.column >= 0 &&\n      aOriginal.line > 0 &&\n      aOriginal.column >= 0 &&\n      aSource\n    ) {\n      // Cases 2 and 3.\n    } else {\n      throw new Error(\n        \"Invalid mapping: \" +\n          JSON.stringify({\n            generated: aGenerated,\n            source: aSource,\n            original: aOriginal,\n            name: aName,\n          })\n      );\n    }\n  }\n\n  /**\n   * Serialize the accumulated mappings in to the stream of base 64 VLQs\n   * specified by the source map format.\n   */\n  _serializeMappings() {\n    let previousGeneratedColumn = 0;\n    let previousGeneratedLine = 1;\n    let previousOriginalColumn = 0;\n    let previousOriginalLine = 0;\n    let previousName = 0;\n    let previousSource = 0;\n    let result = \"\";\n    let next;\n    let mapping;\n    let nameIdx;\n    let sourceIdx;\n\n    const mappings = this._mappings.toArray();\n    for (let i = 0, len = mappings.length; i < len; i++) {\n      mapping = mappings[i];\n      next = \"\";\n\n      if (mapping.generatedLine !== previousGeneratedLine) {\n        previousGeneratedColumn = 0;\n        while (mapping.generatedLine !== previousGeneratedLine) {\n          next += \";\";\n          previousGeneratedLine++;\n        }\n      } else if (i > 0) {\n        if (\n          !util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])\n        ) {\n          continue;\n        }\n        next += \",\";\n      }\n\n      next += base64VLQ.encode(\n        mapping.generatedColumn - previousGeneratedColumn\n      );\n      previousGeneratedColumn = mapping.generatedColumn;\n\n      if (mapping.source != null) {\n        sourceIdx = this._sources.indexOf(mapping.source);\n        next += base64VLQ.encode(sourceIdx - previousSource);\n        previousSource = sourceIdx;\n\n        // lines are stored 0-based in SourceMap spec version 3\n        next += base64VLQ.encode(\n          mapping.originalLine - 1 - previousOriginalLine\n        );\n        previousOriginalLine = mapping.originalLine - 1;\n\n        next += base64VLQ.encode(\n          mapping.originalColumn - previousOriginalColumn\n        );\n        previousOriginalColumn = mapping.originalColumn;\n\n        if (mapping.name != null) {\n          nameIdx = this._names.indexOf(mapping.name);\n          next += base64VLQ.encode(nameIdx - previousName);\n          previousName = nameIdx;\n        }\n      }\n\n      result += next;\n    }\n\n    return result;\n  }\n\n  _generateSourcesContent(aSources, aSourceRoot) {\n    return aSources.map(function (source) {\n      if (!this._sourcesContents) {\n        return null;\n      }\n      if (aSourceRoot != null) {\n        source = util.relative(aSourceRoot, source);\n      }\n      const key = util.toSetString(source);\n      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)\n        ? this._sourcesContents[key]\n        : null;\n    }, this);\n  }\n\n  /**\n   * Externalize the source map.\n   */\n  toJSON() {\n    const map = {\n      version: this._version,\n      sources: this._sources.toArray(),\n      names: this._names.toArray(),\n      mappings: this._serializeMappings(),\n    };\n    if (this._file != null) {\n      map.file = this._file;\n    }\n    if (this._sourceRoot != null) {\n      map.sourceRoot = this._sourceRoot;\n    }\n    if (this._sourcesContents) {\n      map.sourcesContent = this._generateSourcesContent(\n        map.sources,\n        map.sourceRoot\n      );\n    }\n\n    return map;\n  }\n\n  /**\n   * Render the source map being generated to a string.\n   */\n  toString() {\n    return JSON.stringify(this.toJSON());\n  }\n}\n\nSourceMapGenerator.prototype._version = 3;\nexports.SourceMapGenerator = SourceMapGenerator;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst SourceMapGenerator = require(\"./source-map-generator\").SourceMapGenerator;\nconst util = require(\"./util\");\n\n// Matches a Windows-style `\\r\\n` newline or a `\\n` newline used by all other\n// operating systems these days (capturing the result).\nconst REGEX_NEWLINE = /(\\r?\\n)/;\n\n// Newline character code for charCodeAt() comparisons\nconst NEWLINE_CODE = 10;\n\n// Private symbol for identifying `SourceNode`s when multiple versions of\n// the source-map library are loaded. This MUST NOT CHANGE across\n// versions!\nconst isSourceNode = \"$$$isSourceNode$$$\";\n\n/**\n * SourceNodes provide a way to abstract over interpolating/concatenating\n * snippets of generated JavaScript source code while maintaining the line and\n * column information associated with the original source code.\n *\n * @param aLine The original line number.\n * @param aColumn The original column number.\n * @param aSource The original source's filename.\n * @param aChunks Optional. An array of strings which are snippets of\n *        generated JS, or other SourceNodes.\n * @param aName The original identifier.\n */\nclass SourceNode {\n  constructor(aLine, aColumn, aSource, aChunks, aName) {\n    this.children = [];\n    this.sourceContents = {};\n    this.line = aLine == null ? null : aLine;\n    this.column = aColumn == null ? null : aColumn;\n    this.source = aSource == null ? null : aSource;\n    this.name = aName == null ? null : aName;\n    this[isSourceNode] = true;\n    if (aChunks != null) this.add(aChunks);\n  }\n\n  /**\n   * Creates a SourceNode from generated code and a SourceMapConsumer.\n   *\n   * @param aGeneratedCode The generated code\n   * @param aSourceMapConsumer The SourceMap for the generated code\n   * @param aRelativePath Optional. The path that relative sources in the\n   *        SourceMapConsumer should be relative to.\n   */\n  static fromStringWithSourceMap(\n    aGeneratedCode,\n    aSourceMapConsumer,\n    aRelativePath\n  ) {\n    // The SourceNode we want to fill with the generated code\n    // and the SourceMap\n    const node = new SourceNode();\n\n    // All even indices of this array are one line of the generated code,\n    // while all odd indices are the newlines between two adjacent lines\n    // (since `REGEX_NEWLINE` captures its match).\n    // Processed fragments are accessed by calling `shiftNextLine`.\n    const remainingLines = aGeneratedCode.split(REGEX_NEWLINE);\n    let remainingLinesIndex = 0;\n    const shiftNextLine = function () {\n      const lineContents = getNextLine();\n      // The last line of a file might not have a newline.\n      const newLine = getNextLine() || \"\";\n      return lineContents + newLine;\n\n      function getNextLine() {\n        return remainingLinesIndex < remainingLines.length\n          ? remainingLines[remainingLinesIndex++]\n          : undefined;\n      }\n    };\n\n    // We need to remember the position of \"remainingLines\"\n    let lastGeneratedLine = 1,\n      lastGeneratedColumn = 0;\n\n    // The generate SourceNodes we need a code range.\n    // To extract it current and last mapping is used.\n    // Here we store the last mapping.\n    let lastMapping = null;\n    let nextLine;\n\n    aSourceMapConsumer.eachMapping(function (mapping) {\n      if (lastMapping !== null) {\n        // We add the code from \"lastMapping\" to \"mapping\":\n        // First check if there is a new line in between.\n        if (lastGeneratedLine < mapping.generatedLine) {\n          // Associate first line with \"lastMapping\"\n          addMappingWithCode(lastMapping, shiftNextLine());\n          lastGeneratedLine++;\n          lastGeneratedColumn = 0;\n          // The remaining code is added without mapping\n        } else {\n          // There is no new line in between.\n          // Associate the code between \"lastGeneratedColumn\" and\n          // \"mapping.generatedColumn\" with \"lastMapping\"\n          nextLine = remainingLines[remainingLinesIndex] || \"\";\n          const code = nextLine.substr(\n            0,\n            mapping.generatedColumn - lastGeneratedColumn\n          );\n          remainingLines[remainingLinesIndex] = nextLine.substr(\n            mapping.generatedColumn - lastGeneratedColumn\n          );\n          lastGeneratedColumn = mapping.generatedColumn;\n          addMappingWithCode(lastMapping, code);\n          // No more remaining code, continue\n          lastMapping = mapping;\n          return;\n        }\n      }\n      // We add the generated code until the first mapping\n      // to the SourceNode without any mapping.\n      // Each line is added as separate string.\n      while (lastGeneratedLine < mapping.generatedLine) {\n        node.add(shiftNextLine());\n        lastGeneratedLine++;\n      }\n      if (lastGeneratedColumn < mapping.generatedColumn) {\n        nextLine = remainingLines[remainingLinesIndex] || \"\";\n        node.add(nextLine.substr(0, mapping.generatedColumn));\n        remainingLines[remainingLinesIndex] = nextLine.substr(\n          mapping.generatedColumn\n        );\n        lastGeneratedColumn = mapping.generatedColumn;\n      }\n      lastMapping = mapping;\n    }, this);\n    // We have processed all mappings.\n    if (remainingLinesIndex < remainingLines.length) {\n      if (lastMapping) {\n        // Associate the remaining code in the current line with \"lastMapping\"\n        addMappingWithCode(lastMapping, shiftNextLine());\n      }\n      // and add the remaining lines without any mapping\n      node.add(remainingLines.splice(remainingLinesIndex).join(\"\"));\n    }\n\n    // Copy sourcesContent into SourceNode\n    aSourceMapConsumer.sources.forEach(function (sourceFile) {\n      const content = aSourceMapConsumer.sourceContentFor(sourceFile);\n      if (content != null) {\n        if (aRelativePath != null) {\n          sourceFile = util.join(aRelativePath, sourceFile);\n        }\n        node.setSourceContent(sourceFile, content);\n      }\n    });\n\n    return node;\n\n    function addMappingWithCode(mapping, code) {\n      if (mapping === null || mapping.source === undefined) {\n        node.add(code);\n      } else {\n        const source = aRelativePath\n          ? util.join(aRelativePath, mapping.source)\n          : mapping.source;\n        node.add(\n          new SourceNode(\n            mapping.originalLine,\n            mapping.originalColumn,\n            source,\n            code,\n            mapping.name\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   * Add a chunk of generated JS to this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  add(aChunk) {\n    if (Array.isArray(aChunk)) {\n      aChunk.forEach(function (chunk) {\n        this.add(chunk);\n      }, this);\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      if (aChunk) {\n        this.children.push(aChunk);\n      }\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Add a chunk of generated JS to the beginning of this source node.\n   *\n   * @param aChunk A string snippet of generated JS code, another instance of\n   *        SourceNode, or an array where each member is one of those things.\n   */\n  prepend(aChunk) {\n    if (Array.isArray(aChunk)) {\n      for (let i = aChunk.length - 1; i >= 0; i--) {\n        this.prepend(aChunk[i]);\n      }\n    } else if (aChunk[isSourceNode] || typeof aChunk === \"string\") {\n      this.children.unshift(aChunk);\n    } else {\n      throw new TypeError(\n        \"Expected a SourceNode, string, or an array of SourceNodes and strings. Got \" +\n          aChunk\n      );\n    }\n    return this;\n  }\n\n  /**\n   * Walk over the tree of JS snippets in this node and its children. The\n   * walking function is called once for each snippet of JS and is passed that\n   * snippet and the its original associated source's line/column location.\n   *\n   * @param aFn The traversal function.\n   */\n  walk(aFn) {\n    let chunk;\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      chunk = this.children[i];\n      if (chunk[isSourceNode]) {\n        chunk.walk(aFn);\n      } else if (chunk !== \"\") {\n        aFn(chunk, {\n          source: this.source,\n          line: this.line,\n          column: this.column,\n          name: this.name,\n        });\n      }\n    }\n  }\n\n  /**\n   * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between\n   * each of `this.children`.\n   *\n   * @param aSep The separator.\n   */\n  join(aSep) {\n    let newChildren;\n    let i;\n    const len = this.children.length;\n    if (len > 0) {\n      newChildren = [];\n      for (i = 0; i < len - 1; i++) {\n        newChildren.push(this.children[i]);\n        newChildren.push(aSep);\n      }\n      newChildren.push(this.children[i]);\n      this.children = newChildren;\n    }\n    return this;\n  }\n\n  /**\n   * Call String.prototype.replace on the very right-most source snippet. Useful\n   * for trimming whitespace from the end of a source node, etc.\n   *\n   * @param aPattern The pattern to replace.\n   * @param aReplacement The thing to replace the pattern with.\n   */\n  replaceRight(aPattern, aReplacement) {\n    const lastChild = this.children[this.children.length - 1];\n    if (lastChild[isSourceNode]) {\n      lastChild.replaceRight(aPattern, aReplacement);\n    } else if (typeof lastChild === \"string\") {\n      this.children[this.children.length - 1] = lastChild.replace(\n        aPattern,\n        aReplacement\n      );\n    } else {\n      this.children.push(\"\".replace(aPattern, aReplacement));\n    }\n    return this;\n  }\n\n  /**\n   * Set the source content for a source file. This will be added to the SourceMapGenerator\n   * in the sourcesContent field.\n   *\n   * @param aSourceFile The filename of the source file\n   * @param aSourceContent The content of the source file\n   */\n  setSourceContent(aSourceFile, aSourceContent) {\n    this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;\n  }\n\n  /**\n   * Walk over the tree of SourceNodes. The walking function is called for each\n   * source file content and is passed the filename and source content.\n   *\n   * @param aFn The traversal function.\n   */\n  walkSourceContents(aFn) {\n    for (let i = 0, len = this.children.length; i < len; i++) {\n      if (this.children[i][isSourceNode]) {\n        this.children[i].walkSourceContents(aFn);\n      }\n    }\n\n    const sources = Object.keys(this.sourceContents);\n    for (let i = 0, len = sources.length; i < len; i++) {\n      aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);\n    }\n  }\n\n  /**\n   * Return the string representation of this source node. Walks over the tree\n   * and concatenates all the various snippets together to one string.\n   */\n  toString() {\n    let str = \"\";\n    this.walk(function (chunk) {\n      str += chunk;\n    });\n    return str;\n  }\n\n  /**\n   * Returns the string representation of this source node along with a source\n   * map.\n   */\n  toStringWithSourceMap(aArgs) {\n    const generated = {\n      code: \"\",\n      line: 1,\n      column: 0,\n    };\n    const map = new SourceMapGenerator(aArgs);\n    let sourceMappingActive = false;\n    let lastOriginalSource = null;\n    let lastOriginalLine = null;\n    let lastOriginalColumn = null;\n    let lastOriginalName = null;\n    this.walk(function (chunk, original) {\n      generated.code += chunk;\n      if (\n        original.source !== null &&\n        original.line !== null &&\n        original.column !== null\n      ) {\n        if (\n          lastOriginalSource !== original.source ||\n          lastOriginalLine !== original.line ||\n          lastOriginalColumn !== original.column ||\n          lastOriginalName !== original.name\n        ) {\n          map.addMapping({\n            source: original.source,\n            original: {\n              line: original.line,\n              column: original.column,\n            },\n            generated: {\n              line: generated.line,\n              column: generated.column,\n            },\n            name: original.name,\n          });\n        }\n        lastOriginalSource = original.source;\n        lastOriginalLine = original.line;\n        lastOriginalColumn = original.column;\n        lastOriginalName = original.name;\n        sourceMappingActive = true;\n      } else if (sourceMappingActive) {\n        map.addMapping({\n          generated: {\n            line: generated.line,\n            column: generated.column,\n          },\n        });\n        lastOriginalSource = null;\n        sourceMappingActive = false;\n      }\n      for (let idx = 0, length = chunk.length; idx < length; idx++) {\n        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {\n          generated.line++;\n          generated.column = 0;\n          // Mappings end at eol\n          if (idx + 1 === length) {\n            lastOriginalSource = null;\n            sourceMappingActive = false;\n          } else if (sourceMappingActive) {\n            map.addMapping({\n              source: original.source,\n              original: {\n                line: original.line,\n                column: original.column,\n              },\n              generated: {\n                line: generated.line,\n                column: generated.column,\n              },\n              name: original.name,\n            });\n          }\n        } else {\n          generated.column++;\n        }\n      }\n    });\n    this.walkSourceContents(function (sourceFile, sourceContent) {\n      map.setSourceContent(sourceFile, sourceContent);\n    });\n\n    return { code: generated.code, map };\n  }\n}\n\nexports.SourceNode = SourceNode;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\"use strict\";\n\n// Note: This file is overridden in the 'package.json#browser' field to\n// substitute lib/url-browser.js instead.\n\n// Use the URL global for Node 10, and the 'url' module for Node 8.\nmodule.exports = typeof URL === \"function\" ? URL : require(\"url\").URL;\n","/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\nconst URL = require(\"./url\");\n\n/**\n * This is a helper function for getting values from parameter/options\n * objects.\n *\n * @param args The object we are extracting values from\n * @param name The name of the property we are getting.\n * @param defaultValue An optional value to return if the property is missing\n * from the object. If this is not specified and the property is missing, an\n * error will be thrown.\n */\nfunction getArg(aArgs, aName, aDefaultValue) {\n  if (aName in aArgs) {\n    return aArgs[aName];\n  } else if (arguments.length === 3) {\n    return aDefaultValue;\n  }\n  throw new Error('\"' + aName + '\" is a required argument.');\n}\nexports.getArg = getArg;\n\nconst supportsNullProto = (function () {\n  const obj = Object.create(null);\n  return !(\"__proto__\" in obj);\n})();\n\nfunction identity(s) {\n  return s;\n}\n\n/**\n * Because behavior goes wacky when you set `__proto__` on objects, we\n * have to prefix all the strings in our set with an arbitrary character.\n *\n * See https://github.com/mozilla/source-map/pull/31 and\n * https://github.com/mozilla/source-map/issues/30\n *\n * @param String aStr\n */\nfunction toSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return \"$\" + aStr;\n  }\n\n  return aStr;\n}\nexports.toSetString = supportsNullProto ? identity : toSetString;\n\nfunction fromSetString(aStr) {\n  if (isProtoString(aStr)) {\n    return aStr.slice(1);\n  }\n\n  return aStr;\n}\nexports.fromSetString = supportsNullProto ? identity : fromSetString;\n\nfunction isProtoString(s) {\n  if (!s) {\n    return false;\n  }\n\n  const length = s.length;\n\n  if (length < 9 /* \"__proto__\".length */) {\n    return false;\n  }\n\n  /* eslint-disable no-multi-spaces */\n  if (\n    s.charCodeAt(length - 1) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 2) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 3) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 4) !== 116 /* 't' */ ||\n    s.charCodeAt(length - 5) !== 111 /* 'o' */ ||\n    s.charCodeAt(length - 6) !== 114 /* 'r' */ ||\n    s.charCodeAt(length - 7) !== 112 /* 'p' */ ||\n    s.charCodeAt(length - 8) !== 95 /* '_' */ ||\n    s.charCodeAt(length - 9) !== 95 /* '_' */\n  ) {\n    return false;\n  }\n  /* eslint-enable no-multi-spaces */\n\n  for (let i = length - 10; i >= 0; i--) {\n    if (s.charCodeAt(i) !== 36 /* '$' */) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction strcmp(aStr1, aStr2) {\n  if (aStr1 === aStr2) {\n    return 0;\n  }\n\n  if (aStr1 === null) {\n    return 1; // aStr2 !== null\n  }\n\n  if (aStr2 === null) {\n    return -1; // aStr1 !== null\n  }\n\n  if (aStr1 > aStr2) {\n    return 1;\n  }\n\n  return -1;\n}\n\n/**\n * Comparator between two mappings with inflated source and name strings where\n * the generated positions are compared.\n */\nfunction compareByGeneratedPositionsInflated(mappingA, mappingB) {\n  let cmp = mappingA.generatedLine - mappingB.generatedLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.generatedColumn - mappingB.generatedColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = strcmp(mappingA.source, mappingB.source);\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalLine - mappingB.originalLine;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  cmp = mappingA.originalColumn - mappingB.originalColumn;\n  if (cmp !== 0) {\n    return cmp;\n  }\n\n  return strcmp(mappingA.name, mappingB.name);\n}\nexports.compareByGeneratedPositionsInflated =\n  compareByGeneratedPositionsInflated;\n\n/**\n * Strip any JSON XSSI avoidance prefix from the string (as documented\n * in the source maps specification), and then parse the string as\n * JSON.\n */\nfunction parseSourceMapInput(str) {\n  return JSON.parse(str.replace(/^\\)]}'[^\\n]*\\n/, \"\"));\n}\nexports.parseSourceMapInput = parseSourceMapInput;\n\n// We use 'http' as the base here because we want URLs processed relative\n// to the safe base to be treated as \"special\" URLs during parsing using\n// the WHATWG URL parsing. This ensures that backslash normalization\n// applies to the path and such.\nconst PROTOCOL = \"http:\";\nconst PROTOCOL_AND_HOST = `${PROTOCOL}//host`;\n\n/**\n * Make it easy to create small utilities that tweak a URL's path.\n */\nfunction createSafeHandler(cb) {\n  return input => {\n    const type = getURLType(input);\n    const base = buildSafeBase(input);\n    const url = new URL(input, base);\n\n    cb(url);\n\n    const result = url.toString();\n\n    if (type === \"absolute\") {\n      return result;\n    } else if (type === \"scheme-relative\") {\n      return result.slice(PROTOCOL.length);\n    } else if (type === \"path-absolute\") {\n      return result.slice(PROTOCOL_AND_HOST.length);\n    }\n\n    // This assumes that the callback will only change\n    // the path, search and hash values.\n    return computeRelativeURL(base, result);\n  };\n}\n\nfunction withBase(url, base) {\n  return new URL(url, base).toString();\n}\n\nfunction buildUniqueSegment(prefix, str) {\n  let id = 0;\n  do {\n    const ident = prefix + id++;\n    if (str.indexOf(ident) === -1) return ident;\n  } while (true);\n}\n\nfunction buildSafeBase(str) {\n  const maxDotParts = str.split(\"..\").length - 1;\n\n  // If we used a segment that also existed in `str`, then we would be unable\n  // to compute relative paths. For example, if `segment` were just \"a\":\n  //\n  //   const url = \"../../a/\"\n  //   const base = buildSafeBase(url); // http://host/a/a/\n  //   const joined = \"http://host/a/\";\n  //   const result = relative(base, joined);\n  //\n  // Expected: \"../../a/\";\n  // Actual: \"a/\"\n  //\n  const segment = buildUniqueSegment(\"p\", str);\n\n  let base = `${PROTOCOL_AND_HOST}/`;\n  for (let i = 0; i < maxDotParts; i++) {\n    base += `${segment}/`;\n  }\n  return base;\n}\n\nconst ABSOLUTE_SCHEME = /^[A-Za-z0-9\\+\\-\\.]+:/;\nfunction getURLType(url) {\n  if (url[0] === \"/\") {\n    if (url[1] === \"/\") return \"scheme-relative\";\n    return \"path-absolute\";\n  }\n\n  return ABSOLUTE_SCHEME.test(url) ? \"absolute\" : \"path-relative\";\n}\n\n/**\n * Given two URLs that are assumed to be on the same\n * protocol/host/user/password build a relative URL from the\n * path, params, and hash values.\n *\n * @param rootURL The root URL that the target will be relative to.\n * @param targetURL The target that the relative URL points to.\n * @return A rootURL-relative, normalized URL value.\n */\nfunction computeRelativeURL(rootURL, targetURL) {\n  if (typeof rootURL === \"string\") rootURL = new URL(rootURL);\n  if (typeof targetURL === \"string\") targetURL = new URL(targetURL);\n\n  const targetParts = targetURL.pathname.split(\"/\");\n  const rootParts = rootURL.pathname.split(\"/\");\n\n  // If we've got a URL path ending with a \"/\", we remove it since we'd\n  // otherwise be relative to the wrong location.\n  if (rootParts.length > 0 && !rootParts[rootParts.length - 1]) {\n    rootParts.pop();\n  }\n\n  while (\n    targetParts.length > 0 &&\n    rootParts.length > 0 &&\n    targetParts[0] === rootParts[0]\n  ) {\n    targetParts.shift();\n    rootParts.shift();\n  }\n\n  const relativePath = rootParts\n    .map(() => \"..\")\n    .concat(targetParts)\n    .join(\"/\");\n\n  return relativePath + targetURL.search + targetURL.hash;\n}\n\n/**\n * Given a URL, ensure that it is treated as a directory URL.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst ensureDirectory = createSafeHandler(url => {\n  url.pathname = url.pathname.replace(/\\/?$/, \"/\");\n});\n\n/**\n * Given a URL, strip off any filename if one is present.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst trimFilename = createSafeHandler(url => {\n  url.href = new URL(\".\", url.toString()).toString();\n});\n\n/**\n * Normalize a given URL.\n * * Convert backslashes.\n * * Remove any \"..\" and \".\" segments.\n *\n * @param url\n * @return A normalized URL value.\n */\nconst normalize = createSafeHandler(url => {});\nexports.normalize = normalize;\n\n/**\n * Joins two paths/URLs.\n *\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL. Assumed to reference a directory.\n * @param aPath The path or URL to be joined with the root.\n * @return A joined and normalized URL value.\n */\nfunction join(aRoot, aPath) {\n  const pathType = getURLType(aPath);\n  const rootType = getURLType(aRoot);\n\n  aRoot = ensureDirectory(aRoot);\n\n  if (pathType === \"absolute\") {\n    return withBase(aPath, undefined);\n  }\n  if (rootType === \"absolute\") {\n    return withBase(aPath, aRoot);\n  }\n\n  if (pathType === \"scheme-relative\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"scheme-relative\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL.length\n    );\n  }\n\n  if (pathType === \"path-absolute\") {\n    return normalize(aPath);\n  }\n  if (rootType === \"path-absolute\") {\n    return withBase(aPath, withBase(aRoot, PROTOCOL_AND_HOST)).slice(\n      PROTOCOL_AND_HOST.length\n    );\n  }\n\n  const base = buildSafeBase(aPath + aRoot);\n  const newPath = withBase(aPath, withBase(aRoot, base));\n  return computeRelativeURL(base, newPath);\n}\nexports.join = join;\n\n/**\n * Make a path relative to a URL or another path. If returning a\n * relative URL is not possible, the original target will be returned.\n * All returned URLs will be normalized.\n *\n * @param aRoot The root path or URL.\n * @param aPath The path or URL to be made relative to aRoot.\n * @return A rootURL-relative (if possible), normalized URL value.\n */\nfunction relative(rootURL, targetURL) {\n  const result = relativeIfPossible(rootURL, targetURL);\n\n  return typeof result === \"string\" ? result : normalize(targetURL);\n}\nexports.relative = relative;\n\nfunction relativeIfPossible(rootURL, targetURL) {\n  const urlType = getURLType(rootURL);\n  if (urlType !== getURLType(targetURL)) {\n    return null;\n  }\n\n  const base = buildSafeBase(rootURL + targetURL);\n  const root = new URL(rootURL, base);\n  const target = new URL(targetURL, base);\n\n  try {\n    new URL(\"\", target.toString());\n  } catch (err) {\n    // Bail if the URL doesn't support things being relative to it,\n    // For example, data: and blob: URLs.\n    return null;\n  }\n\n  if (\n    target.protocol !== root.protocol ||\n    target.user !== root.user ||\n    target.password !== root.password ||\n    target.hostname !== root.hostname ||\n    target.port !== root.port\n  ) {\n    return null;\n  }\n\n  return computeRelativeURL(root, target);\n}\n\n/**\n * Compute the URL of a source given the the source root, the source's\n * URL, and the source map's URL.\n */\nfunction computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {\n  // The source map spec states that \"sourceRoot\" and \"sources\" entries are to be appended. While\n  // that is a little vague, implementations have generally interpreted that as joining the\n  // URLs with a `/` between then, assuming the \"sourceRoot\" doesn't already end with one.\n  // For example,\n  //\n  //   sourceRoot: \"some-dir\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // and\n  //\n  //   sourceRoot: \"some-dir/\",\n  //   sources: [\"/some-path.js\"]\n  //\n  // must behave as \"some-dir/some-path.js\".\n  //\n  // With this library's the transition to a more URL-focused implementation, that behavior is\n  // preserved here. To acheive that, we trim the \"/\" from absolute-path when a sourceRoot value\n  // is present in order to make the sources entries behave as if they are relative to the\n  // \"sourceRoot\", as they would have if the two strings were simply concated.\n  if (sourceRoot && getURLType(sourceURL) === \"path-absolute\") {\n    sourceURL = sourceURL.replace(/^\\//, \"\");\n  }\n\n  let url = normalize(sourceURL || \"\");\n\n  // Parsing URLs can be expensive, so we only perform these joins when needed.\n  if (sourceRoot) url = join(sourceRoot, url);\n  if (sourceMapURL) url = join(trimFilename(sourceMapURL), url);\n  return url;\n}\nexports.computeSourceURL = computeSourceURL;\n","const readWasm = require(\"../lib/read-wasm\");\n\n/**\n * Provide the JIT with a nice shape / hidden class.\n */\nfunction Mapping() {\n  this.generatedLine = 0;\n  this.generatedColumn = 0;\n  this.lastGeneratedColumn = null;\n  this.source = null;\n  this.originalLine = null;\n  this.originalColumn = null;\n  this.name = null;\n}\n\nlet cachedWasm = null;\n\nmodule.exports = function wasm() {\n  if (cachedWasm) {\n    return cachedWasm;\n  }\n\n  const callbackStack = [];\n\n  cachedWasm = readWasm()\n    .then(buffer => {\n      return WebAssembly.instantiate(buffer, {\n        env: {\n          mapping_callback(\n            generatedLine,\n            generatedColumn,\n\n            hasLastGeneratedColumn,\n            lastGeneratedColumn,\n\n            hasOriginal,\n            source,\n            originalLine,\n            originalColumn,\n\n            hasName,\n            name\n          ) {\n            const mapping = new Mapping();\n            // JS uses 1-based line numbers, wasm uses 0-based.\n            mapping.generatedLine = generatedLine + 1;\n            mapping.generatedColumn = generatedColumn;\n\n            if (hasLastGeneratedColumn) {\n              // JS uses inclusive last generated column, wasm uses exclusive.\n              mapping.lastGeneratedColumn = lastGeneratedColumn - 1;\n            }\n\n            if (hasOriginal) {\n              mapping.source = source;\n              // JS uses 1-based line numbers, wasm uses 0-based.\n              mapping.originalLine = originalLine + 1;\n              mapping.originalColumn = originalColumn;\n\n              if (hasName) {\n                mapping.name = name;\n              }\n            }\n\n            callbackStack[callbackStack.length - 1](mapping);\n          },\n\n          start_all_generated_locations_for() {\n            console.time(\"all_generated_locations_for\");\n          },\n          end_all_generated_locations_for() {\n            console.timeEnd(\"all_generated_locations_for\");\n          },\n\n          start_compute_column_spans() {\n            console.time(\"compute_column_spans\");\n          },\n          end_compute_column_spans() {\n            console.timeEnd(\"compute_column_spans\");\n          },\n\n          start_generated_location_for() {\n            console.time(\"generated_location_for\");\n          },\n          end_generated_location_for() {\n            console.timeEnd(\"generated_location_for\");\n          },\n\n          start_original_location_for() {\n            console.time(\"original_location_for\");\n          },\n          end_original_location_for() {\n            console.timeEnd(\"original_location_for\");\n          },\n\n          start_parse_mappings() {\n            console.time(\"parse_mappings\");\n          },\n          end_parse_mappings() {\n            console.timeEnd(\"parse_mappings\");\n          },\n\n          start_sort_by_generated_location() {\n            console.time(\"sort_by_generated_location\");\n          },\n          end_sort_by_generated_location() {\n            console.timeEnd(\"sort_by_generated_location\");\n          },\n\n          start_sort_by_original_location() {\n            console.time(\"sort_by_original_location\");\n          },\n          end_sort_by_original_location() {\n            console.timeEnd(\"sort_by_original_location\");\n          },\n        },\n      });\n    })\n    .then(Wasm => {\n      return {\n        exports: Wasm.instance.exports,\n        withMappingCallback: (mappingCallback, f) => {\n          callbackStack.push(mappingCallback);\n          try {\n            f();\n          } finally {\n            callbackStack.pop();\n          }\n        },\n      };\n    })\n    .then(null, e => {\n      cachedWasm = null;\n      throw e;\n    });\n\n  return cachedWasm;\n};\n","/*\n * Copyright 2009-2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\nexports.SourceMapGenerator =\n  require(\"./lib/source-map-generator\").SourceMapGenerator;\nexports.SourceMapConsumer =\n  require(\"./lib/source-map-consumer\").SourceMapConsumer;\nexports.SourceNode = require(\"./lib/source-node\").SourceNode;\n"],"names":["Map","Error","TypeError","Math","Promise","__dirname","console","Symbol","t","String","Uint8Array","e","o","n","l","s","Object","JSON","m","i","Array","URL","arguments","c","r","WebAssembly"],"mappings":"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"}