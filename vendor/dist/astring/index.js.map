{"version":3,"file":"astring/index.js","sources":["webpack:///./astring/dist/astring.mjs","webpack:///webpack/runtime/define_property_getters","webpack:///webpack/runtime/has_own_property","webpack:///webpack/runtime/make_namespace_object"],"sourcesContent":["// Astring is a tiny and fast JavaScript code generator from an ESTree-compliant AST.\n//\n// Astring was written by David Bonnet and released under an MIT license.\n//\n// The Git repository for Astring is available at:\n// https://github.com/davidbonnet/astring.git\n//\n// Please use the GitHub bug tracker to report issues:\n// https://github.com/davidbonnet/astring/issues\n\nconst { stringify } = JSON\n\n/* c8 ignore if */\nif (!String.prototype.repeat) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\n/* c8 ignore if */\nif (!String.prototype.endsWith) {\n  /* c8 ignore next */\n  throw new Error(\n    'String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation',\n  )\n}\n\nconst OPERATOR_PRECEDENCE = {\n  '||': 2,\n  '??': 3,\n  '&&': 4,\n  '|': 5,\n  '^': 6,\n  '&': 7,\n  '==': 8,\n  '!=': 8,\n  '===': 8,\n  '!==': 8,\n  '<': 9,\n  '>': 9,\n  '<=': 9,\n  '>=': 9,\n  in: 9,\n  instanceof: 9,\n  '<<': 10,\n  '>>': 10,\n  '>>>': 10,\n  '+': 11,\n  '-': 11,\n  '*': 12,\n  '%': 12,\n  '/': 12,\n  '**': 13,\n}\n\n// Enables parenthesis regardless of precedence\nexport const NEEDS_PARENTHESES = 17\n\nexport const EXPRESSIONS_PRECEDENCE = {\n  // Definitions\n  ArrayExpression: 20,\n  TaggedTemplateExpression: 20,\n  ThisExpression: 20,\n  Identifier: 20,\n  PrivateIdentifier: 20,\n  Literal: 18,\n  TemplateLiteral: 20,\n  Super: 20,\n  SequenceExpression: 20,\n  // Operations\n  MemberExpression: 19,\n  ChainExpression: 19,\n  CallExpression: 19,\n  NewExpression: 19,\n  // Other definitions\n  ArrowFunctionExpression: NEEDS_PARENTHESES,\n  ClassExpression: NEEDS_PARENTHESES,\n  FunctionExpression: NEEDS_PARENTHESES,\n  ObjectExpression: NEEDS_PARENTHESES,\n  // Other operations\n  UpdateExpression: 16,\n  UnaryExpression: 15,\n  AwaitExpression: 15,\n  BinaryExpression: 14,\n  LogicalExpression: 13,\n  ConditionalExpression: 4,\n  AssignmentExpression: 3,\n  YieldExpression: 2,\n  RestElement: 1,\n}\n\nfunction formatSequence(state, nodes) {\n  /*\n  Writes into `state` a sequence of `nodes`.\n  */\n  const { generator } = state\n  state.write('(')\n  if (nodes != null && nodes.length > 0) {\n    generator[nodes[0].type](nodes[0], state)\n    const { length } = nodes\n    for (let i = 1; i < length; i++) {\n      const param = nodes[i]\n      state.write(', ')\n      generator[param.type](param, state)\n    }\n  }\n  state.write(')')\n}\n\nfunction expressionNeedsParenthesis(state, node, parentNode, isRightHand) {\n  const nodePrecedence = state.expressionsPrecedence[node.type]\n  if (nodePrecedence === NEEDS_PARENTHESES) {\n    return true\n  }\n  const parentNodePrecedence = state.expressionsPrecedence[parentNode.type]\n  if (nodePrecedence !== parentNodePrecedence) {\n    // Different node types\n    return (\n      (!isRightHand &&\n        nodePrecedence === 15 &&\n        parentNodePrecedence === 14 &&\n        parentNode.operator === '**') ||\n      nodePrecedence < parentNodePrecedence\n    )\n  }\n  if (nodePrecedence !== 13 && nodePrecedence !== 14) {\n    // Not a `LogicalExpression` or `BinaryExpression`\n    return false\n  }\n  if (node.operator === '**' && parentNode.operator === '**') {\n    // Exponentiation operator has right-to-left associativity\n    return !isRightHand\n  }\n  if (\n    nodePrecedence === 13 &&\n    parentNodePrecedence === 13 &&\n    (node.operator === '??' || parentNode.operator === '??')\n  ) {\n    // Nullish coalescing and boolean operators cannot be combined\n    return true\n  }\n  if (isRightHand) {\n    // Parenthesis are used if both operators have the same precedence\n    return (\n      OPERATOR_PRECEDENCE[node.operator] <=\n      OPERATOR_PRECEDENCE[parentNode.operator]\n    )\n  }\n  return (\n    OPERATOR_PRECEDENCE[node.operator] <\n    OPERATOR_PRECEDENCE[parentNode.operator]\n  )\n}\n\nfunction formatExpression(state, node, parentNode, isRightHand) {\n  /*\n  Writes into `state` the provided `node`, adding parenthesis around if the provided `parentNode` needs it. If `node` is a right-hand argument, the provided `isRightHand` parameter should be `true`.\n  */\n  const { generator } = state\n  if (expressionNeedsParenthesis(state, node, parentNode, isRightHand)) {\n    state.write('(')\n    generator[node.type](node, state)\n    state.write(')')\n  } else {\n    generator[node.type](node, state)\n  }\n}\n\nfunction reindent(state, text, indent, lineEnd) {\n  /*\n  Writes into `state` the `text` string reindented with the provided `indent`.\n  */\n  const lines = text.split('\\n')\n  const end = lines.length - 1\n  state.write(lines[0].trim())\n  if (end > 0) {\n    state.write(lineEnd)\n    for (let i = 1; i < end; i++) {\n      state.write(indent + lines[i].trim() + lineEnd)\n    }\n    state.write(indent + lines[end].trim())\n  }\n}\n\nfunction formatComments(state, comments, indent, lineEnd) {\n  /*\n  Writes into `state` the provided list of `comments`, with the given `indent` and `lineEnd` strings.\n  Line comments will end with `\"\\n\"` regardless of the value of `lineEnd`.\n  Expects to start on a new unindented line.\n  */\n  const { length } = comments\n  for (let i = 0; i < length; i++) {\n    const comment = comments[i]\n    state.write(indent)\n    if (comment.type[0] === 'L') {\n      // Line comment\n      state.write('// ' + comment.value.trim() + '\\n', comment)\n    } else {\n      // Block comment\n      state.write('/*')\n      reindent(state, comment.value, indent, lineEnd)\n      state.write('*/' + lineEnd)\n    }\n  }\n}\n\nfunction hasCallExpression(node) {\n  /*\n  Returns `true` if the provided `node` contains a call expression and `false` otherwise.\n  */\n  let currentNode = node\n  while (currentNode != null) {\n    const { type } = currentNode\n    if (type[0] === 'C' && type[1] === 'a') {\n      // Is CallExpression\n      return true\n    } else if (type[0] === 'M' && type[1] === 'e' && type[2] === 'm') {\n      // Is MemberExpression\n      currentNode = currentNode.object\n    } else {\n      return false\n    }\n  }\n}\n\nfunction formatVariableDeclaration(state, node) {\n  /*\n  Writes into `state` a variable declaration.\n  */\n  const { generator } = state\n  const { declarations } = node\n  state.write(node.kind + ' ')\n  const { length } = declarations\n  if (length > 0) {\n    generator.VariableDeclarator(declarations[0], state)\n    for (let i = 1; i < length; i++) {\n      state.write(', ')\n      generator.VariableDeclarator(declarations[i], state)\n    }\n  }\n}\n\nlet ForInStatement,\n  FunctionDeclaration,\n  RestElement,\n  BinaryExpression,\n  ArrayExpression,\n  BlockStatement\n\nexport const GENERATOR = {\n  /*\n  Default generator.\n  */\n  Program(node, state) {\n    const indent = state.indent.repeat(state.indentLevel)\n    const { lineEnd, writeComments } = state\n    if (writeComments && node.comments != null) {\n      formatComments(state, node.comments, indent, lineEnd)\n    }\n    const statements = node.body\n    const { length } = statements\n    for (let i = 0; i < length; i++) {\n      const statement = statements[i]\n      if (writeComments && statement.comments != null) {\n        formatComments(state, statement.comments, indent, lineEnd)\n      }\n      state.write(indent)\n      this[statement.type](statement, state)\n      state.write(lineEnd)\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, indent, lineEnd)\n    }\n  },\n  BlockStatement: (BlockStatement = function (node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const statementIndent = indent + state.indent\n    state.write('{')\n    const statements = node.body\n    if (statements != null && statements.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, statementIndent, lineEnd)\n      }\n      const { length } = statements\n      for (let i = 0; i < length; i++) {\n        const statement = statements[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n      state.write(indent)\n    } else {\n      if (writeComments && node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, statementIndent, lineEnd)\n        state.write(indent)\n      }\n    }\n    if (writeComments && node.trailingComments != null) {\n      formatComments(state, node.trailingComments, statementIndent, lineEnd)\n    }\n    state.write('}')\n    state.indentLevel--\n  }),\n  ClassBody: BlockStatement,\n  StaticBlock(node, state) {\n    state.write('static ')\n    this.BlockStatement(node, state)\n  },\n  EmptyStatement(node, state) {\n    state.write(';')\n  },\n  ExpressionStatement(node, state) {\n    const precedence = state.expressionsPrecedence[node.expression.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      (precedence === 3 && node.expression.left.type[0] === 'O')\n    ) {\n      // Should always have parentheses or is an AssignmentExpression to an ObjectPattern\n      state.write('(')\n      this[node.expression.type](node.expression, state)\n      state.write(')')\n    } else {\n      this[node.expression.type](node.expression, state)\n    }\n    state.write(';')\n  },\n  IfStatement(node, state) {\n    state.write('if (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.consequent.type](node.consequent, state)\n    if (node.alternate != null) {\n      state.write(' else ')\n      this[node.alternate.type](node.alternate, state)\n    }\n  },\n  LabeledStatement(node, state) {\n    this[node.label.type](node.label, state)\n    state.write(': ')\n    this[node.body.type](node.body, state)\n  },\n  BreakStatement(node, state) {\n    state.write('break')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  ContinueStatement(node, state) {\n    state.write('continue')\n    if (node.label != null) {\n      state.write(' ')\n      this[node.label.type](node.label, state)\n    }\n    state.write(';')\n  },\n  WithStatement(node, state) {\n    state.write('with (')\n    this[node.object.type](node.object, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  SwitchStatement(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    state.indentLevel++\n    const caseIndent = indent + state.indent\n    const statementIndent = caseIndent + state.indent\n    state.write('switch (')\n    this[node.discriminant.type](node.discriminant, state)\n    state.write(') {' + lineEnd)\n    const { cases: occurences } = node\n    const { length: occurencesCount } = occurences\n    for (let i = 0; i < occurencesCount; i++) {\n      const occurence = occurences[i]\n      if (writeComments && occurence.comments != null) {\n        formatComments(state, occurence.comments, caseIndent, lineEnd)\n      }\n      if (occurence.test) {\n        state.write(caseIndent + 'case ')\n        this[occurence.test.type](occurence.test, state)\n        state.write(':' + lineEnd)\n      } else {\n        state.write(caseIndent + 'default:' + lineEnd)\n      }\n      const { consequent } = occurence\n      const { length: consequentCount } = consequent\n      for (let i = 0; i < consequentCount; i++) {\n        const statement = consequent[i]\n        if (writeComments && statement.comments != null) {\n          formatComments(state, statement.comments, statementIndent, lineEnd)\n        }\n        state.write(statementIndent)\n        this[statement.type](statement, state)\n        state.write(lineEnd)\n      }\n    }\n    state.indentLevel -= 2\n    state.write(indent + '}')\n  },\n  ReturnStatement(node, state) {\n    state.write('return')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n    state.write(';')\n  },\n  ThrowStatement(node, state) {\n    state.write('throw ')\n    this[node.argument.type](node.argument, state)\n    state.write(';')\n  },\n  TryStatement(node, state) {\n    state.write('try ')\n    this[node.block.type](node.block, state)\n    if (node.handler) {\n      const { handler } = node\n      if (handler.param == null) {\n        state.write(' catch ')\n      } else {\n        state.write(' catch (')\n        this[handler.param.type](handler.param, state)\n        state.write(') ')\n      }\n      this[handler.body.type](handler.body, state)\n    }\n    if (node.finalizer) {\n      state.write(' finally ')\n      this[node.finalizer.type](node.finalizer, state)\n    }\n  },\n  WhileStatement(node, state) {\n    state.write('while (')\n    this[node.test.type](node.test, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  DoWhileStatement(node, state) {\n    state.write('do ')\n    this[node.body.type](node.body, state)\n    state.write(' while (')\n    this[node.test.type](node.test, state)\n    state.write(');')\n  },\n  ForStatement(node, state) {\n    state.write('for (')\n    if (node.init != null) {\n      const { init } = node\n      if (init.type[0] === 'V') {\n        formatVariableDeclaration(state, init)\n      } else {\n        this[init.type](init, state)\n      }\n    }\n    state.write('; ')\n    if (node.test) {\n      this[node.test.type](node.test, state)\n    }\n    state.write('; ')\n    if (node.update) {\n      this[node.update.type](node.update, state)\n    }\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  },\n  ForInStatement: (ForInStatement = function (node, state) {\n    state.write(`for ${node.await ? 'await ' : ''}(`)\n    const { left } = node\n    if (left.type[0] === 'V') {\n      formatVariableDeclaration(state, left)\n    } else {\n      this[left.type](left, state)\n    }\n    // Identifying whether node.type is `ForInStatement` or `ForOfStatement`\n    state.write(node.type[3] === 'I' ? ' in ' : ' of ')\n    this[node.right.type](node.right, state)\n    state.write(') ')\n    this[node.body.type](node.body, state)\n  }),\n  ForOfStatement: ForInStatement,\n  DebuggerStatement(node, state) {\n    state.write('debugger;', node)\n  },\n  FunctionDeclaration: (FunctionDeclaration = function (node, state) {\n    state.write(\n      (node.async ? 'async ' : '') +\n        (node.generator ? 'function* ' : 'function ') +\n        (node.id ? node.id.name : ''),\n      node,\n    )\n    formatSequence(state, node.params)\n    state.write(' ')\n    this[node.body.type](node.body, state)\n  }),\n  FunctionExpression: FunctionDeclaration,\n  VariableDeclaration(node, state) {\n    formatVariableDeclaration(state, node)\n    state.write(';')\n  },\n  VariableDeclarator(node, state) {\n    this[node.id.type](node.id, state)\n    if (node.init != null) {\n      state.write(' = ')\n      this[node.init.type](node.init, state)\n    }\n  },\n  ClassDeclaration(node, state) {\n    state.write('class ' + (node.id ? `${node.id.name} ` : ''), node)\n    if (node.superClass) {\n      state.write('extends ')\n      const { superClass } = node\n      const { type } = superClass\n      const precedence = state.expressionsPrecedence[type]\n      if (\n        (type[0] !== 'C' || type[1] !== 'l' || type[5] !== 'E') &&\n        (precedence === NEEDS_PARENTHESES ||\n          precedence < state.expressionsPrecedence.ClassExpression)\n      ) {\n        // Not a ClassExpression that needs parentheses\n        state.write('(')\n        this[node.superClass.type](superClass, state)\n        state.write(')')\n      } else {\n        this[superClass.type](superClass, state)\n      }\n      state.write(' ')\n    }\n    this.ClassBody(node.body, state)\n  },\n  ImportDeclaration(node, state) {\n    state.write('import ')\n    const { specifiers, attributes } = node\n    const { length } = specifiers\n    // TODO: Once babili is fixed, put this after condition\n    // https://github.com/babel/babili/issues/430\n    let i = 0\n    if (length > 0) {\n      for (; i < length; ) {\n        if (i > 0) {\n          state.write(', ')\n        }\n        const specifier = specifiers[i]\n        const type = specifier.type[6]\n        if (type === 'D') {\n          // ImportDefaultSpecifier\n          state.write(specifier.local.name, specifier)\n          i++\n        } else if (type === 'N') {\n          // ImportNamespaceSpecifier\n          state.write('* as ' + specifier.local.name, specifier)\n          i++\n        } else {\n          // ImportSpecifier\n          break\n        }\n      }\n      if (i < length) {\n        state.write('{')\n        for (;;) {\n          const specifier = specifiers[i]\n          const { name } = specifier.imported\n          state.write(name, specifier)\n          if (name !== specifier.local.name) {\n            state.write(' as ' + specifier.local.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n        state.write('}')\n      }\n      state.write(' from ')\n    }\n    this.Literal(node.source, state)\n\n    if (attributes && attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < attributes.length; i++) {\n        this.ImportAttribute(attributes[i], state)\n        if (i < attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n    state.write(';')\n  },\n  ImportAttribute(node, state) {\n    this.Identifier(node.key, state)\n    state.write(': ')\n    this.Literal(node.value, state)\n  },\n  ImportExpression(node, state) {\n    state.write('import(')\n    this[node.source.type](node.source, state)\n    state.write(')')\n  },\n  ExportDefaultDeclaration(node, state) {\n    state.write('export default ')\n    this[node.declaration.type](node.declaration, state)\n    if (\n      state.expressionsPrecedence[node.declaration.type] != null &&\n      node.declaration.type[0] !== 'F'\n    ) {\n      // All expression nodes except `FunctionExpression`\n      state.write(';')\n    }\n  },\n  ExportNamedDeclaration(node, state) {\n    state.write('export ')\n    if (node.declaration) {\n      this[node.declaration.type](node.declaration, state)\n    } else {\n      state.write('{')\n      const { specifiers } = node,\n        { length } = specifiers\n      if (length > 0) {\n        for (let i = 0; ; ) {\n          const specifier = specifiers[i]\n          const { name } = specifier.local\n          state.write(name, specifier)\n          if (name !== specifier.exported.name) {\n            state.write(' as ' + specifier.exported.name)\n          }\n          if (++i < length) {\n            state.write(', ')\n          } else {\n            break\n          }\n        }\n      }\n      state.write('}')\n      if (node.source) {\n        state.write(' from ')\n        this.Literal(node.source, state)\n      }\n\n      if (node.attributes && node.attributes.length > 0) {\n        state.write(' with { ')\n        for (let i = 0; i < node.attributes.length; i++) {\n          this.ImportAttribute(node.attributes[i], state)\n          if (i < node.attributes.length - 1) state.write(', ')\n        }\n\n        state.write(' }')\n      }\n\n      state.write(';')\n    }\n  },\n  ExportAllDeclaration(node, state) {\n    if (node.exported != null) {\n      state.write('export * as ' + node.exported.name + ' from ')\n    } else {\n      state.write('export * from ')\n    }\n    this.Literal(node.source, state)\n\n    if (node.attributes && node.attributes.length > 0) {\n      state.write(' with { ')\n      for (let i = 0; i < node.attributes.length; i++) {\n        this.ImportAttribute(node.attributes[i], state)\n        if (i < node.attributes.length - 1) state.write(', ')\n      }\n\n      state.write(' }')\n    }\n\n    state.write(';')\n  },\n  MethodDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    const kind = node.kind[0]\n    if (kind === 'g' || kind === 's') {\n      // Getter or setter\n      state.write(node.kind + ' ')\n    }\n    if (node.value.async) {\n      state.write('async ')\n    }\n    if (node.value.generator) {\n      state.write('*')\n    }\n    if (node.computed) {\n      state.write('[')\n      this[node.key.type](node.key, state)\n      state.write(']')\n    } else {\n      this[node.key.type](node.key, state)\n    }\n    formatSequence(state, node.value.params)\n    state.write(' ')\n    this[node.value.body.type](node.value.body, state)\n  },\n  ClassExpression(node, state) {\n    this.ClassDeclaration(node, state)\n  },\n  ArrowFunctionExpression(node, state) {\n    state.write(node.async ? 'async ' : '', node)\n    const { params } = node\n    if (params != null) {\n      // Omit parenthesis if only one named parameter\n      if (params.length === 1 && params[0].type[0] === 'I') {\n        // If params[0].type[0] starts with 'I', it can't be `ImportDeclaration` nor `IfStatement` and thus is `Identifier`\n        state.write(params[0].name, params[0])\n      } else {\n        formatSequence(state, node.params)\n      }\n    }\n    state.write(' => ')\n    if (node.body.type[0] === 'O') {\n      // Body is an object expression\n      state.write('(')\n      this.ObjectExpression(node.body, state)\n      state.write(')')\n    } else {\n      this[node.body.type](node.body, state)\n    }\n  },\n  ThisExpression(node, state) {\n    state.write('this', node)\n  },\n  Super(node, state) {\n    state.write('super', node)\n  },\n  RestElement: (RestElement = function (node, state) {\n    state.write('...')\n    this[node.argument.type](node.argument, state)\n  }),\n  SpreadElement: RestElement,\n  YieldExpression(node, state) {\n    state.write(node.delegate ? 'yield*' : 'yield')\n    if (node.argument) {\n      state.write(' ')\n      this[node.argument.type](node.argument, state)\n    }\n  },\n  AwaitExpression(node, state) {\n    state.write('await ', node)\n    formatExpression(state, node.argument, node)\n  },\n  TemplateLiteral(node, state) {\n    const { quasis, expressions } = node\n    state.write('`')\n    const { length } = expressions\n    for (let i = 0; i < length; i++) {\n      const expression = expressions[i]\n      const quasi = quasis[i]\n      state.write(quasi.value.raw, quasi)\n      state.write('${')\n      this[expression.type](expression, state)\n      state.write('}')\n    }\n    const quasi = quasis[quasis.length - 1]\n    state.write(quasi.value.raw, quasi)\n    state.write('`')\n  },\n  TemplateElement(node, state) {\n    state.write(node.value.raw, node)\n  },\n  TaggedTemplateExpression(node, state) {\n    formatExpression(state, node.tag, node)\n    this[node.quasi.type](node.quasi, state)\n  },\n  ArrayExpression: (ArrayExpression = function (node, state) {\n    state.write('[')\n    if (node.elements.length > 0) {\n      const { elements } = node,\n        { length } = elements\n      for (let i = 0; ; ) {\n        const element = elements[i]\n        if (element != null) {\n          this[element.type](element, state)\n        }\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          if (element == null) {\n            state.write(', ')\n          }\n          break\n        }\n      }\n    }\n    state.write(']')\n  }),\n  ArrayPattern: ArrayExpression,\n  ObjectExpression(node, state) {\n    const indent = state.indent.repeat(state.indentLevel++)\n    const { lineEnd, writeComments } = state\n    const propertyIndent = indent + state.indent\n    state.write('{')\n    if (node.properties.length > 0) {\n      state.write(lineEnd)\n      if (writeComments && node.comments != null) {\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n      }\n      const comma = ',' + lineEnd\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        const property = properties[i]\n        if (writeComments && property.comments != null) {\n          formatComments(state, property.comments, propertyIndent, lineEnd)\n        }\n        state.write(propertyIndent)\n        this[property.type](property, state)\n        if (++i < length) {\n          state.write(comma)\n        } else {\n          break\n        }\n      }\n      state.write(lineEnd)\n      if (writeComments && node.trailingComments != null) {\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n      }\n      state.write(indent + '}')\n    } else if (writeComments) {\n      if (node.comments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.comments, propertyIndent, lineEnd)\n        if (node.trailingComments != null) {\n          formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        }\n        state.write(indent + '}')\n      } else if (node.trailingComments != null) {\n        state.write(lineEnd)\n        formatComments(state, node.trailingComments, propertyIndent, lineEnd)\n        state.write(indent + '}')\n      } else {\n        state.write('}')\n      }\n    } else {\n      state.write('}')\n    }\n    state.indentLevel--\n  },\n  Property(node, state) {\n    if (node.method || node.kind[0] !== 'i') {\n      // Either a method or of kind `set` or `get` (not `init`)\n      this.MethodDefinition(node, state)\n    } else {\n      if (!node.shorthand) {\n        if (node.computed) {\n          state.write('[')\n          this[node.key.type](node.key, state)\n          state.write(']')\n        } else {\n          this[node.key.type](node.key, state)\n        }\n        state.write(': ')\n      }\n      this[node.value.type](node.value, state)\n    }\n  },\n  PropertyDefinition(node, state) {\n    if (node.static) {\n      state.write('static ')\n    }\n    if (node.computed) {\n      state.write('[')\n    }\n    this[node.key.type](node.key, state)\n    if (node.computed) {\n      state.write(']')\n    }\n    if (node.value == null) {\n      if (node.key.type[0] !== 'F') {\n        state.write(';')\n      }\n      return\n    }\n    state.write(' = ')\n    this[node.value.type](node.value, state)\n    state.write(';')\n  },\n  ObjectPattern(node, state) {\n    state.write('{')\n    if (node.properties.length > 0) {\n      const { properties } = node,\n        { length } = properties\n      for (let i = 0; ; ) {\n        this[properties[i].type](properties[i], state)\n        if (++i < length) {\n          state.write(', ')\n        } else {\n          break\n        }\n      }\n    }\n    state.write('}')\n  },\n  SequenceExpression(node, state) {\n    formatSequence(state, node.expressions)\n  },\n  UnaryExpression(node, state) {\n    if (node.prefix) {\n      const {\n        operator,\n        argument,\n        argument: { type },\n      } = node\n      state.write(operator)\n      const needsParentheses = expressionNeedsParenthesis(state, argument, node)\n      if (\n        !needsParentheses &&\n        (operator.length > 1 ||\n          (type[0] === 'U' &&\n            (type[1] === 'n' || type[1] === 'p') &&\n            argument.prefix &&\n            argument.operator[0] === operator &&\n            (operator === '+' || operator === '-')))\n      ) {\n        // Large operator or argument is UnaryExpression or UpdateExpression node\n        state.write(' ')\n      }\n      if (needsParentheses) {\n        state.write(operator.length > 1 ? ' (' : '(')\n        this[type](argument, state)\n        state.write(')')\n      } else {\n        this[type](argument, state)\n      }\n    } else {\n      // FIXME: This case never occurs\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  UpdateExpression(node, state) {\n    // Always applied to identifiers or members, no parenthesis check needed\n    if (node.prefix) {\n      state.write(node.operator)\n      this[node.argument.type](node.argument, state)\n    } else {\n      this[node.argument.type](node.argument, state)\n      state.write(node.operator)\n    }\n  },\n  AssignmentExpression(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' ' + node.operator + ' ')\n    this[node.right.type](node.right, state)\n  },\n  AssignmentPattern(node, state) {\n    this[node.left.type](node.left, state)\n    state.write(' = ')\n    this[node.right.type](node.right, state)\n  },\n  BinaryExpression: (BinaryExpression = function (node, state) {\n    const isIn = node.operator === 'in'\n    if (isIn) {\n      // Avoids confusion in `for` loops initializers\n      state.write('(')\n    }\n    formatExpression(state, node.left, node, false)\n    state.write(' ' + node.operator + ' ')\n    formatExpression(state, node.right, node, true)\n    if (isIn) {\n      state.write(')')\n    }\n  }),\n  LogicalExpression: BinaryExpression,\n  ConditionalExpression(node, state) {\n    const { test } = node\n    const precedence = state.expressionsPrecedence[test.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence <= state.expressionsPrecedence.ConditionalExpression\n    ) {\n      state.write('(')\n      this[test.type](test, state)\n      state.write(')')\n    } else {\n      this[test.type](test, state)\n    }\n    state.write(' ? ')\n    this[node.consequent.type](node.consequent, state)\n    state.write(' : ')\n    this[node.alternate.type](node.alternate, state)\n  },\n  NewExpression(node, state) {\n    state.write('new ')\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression ||\n      hasCallExpression(node.callee)\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    formatSequence(state, node['arguments'])\n  },\n  CallExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.callee.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.CallExpression\n    ) {\n      state.write('(')\n      this[node.callee.type](node.callee, state)\n      state.write(')')\n    } else {\n      this[node.callee.type](node.callee, state)\n    }\n    if (node.optional) {\n      state.write('?.')\n    }\n    formatSequence(state, node['arguments'])\n  },\n  ChainExpression(node, state) {\n    this[node.expression.type](node.expression, state)\n  },\n  MemberExpression(node, state) {\n    const precedence = state.expressionsPrecedence[node.object.type]\n    if (\n      precedence === NEEDS_PARENTHESES ||\n      precedence < state.expressionsPrecedence.MemberExpression\n    ) {\n      state.write('(')\n      this[node.object.type](node.object, state)\n      state.write(')')\n    } else {\n      this[node.object.type](node.object, state)\n    }\n    if (node.computed) {\n      if (node.optional) {\n        state.write('?.')\n      }\n      state.write('[')\n      this[node.property.type](node.property, state)\n      state.write(']')\n    } else {\n      if (node.optional) {\n        state.write('?.')\n      } else {\n        state.write('.')\n      }\n      this[node.property.type](node.property, state)\n    }\n  },\n  MetaProperty(node, state) {\n    state.write(node.meta.name + '.' + node.property.name, node)\n  },\n  Identifier(node, state) {\n    state.write(node.name, node)\n  },\n  PrivateIdentifier(node, state) {\n    state.write(`#${node.name}`, node)\n  },\n  Literal(node, state) {\n    if (node.raw != null) {\n      // Non-standard property\n      state.write(node.raw, node)\n    } else if (node.regex != null) {\n      this.RegExpLiteral(node, state)\n    } else if (node.bigint != null) {\n      state.write(node.bigint + 'n', node)\n    } else {\n      state.write(stringify(node.value), node)\n    }\n  },\n  RegExpLiteral(node, state) {\n    const { regex } = node\n    state.write(`/${regex.pattern}/${regex.flags}`, node)\n  },\n}\n\nconst EMPTY_OBJECT = {}\n\n/*\nDEPRECATED: Alternate export of `GENERATOR`.\n*/\nexport const baseGenerator = GENERATOR\n\nclass State {\n  constructor(options) {\n    const setup = options == null ? EMPTY_OBJECT : options\n    this.output = ''\n    // Functional options\n    if (setup.output != null) {\n      this.output = setup.output\n      this.write = this.writeToStream\n    } else {\n      this.output = ''\n    }\n    this.generator = setup.generator != null ? setup.generator : GENERATOR\n    this.expressionsPrecedence =\n      setup.expressionsPrecedence != null\n        ? setup.expressionsPrecedence\n        : EXPRESSIONS_PRECEDENCE\n    // Formating setup\n    this.indent = setup.indent != null ? setup.indent : '  '\n    this.lineEnd = setup.lineEnd != null ? setup.lineEnd : '\\n'\n    this.indentLevel =\n      setup.startingIndentLevel != null ? setup.startingIndentLevel : 0\n    this.writeComments = setup.comments ? setup.comments : false\n    // Source map\n    if (setup.sourceMap != null) {\n      this.write =\n        setup.output == null ? this.writeAndMap : this.writeToStreamAndMap\n      this.sourceMap = setup.sourceMap\n      this.line = 1\n      this.column = 0\n      this.lineEndSize = this.lineEnd.split('\\n').length - 1\n      this.mapping = {\n        original: null,\n        // Uses the entire state to avoid generating ephemeral objects\n        generated: this,\n        name: undefined,\n        source: setup.sourceMap.file || setup.sourceMap._file,\n      }\n    }\n  }\n\n  write(code) {\n    this.output += code\n  }\n\n  writeToStream(code) {\n    this.output.write(code)\n  }\n\n  writeAndMap(code, node) {\n    this.output += code\n    this.map(code, node)\n  }\n\n  writeToStreamAndMap(code, node) {\n    this.output.write(code)\n    this.map(code, node)\n  }\n\n  map(code, node) {\n    if (node != null) {\n      const { type } = node\n      if (type[0] === 'L' && type[2] === 'n') {\n        // LineComment\n        this.column = 0\n        this.line++\n        return\n      }\n      if (node.loc != null) {\n        const { mapping } = this\n        mapping.original = node.loc.start\n        mapping.name = node.name\n        this.sourceMap.addMapping(mapping)\n      }\n      if (\n        (type[0] === 'T' && type[8] === 'E') ||\n        (type[0] === 'L' && type[1] === 'i' && typeof node.value === 'string')\n      ) {\n        // TemplateElement or Literal string node\n        const { length } = code\n        let { column, line } = this\n        for (let i = 0; i < length; i++) {\n          if (code[i] === '\\n') {\n            column = 0\n            line++\n          } else {\n            column++\n          }\n        }\n        this.column = column\n        this.line = line\n        return\n      }\n    }\n    const { length } = code\n    const { lineEnd } = this\n    if (length > 0) {\n      if (\n        this.lineEndSize > 0 &&\n        (lineEnd.length === 1\n          ? code[length - 1] === lineEnd\n          : code.endsWith(lineEnd))\n      ) {\n        this.line += this.lineEndSize\n        this.column = 0\n      } else {\n        this.column += length\n      }\n    }\n  }\n\n  toString() {\n    return this.output\n  }\n}\n\nexport function generate(node, options) {\n  /*\n  Returns a string representing the rendered code of the provided AST `node`.\n  The `options` are:\n\n  - `indent`: string to use for indentation (defaults to `␣␣`)\n  - `lineEnd`: string to use for line endings (defaults to `\\n`)\n  - `startingIndentLevel`: indent level to start from (defaults to `0`)\n  - `comments`: generate comments if `true` (defaults to `false`)\n  - `output`: output stream to write the rendered code to (defaults to `null`)\n  - `generator`: custom code generator (defaults to `GENERATOR`)\n  - `expressionsPrecedence`: custom map of node types and their precedence level (defaults to `EXPRESSIONS_PRECEDENCE`)\n  */\n  const state = new State(options)\n  // Travel through the AST node and generate the code\n  state.generator[node.type](node, state)\n  return state.output\n}\n","__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};"],"names":["e","Object","Symbol","JSON","String","Error","formatSequence","expressionNeedsParenthesis","n","formatExpression","reindent","t","i","formatComments","hasCallExpression","formatVariableDeclaration","s","l","State","generate"],"mappings":"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"}