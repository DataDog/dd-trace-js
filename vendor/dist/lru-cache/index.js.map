{"version":3,"file":"lru-cache/index.js","sources":["webpack:///webpack/runtime/define_property_getters","webpack:///webpack/runtime/has_own_property","webpack:///webpack/runtime/make_namespace_object","webpack:///./lru-cache/dist/esm/index.js"],"sourcesContent":["__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n        if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n            Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n        }\n    }\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\n * @module LRUCache\n */\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"],"names":["e","Object","Symbol","performance","Date","Set","process","emitWarning","console","globalThis","warnACPolyfill","isPosInt","Math","isFinite","getUintArray","Uint8Array","Uint16Array","Uint32Array","Number","ZeroArray","Array","Stack","TypeError","LRUCache","i","d","m","Error","Map","t","setTimeout","getNow","s","a","cb","fetchFail","pcall","Promise","n"],"mappings":"2BAAA,GAAoB,CAAC,CAAG,CAACA,EAAS,KACjC,IAAI,IAAI,KAAO,EACL,EAAoB,CAAC,CAAC,EAAY,IAAQ,CAAC,EAAoB,CAAC,CAACA,EAAS,IACzEC,OAAO,cAAc,CAACD,EAAS,EAAK,CAAE,WAAY,GAAM,IAAK,CAAU,CAAC,EAAI,AAAC,EAGzF,ECNA,EAAoB,CAAC,CAAG,CAAC,EAAK,IAAUC,OAAO,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAK,GCClF,EAAoB,CAAC,CAAG,AAAC,IACrB,AAAkB,aAAlB,OAAOC,QAA0BA,OAAO,WAAW,EACrDD,OAAO,cAAc,CAAC,EAASC,OAAO,WAAW,CAAE,CAAE,MAAO,QAAS,GAEtED,OAAO,cAAc,CAAC,EAAS,aAAc,CAAE,MAAO,EAAK,EAC5D,E,+CCHA,IAAM,EAAO,AAAuB,UAAvB,OAAOE,aAChBA,aACA,AAA2B,YAA3B,OAAOA,YAAY,GAAG,CACpBA,YACAC,KACA,EAAS,IAAIC,IAEb,EAAW,AAAmB,UAAnB,OAAOC,SAA0BA,QAAUA,QAAU,CAAC,EAEjEC,YAAc,CAAC,EAAK,EAAM,EAAM,KAClC,AAA+B,YAA/B,OAAO,EAAQ,WAAW,CACpB,EAAQ,WAAW,CAAC,EAAK,EAAM,EAAM,GACrCC,QAAQ,KAAK,CAAC,CAAC,CAAC,EAAE,EAAK,EAAE,EAAE,EAAK,EAAE,EAAE,EAAI,CAAC,CACnD,EACI,EAAKC,WAAW,eAAe,CAC/B,EAAKA,WAAW,WAAW,CAE/B,GAAI,AAAc,SAAP,EAAoB,CAE3B,EAAK,MACD,OAAQ,AACR,UAAW,EAAE,AAAC,AACd,OAAO,AACP,SAAU,EAAM,AAChB,kBAAiB,CAAC,CAAE,CAAE,CAAE,CACpB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,EACvB,CACJ,EAEA,EAAK,MACD,aAAc,CACVC,gBACJ,CACA,OAAS,IAAI,CAAK,AAClB,OAAM,CAAM,CAAE,CACV,IAAI,IAAI,CAAC,MAAM,CAAC,OAAO,EAOvB,IAAK,IAAM,KAJX,IAAI,CAAC,MAAM,CAAC,MAAM,CAAG,EAErB,IAAI,CAAC,MAAM,CAAC,OAAO,CAAG,GAEL,IAAI,CAAC,MAAM,CAAC,QAAQ,EACjC,EAAG,EAEP,KAAI,CAAC,MAAM,CAAC,OAAO,GAAG,GAC1B,CACJ,EACA,IAAI,EAAyB,EAAQ,GAAG,EAAE,8BAAgC,IACpEA,eAAiB,KACd,IAEL,EAAyB,GACzBH,YAAY,maAM+D,sBAAuB,UAAWG,gBACjH,CACJ,CAGaR,OAAO,QACpB,IAAMS,SAAW,AAAC,GAAM,GAAK,IAAMC,KAAK,KAAK,CAAC,IAAM,EAAI,GAAKC,SAAS,GAUhEC,aAAe,AAAC,GAAQ,AAACH,SAAS,GAElC,GAAO,IACHI,WACA,GAAO,MACHC,YACA,GAAO,YACHC,YACA,GAAOC,OAAO,gBAAgB,CAC1BC,UACA,KAThB,KAWN,IAAMA,UAAN,MAAMA,kBAAkBC,MACpB,YAAY,CAAI,CAAE,CACd,KAAK,CAAC,GACN,IAAI,CAAC,IAAI,CAAC,EACd,CACJ,EACA,IAAMC,MAAN,MAAMA,MACF,IAAK,AACL,OAAO,AAEP,QAAO,EAAa,CAAG,EAAM,AAC7B,QAAO,OAAO,CAAG,CAAE,CACf,IAAM,EAAUP,aAAa,GAC7B,GAAI,CAAC,EACD,MAAO,EAAE,AACbO,CAAAA,MAAM,EAAa,CAAG,GACtB,IAAM,EAAI,IAAIA,MAAM,EAAK,GAEzB,OADAA,MAAM,EAAa,CAAG,GACf,CACX,CACA,YAAY,CAAG,CAAE,CAAO,CAAE,CAEtB,GAAI,CAACA,MAAM,EAAa,CACpB,MAAM,AAAIC,UAAU,0CAGxB,KAAI,CAAC,IAAI,CAAG,IAAI,EAAQ,GACxB,IAAI,CAAC,MAAM,CAAG,CAClB,CACA,KAAK,CAAC,CAAE,CACJ,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,MAAM,GAAG,CAAG,CAC/B,CACA,KAAM,CACF,OAAO,IAAI,CAAC,IAAI,CAAC,EAAE,IAAI,CAAC,MAAM,CAAC,AACnC,CACJ,EAgBO,IAAMC,SAAN,MAAMA,SAET,EAAI,AAAC,AACL,GAAQ,AAAC,AACT,GAAQ,AAAC,AACT,GAAa,AAAC,AACd,GAAY,AAAC,AACb,GAAW,AAAC,AAIZ,IAAI,AAIJ,cAAc,AAId,aAAa,AAIb,eAAe,AAIf,eAAe,AAIf,WAAW,AAIX,eAAe,AAIf,YAAY,AAIZ,aAAa,AAIb,gBAAgB,AAIhB,yBAAyB,AAIzB,mBAAmB,AAInB,uBAAuB,AAIvB,2BAA2B,AAI3B,iBAAiB,AAEjB,GAAK,AAAC,AACN,GAAe,AAAC,AAChB,GAAO,AAAC,AACR,GAAQ,AAAC,AACT,GAAQ,AAAC,AACT,GAAK,AAAC,AACN,GAAK,AAAC,AACN,GAAK,AAAC,AACN,GAAK,AAAC,AACN,GAAK,AAAC,AACN,GAAS,AAAC,AACV,GAAM,AAAC,AACP,GAAO,AAAC,AACR,GAAK,AAAC,AACN,GAAW,AAAC,AACZ,GAAe,AAAC,AAChB,GAAgB,AAAC,AAUjB,QAAO,sBAAsB,CAAC,CAAE,CAC5B,MAAO,CAEH,OAAQ,EAAE,EAAO,CACjB,KAAM,EAAE,EAAK,CACb,MAAO,EAAE,EAAM,CACf,OAAQ,EAAE,EAAO,CACjB,QAAS,EAAE,EAAQ,CACnB,QAAS,EAAE,EAAQ,CACnB,KAAM,EAAE,EAAK,CACb,KAAM,EAAE,EAAK,CACb,IAAI,MAAO,CACP,OAAO,EAAE,EAAK,AAClB,EACA,IAAI,MAAO,CACP,OAAO,EAAE,EAAK,AAClB,EACA,KAAM,EAAE,EAAK,CAEb,kBAAmB,AAAC,GAAM,EAAE,EAAkB,CAAC,GAC/C,gBAAiB,CAAC,EAAGC,EAAO,EAAS,IAAY,EAAE,EAAgB,CAAC,EAAGA,EAAO,EAAS,GACvF,WAAY,AAAC,GAAU,EAAE,EAAW,CAAC,GACrC,QAAS,AAAC,GAAY,EAAE,EAAQ,CAAC,GACjC,SAAU,AAAC,GAAY,EAAE,EAAS,CAAC,GACnC,QAAS,AAAC,GAAU,EAAE,EAAQ,CAAC,EACnC,CACJ,CAKA,IAAI,KAAM,CACN,OAAO,IAAI,CAAC,EAAI,AACpB,CAIA,IAAI,SAAU,CACV,OAAO,IAAI,CAAC,EAAQ,AACxB,CAIA,IAAI,gBAAiB,CACjB,OAAO,IAAI,CAAC,EAAe,AAC/B,CAIA,IAAI,MAAO,CACP,OAAO,IAAI,CAAC,EAAK,AACrB,CAIA,IAAI,aAAc,CACd,OAAO,IAAI,CAAC,EAAY,AAC5B,CACA,IAAI,YAAa,CACb,OAAO,IAAI,CAAC,EAAW,AAC3B,CAIA,IAAI,SAAU,CACV,OAAO,IAAI,CAAC,EAAQ,AACxB,CAIA,IAAI,cAAe,CACf,OAAO,IAAI,CAAC,EAAa,AAC7B,CACA,YAAY,CAAO,CAAE,CACjB,KAAM,CAAE,MAAM,CAAC,CAAE,KAAG,CAAE,gBAAgB,CAAC,CAAE,cAAY,CAAE,gBAAc,CAAE,gBAAc,CAAE,YAAU,CAAE,SAAO,CAAEC,aAAAA,CAAY,CAAE,gBAAc,CAAE,aAAW,CAAE,UAAU,CAAC,CAAE,eAAe,CAAC,CAAE,iBAAe,CAAE,aAAW,CAAEC,WAAAA,CAAU,CAAE,0BAAwB,CAAE,oBAAkB,CAAE,4BAA0B,CAAE,wBAAsB,CAAE,kBAAgB,CAAG,CAAG,EACxV,GAAI,AAAQ,IAAR,GAAa,CAACf,SAAS,GACvB,MAAM,AAAIW,UAAU,4CAExB,MAAM,EAAY,EAAMR,aAAa,GAAOM,MAC5C,GAAI,CAAC,EACD,MAAM,AAAIO,MAAM,sBAAwB,GAM5C,GAJA,IAAI,CAAC,EAAI,CAAG,EACZ,IAAI,CAAC,EAAQ,CAAG,EAChB,IAAI,CAAC,YAAY,CAAG,GAAgB,IAAI,CAAC,EAAQ,CACjD,IAAI,CAAC,eAAe,CAAG,EACnB,IAAI,CAAC,eAAe,CAAE,CACtB,GAAI,CAAC,IAAI,CAAC,EAAQ,EAAI,CAAC,IAAI,CAAC,YAAY,CACpC,MAAM,AAAIL,UAAU,sEAExB,GAAI,AAAgC,YAAhC,OAAO,IAAI,CAAC,eAAe,CAC3B,MAAM,AAAIA,UAAU,sCAE5B,CACA,GAAII,AAAe,SAAfA,GACA,AAAsB,YAAtB,OAAOA,EACP,MAAM,AAAIJ,UAAU,4CAGxB,GADA,IAAI,CAAC,EAAW,CAAGI,EACf,AAAgB,SAAhB,GACA,AAAuB,YAAvB,OAAO,EACP,MAAM,AAAIJ,UAAU,+CAkCxB,GAhCA,IAAI,CAAC,EAAY,CAAG,EACpB,IAAI,CAAC,EAAe,CAAG,CAAC,CAAC,EACzB,IAAI,CAAC,EAAO,CAAG,IAAIM,IACnB,IAAI,CAAC,EAAQ,CAAG,AAAIR,MAAM,GAAK,IAAI,CAAC,QACpC,IAAI,CAAC,EAAQ,CAAG,AAAIA,MAAM,GAAK,IAAI,CAAC,QACpC,IAAI,CAAC,EAAK,CAAG,IAAI,EAAU,GAC3B,IAAI,CAAC,EAAK,CAAG,IAAI,EAAU,GAC3B,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAK,CAAGC,MAAM,MAAM,CAAC,GAC1B,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAe,CAAG,EACnB,AAAmB,YAAnB,OAAO,GACP,KAAI,CAAC,EAAQ,CAAG,CAAM,EAEtB,AAAwB,YAAxB,OAAOI,GACP,IAAI,CAAC,EAAa,CAAGA,EACrB,IAAI,CAAC,EAAS,CAAG,EAAE,GAGnB,IAAI,CAAC,EAAa,CAAG,OACrB,IAAI,CAAC,EAAS,CAAG,QAErB,IAAI,CAAC,EAAW,CAAG,CAAC,CAAC,IAAI,CAAC,EAAQ,CAClC,IAAI,CAAC,EAAgB,CAAG,CAAC,CAAC,IAAI,CAAC,EAAa,CAC5C,IAAI,CAAC,cAAc,CAAG,CAAC,CAAC,EACxB,IAAI,CAAC,WAAW,CAAG,CAAC,CAAC,EACrB,IAAI,CAAC,wBAAwB,CAAG,CAAC,CAAC,EAClC,IAAI,CAAC,0BAA0B,CAAG,CAAC,CAAC,EACpC,IAAI,CAAC,sBAAsB,CAAG,CAAC,CAAC,EAChC,IAAI,CAAC,gBAAgB,CAAG,CAAC,CAAC,EAEtB,AAAsB,IAAtB,IAAI,CAAC,YAAY,CAAQ,CACzB,GAAI,AAAkB,IAAlB,IAAI,CAAC,EAAQ,EACT,CAACd,SAAS,IAAI,CAAC,EAAQ,EACvB,MAAM,AAAIW,UAAU,mDAG5B,GAAI,CAACX,SAAS,IAAI,CAAC,YAAY,EAC3B,MAAM,AAAIW,UAAU,wDAExB,IAAI,CAAC,EAAuB,EAChC,CAWA,GAVA,IAAI,CAAC,UAAU,CAAG,CAAC,CAAC,EACpB,IAAI,CAAC,kBAAkB,CAAG,CAAC,CAAC,EAC5B,IAAI,CAAC,cAAc,CAAG,CAAC,CAAC,EACxB,IAAI,CAAC,cAAc,CAAG,CAAC,CAAC,EACxB,IAAI,CAAC,aAAa,CACdX,SAAS,IAAkB,AAAkB,IAAlB,EACrB,EACA,EACV,IAAI,CAAC,YAAY,CAAG,CAAC,CAAC,EACtB,IAAI,CAAC,GAAG,CAAG,GAAO,EACd,IAAI,CAAC,GAAG,CAAE,CACV,GAAI,CAACA,SAAS,IAAI,CAAC,GAAG,EAClB,MAAM,AAAIW,UAAU,+CAExB,IAAI,CAAC,EAAsB,EAC/B,CAEA,GAAI,AAAc,IAAd,IAAI,CAAC,EAAI,EAAU,AAAa,IAAb,IAAI,CAAC,GAAG,EAAU,AAAkB,IAAlB,IAAI,CAAC,EAAQ,CAClD,MAAM,AAAIA,UAAU,oDAExB,GAAI,CAAC,IAAI,CAAC,YAAY,EAAI,CAAC,IAAI,CAAC,EAAI,EAAI,CAAC,IAAI,CAAC,EAAQ,CAAE,CACpD,MAAM,EAAO,sBAjVK,EAAO,GAAG,CAkVb,KACX,EAAO,GAAG,CAAC,GAGXf,YAFY,gGAEK,wBAAyB,EAAMgB,UAExD,CACJ,CAKA,gBAAgB,CAAG,CAAE,CACjB,OAAO,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAAO,IAAW,CAC9C,CACA,EAAsB,GAClB,IAAMM,EAAO,IAAIV,UAAU,IAAI,CAAC,EAAI,EAC9B,EAAS,IAAIA,UAAU,IAAI,CAAC,EAAI,CACtC,KAAI,CAAC,EAAK,CAAGU,EACb,IAAI,CAAC,EAAO,CAAG,EACf,IAAI,CAAC,EAAW,CAAG,CAAC,EAAO,EAAK,EAAQ,EAAK,GAAG,EAAE,IAG9C,GAFA,CAAM,CAAC,EAAM,CAAG,AAAQ,IAAR,EAAY,EAAQ,EACpCA,CAAI,CAAC,EAAM,CAAG,EACV,AAAQ,IAAR,GAAa,IAAI,CAAC,YAAY,CAAE,CAChC,IAAMA,EAAIC,WAAW,KACb,IAAI,CAAC,EAAQ,CAAC,IACd,IAAI,CAAC,EAAO,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAE,SAE3C,EAAG,EAAM,EAGLD,CAAAA,EAAE,KAAK,EACPA,EAAE,KAAK,EAGf,CACJ,EACA,IAAI,CAAC,EAAc,CAAG,IAClB,CAAM,CAAC,EAAM,CAAGA,AAAgB,IAAhBA,CAAI,CAAC,EAAM,CAAS,EAAK,GAAG,GAAK,CACrD,EACA,IAAI,CAAC,EAAU,CAAG,CAAC,EAAQ,KACvB,GAAIA,CAAI,CAAC,EAAM,CAAE,CACb,IAAM,EAAMA,CAAI,CAAC,EAAM,CACjB,EAAQ,CAAM,CAAC,EAAM,CAE3B,GAAI,CAAC,GAAO,CAAC,EACT,MACJ,GAAO,GAAG,CAAG,EACb,EAAO,KAAK,CAAG,EACf,EAAO,GAAG,CAAG,GAAaE,SAC1B,IAAM,EAAM,EAAO,GAAG,CAAG,CACzB,GAAO,YAAY,CAAG,EAAM,CAChC,CACJ,EAGA,IAAI,EAAY,EACVA,OAAS,KACX,IAAM,EAAI,EAAK,GAAG,GAClB,GAAI,IAAI,CAAC,aAAa,CAAG,EAAG,CACxB,EAAY,EACZ,IAAM,EAAID,WAAW,IAAO,EAAY,EAAI,IAAI,CAAC,aAAa,CAG1D,GAAE,KAAK,EACP,EAAE,KAAK,EAGf,CACA,OAAO,CACX,CACA,KAAI,CAAC,eAAe,CAAG,IACnB,IAAM,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC/B,GAAI,AAAU,SAAV,EACA,OAAO,EAEX,IAAM,EAAMD,CAAI,CAAC,EAAM,CACjB,EAAQ,CAAM,CAAC,EAAM,QAC3B,AAAI,AAAC,GAAQ,EAIN,EADK,CAAC,IAAaE,QAAO,EAAK,CAAI,EAF/B,GAIf,EACA,IAAI,CAAC,EAAQ,CAAGP,IACZ,IAAM,EAAI,CAAM,CAACA,EAAM,CACjB,EAAIK,CAAI,CAACL,EAAM,CACrB,MAAO,CAAC,CAAC,GAAK,CAAC,CAAC,GAAK,AAAC,IAAaO,QAAO,EAAK,EAAI,CACvD,CACJ,CAEA,EAAc,CAAG,KAAQ,CAAE,AAC3B,GAAU,CAAG,KAAQ,CAAE,AACvB,GAAW,CAAG,KAAQ,CAAE,AAExB,GAAQ,CAAG,IAAM,EAAM,AACvB,GAAuB,GACnB,IAAM,EAAQ,IAAIZ,UAAU,IAAI,CAAC,EAAI,CACrC,KAAI,CAAC,EAAe,CAAG,EACvB,IAAI,CAAC,EAAM,CAAG,EACd,IAAI,CAAC,EAAe,CAAG,IACnB,IAAI,CAAC,EAAe,EAAI,CAAK,CAAC,EAAM,CACpC,CAAK,CAAC,EAAM,CAAG,CACnB,EACA,IAAI,CAAC,EAAY,CAAG,CAAC,EAAG,EAAG,EAAMa,KAG7B,GAAI,IAAI,CAAC,EAAkB,CAAC,GACxB,OAAO,EAEX,GAAI,CAACrB,SAAS,GACV,GAAIqB,EAAiB,CACjB,GAAI,AAA2B,YAA3B,OAAOA,EACP,MAAM,AAAIV,UAAU,sCAGxB,GAAI,CAACX,SADL,EAAOqB,EAAgB,EAAG,IAEtB,MAAM,AAAIV,UAAU,2DAE5B,MAEI,MAAM,AAAIA,UAAU,6HAK5B,OAAO,CACX,EACA,IAAI,CAAC,EAAY,CAAG,CAAC,EAAO,EAAMU,KAE9B,GADA,CAAK,CAAC,EAAM,CAAG,EACX,IAAI,CAAC,EAAQ,CAAE,CACf,IAAM,EAAU,IAAI,CAAC,EAAQ,CAAG,CAAK,CAAC,EAAM,CAC5C,KAAO,IAAI,CAAC,EAAe,CAAG,GAC1B,IAAI,CAAC,EAAM,CAAC,GAEpB,CACA,IAAI,CAAC,EAAe,EAAI,CAAK,CAAC,EAAM,CAChCA,IACAA,EAAO,SAAS,CAAG,EACnBA,EAAO,mBAAmB,CAAG,IAAI,CAAC,EAAe,CAEzD,CACJ,CACA,EAAe,CAAG,IAAQ,CAAE,AAC5B,GAAY,CAAG,CAAC,EAAI,EAAI,KAAU,CAAE,AACpC,GAAY,CAAG,CAAC,EAAI,EAAI,EAAMA,KAC1B,GAAI,GAAQA,EACR,MAAM,AAAIV,UAAU,oEAExB,OAAO,CACX,CAAE,AACF,EAAC,EAAQ,CAAC,CAAE,aAAa,IAAI,CAAC,UAAU,CAAE,CAAG,CAAC,CAAC,EAC3C,GAAI,IAAI,CAAC,EAAK,CACV,IAAK,IAAI,EAAI,IAAI,CAAC,EAAK,CAOnB,AANK,IAAI,CAAC,EAAa,CAAC,KAGpB,IAAc,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAC,GAC9B,OAAM,GAEN,IAAM,IAAI,CAAC,EAAK,GAIhB,EAAI,IAAI,CAAC,EAAK,CAAC,EAAE,AAIjC,CACA,CAAC,EAAS,CAAC,CAAE,aAAa,IAAI,CAAC,UAAU,CAAE,CAAG,CAAC,CAAC,EAC5C,GAAI,IAAI,CAAC,EAAK,CACV,IAAK,IAAI,EAAI,IAAI,CAAC,EAAK,CAOnB,AANK,IAAI,CAAC,EAAa,CAAC,KAGpB,IAAc,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAC,GAC9B,OAAM,GAEN,IAAM,IAAI,CAAC,EAAK,GAIhB,EAAI,IAAI,CAAC,EAAK,CAAC,EAAE,AAIjC,CACA,EAAa,CAAC,CAAK,EACf,OAAQ,AAAU,SAAV,GACJ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAM,IAAM,CACnD,CAKA,CAAC,SAAU,CACP,IAAK,IAAM,KAAK,IAAI,CAAC,EAAQ,GACrB,AAAqB,SAArB,IAAI,CAAC,EAAQ,CAAC,EAAE,EAChB,AAAqB,SAArB,IAAI,CAAC,EAAQ,CAAC,EAAE,EACf,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,MAAM,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,CAAE,IAAI,CAAC,EAAQ,CAAC,EAAE,CAAC,AAAD,CAGrD,CAOA,CAAC,UAAW,CACR,IAAK,IAAM,KAAK,IAAI,CAAC,EAAS,GACtB,AAAqB,SAArB,IAAI,CAAC,EAAQ,CAAC,EAAE,EAChB,AAAqB,SAArB,IAAI,CAAC,EAAQ,CAAC,EAAE,EACf,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,MAAM,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,CAAE,IAAI,CAAC,EAAQ,CAAC,EAAE,CAAC,AAAD,CAGrD,CAKA,CAAC,MAAO,CACJ,IAAK,IAAM,KAAK,IAAI,CAAC,EAAQ,GAAI,CAC7B,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAE,AACtB,AAAM,UAAN,GACC,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,OAAM,EAEd,CACJ,CAOA,CAAC,OAAQ,CACL,IAAK,IAAM,KAAK,IAAI,CAAC,EAAS,GAAI,CAC9B,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAE,AACtB,AAAM,UAAN,GACC,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,OAAM,EAEd,CACJ,CAKA,CAAC,QAAS,CACN,IAAK,IAAM,KAAK,IAAI,CAAC,EAAQ,GAErB,AAAM,SADA,IAAI,CAAC,EAAQ,CAAC,EAAE,EAErB,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,OAAM,IAAI,CAAC,EAAQ,CAAC,EAAE,AAAD,CAGjC,CAOA,CAAC,SAAU,CACP,IAAK,IAAM,KAAK,IAAI,CAAC,EAAS,GAEtB,AAAM,SADA,IAAI,CAAC,EAAQ,CAAC,EAAE,EAErB,IAAI,CAAC,EAAkB,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,GACzC,OAAM,IAAI,CAAC,EAAQ,CAAC,EAAE,AAAD,CAGjC,CAKA,CAACpB,OAAO,QAAQ,CAAC,EAAG,CAChB,OAAO,IAAI,CAAC,OAAO,EACvB,CAMA,CAACA,OAAO,WAAW,CAAC,CAAG,UAAW,AAKlC,MAAK,CAAE,CAAE,EAAa,CAAC,CAAC,CAAE,CACtB,IAAK,IAAMsB,KAAK,IAAI,CAAC,EAAQ,GAAI,CAC7B,IAAM,EAAI,IAAI,CAAC,EAAQ,CAACA,EAAE,CACpB,EAAQ,IAAI,CAAC,EAAkB,CAAC,GAChC,EAAE,oBAAoB,CACtB,EACN,GAAI,AAAU,SAAV,GAEA,EAAG,EAAO,IAAI,CAAC,EAAQ,CAACA,EAAE,CAAE,IAAI,EAChC,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,EAAQ,CAACA,EAAE,CAAE,EAE1C,CACJ,CAYA,QAAQ,CAAE,CAAE,EAAQ,IAAI,CAAE,CACtB,IAAK,IAAMA,KAAK,IAAI,CAAC,EAAQ,GAAI,CAC7B,IAAM,EAAI,IAAI,CAAC,EAAQ,CAACA,EAAE,CACpB,EAAQ,IAAI,CAAC,EAAkB,CAAC,GAChC,EAAE,oBAAoB,CACtB,CACQ,UAAV,GAEJ,EAAG,IAAI,CAAC,EAAO,EAAO,IAAI,CAAC,EAAQ,CAACA,EAAE,CAAE,IAAI,CAChD,CACJ,CAKA,SAAS,CAAE,CAAE,EAAQ,IAAI,CAAE,CACvB,IAAK,IAAMA,KAAK,IAAI,CAAC,EAAS,GAAI,CAC9B,IAAM,EAAI,IAAI,CAAC,EAAQ,CAACA,EAAE,CACpB,EAAQ,IAAI,CAAC,EAAkB,CAAC,GAChC,EAAE,oBAAoB,CACtB,CACQ,UAAV,GAEJ,EAAG,IAAI,CAAC,EAAO,EAAO,IAAI,CAAC,EAAQ,CAACA,EAAE,CAAE,IAAI,CAChD,CACJ,CAKA,YAAa,CACT,IAAI,EAAU,GACd,IAAK,IAAM,KAAK,IAAI,CAAC,EAAS,CAAC,CAAE,WAAY,EAAK,GAC1C,IAAI,CAAC,EAAQ,CAAC,KACd,IAAI,CAAC,EAAO,CAAC,IAAI,CAAC,EAAQ,CAAC,EAAE,CAAE,UAC/B,EAAU,IAGlB,OAAO,CACX,CAaA,KAAK,CAAG,CAAE,CACN,IAAM,EAAI,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC3B,GAAI,AAAM,SAAN,EACA,OACJ,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAE,CACpB,EAAQ,IAAI,CAAC,EAAkB,CAAC,GAChC,EAAE,oBAAoB,CACtB,EACN,GAAI,AAAU,SAAV,EACA,OACJ,IAAM,EAAQ,CAAE,OAAM,EACtB,GAAI,IAAI,CAAC,EAAK,EAAI,IAAI,CAAC,EAAO,CAAE,CAC5B,IAAMK,EAAM,IAAI,CAAC,EAAK,CAAC,EAAE,CACnBG,EAAQ,IAAI,CAAC,EAAO,CAAC,EAAE,CACzBH,GAAOG,IAEP,EAAM,GAAG,CADMH,EAAO,GAAK,GAAG,GAAKG,CAAI,EAEvC,EAAM,KAAK,CAAG5B,KAAK,GAAG,GAE9B,CAIA,OAHI,IAAI,CAAC,EAAM,EACX,GAAM,IAAI,CAAG,IAAI,CAAC,EAAM,CAAC,EAAE,AAAD,EAEvB,CACX,CAcA,MAAO,CACH,IAAM,EAAM,EAAE,CACd,IAAK,IAAM,KAAK,IAAI,CAAC,EAAQ,CAAC,CAAE,WAAY,EAAK,GAAI,CACjD,IAAM,EAAM,IAAI,CAAC,EAAQ,CAAC,EAAE,CACtB,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAE,CACpB,EAAQ,IAAI,CAAC,EAAkB,CAAC,GAChC,EAAE,oBAAoB,CACtB,EACN,GAAI,AAAU,SAAV,GAAuB,AAAQ,SAAR,EACvB,SACJ,IAAM,EAAQ,CAAE,OAAM,EACtB,GAAI,IAAI,CAAC,EAAK,EAAI,IAAI,CAAC,EAAO,CAAE,CAC5B,EAAM,GAAG,CAAG,IAAI,CAAC,EAAK,CAAC,EAAE,CAGzB,IAAM,EAAM,EAAK,GAAG,GAAK,IAAI,CAAC,EAAO,CAAC,EAAE,AACxC,GAAM,KAAK,CAAGQ,KAAK,KAAK,CAACR,KAAK,GAAG,GAAK,EAC1C,CACI,IAAI,CAAC,EAAM,EACX,GAAM,IAAI,CAAG,IAAI,CAAC,EAAM,CAAC,EAAE,AAAD,EAE9B,EAAI,OAAO,CAAC,CAAC,EAAK,EAAM,CAC5B,CACA,OAAO,CACX,CAUA,KAAK,CAAG,CAAE,CAEN,IAAK,GAAM,CAAC,EAAK,EAAM,GADvB,IAAI,CAAC,KAAK,GACiB,GAAK,CAC5B,GAAI,EAAM,KAAK,CAAE,CAOb,IAAM,EAAMA,KAAK,GAAG,GAAK,EAAM,KAAK,AACpC,GAAM,KAAK,CAAG,EAAK,GAAG,GAAK,CAC/B,CACA,IAAI,CAAC,GAAG,CAAC,EAAK,EAAM,KAAK,CAAE,EAC/B,CACJ,CA+BA,IAAI,CAAC,CAAE,CAAC,CAAE,EAAa,CAAC,CAAC,CAAE,CACvB,GAAI,AAAM,SAAN,EAEA,OADA,IAAI,CAAC,MAAM,CAAC,GACL,IAAI,CAEf,GAAM,CAAE,MAAM,IAAI,CAAC,GAAG,CAAE,OAAK,CAAE,iBAAiB,IAAI,CAAC,cAAc,CAAE,kBAAkB,IAAI,CAAC,eAAe,CAAE,QAAM,CAAG,CAAG,EACrH,CAAE,cAAc,IAAI,CAAC,WAAW,CAAE,CAAG,EACnC,EAAO,IAAI,CAAC,EAAY,CAAC,EAAG,EAAG,EAAW,IAAI,EAAI,EAAG,GAG3D,GAAI,IAAI,CAAC,YAAY,EAAI,EAAO,IAAI,CAAC,YAAY,CAO7C,OANI,IACA,EAAO,GAAG,CAAG,OACb,EAAO,oBAAoB,CAAG,IAGlC,IAAI,CAAC,EAAO,CAAC,EAAG,OACT,IAAI,CAEf,IAAI,EAAQ,AAAe,IAAf,IAAI,CAAC,EAAK,CAAS,OAAY,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC5D,GAAI,AAAU,SAAV,EAEA,EAAS,AAAe,IAAf,IAAI,CAAC,EAAK,CACb,IAAI,CAAC,EAAK,CACV,AAAsB,IAAtB,IAAI,CAAC,EAAK,CAAC,MAAM,CACb,IAAI,CAAC,EAAK,CAAC,GAAG,GACd,IAAI,CAAC,EAAK,GAAK,IAAI,CAAC,EAAI,CACpB,IAAI,CAAC,EAAM,CAAC,IACZ,IAAI,CAAC,EAAK,CACxB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,EACvB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,EACvB,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,EAAG,GACpB,IAAI,CAAC,EAAK,CAAC,IAAI,CAAC,EAAK,CAAC,CAAG,EACzB,IAAI,CAAC,EAAK,CAAC,EAAM,CAAG,IAAI,CAAC,EAAK,CAC9B,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAK,GACV,IAAI,CAAC,EAAY,CAAC,EAAO,EAAM,GAC3B,GACA,GAAO,GAAG,CAAG,KAAI,EACrB,EAAc,OAEb,CAED,IAAI,CAAC,EAAW,CAAC,GACjB,IAAM,EAAS,IAAI,CAAC,EAAQ,CAAC,EAAM,CACnC,GAAI,IAAM,EAAQ,CACd,GAAI,IAAI,CAAC,EAAe,EAAI,IAAI,CAAC,EAAkB,CAAC,GAAS,CACzD,EAAO,iBAAiB,CAAC,KAAK,CAAC,AAAIuB,MAAM,aACzC,GAAM,CAAE,qBAAsB,CAAC,CAAE,CAAG,CAC1B,UAAN,GAAmB,CAAC,IAChB,IAAI,CAAC,EAAW,EAChB,IAAI,CAAC,EAAQ,GAAG,EAAG,EAAG,OAEtB,IAAI,CAAC,EAAgB,EACrB,IAAI,CAAC,EAAS,EAAE,KAAK,CAAC,EAAG,EAAG,MAAM,EAG9C,KACS,CAAC,IACF,IAAI,CAAC,EAAW,EAChB,IAAI,CAAC,EAAQ,GAAG,EAAQ,EAAG,OAE3B,IAAI,CAAC,EAAgB,EACrB,IAAI,CAAC,EAAS,EAAE,KAAK,CAAC,EAAQ,EAAG,MAAM,GAM/C,GAHA,IAAI,CAAC,EAAe,CAAC,GACrB,IAAI,CAAC,EAAY,CAAC,EAAO,EAAM,GAC/B,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,EACnB,EAAQ,CACR,EAAO,GAAG,CAAG,UACb,IAAM,EAAW,GAAU,IAAI,CAAC,EAAkB,CAAC,GAC7C,EAAO,oBAAoB,CAC3B,CACF,AAAa,UAAb,GACA,GAAO,QAAQ,CAAG,CAAO,CACjC,CACJ,MACS,GACL,GAAO,GAAG,CAAG,QAAO,CAE5B,CAWA,GAVI,AAAQ,IAAR,GAAc,IAAI,CAAC,EAAK,EACxB,IAAI,CAAC,EAAsB,GAE3B,IAAI,CAAC,EAAK,GACN,AAAC,GACD,IAAI,CAAC,EAAW,CAAC,EAAO,EAAK,GAE7B,GACA,IAAI,CAAC,EAAU,CAAC,EAAQ,IAE5B,CAAC,GAAkB,IAAI,CAAC,EAAgB,EAAI,IAAI,CAAC,EAAS,CAAE,CAC5D,IACIE,EADE,EAAK,IAAI,CAAC,EAAS,CAEzB,KAAQA,EAAO,GAAI,SACf,IAAI,CAAC,EAAa,MAAMA,EAEhC,CACA,OAAO,IAAI,AACf,CAKA,KAAM,CACF,GAAI,CACA,KAAO,IAAI,CAAC,EAAK,EAAE,CACf,IAAM,EAAM,IAAI,CAAC,EAAQ,CAAC,IAAI,CAAC,EAAK,CAAC,CAErC,GADA,IAAI,CAAC,EAAM,CAAC,IACR,IAAI,CAAC,EAAkB,CAAC,GACxB,IAAI,EAAI,oBAAoB,CACxB,OAAO,EAAI,oBAAoB,AACnC,MAEC,GAAI,AAAQ,SAAR,EACL,OAAO,CAEf,CACJ,QACQ,CACJ,GAAI,IAAI,CAAC,EAAgB,EAAI,IAAI,CAAC,EAAS,CAAE,CACzC,IACIA,EADE,EAAK,IAAI,CAAC,EAAS,CAEzB,KAAQA,EAAO,GAAI,SACf,IAAI,CAAC,EAAa,MAAMA,EAEhC,CACJ,CACJ,CACA,EAAM,CAAC,CAAI,EACP,IAAM,EAAO,IAAI,CAAC,EAAK,CACjB,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAK,CACvB,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAK,CA4B7B,OA3BI,IAAI,CAAC,EAAe,EAAI,IAAI,CAAC,EAAkB,CAAC,GAChD,EAAE,iBAAiB,CAAC,KAAK,CAAC,AAAIF,MAAM,YAE/B,KAAI,CAAC,EAAW,EAAI,IAAI,CAAC,EAAgB,AAAD,IACzC,IAAI,CAAC,EAAW,EAChB,IAAI,CAAC,EAAQ,GAAG,EAAG,EAAG,SAEtB,IAAI,CAAC,EAAgB,EACrB,IAAI,CAAC,EAAS,EAAE,KAAK,CAAC,EAAG,EAAG,QAAQ,GAG5C,IAAI,CAAC,EAAe,CAAC,GAEjB,IACA,IAAI,CAAC,EAAQ,CAAC,EAAK,CAAG,OACtB,IAAI,CAAC,EAAQ,CAAC,EAAK,CAAG,OACtB,IAAI,CAAC,EAAK,CAAC,IAAI,CAAC,IAEhB,AAAe,IAAf,IAAI,CAAC,EAAK,EACV,IAAI,CAAC,EAAK,CAAG,IAAI,CAAC,EAAK,CAAG,EAC1B,IAAI,CAAC,EAAK,CAAC,MAAM,CAAG,GAGpB,IAAI,CAAC,EAAK,CAAG,IAAI,CAAC,EAAK,CAAC,EAAK,CAEjC,IAAI,CAAC,EAAO,CAAC,MAAM,CAAC,GACpB,IAAI,CAAC,EAAK,GACH,CACX,CAiBA,IAAI,CAAC,CAAE,EAAa,CAAC,CAAC,CAAE,CACpB,GAAM,CAAE,iBAAiB,IAAI,CAAC,cAAc,CAAEK,OAAAA,CAAM,CAAE,CAAG,EACnD,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC/B,GAAI,AAAU,SAAV,EAAqB,CACrB,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,CAC9B,GAAI,IAAI,CAAC,EAAkB,CAAC,IACxB,AAA2B,SAA3B,EAAE,oBAAoB,CACtB,MAAO,GAEX,GAAI,CAAC,IAAI,CAAC,EAAQ,CAAC,GAQf,OAPI,GACA,IAAI,CAAC,EAAc,CAAC,GAEpBA,IACAA,EAAO,GAAG,CAAG,MACb,IAAI,CAAC,EAAU,CAACA,EAAQ,IAErB,GAEFA,IACLA,EAAO,GAAG,CAAG,QACb,IAAI,CAAC,EAAU,CAACA,EAAQ,GAEhC,MACSA,GACLA,CAAAA,EAAO,GAAG,CAAG,MAAK,EAEtB,MAAO,EACX,CAQA,KAAK,CAAC,CAAE,EAAc,CAAC,CAAC,CAAE,CACtB,GAAM,CAAE,aAAa,IAAI,CAAC,UAAU,CAAE,CAAG,EACnC,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC/B,GAAI,AAAU,SAAV,GACC,CAAC,GAAc,IAAI,CAAC,EAAQ,CAAC,GAC9B,OAEJ,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,CAE9B,OAAO,IAAI,CAAC,EAAkB,CAAC,GAAK,EAAE,oBAAoB,CAAG,CACjE,CACA,EAAgB,CAAC,CAAC,CAAE,CAAK,CAAE,CAAO,CAAE,CAAO,EACvC,IAAM,EAAI,AAAU,SAAV,EAAsB,OAAY,IAAI,CAAC,EAAQ,CAAC,EAAM,CAChE,GAAI,IAAI,CAAC,EAAkB,CAAC,GACxB,OAAO,EAEX,IAAMC,EAAK,IAAI,EACT,CAAE,QAAM,CAAE,CAAG,EAEnB,GAAQ,iBAAiB,QAAS,IAAMA,EAAG,KAAK,CAAC,EAAO,MAAM,EAAG,CAC7D,OAAQA,EAAG,MAAM,AACrB,GACA,IAAM,EAAY,CACd,OAAQA,EAAG,MAAM,CACjB,UACA,SACJ,EACMC,GAAK,CAAC,EAAG,EAAc,EAAK,IAC9B,GAAM,CAAE,SAAO,CAAE,CAAGD,EAAG,MAAM,CACvB,EAAc,EAAQ,gBAAgB,EAAI,AAAM,SAAN,QAYhD,CAXI,EAAQ,MAAM,GACV,GAAW,CAAC,GACZ,EAAQ,MAAM,CAAC,YAAY,CAAG,GAC9B,EAAQ,MAAM,CAAC,UAAU,CAAGA,EAAG,MAAM,CAAC,MAAM,CACxC,GACA,GAAQ,MAAM,CAAC,iBAAiB,CAAG,EAAG,GAG1C,EAAQ,MAAM,CAAC,aAAa,CAAG,IAGnC,IAAY,GAAgB,IAK5B,IAAI,CAAC,EAAQ,CAAC,EAAM,GAAK,IACrB,AAAM,SAAN,EACI,AAHD,EAGI,oBAAoB,CACvB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,AAJxB,EAI2B,oBAAoB,CAG9C,IAAI,CAAC,EAAO,CAAC,EAAG,UAIhB,EAAQ,MAAM,EACd,GAAQ,MAAM,CAAC,YAAY,CAAG,EAAG,EACrC,IAAI,CAAC,GAAG,CAAC,EAAG,EAAG,EAAU,OAAO,IAGjC,GAnBIE,UAAUF,EAAG,MAAM,CAAC,MAAM,CAoBzC,EAQME,UAAY,AAAC,IACf,GAAM,CAAE,SAAO,CAAE,CAAGF,EAAG,MAAM,CACvB,EAAoB,GAAW,EAAQ,sBAAsB,CAC7D,EAAa,GAAqB,EAAQ,0BAA0B,CACpE,EAAW,GAAc,EAAQ,wBAAwB,CAiB/D,GAfI,IAAI,CAAC,EAAQ,CAAC,EAAM,GAAK,IAGb,AAAC,GAAY,AAA4B,SAA5B,AAJlB,EAIqB,oBAAoB,CAIvC,AAAC,GAKN,KAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,AAbpB,EAauB,oBAAoB,AAAD,EAP7C,IAAI,CAAC,EAAO,CAAC,EAAG,UAUpB,EAIA,OAHI,EAAQ,MAAM,EAAI,AAA4B,SAA5B,AAjBf,EAiBkB,oBAAoB,EACzC,GAAQ,MAAM,CAAC,aAAa,CAAG,EAAG,EAE/B,AApBA,EAoBG,oBAAoB,CAE7B,GAAI,AAtBE,EAsBC,UAAU,GAtBX,EAuBP,MAAM,CAEd,EACMG,MAAQ,CAAC,EAAK,KAChB,IAAM,EAAM,IAAI,CAAC,EAAY,GAAG,EAAG,EAAG,EAClC,IAAO,aAAeC,SACtB,EAAI,IAAI,CAAC,GAAK,EAAI,AAAM,SAAN,EAAkB,OAAY,GAAI,GAKxDJ,EAAG,MAAM,CAAC,gBAAgB,CAAC,QAAS,KAC5B,EAAC,EAAQ,gBAAgB,EACzB,EAAQ,sBAAsB,AAAD,IAC7B,EAAI,QAEA,EAAQ,sBAAsB,EAC9B,GAAM,GAAKC,GAAG,EAAG,GAAI,EAGjC,EACJ,CACI,GAAQ,MAAM,EACd,GAAQ,MAAM,CAAC,eAAe,CAAG,EAAG,EACxC,IAAM,EAAI,IAAIG,QAAQD,OAAO,IAAI,CAACF,GA3DvB,AAAC,IACJ,EAAQ,MAAM,GACd,EAAQ,MAAM,CAAC,aAAa,CAAG,GAC/B,EAAQ,MAAM,CAAC,UAAU,CAAG,GAEzBC,UAAU,KAuDf,EAAKlC,OAAO,MAAM,CAAC,EAAG,CACxB,kBAAmBgC,EACnB,qBAAsB,EACtB,WAAY,MAChB,GASA,OARI,AAAU,SAAV,GAEA,IAAI,CAAC,GAAG,CAAC,EAAG,EAAI,CAAE,GAAG,EAAU,OAAO,CAAE,OAAQ,MAAU,GAC1D,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,IAGzB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,EAEpB,CACX,CACA,EAAkB,CAAC,CAAC,QAChB,CAAI,CAAC,IAAI,CAAC,EAAe,EAGjB,CAAC,CADC,GAEN,AAFM,aAEOI,SACb,AAHM,EAGJ,cAAc,CAAC,yBACjB,AAJM,EAIJ,iBAAiB,YAAY,CACvC,CACA,MAAM,MAAM,CAAC,CAAE,EAAe,CAAC,CAAC,CAAE,CAC9B,GAAM,CAEN,aAAa,IAAI,CAAC,UAAU,CAAE,iBAAiB,IAAI,CAAC,cAAc,CAAE,qBAAqB,IAAI,CAAC,kBAAkB,CAEhH,MAAM,IAAI,CAAC,GAAG,CAAE,iBAAiB,IAAI,CAAC,cAAc,CAAE,OAAO,CAAC,CAAE,kBAAkB,IAAI,CAAC,eAAe,CAAEC,YAAAA,EAAc,IAAI,CAAC,WAAW,CAEtI,2BAA2B,IAAI,CAAC,wBAAwB,CAAE,6BAA6B,IAAI,CAAC,0BAA0B,CAAE,mBAAmB,IAAI,CAAC,gBAAgB,CAAE,yBAAyB,IAAI,CAAC,sBAAsB,CAAE,SAAO,CAAE,eAAe,EAAK,CAAE,QAAM,CAAE,QAAM,CAAG,CAAG,EAC3Q,GAAI,CAAC,IAAI,CAAC,EAAe,CAGrB,OAFI,GACA,GAAO,KAAK,CAAG,KAAI,EAChB,IAAI,CAAC,GAAG,CAAC,EAAG,CACf,aACA,iBACA,qBACA,QACJ,GAEJ,IAAM,EAAU,CACZ,aACA,iBACA,qBACA,MACA,iBACA,OACA,kBACAA,YAAAA,EACA,2BACA,6BACA,yBACA,mBACA,SACA,QACJ,EACI,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC7B,GAAI,AAAU,SAAV,EAAqB,CACjB,GACA,GAAO,KAAK,CAAG,MAAK,EACxB,IAAM,EAAI,IAAI,CAAC,EAAgB,CAAC,EAAG,EAAO,EAAS,GACnD,OAAQ,EAAE,UAAU,CAAG,CAC3B,CACK,CAED,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,CAC9B,GAAI,IAAI,CAAC,EAAkB,CAAC,GAAI,CAC5B,IAAM,EAAQ,GAAc,AAA2B,SAA3B,EAAE,oBAAoB,CAMlD,OALI,IACA,EAAO,KAAK,CAAG,WACX,GACA,GAAO,aAAa,CAAG,EAAG,GAE3B,EAAQ,EAAE,oBAAoB,CAAI,EAAE,UAAU,CAAG,CAC5D,CAGA,IAAM,EAAU,IAAI,CAAC,EAAQ,CAAC,GAC9B,GAAI,CAAC,GAAgB,CAAC,EASlB,OARI,GACA,GAAO,KAAK,CAAG,KAAI,EACvB,IAAI,CAAC,EAAW,CAAC,GACb,GACA,IAAI,CAAC,EAAc,CAAC,GAEpB,GACA,IAAI,CAAC,EAAU,CAAC,EAAQ,GACrB,EAIX,IAAM,EAAI,IAAI,CAAC,EAAgB,CAAC,EAAG,EAAO,EAAS,GAE7C,EAAW,AAD2B,SAA3B,EAAE,oBAAoB,EACV,EAM7B,OALI,IACA,EAAO,KAAK,CAAG,EAAU,QAAU,UAC/B,GAAY,GACZ,GAAO,aAAa,CAAG,EAAG,GAE3B,EAAW,EAAE,oBAAoB,CAAI,EAAE,UAAU,CAAG,CAC/D,CACJ,CACA,MAAM,WAAW,CAAC,CAAE,EAAe,CAAC,CAAC,CAAE,CACnC,IAAM,EAAI,MAAM,IAAI,CAAC,KAAK,CAAC,EAAG,GAC9B,GAAI,AAAM,SAAN,EACA,MAAM,AAAIX,MAAM,8BACpB,OAAO,CACX,CACA,KAAK,CAAC,CAAE,EAAc,CAAC,CAAC,CAAE,CACtB,IAAM,EAAa,IAAI,CAAC,EAAW,CACnC,GAAI,CAAC,EACD,MAAM,AAAIA,MAAM,yCAEpB,GAAM,CAAE,SAAO,CAAE,cAAY,CAAE,GAAG,EAAS,CAAG,EACxC,EAAI,IAAI,CAAC,GAAG,CAAC,EAAG,GACtB,GAAI,CAAC,GAAgB,AAAM,SAAN,EACjB,OAAO,EACX,IAAM,EAAK,EAAW,EAAG,EAAG,CACxB,UACA,SACJ,GAEA,OADA,IAAI,CAAC,GAAG,CAAC,EAAG,EAAI,GACT,CACX,CAOA,IAAI,CAAC,CAAE,EAAa,CAAC,CAAC,CAAE,CACpB,GAAM,CAAE,aAAa,IAAI,CAAC,UAAU,CAAE,iBAAiB,IAAI,CAAC,cAAc,CAAE,qBAAqB,IAAI,CAAC,kBAAkB,CAAE,QAAM,CAAG,CAAG,EAChI,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC/B,GAAI,AAAU,SAAV,EAAqB,CACrB,IAAM,EAAQ,IAAI,CAAC,EAAQ,CAAC,EAAM,CAC5B,EAAW,IAAI,CAAC,EAAkB,CAAC,SAGzC,CAFI,GACA,IAAI,CAAC,EAAU,CAAC,EAAQ,GACxB,IAAI,CAAC,EAAQ,CAAC,IAId,CAHI,GACA,GAAO,GAAG,CAAG,OAAM,EAElB,IASG,GACA,GACA,AAA+B,SAA/B,EAAM,oBAAoB,EAC1B,GAAO,aAAa,CAAG,EAAG,EAEvB,EAAa,EAAM,oBAAoB,CAAG,SAb7C,AAAC,GACD,IAAI,CAAC,EAAO,CAAC,EAAG,UAEhB,GAAU,GACV,GAAO,aAAa,CAAG,EAAG,EACvB,EAAa,EAAQ,QAmBhC,CAPI,GACA,GAAO,GAAG,CAAG,KAAI,EAMjB,GACO,EAAM,oBAAoB,EAErC,IAAI,CAAC,EAAW,CAAC,GACb,GACA,IAAI,CAAC,EAAc,CAAC,GAEjB,EAEf,CACS,GACL,GAAO,GAAG,CAAG,MAAK,CAE1B,CACA,EAAQ,CAAC,CAAC,CAAE,CAAC,EACT,IAAI,CAAC,EAAK,CAAC,EAAE,CAAG,EAChB,IAAI,CAAC,EAAK,CAAC,EAAE,CAAG,CACpB,CACA,EAAW,CAAC,CAAK,EAST,IAAU,IAAI,CAAC,EAAK,GAChB,IAAU,IAAI,CAAC,EAAK,CACpB,IAAI,CAAC,EAAK,CAAG,IAAI,CAAC,EAAK,CAAC,EAAM,CAG9B,IAAI,CAAC,EAAQ,CAAC,IAAI,CAAC,EAAK,CAAC,EAAM,CAAE,IAAI,CAAC,EAAK,CAAC,EAAM,EAEtD,IAAI,CAAC,EAAQ,CAAC,IAAI,CAAC,EAAK,CAAE,GAC1B,IAAI,CAAC,EAAK,CAAG,EAErB,CAMA,OAAO,CAAC,CAAE,CACN,OAAO,IAAI,CAAC,EAAO,CAAC,EAAG,SAC3B,CACA,EAAO,CAAC,CAAC,CAAE,CAAM,EACb,IAAI,EAAU,GACd,GAAI,AAAe,IAAf,IAAI,CAAC,EAAK,CAAQ,CAClB,IAAM,EAAQ,IAAI,CAAC,EAAO,CAAC,GAAG,CAAC,GAC/B,GAAI,AAAU,SAAV,EAEA,GADA,EAAU,GACN,AAAe,IAAf,IAAI,CAAC,EAAK,CACV,IAAI,CAAC,EAAM,CAAC,OAEX,CACD,IAAI,CAAC,EAAe,CAAC,GACrB,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,CAe9B,GAdI,IAAI,CAAC,EAAkB,CAAC,GACxB,EAAE,iBAAiB,CAAC,KAAK,CAAC,AAAIA,MAAM,YAE/B,KAAI,CAAC,EAAW,EAAI,IAAI,CAAC,EAAgB,AAAD,IACzC,IAAI,CAAC,EAAW,EAChB,IAAI,CAAC,EAAQ,GAAG,EAAG,EAAG,GAEtB,IAAI,CAAC,EAAgB,EACrB,IAAI,CAAC,EAAS,EAAE,KAAK,CAAC,EAAG,EAAG,EAAO,GAG3C,IAAI,CAAC,EAAO,CAAC,MAAM,CAAC,GACpB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,OACvB,IAAI,CAAC,EAAQ,CAAC,EAAM,CAAG,OACnB,IAAU,IAAI,CAAC,EAAK,CACpB,IAAI,CAAC,EAAK,CAAG,IAAI,CAAC,EAAK,CAAC,EAAM,MAE7B,GAAI,IAAU,IAAI,CAAC,EAAK,CACzB,IAAI,CAAC,EAAK,CAAG,IAAI,CAAC,EAAK,CAAC,EAAM,KAE7B,CACD,IAAM,EAAK,IAAI,CAAC,EAAK,CAAC,EAAM,AAC5B,KAAI,CAAC,EAAK,CAAC,EAAG,CAAG,IAAI,CAAC,EAAK,CAAC,EAAM,CAClC,IAAM,EAAK,IAAI,CAAC,EAAK,CAAC,EAAM,AAC5B,KAAI,CAAC,EAAK,CAAC,EAAG,CAAG,IAAI,CAAC,EAAK,CAAC,EAAM,AACtC,CACA,IAAI,CAAC,EAAK,GACV,IAAI,CAAC,EAAK,CAAC,IAAI,CAAC,EACpB,CAER,CACA,GAAI,IAAI,CAAC,EAAgB,EAAI,IAAI,CAAC,EAAS,EAAE,OAAQ,CACjD,IACIE,EADE,EAAK,IAAI,CAAC,EAAS,CAEzB,KAAQA,EAAO,GAAI,SACf,IAAI,CAAC,EAAa,MAAMA,EAEhC,CACA,OAAO,CACX,CAIA,OAAQ,CACJ,OAAO,IAAI,CAAC,EAAM,CAAC,SACvB,CACA,EAAM,CAAC,CAAM,EACT,IAAK,IAAM,KAAS,IAAI,CAAC,EAAS,CAAC,CAAE,WAAY,EAAK,GAAI,CACtD,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,CAC9B,GAAI,IAAI,CAAC,EAAkB,CAAC,GACxB,EAAE,iBAAiB,CAAC,KAAK,CAAC,AAAIF,MAAM,gBAEnC,CACD,IAAM,EAAI,IAAI,CAAC,EAAQ,CAAC,EAAM,AAC1B,KAAI,CAAC,EAAW,EAChB,IAAI,CAAC,EAAQ,GAAG,EAAG,EAAG,GAEtB,IAAI,CAAC,EAAgB,EACrB,IAAI,CAAC,EAAS,EAAE,KAAK,CAAC,EAAG,EAAG,EAAO,CAE3C,CACJ,CAgBA,GAfA,IAAI,CAAC,EAAO,CAAC,KAAK,GAClB,IAAI,CAAC,EAAQ,CAAC,IAAI,CAAC,QACnB,IAAI,CAAC,EAAQ,CAAC,IAAI,CAAC,QACf,IAAI,CAAC,EAAK,EAAI,IAAI,CAAC,EAAO,GAC1B,IAAI,CAAC,EAAK,CAAC,IAAI,CAAC,GAChB,IAAI,CAAC,EAAO,CAAC,IAAI,CAAC,IAElB,IAAI,CAAC,EAAM,EACX,IAAI,CAAC,EAAM,CAAC,IAAI,CAAC,GAErB,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAK,CAAG,EACb,IAAI,CAAC,EAAK,CAAC,MAAM,CAAG,EACpB,IAAI,CAAC,EAAe,CAAG,EACvB,IAAI,CAAC,EAAK,CAAG,EACT,IAAI,CAAC,EAAgB,EAAI,IAAI,CAAC,EAAS,CAAE,CACzC,IACIE,EADE,EAAK,IAAI,CAAC,EAAS,CAEzB,KAAQA,EAAO,GAAI,SACf,IAAI,CAAC,EAAa,MAAMA,EAEhC,CACJ,CACJ,C"}