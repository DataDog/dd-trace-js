(()=>{"use strict";var t={};t.d=(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},t.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),t.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var e={};t.r(e),t.d(e,{LRUCache:()=>LRUCache});let i="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,s=new Set,h="object"==typeof process&&process?process:{},emitWarning=(t,e,i,s)=>{"function"==typeof h.emitWarning?h.emitWarning(t,e,i,s):console.error(`[${i}] ${e}: ${t}`)},r=globalThis.AbortController,a=globalThis.AbortSignal;if(void 0===r){a=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(t,e){this._onabort.push(e)}},r=class{constructor(){warnACPolyfill()}signal=new a;abort(t){if(!this.signal.aborted){for(let e of(this.signal.reason=t,this.signal.aborted=!0,this.signal._onabort))e(t);this.signal.onabort?.(t)}}};let t=h.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1",warnACPolyfill=()=>{t&&(t=!1,emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",warnACPolyfill))}}Symbol("type");let isPosInt=t=>t&&t===Math.floor(t)&&t>0&&isFinite(t),getUintArray=t=>isPosInt(t)?t<=256?Uint8Array:t<=65536?Uint16Array:t<=0x100000000?Uint32Array:t<=Number.MAX_SAFE_INTEGER?ZeroArray:null:null;let ZeroArray=class ZeroArray extends Array{constructor(t){super(t),this.fill(0)}};let Stack=class Stack{heap;length;static #t=!1;static create(t){let e=getUintArray(t);if(!e)return[];Stack.#t=!0;let i=new Stack(t,e);return Stack.#t=!1,i}constructor(t,e){if(!Stack.#t)throw TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}};let LRUCache=class LRUCache{#e;#i;#s;#h;#r;#a;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#o;#l;#n;#d;#c;#u;#f;#p;#g;#v;#m;#y;#S;#z;#L;#_;#k;static unsafeExposeInternals(t){return{starts:t.#S,ttls:t.#z,sizes:t.#y,keyMap:t.#n,keyList:t.#d,valList:t.#c,next:t.#u,prev:t.#f,get head(){return t.#p},get tail(){return t.#g},free:t.#v,isBackgroundFetch:e=>t.#A(e),backgroundFetch:(e,i,s,h)=>t.#x(e,i,s,h),moveToTail:e=>t.#F(e),indexes:e=>t.#T(e),rindexes:e=>t.#b(e),isStale:e=>t.#w(e)}}get max(){return this.#e}get maxSize(){return this.#i}get calculatedSize(){return this.#l}get size(){return this.#o}get fetchMethod(){return this.#r}get memoMethod(){return this.#a}get dispose(){return this.#s}get disposeAfter(){return this.#h}constructor(t){const{max:e=0,ttl:i,ttlResolution:h=1,ttlAutopurge:r,updateAgeOnGet:a,updateAgeOnHas:o,allowStale:l,dispose:n,disposeAfter:d,noDisposeOnSet:c,noUpdateTTL:u,maxSize:f=0,maxEntrySize:p=0,sizeCalculation:g,fetchMethod:v,memoMethod:m,noDeleteOnFetchRejection:y,noDeleteOnStaleGet:S,allowStaleOnFetchRejection:z,allowStaleOnFetchAbort:L,ignoreFetchAbort:_}=t;if(0!==e&&!isPosInt(e))throw TypeError("max option must be a nonnegative integer");const k=e?getUintArray(e):Array;if(!k)throw Error("invalid max value: "+e);if(this.#e=e,this.#i=f,this.maxEntrySize=p||this.#i,this.sizeCalculation=g,this.sizeCalculation){if(!this.#i&&!this.maxEntrySize)throw TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw TypeError("sizeCalculation set to non-function")}if(void 0!==m&&"function"!=typeof m)throw TypeError("memoMethod must be a function if defined");if(this.#a=m,void 0!==v&&"function"!=typeof v)throw TypeError("fetchMethod must be a function if specified");if(this.#r=v,this.#_=!!v,this.#n=new Map,this.#d=Array(e).fill(void 0),this.#c=Array(e).fill(void 0),this.#u=new k(e),this.#f=new k(e),this.#p=0,this.#g=0,this.#v=Stack.create(e),this.#o=0,this.#l=0,"function"==typeof n&&(this.#s=n),"function"==typeof d?(this.#h=d,this.#m=[]):(this.#h=void 0,this.#m=void 0),this.#L=!!this.#s,this.#k=!!this.#h,this.noDisposeOnSet=!!c,this.noUpdateTTL=!!u,this.noDeleteOnFetchRejection=!!y,this.allowStaleOnFetchRejection=!!z,this.allowStaleOnFetchAbort=!!L,this.ignoreFetchAbort=!!_,0!==this.maxEntrySize){if(0!==this.#i&&!isPosInt(this.#i))throw TypeError("maxSize must be a positive integer if specified");if(!isPosInt(this.maxEntrySize))throw TypeError("maxEntrySize must be a positive integer if specified");this.#E()}if(this.allowStale=!!l,this.noDeleteOnStaleGet=!!S,this.updateAgeOnGet=!!a,this.updateAgeOnHas=!!o,this.ttlResolution=isPosInt(h)||0===h?h:1,this.ttlAutopurge=!!r,this.ttl=i||0,this.ttl){if(!isPosInt(this.ttl))throw TypeError("ttl must be a positive integer if specified");this.#M()}if(0===this.#e&&0===this.ttl&&0===this.#i)throw TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#e&&!this.#i){const t="LRU_CACHE_UNBOUNDED";s.has(t)||(s.add(t),emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",t,LRUCache))}}getRemainingTTL(t){return this.#n.has(t)?1/0:0}#M(){let t=new ZeroArray(this.#e),e=new ZeroArray(this.#e);this.#z=t,this.#S=e,this.#O=(s,h,r=i.now())=>{if(e[s]=0!==h?r:0,t[s]=h,0!==h&&this.ttlAutopurge){let t=setTimeout(()=>{this.#w(s)&&this.#C(this.#d[s],"expire")},h+1);t.unref&&t.unref()}},this.#D=s=>{e[s]=0!==t[s]?i.now():0},this.#I=(i,h)=>{if(t[h]){let r=t[h],a=e[h];if(!r||!a)return;i.ttl=r,i.start=a,i.now=s||getNow();let o=i.now-a;i.remainingTTL=r-o}};let s=0,getNow=()=>{let t=i.now();if(this.ttlResolution>0){s=t;let e=setTimeout(()=>s=0,this.ttlResolution);e.unref&&e.unref()}return t};this.getRemainingTTL=i=>{let h=this.#n.get(i);if(void 0===h)return 0;let r=t[h],a=e[h];return r&&a?r-((s||getNow())-a):1/0},this.#w=i=>{let h=e[i],r=t[i];return!!r&&!!h&&(s||getNow())-h>r}}#D=()=>{};#I=()=>{};#O=()=>{};#w=()=>!1;#E(){let t=new ZeroArray(this.#e);this.#l=0,this.#y=t,this.#W=e=>{this.#l-=t[e],t[e]=0},this.#R=(t,e,i,s)=>{if(this.#A(e))return 0;if(!isPosInt(i))if(s){if("function"!=typeof s)throw TypeError("sizeCalculation must be a function");if(!isPosInt(i=s(e,t)))throw TypeError("sizeCalculation return invalid (expect positive integer)")}else throw TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return i},this.#B=(e,i,s)=>{if(t[e]=i,this.#i){let i=this.#i-t[e];for(;this.#l>i;)this.#U(!0)}this.#l+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#l)}}#W=t=>{};#B=(t,e,i)=>{};#R=(t,e,i,s)=>{if(i||s)throw TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#T({allowStale:t=this.allowStale}={}){if(this.#o)for(let e=this.#g;this.#P(e)&&((t||!this.#w(e))&&(yield e),e!==this.#p);)e=this.#f[e]}*#b({allowStale:t=this.allowStale}={}){if(this.#o)for(let e=this.#p;this.#P(e)&&((t||!this.#w(e))&&(yield e),e!==this.#g);)e=this.#u[e]}#P(t){return void 0!==t&&this.#n.get(this.#d[t])===t}*entries(){for(let t of this.#T())void 0===this.#c[t]||void 0===this.#d[t]||this.#A(this.#c[t])||(yield[this.#d[t],this.#c[t]])}*rentries(){for(let t of this.#b())void 0===this.#c[t]||void 0===this.#d[t]||this.#A(this.#c[t])||(yield[this.#d[t],this.#c[t]])}*keys(){for(let t of this.#T()){let e=this.#d[t];void 0===e||this.#A(this.#c[t])||(yield e)}}*rkeys(){for(let t of this.#b()){let e=this.#d[t];void 0===e||this.#A(this.#c[t])||(yield e)}}*values(){for(let t of this.#T())void 0===this.#c[t]||this.#A(this.#c[t])||(yield this.#c[t])}*rvalues(){for(let t of this.#b())void 0===this.#c[t]||this.#A(this.#c[t])||(yield this.#c[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(let i of this.#T()){let s=this.#c[i],h=this.#A(s)?s.__staleWhileFetching:s;if(void 0!==h&&t(h,this.#d[i],this))return this.get(this.#d[i],e)}}forEach(t,e=this){for(let i of this.#T()){let s=this.#c[i],h=this.#A(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#d[i],this)}}rforEach(t,e=this){for(let i of this.#b()){let s=this.#c[i],h=this.#A(s)?s.__staleWhileFetching:s;void 0!==h&&t.call(e,h,this.#d[i],this)}}purgeStale(){let t=!1;for(let e of this.#b({allowStale:!0}))this.#w(e)&&(this.#C(this.#d[e],"expire"),t=!0);return t}info(t){let e=this.#n.get(t);if(void 0===e)return;let s=this.#c[e],h=this.#A(s)?s.__staleWhileFetching:s;if(void 0===h)return;let r={value:h};if(this.#z&&this.#S){let t=this.#z[e],s=this.#S[e];t&&s&&(r.ttl=t-(i.now()-s),r.start=Date.now())}return this.#y&&(r.size=this.#y[e]),r}dump(){let t=[];for(let e of this.#T({allowStale:!0})){let s=this.#d[e],h=this.#c[e],r=this.#A(h)?h.__staleWhileFetching:h;if(void 0===r||void 0===s)continue;let a={value:r};if(this.#z&&this.#S){a.ttl=this.#z[e];let t=i.now()-this.#S[e];a.start=Math.floor(Date.now()-t)}this.#y&&(a.size=this.#y[e]),t.unshift([s,a])}return t}load(t){for(let[e,s]of(this.clear(),t)){if(s.start){let t=Date.now()-s.start;s.start=i.now()-t}this.set(e,s.value,s)}}set(t,e,i={}){if(void 0===e)return this.delete(t),this;let{ttl:s=this.ttl,start:h,noDisposeOnSet:r=this.noDisposeOnSet,sizeCalculation:a=this.sizeCalculation,status:o}=i,{noUpdateTTL:l=this.noUpdateTTL}=i,n=this.#R(t,e,i.size||0,a);if(this.maxEntrySize&&n>this.maxEntrySize)return o&&(o.set="miss",o.maxEntrySizeExceeded=!0),this.#C(t,"set"),this;let d=0===this.#o?void 0:this.#n.get(t);if(void 0===d)d=0===this.#o?this.#g:0!==this.#v.length?this.#v.pop():this.#o===this.#e?this.#U(!1):this.#o,this.#d[d]=t,this.#c[d]=e,this.#n.set(t,d),this.#u[this.#g]=d,this.#f[d]=this.#g,this.#g=d,this.#o++,this.#B(d,n,o),o&&(o.set="add"),l=!1;else{this.#F(d);let i=this.#c[d];if(e!==i){if(this.#_&&this.#A(i)){i.__abortController.abort(Error("replaced"));let{__staleWhileFetching:e}=i;void 0!==e&&!r&&(this.#L&&this.#s?.(e,t,"set"),this.#k&&this.#m?.push([e,t,"set"]))}else!r&&(this.#L&&this.#s?.(i,t,"set"),this.#k&&this.#m?.push([i,t,"set"]));if(this.#W(d),this.#B(d,n,o),this.#c[d]=e,o){o.set="replace";let t=i&&this.#A(i)?i.__staleWhileFetching:i;void 0!==t&&(o.oldValue=t)}}else o&&(o.set="update")}if(0===s||this.#z||this.#M(),this.#z&&(l||this.#O(d,s,h),o&&this.#I(o,d)),!r&&this.#k&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#h?.(...t)}return this}pop(){try{for(;this.#o;){let t=this.#c[this.#p];if(this.#U(!0),this.#A(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(void 0!==t)return t}}finally{if(this.#k&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#h?.(...t)}}}#U(t){let e=this.#p,i=this.#d[e],s=this.#c[e];return this.#_&&this.#A(s)?s.__abortController.abort(Error("evicted")):(this.#L||this.#k)&&(this.#L&&this.#s?.(s,i,"evict"),this.#k&&this.#m?.push([s,i,"evict"])),this.#W(e),t&&(this.#d[e]=void 0,this.#c[e]=void 0,this.#v.push(e)),1===this.#o?(this.#p=this.#g=0,this.#v.length=0):this.#p=this.#u[e],this.#n.delete(i),this.#o--,e}has(t,e={}){let{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,h=this.#n.get(t);if(void 0!==h){let t=this.#c[h];if(this.#A(t)&&void 0===t.__staleWhileFetching)return!1;if(!this.#w(h))return i&&this.#D(h),s&&(s.has="hit",this.#I(s,h)),!0;s&&(s.has="stale",this.#I(s,h))}else s&&(s.has="miss");return!1}peek(t,e={}){let{allowStale:i=this.allowStale}=e,s=this.#n.get(t);if(void 0===s||!i&&this.#w(s))return;let h=this.#c[s];return this.#A(h)?h.__staleWhileFetching:h}#x(t,e,i,s){let h=void 0===e?void 0:this.#c[e];if(this.#A(h))return h;let a=new r,{signal:o}=i;o?.addEventListener("abort",()=>a.abort(o.reason),{signal:a.signal});let l={signal:a.signal,options:i,context:s},cb=(s,h=!1)=>{let{aborted:r}=a.signal,o=i.ignoreFetchAbort&&void 0!==s;return(i.status&&(r&&!h?(i.status.fetchAborted=!0,i.status.fetchError=a.signal.reason,o&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),!r||o||h)?(this.#c[e]===n&&(void 0===s?n.__staleWhileFetching?this.#c[e]=n.__staleWhileFetching:this.#C(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,s,l.options))),s):fetchFail(a.signal.reason)},fetchFail=s=>{let{aborted:h}=a.signal,r=h&&i.allowStaleOnFetchAbort,o=r||i.allowStaleOnFetchRejection,l=o||i.noDeleteOnFetchRejection;if(this.#c[e]===n&&(l&&void 0!==n.__staleWhileFetching?r||(this.#c[e]=n.__staleWhileFetching):this.#C(t,"fetch")),o)return i.status&&void 0!==n.__staleWhileFetching&&(i.status.returnedStale=!0),n.__staleWhileFetching;if(n.__returned===n)throw s},pcall=(e,s)=>{let r=this.#r?.(t,h,l);r&&r instanceof Promise&&r.then(t=>e(void 0===t?void 0:t),s),a.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(e(void 0),i.allowStaleOnFetchAbort&&(e=t=>cb(t,!0)))})};i.status&&(i.status.fetchDispatched=!0);let n=new Promise(pcall).then(cb,t=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=t),fetchFail(t))),d=Object.assign(n,{__abortController:a,__staleWhileFetching:h,__returned:void 0});return void 0===e?(this.set(t,d,{...l.options,status:void 0}),e=this.#n.get(t)):this.#c[e]=d,d}#A(t){return!!this.#_&&!!t&&t instanceof Promise&&t.hasOwnProperty("__staleWhileFetching")&&t.__abortController instanceof r}async fetch(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,ttl:r=this.ttl,noDisposeOnSet:a=this.noDisposeOnSet,size:o=0,sizeCalculation:l=this.sizeCalculation,noUpdateTTL:n=this.noUpdateTTL,noDeleteOnFetchRejection:d=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:c=this.allowStaleOnFetchRejection,ignoreFetchAbort:u=this.ignoreFetchAbort,allowStaleOnFetchAbort:f=this.allowStaleOnFetchAbort,context:p,forceRefresh:g=!1,status:v,signal:m}=e;if(!this.#_)return v&&(v.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,status:v});let y={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:h,ttl:r,noDisposeOnSet:a,size:o,sizeCalculation:l,noUpdateTTL:n,noDeleteOnFetchRejection:d,allowStaleOnFetchRejection:c,allowStaleOnFetchAbort:f,ignoreFetchAbort:u,status:v,signal:m},S=this.#n.get(t);if(void 0===S){v&&(v.fetch="miss");let e=this.#x(t,S,y,p);return e.__returned=e}{let e=this.#c[S];if(this.#A(e)){let t=i&&void 0!==e.__staleWhileFetching;return v&&(v.fetch="inflight",t&&(v.returnedStale=!0)),t?e.__staleWhileFetching:e.__returned=e}let h=this.#w(S);if(!g&&!h)return v&&(v.fetch="hit"),this.#F(S),s&&this.#D(S),v&&this.#I(v,S),e;let r=this.#x(t,S,y,p),a=void 0!==r.__staleWhileFetching&&i;return v&&(v.fetch=h?"stale":"refresh",a&&h&&(v.returnedStale=!0)),a?r.__staleWhileFetching:r.__returned=r}}async forceFetch(t,e={}){let i=await this.fetch(t,e);if(void 0===i)throw Error("fetch() returned undefined");return i}memo(t,e={}){let i=this.#a;if(!i)throw Error("no memoMethod provided to constructor");let{context:s,forceRefresh:h,...r}=e,a=this.get(t,r);if(!h&&void 0!==a)return a;let o=i(t,a,{options:r,context:s});return this.set(t,o,r),o}get(t,e={}){let{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:h=this.noDeleteOnStaleGet,status:r}=e,a=this.#n.get(t);if(void 0!==a){let e=this.#c[a],o=this.#A(e);return(r&&this.#I(r,a),this.#w(a))?(r&&(r.get="stale"),o)?(r&&i&&void 0!==e.__staleWhileFetching&&(r.returnedStale=!0),i?e.__staleWhileFetching:void 0):(h||this.#C(t,"expire"),r&&i&&(r.returnedStale=!0),i?e:void 0):(r&&(r.get="hit"),o)?e.__staleWhileFetching:(this.#F(a),s&&this.#D(a),e)}r&&(r.get="miss")}#N(t,e){this.#f[e]=t,this.#u[t]=e}#F(t){t!==this.#g&&(t===this.#p?this.#p=this.#u[t]:this.#N(this.#f[t],this.#u[t]),this.#N(this.#g,t),this.#g=t)}delete(t){return this.#C(t,"delete")}#C(t,e){let i=!1;if(0!==this.#o){let s=this.#n.get(t);if(void 0!==s)if(i=!0,1===this.#o)this.#j(e);else{this.#W(s);let i=this.#c[s];if(this.#A(i)?i.__abortController.abort(Error("deleted")):(this.#L||this.#k)&&(this.#L&&this.#s?.(i,t,e),this.#k&&this.#m?.push([i,t,e])),this.#n.delete(t),this.#d[s]=void 0,this.#c[s]=void 0,s===this.#g)this.#g=this.#f[s];else if(s===this.#p)this.#p=this.#u[s];else{let t=this.#f[s];this.#u[t]=this.#u[s];let e=this.#u[s];this.#f[e]=this.#f[s]}this.#o--,this.#v.push(s)}}if(this.#k&&this.#m?.length){let t,e=this.#m;for(;t=e?.shift();)this.#h?.(...t)}return i}clear(){return this.#j("delete")}#j(t){for(let e of this.#b({allowStale:!0})){let i=this.#c[e];if(this.#A(i))i.__abortController.abort(Error("deleted"));else{let s=this.#d[e];this.#L&&this.#s?.(i,s,t),this.#k&&this.#m?.push([i,s,t])}}if(this.#n.clear(),this.#c.fill(void 0),this.#d.fill(void 0),this.#z&&this.#S&&(this.#z.fill(0),this.#S.fill(0)),this.#y&&this.#y.fill(0),this.#p=0,this.#g=0,this.#v.length=0,this.#l=0,this.#o=0,this.#k&&this.#m){let t,e=this.#m;for(;t=e?.shift();)this.#h?.(...t)}}};module.exports=e})();