'use strict'

/**
 * Hooks Generator - Creates instrumentation registration files
 *
 * Purpose: Generate clean hook registration without complex wrapping logic
 * Output: Simple addHook calls with TODO comments for implementation
 */

function generateHooks (analysis, integrationName) {
  const packageName = analysis.package.name
  const category = analysis.category
  const methods = analysis.methods || []

  const hookFile = `packages/datadog-instrumentations/src/${integrationName}.js`
  const content = generateHookContent(packageName, integrationName, category, methods)

  return {
    [hookFile]: content
  }
}

function generateHookContent (packageName, integrationName, category, methods) {
  const methodHooks = generateMethodHooks(methods)
  const methodWrappers = generateMethodWrappers(methods, category)

  return `'use strict'

/**
 * ${packageName} instrumentation hooks
 * Generated by dd-apm-scaffolder-v2
 *
 * TODO: Implement actual instrumentation logic
 * TODO: Test with real ${packageName} usage
 */

const { addHook, channel } = require('./helpers/instrument')
// const shimmer = require('../../datadog-shimmer')

// TODO: Define appropriate channels for ${category} operations
// const startCh = channel('apm:${integrationName}:operation:start')
// const finishCh = channel('apm:${integrationName}:operation:finish')
// const errorCh = channel('apm:${integrationName}:operation:error')

// Hook registration for main package
addHook({ name: '${packageName}', versions: ['>=0'] }, (mod) => {
  // TODO: Remove console.log and implement proper instrumentation
  // console.log('ðŸ”§ Instrumenting ${packageName}')

  // TODO: Identify correct target object/prototype
  // Analysis found these methods: ${methods.join(', ')}

  ${methodHooks}

  return mod
})

${methodWrappers}

module.exports = {
  // Export for testing if needed
}
`
}

function generateMethodHooks (methods) {
  if (!methods.length) {
    return `// TODO: No methods found in analysis - manual investigation needed
  // Common patterns:
  // shimmer.wrap(mod.prototype, 'methodName', makeWrapMethod())
  // shimmer.wrap(mod, 'staticMethod', makeWrapMethod())`
  }

  return methods.map(method =>
    `// TODO: Hook ${method} method
  // shimmer.wrap(target, '${method}', makeWrap${capitalize(method)}())`
  ).join('\n  ')
}

function generateMethodWrappers (methods, category) {
  if (!methods.length) {
    return `// TODO: Implement wrapper functions based on ${category} patterns
// Example:
// function makeWrapMethod() {
//   return function wrapMethod(original) {
//     return function wrapped(...args) {
//       // Create span, call original, finish span
//       return original.apply(this, args)
//     }
//   }
// }`
  }

  return methods.map(method => `
// TODO: Implement ${method} wrapper
function makeWrap${capitalize(method)}() {
  return function wrap${capitalize(method)}(original) {
    return function wrapped(...args) {
      if (!startCh.hasSubscribers) {
        return original.apply(this, arguments)
      }
      
      // TODO: Extract operation details from args
      const ctx = { operation: '${method}' }
      
      return startCh.runStores(ctx, () => {
        try {
          const result = original.apply(this, arguments)
          finishCh.publish(ctx)
          return result
        } catch (error) {
          ctx.error = error
          errorCh.publish(ctx)
          throw error
        }
      })
    }
  }
}`).join('')
}

function capitalize (str) {
  return str.charAt(0).toUpperCase() + str.slice(1)
}

module.exports = { generateHooks }
