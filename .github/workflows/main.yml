name: Cache Forensics Extractor

on:
  workflow_dispatch
    
jobs:
  extract-cache:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout (minimal)
        uses: actions/checkout@v4
        with:
          sparse-checkout: |
            .github
          sparse-checkout-cone-mode: false
      
      - name: Parse cache entries
        id: parse
        run: |
          echo 'entries<<EOF' >> $GITHUB_OUTPUT
          echo '[ {"key": "n71Gg/JormzoitmBpVjBCZCcL6Y=","version": "0c867ee6264758fbca938e6c6d38a3160cb478f2770da2f831e22e4c9e3720d8"}, {"key": "PFxRDTsQC2CBRTRk3TMxWNYXnd0=","version": "4793076103aa823b0a4c97942d7385d4346f77a3c30a0bad6e0f1d748becbab5"} ]' | jq -c '.[]' >> $GITHUB_OUTPUT
          echo 'EOF' >> $GITHUB_OUTPUT
      
      - name: Extract caches
        run: |
          mkdir -p cache-artifacts
          
          # Parse JSON array
          echo '[ {"key": "n71Gg/JormzoitmBpVjBCZCcL6Y=","version": "0c867ee6264758fbca938e6c6d38a3160cb478f2770da2f831e22e4c9e3720d8"}, {"key": "PFxRDTsQC2CBRTRk3TMxWNYXnd0=","version": "4793076103aa823b0a4c97942d7385d4346f77a3c30a0bad6e0f1d748becbab5"} ]' | jq -c '.[]' | while read -r entry; do
            key=$(echo "$entry" | jq -r '.key')
            version=$(echo "$entry" | jq -r '.version')
            
            echo "================================================"
            echo "Attempting to restore: $key (version: $version)"
            echo "================================================"
            
            # Create unique directory for this cache
            safe_name=$(echo "$key-$version" | tr '/' '_' | tr ':' '_')
            cache_dir="cache-artifacts/$safe_name"
            mkdir -p "$cache_dir"
            
            # Try to restore cache (will fail if not found, but won't stop workflow)
            echo "Restoring to: $cache_dir"
            
            # Save metadata
            cat > "$cache_dir/metadata.json" <<EOF
          {
            "key": "$key",
            "version": "$version",
            "requested_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "runner_os": "$RUNNER_OS",
            "runner_arch": "$RUNNER_ARCH"
          }
          EOF
          done
      
      - name: Restore cache entries
        id: restore
        continue-on-error: true
        run: |
          echo '[ {"key": "n71Gg/JormzoitmBpVjBCZCcL6Y=","version": "0c867ee6264758fbca938e6c6d38a3160cb478f2770da2f831e22e4c9e3720d8"}, {"key": "PFxRDTsQC2CBRTRk3TMxWNYXnd0=","version": "4793076103aa823b0a4c97942d7385d4346f77a3c30a0bad6e0f1d748becbab5"} ]' | jq -c '.[]' | while read -r entry; do
            key=$(echo "$entry" | jq -r '.key')
            version=$(echo "$entry" | jq -r '.version')
            safe_name=$(echo "$key-$version" | tr '/' '_' | tr ':' '_')
            cache_dir="cache-artifacts/$safe_name"
            
            # Use actions/cache restore with specific key
            echo "::group::Restoring $key"
            
            # Try direct cache restore using GitHub API
            # Note: actions/cache doesn't support version parameter directly
            # So we'll use the cache key pattern matching
            
            restored="false"
            if gh cache restore "$cache_dir" --key "$key" 2>/dev/null; then
              echo "âœ“ Successfully restored $key"
              restored="true"
            else
              echo "âœ— Failed to restore $key"
            fi
            
            echo "$restored" > "$cache_dir/restore_status.txt"
            echo "::endgroup::"
          done
        env:
          GH_TOKEN: ${{ github.token }}
      
      - name: Create file hashes
        run: |
          echo "# File Hashes (SHA256)" > cache-artifacts/HASHES.txt
          find cache-artifacts -type f -not -name "HASHES.txt" -not -name "REPORT.md" -exec sha256sum {} \; >> cache-artifacts/HASHES.txt
      
      - name: Upload each cache as separate artifact
        run: |
          echo '[ {"key": "n71Gg/JormzoitmBpVjBCZCcL6Y=","version": "0c867ee6264758fbca938e6c6d38a3160cb478f2770da2f831e22e4c9e3720d8"}, {"key": "PFxRDTsQC2CBRTRk3TMxWNYXnd0=","version": "4793076103aa823b0a4c97942d7385d4346f77a3c30a0bad6e0f1d748becbab5"} ]' | jq -c '.[]' | while read -r entry; do
            key=$(echo "$entry" | jq -r '.key')
            version=$(echo "$entry" | jq -r '.version')
            safe_name=$(echo "$key-$version" | tr '/' '_' | tr ':' '_')
            cache_dir="cache-artifacts/$safe_name"
            
            # Create artifact name as key:version
            artifact_name="${key}:${version}"
            
            echo "::group::Uploading artifact: $artifact_name"
            
            if [ -d "$cache_dir" ]; then
              # Use GitHub CLI to upload artifact with exact name
              # Note: artifact names have restrictions, so we'll encode problematic chars
              # GitHub artifact names allow: alphanumeric, -, and _
              safe_artifact_name=$(echo "$artifact_name" | sed 's/[^a-zA-Z0-9:_-]/_/g')
              
              # Create a temporary tarball for upload
              tar -czf "${safe_name}.tar.gz" -C "cache-artifacts" "$(basename "$cache_dir")"
              
              echo "Artifact name: $safe_artifact_name"
              echo "Archive: ${safe_name}.tar.gz"
              
              # Upload using actions/upload-artifact
              # We'll do this in the next step since we can't dynamically call actions in a loop
              echo "$safe_artifact_name|${safe_name}.tar.gz" >> artifact_list.txt
            fi
            
            echo "::endgroup::"
          done
      
      - name: Upload artifacts individually
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: cache-forensics-batch-${{ github.run_number }}
          path: |
            *.tar.gz
            cache-artifacts/REPORT.md
            cache-artifacts/HASHES.txt
          retention-days: 30
          if-no-files-found: warn
      
      - name: Create artifact index
        if: always()
        run: |
          echo "# Artifact Index" > ARTIFACT_INDEX.md
          echo "" >> ARTIFACT_INDEX.md
          echo "## Extracted Cache Entries" >> ARTIFACT_INDEX.md
          echo "" >> ARTIFACT_INDEX.md
          
          if [ -f artifact_list.txt ]; then
            while IFS='|' read -r artifact_name archive_file; do
              echo "- **$artifact_name** â†’ \`$archive_file\`" >> ARTIFACT_INDEX.md
            done < artifact_list.txt
          fi
          
          echo "" >> ARTIFACT_INDEX.md
          echo "## Download Instructions" >> ARTIFACT_INDEX.md
          echo "" >> ARTIFACT_INDEX.md
          echo '```bash' >> ARTIFACT_INDEX.md
          echo "# Download all artifacts" >> ARTIFACT_INDEX.md
          echo "gh run download ${{ github.run_id }}" >> ARTIFACT_INDEX.md
          echo "" >> ARTIFACT_INDEX.md
          echo "# Extract individual cache" >> ARTIFACT_INDEX.md
          echo "tar -xzf <archive-name>.tar.gz" >> ARTIFACT_INDEX.md
          echo '```' >> ARTIFACT_INDEX.md
          
          cat ARTIFACT_INDEX.md >> cache-artifacts/REPORT.md
      
      - name: Display summary
        if: always()
        run: |
          echo "## Cache Extraction Complete ðŸ”" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ -f artifact_list.txt ]; then
            echo "### Extracted Artifacts" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "| Cache Key:Version | Archive File |" >> $GITHUB_STEP_SUMMARY
            echo "|-------------------|--------------|" >> $GITHUB_STEP_SUMMARY
            while IFS='|' read -r artifact_name archive_file; do
              echo "| \`$artifact_name\` | \`$archive_file\` |" >> $GITHUB_STEP_SUMMARY
            done < artifact_list.txt
            echo "" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          cat cache-artifacts/REPORT.md >> $GITHUB_STEP_SUMMARY
