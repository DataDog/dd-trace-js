if (typeof process === 'object' && process !== null &&
    process.env !== null && typeof process.env === 'object') {
  process.env.DD_GIT_REPOSITORY_URL = 'git@github.com:DataDog/dd-trace-js.git';
  process.env.DD_GIT_COMMIT_SHA = 'fe119014add9f8baeef3053b5642c15261aa475b';
}
import { createRequire as $dd_createRequire } from 'module';
import { fileURLToPath as $dd_fileURLToPath } from 'url';
import { dirname as $dd_dirname } from 'path';
globalThis.require ??= $dd_createRequire(import.meta.url);
globalThis.__filename ??= $dd_fileURLToPath(import.meta.url);
globalThis.__dirname ??= $dd_dirname(globalThis.__filename);

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// ../../packages/dd-trace/src/util.js
var require_util = __commonJS({
  "../../packages/dd-trace/src/util.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    function isTrue(str) {
      str = String(str).toLowerCase();
      return str === "true" || str === "1";
    }
    function isFalse(str) {
      str = String(str).toLowerCase();
      return str === "false" || str === "0";
    }
    function isError(value) {
      return Boolean(value?.message || value instanceof Error);
    }
    function globMatch(pattern, subject) {
      if (typeof pattern === "string") pattern = pattern.toLowerCase();
      if (typeof subject === "string") subject = subject.toLowerCase();
      if (typeof subject === "number" && Number.isInteger(subject)) subject = String(subject);
      let px = 0;
      let sx = 0;
      let nextPx = 0;
      let nextSx = 0;
      while (px < pattern.length || sx < subject.length) {
        if (px < pattern.length) {
          const c = pattern[px];
          switch (c) {
            case "?":
              if (sx < subject.length) {
                px++;
                sx++;
                continue;
              }
              break;
            case "*":
              nextPx = px;
              nextSx = sx + 1;
              px++;
              continue;
            default:
              if (sx < subject.length && subject[sx] === c) {
                px++;
                sx++;
                continue;
              }
              break;
          }
        }
        if (nextSx > 0 && nextSx <= subject.length) {
          px = nextPx;
          sx = nextSx;
          continue;
        }
        return false;
      }
      return true;
    }
    function calculateDDBasePath(dirname) {
      const dirSteps = dirname.split(path.sep);
      const packagesIndex = dirSteps.lastIndexOf("packages");
      return dirSteps.slice(0, packagesIndex).join(path.sep) + path.sep;
    }
    function normalizeProfilingEnabledValue(configValue) {
      return isTrue(configValue) ? "true" : isFalse(configValue) ? "false" : configValue === "auto" ? "auto" : void 0;
    }
    function normalizePluginEnvName(envPluginName, makeLowercase = false) {
      if (envPluginName.startsWith("@")) {
        envPluginName = envPluginName.slice(1);
      }
      envPluginName = envPluginName.replaceAll(/[^a-z0-9_]/ig, "_");
      return makeLowercase ? envPluginName.toLowerCase() : envPluginName;
    }
    module2.exports = {
      isTrue,
      isFalse,
      isError,
      globMatch,
      ddBasePath: globalThis.__DD_ESBUILD_BASEPATH || calculateDDBasePath(__dirname),
      normalizeProfilingEnabledValue,
      normalizePluginEnvName
    };
  }
});

// ../../packages/dd-trace/src/supported-configurations.json
var require_supported_configurations = __commonJS({
  "../../packages/dd-trace/src/supported-configurations.json"(exports2, module2) {
    module2.exports = {
      supportedConfigurations: {
        DD_AAS_DOTNET_EXTENSION_VERSION: ["A"],
        DD_ACTION_EXECUTION_ID: ["A"],
        DD_AGENT_HOST: ["A"],
        DD_AGENTLESS_LOG_SUBMISSION_ENABLED: ["A"],
        DD_AGENTLESS_LOG_SUBMISSION_URL: ["A"],
        DD_AI_GUARD_ENABLED: ["A"],
        DD_AI_GUARD_ENDPOINT: ["A"],
        DD_AI_GUARD_MAX_CONTENT_SIZE: ["A"],
        DD_AI_GUARD_MAX_MESSAGES_LENGTH: ["A"],
        DD_AI_GUARD_TIMEOUT: ["A"],
        DD_API_KEY: ["A"],
        DD_API_SECURITY_ENABLED: ["A"],
        DD_API_SECURITY_SAMPLE_DELAY: ["A"],
        DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED: ["A"],
        DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT: ["A"],
        DD_APM_FLUSH_DEADLINE_MILLISECONDS: ["A"],
        DD_APM_TRACING_ENABLED: ["A"],
        DD_APP_KEY: ["A"],
        DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE: ["A"],
        DD_APPSEC_COLLECT_ALL_HEADERS: ["A"],
        DD_APPSEC_ENABLED: ["A"],
        DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON: ["A"],
        DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED: ["A"],
        DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML: ["A"],
        DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON: ["A"],
        DD_APPSEC_MAX_COLLECTED_HEADERS: ["A"],
        DD_APPSEC_MAX_STACK_TRACE_DEPTH: ["A"],
        DD_APPSEC_MAX_STACK_TRACES: ["A"],
        DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP: ["A"],
        DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP: ["A"],
        DD_APPSEC_RASP_COLLECT_REQUEST_BODY: ["A"],
        DD_APPSEC_RASP_ENABLED: ["A"],
        DD_APPSEC_RULES: ["A"],
        DD_APPSEC_SCA_ENABLED: ["A"],
        DD_APPSEC_STACK_TRACE_ENABLED: ["A"],
        DD_APPSEC_TRACE_RATE_LIMIT: ["A"],
        DD_APPSEC_WAF_TIMEOUT: ["A"],
        DD_CIVISIBILITY_AGENTLESS_ENABLED: ["A"],
        DD_CIVISIBILITY_AGENTLESS_URL: ["A"],
        DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER: ["A"],
        DD_CIVISIBILITY_DANGEROUSLY_FORCE_COVERAGE: ["A"],
        DD_CIVISIBILITY_DANGEROUSLY_FORCE_TEST_SKIPPING: ["A"],
        DD_CIVISIBILITY_EARLY_FLAKE_DETECTION_ENABLED: ["A"],
        DD_CIVISIBILITY_ENABLED: ["A"],
        DD_CIVISIBILITY_FLAKY_RETRY_COUNT: ["A"],
        DD_CIVISIBILITY_FLAKY_RETRY_ENABLED: ["A"],
        DD_CIVISIBILITY_GIT_UNSHALLOW_ENABLED: ["A"],
        DD_CIVISIBILITY_GIT_UPLOAD_ENABLED: ["A"],
        DD_CIVISIBILITY_IMPACTED_TESTS_DETECTION_ENABLED: ["A"],
        DD_CIVISIBILITY_ITR_ENABLED: ["A"],
        DD_CIVISIBILITY_MANUAL_API_ENABLED: ["A"],
        DD_CIVISIBILITY_TEST_COMMAND: ["A"],
        DD_CIVISIBILITY_TEST_MODULE_ID: ["A"],
        DD_CIVISIBILITY_TEST_SESSION_ID: ["A"],
        DD_CODE_ORIGIN_FOR_SPANS_ENABLED: ["A"],
        DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED: ["A"],
        DD_CRASHTRACKING_ENABLED: ["A"],
        DD_CUSTOM_TRACE_ID: ["A"],
        DD_DATA_STREAMS_ENABLED: ["A"],
        DD_DBM_PROPAGATION_MODE: ["A"],
        DD_DOGSTATSD_HOST: ["A"],
        DD_DOGSTATSD_PORT: ["A"],
        DD_DYNAMIC_INSTRUMENTATION_ENABLED: ["A"],
        DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE: ["A"],
        DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS: ["A"],
        DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS: ["A"],
        DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS: ["A"],
        DD_ENV: ["A"],
        DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED: ["A"],
        DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED: ["A"],
        DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_ENABLED: ["A"],
        DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_DIR: ["A"],
        DD_EXTERNAL_ENV: ["A"],
        DD_FLAGGING_PROVIDER_ENABLED: ["A"],
        DD_GIT_BRANCH: ["A"],
        DD_GIT_COMMIT_AUTHOR_DATE: ["A"],
        DD_GIT_COMMIT_AUTHOR_EMAIL: ["A"],
        DD_GIT_COMMIT_AUTHOR_NAME: ["A"],
        DD_GIT_COMMIT_COMMITTER_DATE: ["A"],
        DD_GIT_COMMIT_COMMITTER_EMAIL: ["A"],
        DD_GIT_COMMIT_COMMITTER_NAME: ["A"],
        DD_GIT_COMMIT_MESSAGE: ["A"],
        DD_GIT_COMMIT_SHA: ["A"],
        DD_GIT_PROPERTIES_FILE: ["A"],
        DD_GIT_FOLDER_PATH: ["A"],
        DD_GIT_REPOSITORY_URL: ["A"],
        DD_GIT_TAG: ["A"],
        DD_GIT_PULL_REQUEST_BASE_BRANCH: ["A"],
        DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA: ["A"],
        DD_GRPC_CLIENT_ERROR_STATUSES: ["A"],
        DD_GRPC_SERVER_ERROR_STATUSES: ["A"],
        DD_HEAP_SNAPSHOT_COUNT: ["A"],
        DD_HEAP_SNAPSHOT_INTERVAL: ["A"],
        DD_HEAP_SNAPSHOT_DESTINATION: ["A"],
        DD_IAST_DB_ROWS_TO_TAINT: ["A"],
        DD_IAST_DEDUPLICATION_ENABLED: ["A"],
        DD_IAST_ENABLED: ["A"],
        DD_IAST_MAX_CONCURRENT_REQUESTS: ["A"],
        DD_IAST_MAX_CONTEXT_OPERATIONS: ["A"],
        DD_IAST_REDACTION_ENABLED: ["A"],
        DD_IAST_REDACTION_NAME_PATTERN: ["A"],
        DD_IAST_REDACTION_VALUE_PATTERN: ["A"],
        DD_IAST_REQUEST_SAMPLING: ["A"],
        DD_IAST_SECURITY_CONTROLS_CONFIGURATION: ["A"],
        DD_IAST_STACK_TRACE_ENABLED: ["A"],
        DD_IAST_TELEMETRY_VERBOSITY: ["A"],
        DD_INJECT_FORCE: ["A"],
        DD_INJECTION_ENABLED: ["A"],
        DD_INSTRUMENTATION_CONFIG_ID: ["A"],
        DD_INSTRUMENTATION_INSTALL_ID: ["A"],
        DD_INSTRUMENTATION_INSTALL_TIME: ["A"],
        DD_INSTRUMENTATION_INSTALL_TYPE: ["A"],
        DD_INSTRUMENTATION_TELEMETRY_ENABLED: ["A"],
        DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD: ["A"],
        DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED: ["A"],
        DD_LAMBDA_HANDLER: ["A"],
        DD_LANGCHAIN_SPAN_CHAR_LIMIT: ["A"],
        DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE: ["A"],
        DD_LLMOBS_AGENTLESS_ENABLED: ["A"],
        DD_LLMOBS_ENABLED: ["A"],
        DD_LLMOBS_ML_APP: ["A"],
        DD_LOG_LEVEL: ["A"],
        DD_LOGS_INJECTION: ["A"],
        DD_LOGS_OTEL_ENABLED: ["A"],
        DD_MINI_AGENT_PATH: ["A"],
        DD_OPENAI_LOGS_ENABLED: ["A"],
        DD_OPENAI_SPAN_CHAR_LIMIT: ["A"],
        DD_PIPELINE_EXECUTION_ID: ["A"],
        DD_PLAYWRIGHT_WORKER: ["A"],
        DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED: ["A"],
        DD_PROFILING_CODEHOTSPOTS_ENABLED: ["A"],
        DD_PROFILING_CPU_ENABLED: ["A"],
        DD_PROFILING_DEBUG_SOURCE_MAPS: ["A"],
        DD_PROFILING_DEBUG_UPLOAD_COMPRESSION: ["A"],
        DD_PROFILING_ENABLED: ["A"],
        DD_PROFILING_ENDPOINT_COLLECTION_ENABLED: ["A"],
        DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES: ["A"],
        DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE: ["A"],
        DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT: ["A"],
        DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED: ["A"],
        DD_PROFILING_EXPORTERS: ["A"],
        DD_PROFILING_HEAP_ENABLED: ["A"],
        DD_PROFILING_HEAP_SAMPLING_INTERVAL: ["A"],
        DD_PROFILING_PPROF_PREFIX: ["A"],
        DD_PROFILING_PROFILERS: ["A"],
        DD_PROFILING_SOURCE_MAP: ["A"],
        DD_PROFILING_TIMELINE_ENABLED: ["A"],
        DD_PROFILING_UPLOAD_PERIOD: ["A"],
        DD_PROFILING_UPLOAD_TIMEOUT: ["A"],
        DD_PROFILING_V8_PROFILER_BUG_WORKAROUND: ["A"],
        DD_PROFILING_WALLTIME_ENABLED: ["A"],
        DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS: ["A"],
        DD_REMOTE_CONFIGURATION_ENABLED: ["A"],
        DD_RUNTIME_METRICS_ENABLED: ["A"],
        DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED: ["A"],
        DD_RUNTIME_METRICS_GC_ENABLED: ["A"],
        DD_RUNTIME_METRICS_FLUSH_INTERVAL: ["A"],
        DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED: ["A"],
        DD_SERVICE_MAPPING: ["A"],
        DD_SERVICE: ["A"],
        DD_SITE: ["A"],
        DD_SPAN_SAMPLING_RULES_FILE: ["A"],
        DD_SPAN_SAMPLING_RULES: ["A"],
        DD_TAGS: ["A"],
        DD_TELEMETRY_DEBUG: ["A"],
        DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED: ["A"],
        DD_TELEMETRY_FORWARDER_PATH: ["A"],
        DD_TELEMETRY_HEARTBEAT_INTERVAL: ["A"],
        DD_TELEMETRY_LOG_COLLECTION_ENABLED: ["A"],
        DD_TELEMETRY_METRICS_ENABLED: ["A"],
        DD_TEST_FAILED_TEST_REPLAY_ENABLED: ["A"],
        DD_TEST_FLEET_CONFIG_PATH: ["A"],
        DD_TEST_LOCAL_CONFIG_PATH: ["A"],
        DD_TEST_MANAGEMENT_ATTEMPT_TO_FIX_RETRIES: ["A"],
        DD_TEST_MANAGEMENT_ENABLED: ["A"],
        DD_TEST_SESSION_NAME: ["A"],
        DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED: ["A"],
        DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED: ["A"],
        DD_TRACE_AEROSPIKE_ENABLED: ["A"],
        DD_TRACE_AI_ENABLED: ["A"],
        DD_TRACE_ANTHROPIC_ENABLED: ["A"],
        DD_TRACE_AGENT_PORT: ["A"],
        DD_TRACE_AGENT_PROTOCOL_VERSION: ["A"],
        DD_TRACE_AGENT_URL: ["A"],
        DD_TRACE_AMQP10_ENABLED: ["A"],
        DD_TRACE_AMQPLIB_ENABLED: ["A"],
        DD_TRACE_APOLLO_ENABLED: ["A"],
        DD_TRACE_APOLLO_GATEWAY_ENABLED: ["A"],
        DD_TRACE_APOLLO_SERVER_CORE_ENABLED: ["A"],
        DD_TRACE_APOLLO_SERVER_ENABLED: ["A"],
        DD_TRACE_APOLLO_SERVER_EXPRESS_ENABLED: ["A"],
        DD_TRACE_APOLLO_SERVER_FASTIFY_ENABLED: ["A"],
        DD_TRACE_APOLLO_SUBGRAPH_ENABLED: ["A"],
        DD_TRACE_AVSC_ENABLED: ["A"],
        DD_TRACE_AWS_ADD_SPAN_POINTERS: ["A"],
        DD_TRACE_AWS_SDK_AWS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_AWS_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_BEDROCKRUNTIME_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_BEDROCKRUNTIME_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_CLOUDWATCHLOGS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_CLOUDWATCHLOGS_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_DYNAMODB_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_DYNAMODB_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_EVENTBRIDGE_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_EVENTBRIDGE_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_KINESIS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_KINESIS_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_LAMBDA_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_LAMBDA_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_NODE_HTTP_HANDLER_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_REDSHIFT_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_REDSHIFT_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_S3_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_S3_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SFN_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SFN_CLIENT_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SFN_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SMITHY_CLIENT_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SNS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SNS_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SQS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_SQS_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_STATES_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_STATES_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_STEPFUNCTIONS_BATCH_PROPAGATION_ENABLED: ["A"],
        DD_TRACE_AWS_SDK_STEPFUNCTIONS_ENABLED: ["A"],
        DD_TRACE_AXIOS_ENABLED: ["A"],
        DD_TRACE_AZURE_EVENT_HUBS_ENABLED: ["A"],
        DD_TRACE_AZURE_EVENTHUBS_BATCH_LINKS_ENABLED: ["A"],
        DD_TRACE_AZURE_FUNCTIONS_ENABLED: ["A"],
        DD_TRACE_AZURE_SERVICE_BUS_ENABLED: ["A"],
        DD_TRACE_AZURE_SERVICEBUS_BATCH_LINKS_ENABLED: ["A"],
        DD_TRACE_BAGGAGE_MAX_BYTES: ["A"],
        DD_TRACE_BAGGAGE_MAX_ITEMS: ["A"],
        DD_TRACE_BAGGAGE_TAG_KEYS: ["A"],
        DD_TRACE_BEAUTIFUL_LOGS: ["A"],
        DD_TRACE_BLUEBIRD_ENABLED: ["A"],
        DD_TRACE_BODY_PARSER_ENABLED: ["A"],
        DD_TRACE_BSON_ENABLED: ["A"],
        DD_TRACE_BUNYAN_ENABLED: ["A"],
        DD_TRACE_CASSANDRA_DRIVER_ENABLED: ["A"],
        DD_TRACE_CHILD_PROCESS_ENABLED: ["A"],
        DD_TRACE_CLIENT_IP_ENABLED: ["A"],
        DD_TRACE_CLIENT_IP_HEADER: ["A"],
        DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH: ["A"],
        DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING: ["A"],
        DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING: ["A"],
        DD_TRACE_COLLECTIONS_ENABLED: ["A"],
        DD_TRACE_COMMONPLUGIN_ENABLED: ["A"],
        DD_TRACE_CONFLUENTINC_KAFKA_JAVASCRIPT_ENABLED: ["A"],
        DD_TRACE_CONNECT_ENABLED: ["A"],
        DD_TRACE_COOKIE_ENABLED: ["A"],
        DD_TRACE_COOKIE_PARSER_ENABLED: ["A"],
        DD_TRACE_COUCHBASE_ENABLED: ["A"],
        DD_TRACE_CRYPTO_ENABLED: ["A"],
        DD_TRACE_CUCUMBER_CUCUMBER_ENABLED: ["A"],
        DD_TRACE_CUCUMBER_ENABLED: ["A"],
        DD_TRACE_CYPRESS_ENABLED: ["A"],
        DD_TRACE_DD_TRACE_API_ENABLED: ["A"],
        DD_TRACE_DEBUG: ["A"],
        DD_TRACE_DISABLED_INSTRUMENTATIONS: ["A"],
        DD_TRACE_DISABLED_PLUGINS: ["A"],
        DD_TRACE_DNS_ENABLED: ["A"],
        DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS: ["A"],
        DD_TRACE_ELASTIC_ELASTICSEARCH_ENABLED: ["A"],
        DD_TRACE_ELASTIC_TRANSPORT_ENABLED: ["A"],
        DD_TRACE_ELASTICSEARCH_ENABLED: ["A"],
        DD_TRACE_ENABLED: ["A"],
        DD_TRACE_ENCODING_DEBUG: ["A"],
        DD_TRACE_EXPERIMENTAL_B3_ENABLED: ["A"],
        DD_TRACE_EXPERIMENTAL_EXPORTER: ["A"],
        DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED: ["A"],
        DD_TRACE_EXPERIMENTAL_SPAN_COUNTS: ["A"],
        DD_TRACE_EXPERIMENTAL_STATE_TRACKING: ["A"],
        DD_TRACE_EXPRESS_ENABLED: ["A"],
        DD_TRACE_EXPRESS_MONGO_SANITIZE_ENABLED: ["A"],
        DD_TRACE_EXPRESS_SESSION_ENABLED: ["A"],
        DD_TRACE_FASTIFY_ENABLED: ["A"],
        DD_TRACE_FETCH_ENABLED: ["A"],
        DD_TRACE_FIND_MY_WAY_ENABLED: ["A"],
        DD_TRACE_FLUSH_INTERVAL: ["A"],
        DD_TRACE_FS_ENABLED: ["A"],
        DD_TRACE_GENERIC_POOL_ENABLED: ["A"],
        DD_TRACE_GIT_METADATA_ENABLED: ["A"],
        DD_TRACE_GLOBAL_TAGS: ["A"],
        DD_TRACE_GOOGLE_CLOUD_PUBSUB_ENABLED: ["A"],
        DD_TRACE_GOOGLE_CLOUD_VERTEXAI_ENABLED: ["A"],
        DD_TRACE_GOOGLE_GAX_ENABLED: ["A"],
        DD_TRACE_GRAPHQL_ENABLED: ["A"],
        DD_TRACE_GRAPHQL_ERROR_EXTENSIONS: ["A"],
        DD_TRACE_GRAPHQL_TAG_ENABLED: ["A"],
        DD_TRACE_GRAPHQL_TOOLS_ENABLED: ["A"],
        DD_TRACE_GRAPHQL_TOOLS_EXECUTOR_ENABLED: ["A"],
        DD_TRACE_GRAPHQL_YOGA_ENABLED: ["A"],
        DD_TRACE_GRPC_ENABLED: ["A"],
        DD_TRACE_GRPC_GRPC_JS_ENABLED: ["A"],
        DD_TRACE_GRPC_PROTO_LOADER_ENABLED: ["A"],
        DD_TRACE_HANDLEBARS_ENABLED: ["A"],
        DD_TRACE_HAPI_BOOM_ENABLED: ["A"],
        DD_TRACE_HAPI_ENABLED: ["A"],
        DD_TRACE_HAPI_HAPI_ENABLED: ["A"],
        DD_TRACE_HEADER_TAGS: ["A"],
        DD_TRACE_HONO_ENABLED: ["A"],
        DD_TRACE_HTTP_ENABLED: ["A"],
        DD_TRACE_HTTP2_ENABLED: ["A"],
        DD_TRACE_HTTPS_ENABLED: ["A"],
        DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED: ["A"],
        DD_TRACE_IOREDIS_ENABLED: ["A"],
        DD_TRACE_IOVALKEY_ENABLED: ["A"],
        DD_TRACE_JEST_CIRCUS_ENABLED: ["A"],
        DD_TRACE_JEST_CONFIG_ENABLED: ["A"],
        DD_TRACE_JEST_CORE_ENABLED: ["A"],
        DD_TRACE_JEST_ENABLED: ["A"],
        DD_TRACE_JEST_ENVIRONMENT_JSDOM_ENABLED: ["A"],
        DD_TRACE_JEST_ENVIRONMENT_NODE_ENABLED: ["A"],
        DD_TRACE_JEST_GLOBALS_ENABLED: ["A"],
        DD_TRACE_JEST_REPORTERS_ENABLED: ["A"],
        DD_TRACE_JEST_RUNTIME_ENABLED: ["A"],
        DD_TRACE_JEST_TEST_SEQUENCER_ENABLED: ["A"],
        DD_TRACE_JEST_TRANSFORM_ENABLED: ["A"],
        DD_TRACE_JEST_WORKER_ENABLED: ["A"],
        DD_TRACE_KAFKAJS_ENABLED: ["A"],
        DD_TRACE_KNEX_ENABLED: ["A"],
        DD_TRACE_KOA_ENABLED: ["A"],
        DD_TRACE_KOA_ROUTE_ENABLED: ["A"],
        DD_TRACE_KOA_ROUTER_ENABLED: ["A"],
        DD_TRACE_KOA_WEBSOCKET_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_ANTHROPIC_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_COHERE_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_CORE_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_GOOGLE_GENAI_ENABLED: ["A"],
        DD_TRACE_LANGCHAIN_OPENAI_ENABLED: ["A"],
        DD_TRACE_LDAPJS_ENABLED: ["A"],
        DD_TRACE_LDAPJS_PROMISE_ENABLED: ["A"],
        DD_TRACE_LEGACY_BAGGAGE_ENABLED: ["A"],
        DD_TRACE_LIMITD_CLIENT_ENABLED: ["A"],
        DD_TRACE_LODASH_ENABLED: ["A"],
        DD_TRACE_LOG_LEVEL: ["A"],
        DD_TRACE_LOOPBACK_ENABLED: ["A"],
        DD_TRACE_MARIADB_ENABLED: ["A"],
        DD_TRACE_MEMCACHED_COMMAND_ENABLED: ["A"],
        DD_TRACE_MEMCACHED_ENABLED: ["A"],
        DD_TRACE_MICROGATEWAY_CORE_ENABLED: ["A"],
        DD_TRACE_MIDDIE_ENABLED: ["A"],
        DD_TRACE_MIDDLEWARE_TRACING_ENABLED: ["A"],
        DD_TRACE_MOCHA_EACH_ENABLED: ["A"],
        DD_TRACE_MOCHA_ENABLED: ["A"],
        DD_TRACE_MOLECULER_ENABLED: ["A"],
        DD_TRACE_MONGODB_CORE_ENABLED: ["A"],
        DD_TRACE_MONGODB_ENABLED: ["A"],
        DD_TRACE_MONGODB_HEARTBEAT_ENABLED: ["A"],
        DD_TRACE_MONGOOSE_ENABLED: ["A"],
        DD_TRACE_MQUERY_ENABLED: ["A"],
        DD_TRACE_MULTER_ENABLED: ["A"],
        DD_TRACE_MYSQL_ENABLED: ["A"],
        DD_TRACE_MYSQL2_ENABLED: ["A"],
        DD_TRACE_NATIVE_SPAN_EVENTS: ["A"],
        DD_TRACE_NET_ENABLED: ["A"],
        DD_TRACE_NEXT_ENABLED: ["A"],
        DD_TRACE_NODE_CHILD_PROCESS_ENABLED: ["A"],
        DD_TRACE_NODE_REDIS_CLIENT_ENABLED: ["A"],
        DD_TRACE_NODE_SERIALIZE_ENABLED: ["A"],
        DD_TRACE_NYC_ENABLED: ["A"],
        DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP: ["A"],
        DD_TRACE_OPENAI_ENABLED: ["A"],
        DD_TRACE_OPENSEARCH_ENABLED: ["A"],
        DD_TRACE_OPENSEARCH_PROJECT_OPENSEARCH_ENABLED: ["A"],
        DD_TRACE_OPENTELEMETRY_SDK_TRACE_NODE_ENABLED: ["A"],
        DD_TRACE_ORACLEDB_ENABLED: ["A"],
        DD_TRACE_OTEL_ENABLED: ["A"],
        DD_TRACE_PARTIAL_FLUSH_MIN_SPANS: ["A"],
        DD_TRACE_PASSPORT_ENABLED: ["A"],
        DD_TRACE_PASSPORT_HTTP_ENABLED: ["A"],
        DD_TRACE_PASSPORT_LOCAL_ENABLED: ["A"],
        DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED: ["A"],
        DD_TRACE_PEER_SERVICE_MAPPING: ["A"],
        DD_TRACE_PG_CURSOR_ENABLED: ["A"],
        DD_TRACE_PG_ENABLED: ["A"],
        DD_TRACE_PG_NATIVE_ENABLED: ["A"],
        DD_TRACE_PG_QUERY_STREAM_ENABLED: ["A"],
        DD_TRACE_PINO_ENABLED: ["A"],
        DD_TRACE_PINO_PRETTY_ENABLED: ["A"],
        DD_TRACE_PLAYWRIGHT_CORE_ENABLED: ["A"],
        DD_TRACE_PLAYWRIGHT_ENABLED: ["A"],
        DD_TRACE_PLAYWRIGHT_TEST_ENABLED: ["A"],
        DD_TRACE_PRISMA_ENABLED: ["A"],
        DD_TRACE_PROCESS_ENABLED: ["A"],
        DD_TRACE_PROMISE_ENABLED: ["A"],
        DD_TRACE_PROMISE_JS_ENABLED: ["A"],
        DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT: ["A"],
        DD_TRACE_PROPAGATION_EXTRACT_FIRST: ["A"],
        DD_TRACE_PROPAGATION_STYLE_EXTRACT: ["A"],
        DD_TRACE_PROPAGATION_STYLE_INJECT: ["A"],
        DD_TRACE_PROPAGATION_STYLE: ["A"],
        DD_TRACE_PROTOBUFJS_ENABLED: ["A"],
        DD_TRACE_PUG_ENABLED: ["A"],
        DD_TRACE_Q_ENABLED: ["A"],
        DD_TRACE_RATE_LIMIT: ["A"],
        DD_TRACE_REACT_DOM_ENABLED: ["A"],
        DD_TRACE_REACT_ENABLED: ["A"],
        DD_TRACE_REDIS_CLIENT_ENABLED: ["A"],
        DD_TRACE_REDIS_ENABLED: ["A"],
        DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED: ["A"],
        DD_TRACE_REPORT_HOSTNAME: ["A"],
        DD_TRACE_REQUEST_ENABLED: ["A"],
        DD_TRACE_RESTIFY_ENABLED: ["A"],
        DD_TRACE_RHEA_ENABLED: ["A"],
        DD_TRACE_ROUTER_ENABLED: ["A"],
        DD_TRACE_SAMPLE_RATE: ["A"],
        DD_TRACE_SAMPLING_RULES: ["A"],
        DD_TRACE_SCOPE: ["A"],
        DD_TRACE_SELENIUM_ENABLED: ["A"],
        DD_TRACE_SELENIUM_WEBDRIVER_ENABLED: ["A"],
        DD_TRACE_SEQUELIZE_ENABLED: ["A"],
        DD_TRACE_SHAREDB_ENABLED: ["A"],
        DD_TRACE_SMITHY_SMITHY_CLIENT_ENABLED: ["A"],
        DD_TRACE_SPAN_ATTRIBUTE_SCHEMA: ["A"],
        DD_TRACE_SPAN_LEAK_DEBUG: ["A"],
        DD_TRACE_SQLITE3_ENABLED: ["A"],
        DD_TRACE_STARTUP_LOGS: ["A"],
        DD_TRACE_STATS_COMPUTATION_ENABLED: ["A"],
        DD_TRACE_SUFFIXPLUGIN_ENABLED: ["A"],
        DD_TRACE_TAGS: ["A"],
        DD_TRACE_TEDIOUS_ENABLED: ["A"],
        DD_TRACE_UNDICI_ENABLED: ["A"],
        DD_TRACE_URL_ENABLED: ["A"],
        DD_TRACE_VITEST_ENABLED: ["A"],
        DD_TRACE_VITEST_RUNNER_ENABLED: ["A"],
        DD_TRACE_VM_ENABLED: ["A"],
        DD_TRACE_WEBSOCKET_MESSAGES_ENABLED: ["A"],
        DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING: ["A"],
        DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES: ["A"],
        DD_TRACE_WHEN_ENABLED: ["A"],
        DD_TRACE_WINSTON_ENABLED: ["A"],
        DD_TRACE_WORKERPOOL_ENABLED: ["A"],
        DD_TRACE_WS_ENABLED: ["A"],
        DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH: ["A"],
        DD_TRACING_ENABLED: ["A"],
        DD_VERSION: ["A"],
        DD_VERTEXAI_SPAN_CHAR_LIMIT: ["A"],
        DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE: ["A"],
        OTEL_LOG_LEVEL: ["A"],
        OTEL_LOGS_EXPORTER: ["A"],
        OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: ["A"],
        OTEL_EXPORTER_OTLP_LOGS_HEADERS: ["A"],
        OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: ["A"],
        OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: ["A"],
        OTEL_EXPORTER_OTLP_ENDPOINT: ["A"],
        OTEL_EXPORTER_OTLP_HEADERS: ["A"],
        OTEL_EXPORTER_OTLP_PROTOCOL: ["A"],
        OTEL_EXPORTER_OTLP_TIMEOUT: ["A"],
        OTEL_BSP_SCHEDULE_DELAY: ["A"],
        OTEL_BSP_MAX_EXPORT_BATCH_SIZE: ["A"],
        OTEL_BSP_MAX_QUEUE_SIZE: ["A"],
        OTEL_METRICS_EXPORTER: ["A"],
        OTEL_PROPAGATORS: ["A"],
        OTEL_RESOURCE_ATTRIBUTES: ["A"],
        OTEL_SDK_DISABLED: ["A"],
        OTEL_SERVICE_NAME: ["A"],
        OTEL_TRACES_EXPORTER: ["A"],
        OTEL_TRACES_SAMPLER_ARG: ["A"],
        OTEL_TRACES_SAMPLER: ["A"]
      },
      aliases: {
        DD_AGENT_HOST: ["DD_TRACE_AGENT_HOSTNAME"],
        DD_API_KEY: ["DATADOG_API_KEY"],
        DD_API_SECURITY_ENABLED: ["DD_EXPERIMENTAL_API_SECURITY_ENABLED"],
        DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE: ["DD_APPSEC_AUTOMATED_USER_EVENTS_TRACKING"],
        DD_DOGSTATSD_HOST: ["DD_DOGSTATSD_HOSTNAME"],
        DD_INSTRUMENTATION_TELEMETRY_ENABLED: ["DD_TRACE_TELEMETRY_ENABLED"],
        DD_PROFILING_CODEHOTSPOTS_ENABLED: ["DD_PROFILING_EXPERIMENTAL_CODEHOTSPOTS_ENABLED"],
        DD_PROFILING_CPU_ENABLED: ["DD_PROFILING_EXPERIMENTAL_CPU_ENABLED"],
        DD_PROFILING_ENABLED: ["DD_EXPERIMENTAL_PROFILING_ENABLED"],
        DD_PROFILING_ENDPOINT_COLLECTION_ENABLED: ["DD_PROFILING_EXPERIMENTAL_ENDPOINT_COLLECTION_ENABLED"],
        DD_PROFILING_TIMELINE_ENABLED: ["DD_PROFILING_EXPERIMENTAL_TIMELINE_ENABLED"],
        DD_REMOTE_CONFIGURATION_ENABLED: ["DD_REMOTE_CONFIG_ENABLED"],
        DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED: ["DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED"],
        DD_SERVICE: ["DD_SERVICE_NAME"],
        DD_TRACE_AGENT_URL: ["DD_TRACE_URL"]
      },
      deprecations: {
        DD_PROFILING_EXPERIMENTAL_ENDPOINT_COLLECTION_ENABLED: "DD_PROFILING_ENDPOINT_COLLECTION_ENABLED",
        DD_PROFILING_EXPERIMENTAL_CPU_ENABLED: "DD_PROFILING_CPU_ENABLED",
        DD_EXPERIMENTAL_PROFILING_ENABLED: "DD_PROFILING_ENABLED",
        DD_PROFILING_EXPERIMENTAL_CODEHOTSPOTS_ENABLED: "DD_PROFILING_CODEHOTSPOTS_ENABLED",
        DD_PROFILING_EXPERIMENTAL_TIMELINE_ENABLED: "DD_PROFILING_TIMELINE_ENABLED",
        DD_TRACE_EXPERIMENTAL_RUNTIME_ID_ENABLED: "DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED"
      }
    };
  }
});

// ../../packages/dd-trace/src/config-helper.js
var require_config_helper = __commonJS({
  "../../packages/dd-trace/src/config-helper.js"(exports2, module2) {
    "use strict";
    var { deprecate } = __require("util");
    var { supportedConfigurations, aliases, deprecations } = require_supported_configurations();
    var aliasToCanonical = {};
    for (const canonical of Object.keys(aliases)) {
      for (const alias of aliases[canonical]) {
        if (aliasToCanonical[alias]) {
          throw new Error(`The alias ${alias} is already used for ${aliasToCanonical[alias]}.`);
        }
        aliasToCanonical[alias] = canonical;
      }
    }
    var deprecationMethods = {};
    for (const deprecation of Object.keys(deprecations)) {
      deprecationMethods[deprecation] = deprecate(
        () => {
        },
        `The environment variable ${deprecation} is deprecated.` + (aliasToCanonical[deprecation] ? ` Please use ${aliasToCanonical[deprecation]} instead.` : ` ${deprecations[deprecation]}`),
        `DATADOG_${deprecation}`
      );
    }
    module2.exports = {
      /**
       * Returns the environment variables that are supported by the tracer
       * (including all non-Datadog/OTEL specific environment variables).
       *
       * This should only be called once in config.js to avoid copying the object frequently.
       *
       * @returns {TracerEnv} The environment variables
       */
      getEnvironmentVariables() {
        const configs = {};
        for (const [key, value] of Object.entries(process.env)) {
          if (key.startsWith("DD_") || key.startsWith("OTEL_") || aliasToCanonical[key]) {
            if (supportedConfigurations[key]) {
              configs[key] = value;
            } else if (aliasToCanonical[key] && configs[aliasToCanonical[key]] === void 0) {
              for (const alias of aliases[aliasToCanonical[key]]) {
                if (process.env[alias] !== void 0) {
                  configs[aliasToCanonical[key]] = value;
                  break;
                }
              }
            }
            deprecationMethods[key]?.();
          } else {
            configs[key] = value;
          }
        }
        return configs;
      },
      /**
       * Returns the environment variable, if it's supported or a non Datadog
       * configuration. Otherwise, it throws an error.
       *
       * @param {string} name Environment variable name
       * @returns {string|undefined}
       * @throws {Error} if the configuration is not supported
       */
      getEnvironmentVariable(name) {
        if ((name.startsWith("DD_") || name.startsWith("OTEL_") || aliasToCanonical[name]) && !supportedConfigurations[name]) {
          throw new Error(`Missing ${name} env/configuration in "supported-configurations.json" file.`);
        }
        const config = process.env[name];
        if (config === void 0 && aliases[name]) {
          for (const alias of aliases[name]) {
            if (process.env[alias] !== void 0) {
              return process.env[alias];
            }
          }
        }
        return config;
      }
    };
  }
});

// ../../packages/dd-trace/src/noop/scope.js
var require_scope = __commonJS({
  "../../packages/dd-trace/src/noop/scope.js"(exports2, module2) {
    "use strict";
    var Scope = class {
      active() {
        return null;
      }
      activate(span, callback) {
        if (typeof callback !== "function") return callback;
        return callback();
      }
      bind(fn, span) {
        return fn;
      }
    };
    module2.exports = Scope;
  }
});

// ../../ext/priority.js
var require_priority = __commonJS({
  "../../ext/priority.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      USER_REJECT: -1,
      AUTO_REJECT: 0,
      AUTO_KEEP: 1,
      USER_KEEP: 2
    };
  }
});

// ../../packages/dd-trace/src/opentracing/span_context.js
var require_span_context = __commonJS({
  "../../packages/dd-trace/src/opentracing/span_context.js"(exports2, module2) {
    "use strict";
    var util = __require("util");
    var { AUTO_KEEP } = require_priority();
    var TRACE_ID_128 = "_dd.p.tid";
    var DatadogSpanContext = class {
      constructor(props) {
        props = props || {};
        this._traceId = props.traceId;
        this._spanId = props.spanId;
        this._isRemote = props.isRemote ?? true;
        this._parentId = props.parentId || null;
        this._name = props.name;
        this._isFinished = props.isFinished || false;
        this._tags = props.tags || {};
        this._sampling = props.sampling || {};
        this._spanSampling = void 0;
        this._links = props.links || [];
        this._baggageItems = props.baggageItems || {};
        this._traceparent = props.traceparent;
        this._tracestate = props.tracestate;
        this._noop = props.noop || null;
        this._trace = props.trace || {
          started: [],
          finished: [],
          tags: {}
        };
        this._otelSpanContext = void 0;
      }
      [util.inspect.custom]() {
        return {
          ...this,
          _trace: {
            ...this._trace,
            started: "[Array]",
            finished: "[Array]"
          }
        };
      }
      toTraceId(get128bitId = false) {
        if (get128bitId) {
          return this._traceId.toBuffer().length <= 8 && this._trace.tags[TRACE_ID_128] ? this._trace.tags[TRACE_ID_128] + this._traceId.toString(16).padStart(16, "0") : this._traceId.toString(16).padStart(32, "0");
        }
        return this._traceId.toString(10);
      }
      toSpanId(get128bitId = false) {
        if (get128bitId) {
          return this._spanId.toString(16).padStart(16, "0");
        }
        return this._spanId.toString(10);
      }
      toBigIntSpanId() {
        return this._spanId.toBigInt();
      }
      toTraceparent() {
        const flags = this._sampling.priority >= AUTO_KEEP ? "01" : "00";
        const traceId = this.toTraceId(true);
        const spanId = this.toSpanId(true);
        const version = this._traceparent && this._traceparent.version || "00";
        return `${version}-${traceId}-${spanId}-${flags}`;
      }
    };
    module2.exports = DatadogSpanContext;
  }
});

// ../../packages/dd-trace/src/noop/span_context.js
var require_span_context2 = __commonJS({
  "../../packages/dd-trace/src/noop/span_context.js"(exports2, module2) {
    "use strict";
    var DatadogSpanContext = require_span_context();
    var priority = require_priority();
    var USER_REJECT = priority.USER_REJECT;
    var NoopSpanContext = class extends DatadogSpanContext {
      constructor(props) {
        super(props);
        this._sampling.priority = USER_REJECT;
      }
    };
    module2.exports = NoopSpanContext;
  }
});

// ../../packages/dd-trace/src/id.js
var require_id = __commonJS({
  "../../packages/dd-trace/src/id.js"(exports2, module2) {
    "use strict";
    var { randomFillSync } = __require("crypto");
    var UINT_MAX = 4294967296;
    var data = new Uint8Array(8 * 8192);
    var zeroId = new Uint8Array(8);
    var map = Array.prototype.map;
    var pad = (byte) => `${byte < 16 ? "0" : ""}${byte.toString(16)}`;
    var batch = 0;
    var Identifier = class {
      constructor(value, radix = 16) {
        this._buffer = radix === 16 ? createBuffer(value) : fromString(value, radix);
      }
      toString(radix = 16) {
        return radix === 16 ? toHexString(this._buffer) : toNumberString(this._buffer, radix);
      }
      toBigInt() {
        return Buffer.from(this._buffer).readBigUInt64BE(0);
      }
      toBuffer() {
        return this._buffer;
      }
      toArray() {
        if (this._buffer.length === 8) {
          return this._buffer;
        }
        return this._buffer.slice(-8);
      }
      toJSON() {
        return this.toString();
      }
      equals(other) {
        const length = this._buffer.length;
        const otherLength = other._buffer.length;
        for (let i = length, j = otherLength; i >= 0 && j >= 0; i--, j--) {
          if (this._buffer[i] !== other._buffer[j]) return false;
        }
        return true;
      }
    };
    function createBuffer(value) {
      if (value === "0") return zeroId;
      if (!value) return pseudoRandom();
      const size = Math.ceil(value.length / 16) * 16;
      const bytes = size / 2;
      const buffer = [];
      value = value.padStart(size, "0");
      for (let i = 0; i < bytes; i++) {
        buffer[i] = Number.parseInt(value.slice(i * 2, i * 2 + 2), 16);
      }
      return buffer;
    }
    function fromString(str, raddix) {
      const buffer = new Array(8);
      const len = str.length;
      let pos = 0;
      let high = 0;
      let low = 0;
      if (str[0] === "-") pos++;
      const sign = pos;
      while (pos < len) {
        const chr = Number.parseInt(str[pos++], raddix);
        if (!(chr >= 0)) break;
        low = low * raddix + chr;
        high = high * raddix + Math.floor(low / UINT_MAX);
        low %= UINT_MAX;
      }
      if (sign) {
        high = ~high;
        if (low) {
          low = UINT_MAX - low;
        } else {
          high++;
        }
      }
      writeUInt32BE(buffer, high, 0);
      writeUInt32BE(buffer, low, 4);
      return buffer;
    }
    function toNumberString(buffer, radix) {
      let high = readInt32(buffer, buffer.length - 8);
      let low = readInt32(buffer, buffer.length - 4);
      let str = "";
      radix = radix || 10;
      while (1) {
        const mod2 = high % radix * UINT_MAX + low;
        high = Math.floor(high / radix);
        low = Math.floor(mod2 / radix);
        str = (mod2 % radix).toString(radix) + str;
        if (!high && !low) break;
      }
      return str;
    }
    function toHexString(buffer) {
      return map.call(buffer, pad).join("");
    }
    function pseudoRandom() {
      if (batch === 0) {
        randomFillSync(data);
      }
      batch = (batch + 1) % 8192;
      const offset = batch * 8;
      return [
        data[offset] & 127,
        // only positive int64,
        data[offset + 1],
        data[offset + 2],
        data[offset + 3],
        data[offset + 4],
        data[offset + 5],
        data[offset + 6],
        data[offset + 7]
      ];
    }
    function readInt32(buffer, offset) {
      return buffer[offset + 0] * 16777216 + (buffer[offset + 1] << 16) + (buffer[offset + 2] << 8) + buffer[offset + 3];
    }
    function writeUInt32BE(buffer, value, offset) {
      buffer[3 + offset] = value & 255;
      value >>= 8;
      buffer[2 + offset] = value & 255;
      value >>= 8;
      buffer[1 + offset] = value & 255;
      value >>= 8;
      buffer[0 + offset] = value & 255;
    }
    module2.exports = function createIdentifier(value, radix) {
      return new Identifier(value, radix);
    };
  }
});

// ../../packages/datadog-core/src/storage.js
var require_storage = __commonJS({
  "../../packages/datadog-core/src/storage.js"(exports2, module2) {
    "use strict";
    var { AsyncLocalStorage } = __require("async_hooks");
    var DatadogStorage = class extends AsyncLocalStorage {
      /**
       *
       * @param store {Store}
       * @override
       */
      enterWith(store) {
        const handle = {};
        stores.set(handle, store);
        super.enterWith(handle);
      }
      /**
       * This is method is a passthrough to the real `getStore()`, so that, when we
       * need it, we can use the handle rather than our mapped store.
       *
       * It's only here because stores are currently used for a bunch of things,
       * and we don't want to hold on to all of them in spans
       * (see opentracing/span.js). Using a namespaced storage for spans would
       * solve this.
       *
       * TODO: Refactor the Scope class to use a span-only store and remove this.
       *
       * @returns {Store}
       */
      getHandle() {
        return super.getStore();
      }
      /**
       * Here, we replicate the behavior of the original `getStore()` method by
       * passing in the handle, which we retrieve by calling it on super. Handles
       * retrieved through `getHandle()` can also be passed in to be used as the
       * key. This is useful if you've stashed a handle somewhere and want to
       * retrieve the store with it.
       * @param {{}} [handle]
       * @returns {Store | undefined}
       * @override
       */
      getStore(handle) {
        if (!handle) {
          handle = super.getStore();
        }
        if (handle) {
          return stores.get(handle);
        }
      }
      /**
       * Here, we replicate the behavior of the original `run()` method. We ensure
       * that our `enterWith()` is called internally, so that the handle to the
       * store is set. As an optimization, we use super for getStore and enterWith
       * when dealing with the parent store, so that we don't have to access the
       * WeakMap.
       * @template R
       * @template TArgs = unknown[]
       * @param {Store} store
       * @param {() => R} fn
       * @param {...TArgs} args
       * @returns {R}
       * @override
       */
      run(store, fn, ...args) {
        const prior = super.getStore();
        this.enterWith(store);
        try {
          return Reflect.apply(fn, null, args);
        } finally {
          super.enterWith(prior);
        }
      }
    };
    var stores = /* @__PURE__ */ new WeakMap();
    var storages = /* @__PURE__ */ Object.create(null);
    function storage(namespace2) {
      if (!storages[namespace2]) {
        storages[namespace2] = new DatadogStorage();
      }
      return storages[namespace2];
    }
    module2.exports = { storage };
  }
});

// ../../packages/datadog-core/index.js
var require_datadog_core = __commonJS({
  "../../packages/datadog-core/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_storage();
    module2.exports = { storage };
  }
});

// ../../packages/dd-trace/src/noop/span.js
var require_span = __commonJS({
  "../../packages/dd-trace/src/noop/span.js"(exports2, module2) {
    "use strict";
    var NoopSpanContext = require_span_context2();
    var id = require_id();
    var { storage } = require_datadog_core();
    var NoopSpan = class {
      constructor(tracer2, parent) {
        this._store = storage("legacy").getHandle();
        this._noopTracer = tracer2;
        this._noopContext = this._createContext(parent);
      }
      context() {
        return this._noopContext;
      }
      tracer() {
        return this._noopTracer;
      }
      setOperationName(name) {
        return this;
      }
      setBaggageItem(key, value) {
        return this;
      }
      getBaggageItem(key) {
      }
      getAllBaggageItems() {
      }
      removeBaggageItem(key) {
        return this;
      }
      removeAllBaggageItems() {
        return this;
      }
      setTag(key, value) {
        return this;
      }
      addTags(keyValueMap) {
        return this;
      }
      addLink(link) {
        return this;
      }
      addLinks(links) {
        return this;
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        return this;
      }
      log() {
        return this;
      }
      logEvent() {
      }
      finish(finishTime) {
      }
      _createContext(parent) {
        const spanId = id();
        return parent ? new NoopSpanContext({
          noop: this,
          traceId: parent._traceId,
          spanId,
          parentId: parent._spanId,
          baggageItems: { ...parent._baggageItems }
        }) : new NoopSpanContext({
          noop: this,
          traceId: spanId,
          spanId
        });
      }
    };
    module2.exports = NoopSpan;
  }
});

// ../../packages/dd-trace/src/noop/tracer.js
var require_tracer = __commonJS({
  "../../packages/dd-trace/src/noop/tracer.js"(exports2, module2) {
    "use strict";
    var Scope = require_scope();
    var Span = require_span();
    var NoopTracer2 = class {
      constructor(config) {
        this._scope = new Scope();
        this._span = new Span(this);
      }
      configure(options) {
      }
      trace(name, options, fn) {
        return fn(this._span, () => {
        });
      }
      wrap(name, options, fn) {
        return fn;
      }
      scope() {
        return this._scope;
      }
      getRumData() {
        return "";
      }
      setUrl() {
      }
      startSpan(name, options) {
        return this._span;
      }
      inject(spanContext, format, carrier) {
      }
      extract(format, carrier) {
        return this._span.context();
      }
      setUser() {
        return this;
      }
    };
    module2.exports = NoopTracer2;
  }
});

// ../../packages/dd-trace/src/appsec/sdk/noop.js
var require_noop = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/noop.js"(exports2, module2) {
    "use strict";
    var NoopEventTrackingV2 = class {
      trackUserLoginSuccess() {
      }
      trackUserLoginFailure() {
      }
    };
    var NoopAppsecSdk = class {
      constructor() {
        this.eventTrackingV2 = new NoopEventTrackingV2();
      }
      trackUserLoginSuccessEvent() {
      }
      trackUserLoginFailureEvent() {
      }
      trackCustomEvent() {
      }
      isUserBlocked() {
      }
      blockRequest() {
      }
      setUser() {
      }
    };
    module2.exports = NoopAppsecSdk;
  }
});

// ../../packages/dd-trace/src/noop/dogstatsd.js
var require_dogstatsd = __commonJS({
  "../../packages/dd-trace/src/noop/dogstatsd.js"(exports2, module2) {
    "use strict";
    module2.exports = class NoopDogStatsDClient {
      increment() {
      }
      decrement() {
      }
      gauge() {
      }
      distribution() {
      }
      histogram() {
      }
      flush() {
      }
    };
  }
});

// ../../packages/dd-trace/src/llmobs/noop.js
var require_noop2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/noop.js"(exports2, module2) {
    "use strict";
    var NoopLLMObs = class {
      constructor(noopTracer) {
        this._tracer = noopTracer;
      }
      get enabled() {
        return false;
      }
      enable(options) {
      }
      disable() {
      }
      trace(options = {}, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        const name = options.name || options.kind || fn.name;
        return this._tracer.trace(name, options, fn);
      }
      wrap(options = {}, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        const name = options.name || options.kind || fn.name;
        return this._tracer.wrap(name, options, fn);
      }
      decorate(options = {}) {
        const llmobs = this;
        return function(target, ctxOrPropertyKey, descriptor) {
          if (!ctxOrPropertyKey) return target;
          if (typeof ctxOrPropertyKey === "object") {
            const ctx = ctxOrPropertyKey;
            if (ctx.kind !== "method") return target;
            return llmobs.wrap({ name: ctx.name, _decorator: true, ...options }, target);
          }
          const propertyKey = ctxOrPropertyKey;
          if (descriptor) {
            if (typeof descriptor.value !== "function") return descriptor;
            const original2 = descriptor.value;
            descriptor.value = llmobs.wrap({ name: propertyKey, _decorator: true, ...options }, original2);
            return descriptor;
          }
          if (typeof target[propertyKey] !== "function") return target[propertyKey];
          const original = target[propertyKey];
          Object.defineProperty(target, propertyKey, {
            ...Object.getOwnPropertyDescriptor(target, propertyKey),
            value: llmobs.wrap({ name: propertyKey, _decorator: true, ...options }, original)
          });
          return target;
        };
      }
      annotate(span, options) {
      }
      exportSpan(span) {
        return {};
      }
      submitEvaluation(llmobsSpanContext, options) {
      }
      flush() {
      }
    };
    module2.exports = NoopLLMObs;
  }
});

// ../../packages/dd-trace/src/openfeature/constants/constants.js
var require_constants = __commonJS({
  "../../packages/dd-trace/src/openfeature/constants/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * @constant
       * @type {string} Base path for EVP proxy agent endpoint
       */
      EVP_PROXY_AGENT_BASE_PATH: "/evp_proxy/v2/",
      /**
       * @constant
       * @type {string} HTTP header name for EVP subdomain routing
       */
      EVP_SUBDOMAIN_HEADER_NAME: "X-Datadog-EVP-Subdomain",
      /**
       * @constant
       * @type {string} EVP subdomain value for event platform intake
       */
      EVP_SUBDOMAIN_VALUE: "event-platform-intake",
      /**
       * @constant
       * @type {string} API endpoint for exposure events EVP track
       */
      EXPOSURES_ENDPOINT: "/api/v2/exposures",
      /**
       * @constant
       * @type {number} Maximum payload size for EVP intake (5MB, actual limit is 5.1MB)
       */
      EVP_PAYLOAD_SIZE_LIMIT: 5 << 20,
      /**
       * @constant
       * @type {number} Maximum individual event size (999KB, actual limit is 1MB)
       */
      EVP_EVENT_SIZE_LIMIT: (1 << 20) - 1024,
      /**
       * @constant
       * @type {string} Channel name for exposure event submission
       */
      EXPOSURE_CHANNEL: "ffe:exposure:submit",
      /**
       * @constant
       * @type {string} Reason code for noop provider evaluations
       */
      NOOP_REASON: "STATIC"
    };
  }
});

// ../../packages/dd-trace/src/openfeature/noop.js
var require_noop3 = __commonJS({
  "../../packages/dd-trace/src/openfeature/noop.js"(exports2, module2) {
    "use strict";
    var { NOOP_REASON } = require_constants();
    var NoopFlaggingProvider = class {
      /**
       * @param {Object} [noopTracer] - Optional noop tracer instance
       */
      constructor(noopTracer) {
        this._tracer = noopTracer;
        this._config = {};
        this.metadata = { name: "NoopFlaggingProvider" };
        this.status = "NOT_READY";
        this.runsOn = "server";
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {boolean} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: boolean, reason: string}>} Resolution details
       */
      resolveBooleanEvaluation(flagKey, defaultValue, context2, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON
        });
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {string} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: string, reason: string}>} Resolution details
       */
      resolveStringEvaluation(flagKey, defaultValue, context2, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON
        });
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {number} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: number, reason: string}>} Resolution details
       */
      resolveNumberEvaluation(flagKey, defaultValue, context2, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON
        });
      }
      /**
       * @param {string} flagKey - Flag key
       * @param {Object} defaultValue - Default value to return
       * @param {Object} context - Evaluation context
       * @param {Object} logger - Logger instance
       * @returns {Promise<{value: Object, reason: string}>} Resolution details
       */
      resolveObjectEvaluation(flagKey, defaultValue, context2, logger) {
        return Promise.resolve({
          value: defaultValue,
          reason: NOOP_REASON
        });
      }
      /**
       * @returns {Object} Current configuration
       */
      getConfiguration() {
        return this._config;
      }
      /**
       * @param {Object} config - Configuration to set
       */
      setConfiguration(config) {
        this._config = config;
      }
      /**
       * @internal
       * @param {Object} ufc - Universal Flag Configuration object
       */
      _setConfiguration(ufc) {
        this.setConfiguration(ufc);
      }
    };
    module2.exports = NoopFlaggingProvider;
  }
});

// ../../packages/dd-trace/src/aiguard/noop.js
var require_noop4 = __commonJS({
  "../../packages/dd-trace/src/aiguard/noop.js"(exports2, module2) {
    "use strict";
    var NoopAIGuard = class {
      evaluate(messages, opts) {
        return Promise.resolve({ action: "ALLOW", reason: "AI Guard is not enabled" });
      }
    };
    module2.exports = NoopAIGuard;
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    init_globalThis();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    init_node();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/version.js"() {
    VERSION = "1.9.0";
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag3, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag3.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag3.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag3.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag3) {
  diag3.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace2, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace2);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    (function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    init_types();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    (function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME, self2);
        };
        self2.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js
var __read3, __values, BaggageImpl;
var init_baggage_impl = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/baggage/internal/baggage-impl.js"() {
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __values = function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m) return m.call(o);
      if (o && typeof o.length === "number") return {
        next: function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    BaggageImpl = /** @class */
    (function() {
      function BaggageImpl2(entries) {
        this._entries = entries ? new Map(entries) : /* @__PURE__ */ new Map();
      }
      BaggageImpl2.prototype.getEntry = function(key) {
        var entry = this._entries.get(key);
        if (!entry) {
          return void 0;
        }
        return Object.assign({}, entry);
      };
      BaggageImpl2.prototype.getAllEntries = function() {
        return Array.from(this._entries.entries()).map(function(_a) {
          var _b = __read3(_a, 2), k = _b[0], v = _b[1];
          return [k, v];
        });
      };
      BaggageImpl2.prototype.setEntry = function(key, entry) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.set(key, entry);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntry = function(key) {
        var newBaggage = new BaggageImpl2(this._entries);
        newBaggage._entries.delete(key);
        return newBaggage;
      };
      BaggageImpl2.prototype.removeEntries = function() {
        var e_1, _a;
        var keys = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          keys[_i] = arguments[_i];
        }
        var newBaggage = new BaggageImpl2(this._entries);
        try {
          for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
            var key = keys_1_1.value;
            newBaggage._entries.delete(key);
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
        return newBaggage;
      };
      BaggageImpl2.prototype.clear = function() {
        return new BaggageImpl2();
      };
      return BaggageImpl2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js
var baggageEntryMetadataSymbol;
var init_symbol = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/baggage/internal/symbol.js"() {
    baggageEntryMetadataSymbol = Symbol("BaggageEntryMetadata");
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/baggage/utils.js
function createBaggage(entries) {
  if (entries === void 0) {
    entries = {};
  }
  return new BaggageImpl(new Map(Object.entries(entries)));
}
function baggageEntryMetadataFromString(str) {
  if (typeof str !== "string") {
    diag.error("Cannot create baggage metadata from unknown type: " + typeof str);
    str = "";
  }
  return {
    __TYPE__: baggageEntryMetadataSymbol,
    toString: function() {
      return str;
    }
  };
}
var diag;
var init_utils = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/baggage/utils.js"() {
    init_diag();
    init_baggage_impl();
    init_symbol();
    diag = DiagAPI.instance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    BaseContext = /** @class */
    /* @__PURE__ */ (function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self2.deleteValue = function(key) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    })();
    ROOT_CONTEXT = new BaseContext();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js
var consoleMap, DiagConsoleLogger;
var init_consoleLogger = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/diag/consoleLogger.js"() {
    consoleMap = [
      { n: "error", c: "error" },
      { n: "warn", c: "warn" },
      { n: "info", c: "info" },
      { n: "debug", c: "debug" },
      { n: "verbose", c: "trace" }
    ];
    DiagConsoleLogger = /** @class */
    /* @__PURE__ */ (function() {
      function DiagConsoleLogger2() {
        function _consoleFunc(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            if (console) {
              var theFunc = console[funcName];
              if (typeof theFunc !== "function") {
                theFunc = console.log;
              }
              if (typeof theFunc === "function") {
                return theFunc.apply(console, args);
              }
            }
          };
        }
        for (var i = 0; i < consoleMap.length; i++) {
          this[consoleMap[i].n] = _consoleFunc(consoleMap[i].c);
        }
      }
      return DiagConsoleLogger2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js
function createNoopMeter() {
  return NOOP_METER;
}
var __extends, NoopMeter, NoopMetric, NoopCounterMetric, NoopUpDownCounterMetric, NoopGaugeMetric, NoopHistogramMetric, NoopObservableMetric, NoopObservableCounterMetric, NoopObservableGaugeMetric, NoopObservableUpDownCounterMetric, NOOP_METER, NOOP_COUNTER_METRIC, NOOP_GAUGE_METRIC, NOOP_HISTOGRAM_METRIC, NOOP_UP_DOWN_COUNTER_METRIC, NOOP_OBSERVABLE_COUNTER_METRIC, NOOP_OBSERVABLE_GAUGE_METRIC, NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
var init_NoopMeter = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeter.js"() {
    __extends = /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    NoopMeter = /** @class */
    (function() {
      function NoopMeter2() {
      }
      NoopMeter2.prototype.createGauge = function(_name, _options) {
        return NOOP_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createHistogram = function(_name, _options) {
        return NOOP_HISTOGRAM_METRIC;
      };
      NoopMeter2.prototype.createCounter = function(_name, _options) {
        return NOOP_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createUpDownCounter = function(_name, _options) {
        return NOOP_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableGauge = function(_name, _options) {
        return NOOP_OBSERVABLE_GAUGE_METRIC;
      };
      NoopMeter2.prototype.createObservableCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_COUNTER_METRIC;
      };
      NoopMeter2.prototype.createObservableUpDownCounter = function(_name, _options) {
        return NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC;
      };
      NoopMeter2.prototype.addBatchObservableCallback = function(_callback, _observables) {
      };
      NoopMeter2.prototype.removeBatchObservableCallback = function(_callback) {
      };
      return NoopMeter2;
    })();
    NoopMetric = /** @class */
    /* @__PURE__ */ (function() {
      function NoopMetric2() {
      }
      return NoopMetric2;
    })();
    NoopCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopCounterMetric2, _super);
      function NoopCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopCounterMetric2;
    })(NoopMetric);
    NoopUpDownCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopUpDownCounterMetric2, _super);
      function NoopUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopUpDownCounterMetric2.prototype.add = function(_value, _attributes) {
      };
      return NoopUpDownCounterMetric2;
    })(NoopMetric);
    NoopGaugeMetric = /** @class */
    (function(_super) {
      __extends(NoopGaugeMetric2, _super);
      function NoopGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopGaugeMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopGaugeMetric2;
    })(NoopMetric);
    NoopHistogramMetric = /** @class */
    (function(_super) {
      __extends(NoopHistogramMetric2, _super);
      function NoopHistogramMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      NoopHistogramMetric2.prototype.record = function(_value, _attributes) {
      };
      return NoopHistogramMetric2;
    })(NoopMetric);
    NoopObservableMetric = /** @class */
    (function() {
      function NoopObservableMetric2() {
      }
      NoopObservableMetric2.prototype.addCallback = function(_callback) {
      };
      NoopObservableMetric2.prototype.removeCallback = function(_callback) {
      };
      return NoopObservableMetric2;
    })();
    NoopObservableCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableCounterMetric2, _super);
      function NoopObservableCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableCounterMetric2;
    })(NoopObservableMetric);
    NoopObservableGaugeMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableGaugeMetric2, _super);
      function NoopObservableGaugeMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableGaugeMetric2;
    })(NoopObservableMetric);
    NoopObservableUpDownCounterMetric = /** @class */
    (function(_super) {
      __extends(NoopObservableUpDownCounterMetric2, _super);
      function NoopObservableUpDownCounterMetric2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return NoopObservableUpDownCounterMetric2;
    })(NoopObservableMetric);
    NOOP_METER = new NoopMeter();
    NOOP_COUNTER_METRIC = new NoopCounterMetric();
    NOOP_GAUGE_METRIC = new NoopGaugeMetric();
    NOOP_HISTOGRAM_METRIC = new NoopHistogramMetric();
    NOOP_UP_DOWN_COUNTER_METRIC = new NoopUpDownCounterMetric();
    NOOP_OBSERVABLE_COUNTER_METRIC = new NoopObservableCounterMetric();
    NOOP_OBSERVABLE_GAUGE_METRIC = new NoopObservableGaugeMetric();
    NOOP_OBSERVABLE_UP_DOWN_COUNTER_METRIC = new NoopObservableUpDownCounterMetric();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/metrics/Metric.js
var ValueType;
var init_Metric = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/metrics/Metric.js"() {
    (function(ValueType2) {
      ValueType2[ValueType2["INT"] = 0] = "INT";
      ValueType2[ValueType2["DOUBLE"] = 1] = "DOUBLE";
    })(ValueType || (ValueType = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js
var defaultTextMapGetter, defaultTextMapSetter;
var init_TextMapPropagator = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/propagation/TextMapPropagator.js"() {
    defaultTextMapGetter = {
      get: function(carrier, key) {
        if (carrier == null) {
          return void 0;
        }
        return carrier[key];
      },
      keys: function(carrier) {
        if (carrier == null) {
          return [];
        }
        return Object.keys(carrier);
      }
    };
    defaultTextMapSetter = {
      set: function(carrier, key, value) {
        if (carrier == null) {
          return;
        }
        carrier[key] = value;
      }
    };
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read4, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    init_context();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    (function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read4(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/api/context.js
var __read5, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read5 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    (function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read5(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    (function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    (function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    (function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer2 = this._getTracer();
        return Reflect.apply(tracer2.startActiveSpan, tracer2, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer2 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer2) {
          return NOOP_TRACER;
        }
        this._delegate = tracer2;
        return this._delegate;
      };
      return ProxyTracer2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    (function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    (function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js
var SamplingDecision;
var init_SamplingResult = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/SamplingResult.js"() {
    (function(SamplingDecision2) {
      SamplingDecision2[SamplingDecision2["NOT_RECORD"] = 0] = "NOT_RECORD";
      SamplingDecision2[SamplingDecision2["RECORD"] = 1] = "RECORD";
      SamplingDecision2[SamplingDecision2["RECORD_AND_SAMPLED"] = 2] = "RECORD_AND_SAMPLED";
    })(SamplingDecision || (SamplingDecision = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/span_kind.js
var SpanKind;
var init_span_kind = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/span_kind.js"() {
    (function(SpanKind2) {
      SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
      SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
      SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
      SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
      SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
    })(SpanKind || (SpanKind = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js
function validateKey(key) {
  return VALID_KEY_REGEX.test(key);
}
function validateValue(value) {
  return VALID_VALUE_BASE_REGEX.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX.test(value);
}
var VALID_KEY_CHAR_RANGE, VALID_KEY, VALID_VENDOR_KEY, VALID_KEY_REGEX, VALID_VALUE_BASE_REGEX, INVALID_VALUE_COMMA_EQUAL_REGEX;
var init_tracestate_validators = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-validators.js"() {
    VALID_KEY_CHAR_RANGE = "[_0-9a-z-*/]";
    VALID_KEY = "[a-z]" + VALID_KEY_CHAR_RANGE + "{0,255}";
    VALID_VENDOR_KEY = "[a-z0-9]" + VALID_KEY_CHAR_RANGE + "{0,240}@[a-z]" + VALID_KEY_CHAR_RANGE + "{0,13}";
    VALID_KEY_REGEX = new RegExp("^(?:" + VALID_KEY + "|" + VALID_VENDOR_KEY + ")$");
    VALID_VALUE_BASE_REGEX = /^[ -~]{0,255}[!-~]$/;
    INVALID_VALUE_COMMA_EQUAL_REGEX = /,|=/;
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js
var MAX_TRACE_STATE_ITEMS, MAX_TRACE_STATE_LEN, LIST_MEMBERS_SEPARATOR, LIST_MEMBER_KEY_VALUE_SPLITTER, TraceStateImpl;
var init_tracestate_impl = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/internal/tracestate-impl.js"() {
    init_tracestate_validators();
    MAX_TRACE_STATE_ITEMS = 32;
    MAX_TRACE_STATE_LEN = 512;
    LIST_MEMBERS_SEPARATOR = ",";
    LIST_MEMBER_KEY_VALUE_SPLITTER = "=";
    TraceStateImpl = /** @class */
    (function() {
      function TraceStateImpl2(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      TraceStateImpl2.prototype.set = function(key, value) {
        var traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      };
      TraceStateImpl2.prototype.unset = function(key) {
        var traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      };
      TraceStateImpl2.prototype.get = function(key) {
        return this._internalState.get(key);
      };
      TraceStateImpl2.prototype.serialize = function() {
        var _this = this;
        return this._keys().reduce(function(agg, key) {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER + _this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR);
      };
      TraceStateImpl2.prototype._parse = function(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR).reverse().reduce(function(agg, part) {
          var listMember = part.trim();
          var i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER);
          if (i !== -1) {
            var key = listMember.slice(0, i);
            var value = listMember.slice(i + 1, part.length);
            if (validateKey(key) && validateValue(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS));
        }
      };
      TraceStateImpl2.prototype._keys = function() {
        return Array.from(this._internalState.keys()).reverse();
      };
      TraceStateImpl2.prototype._clone = function() {
        var traceState = new TraceStateImpl2();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      };
      return TraceStateImpl2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js
function createTraceState(rawTraceState) {
  return new TraceStateImpl(rawTraceState);
}
var init_utils2 = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace/internal/utils.js"() {
    init_tracestate_impl();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/diag-api.js
var diag2;
var init_diag_api = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/diag-api.js"() {
    init_diag();
    diag2 = DiagAPI.instance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js
var NoopMeterProvider, NOOP_METER_PROVIDER;
var init_NoopMeterProvider = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/metrics/NoopMeterProvider.js"() {
    init_NoopMeter();
    NoopMeterProvider = /** @class */
    (function() {
      function NoopMeterProvider2() {
      }
      NoopMeterProvider2.prototype.getMeter = function(_name, _version, _options) {
        return NOOP_METER;
      };
      return NoopMeterProvider2;
    })();
    NOOP_METER_PROVIDER = new NoopMeterProvider();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/api/metrics.js
var API_NAME3, MetricsAPI;
var init_metrics = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/api/metrics.js"() {
    init_NoopMeterProvider();
    init_global_utils();
    init_diag();
    API_NAME3 = "metrics";
    MetricsAPI = /** @class */
    (function() {
      function MetricsAPI2() {
      }
      MetricsAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new MetricsAPI2();
        }
        return this._instance;
      };
      MetricsAPI2.prototype.setGlobalMeterProvider = function(provider) {
        return registerGlobal(API_NAME3, provider, DiagAPI.instance());
      };
      MetricsAPI2.prototype.getMeterProvider = function() {
        return getGlobal(API_NAME3) || NOOP_METER_PROVIDER;
      };
      MetricsAPI2.prototype.getMeter = function(name, version, options) {
        return this.getMeterProvider().getMeter(name, version, options);
      };
      MetricsAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
      };
      return MetricsAPI2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/metrics-api.js
var metrics;
var init_metrics_api = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/metrics-api.js"() {
    init_metrics();
    metrics = MetricsAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js
var NoopTextMapPropagator;
var init_NoopTextMapPropagator = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/propagation/NoopTextMapPropagator.js"() {
    NoopTextMapPropagator = /** @class */
    (function() {
      function NoopTextMapPropagator2() {
      }
      NoopTextMapPropagator2.prototype.inject = function(_context, _carrier) {
      };
      NoopTextMapPropagator2.prototype.extract = function(context2, _carrier) {
        return context2;
      };
      NoopTextMapPropagator2.prototype.fields = function() {
        return [];
      };
      return NoopTextMapPropagator2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js
function getBaggage(context2) {
  return context2.getValue(BAGGAGE_KEY) || void 0;
}
function getActiveBaggage() {
  return getBaggage(ContextAPI.getInstance().active());
}
function setBaggage(context2, baggage) {
  return context2.setValue(BAGGAGE_KEY, baggage);
}
function deleteBaggage(context2) {
  return context2.deleteValue(BAGGAGE_KEY);
}
var BAGGAGE_KEY;
var init_context_helpers = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/baggage/context-helpers.js"() {
    init_context2();
    init_context();
    BAGGAGE_KEY = createContextKey("OpenTelemetry Baggage Key");
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/api/propagation.js
var API_NAME4, NOOP_TEXT_MAP_PROPAGATOR, PropagationAPI;
var init_propagation = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/api/propagation.js"() {
    init_global_utils();
    init_NoopTextMapPropagator();
    init_TextMapPropagator();
    init_context_helpers();
    init_utils();
    init_diag();
    API_NAME4 = "propagation";
    NOOP_TEXT_MAP_PROPAGATOR = new NoopTextMapPropagator();
    PropagationAPI = /** @class */
    (function() {
      function PropagationAPI2() {
        this.createBaggage = createBaggage;
        this.getBaggage = getBaggage;
        this.getActiveBaggage = getActiveBaggage;
        this.setBaggage = setBaggage;
        this.deleteBaggage = deleteBaggage;
      }
      PropagationAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new PropagationAPI2();
        }
        return this._instance;
      };
      PropagationAPI2.prototype.setGlobalPropagator = function(propagator) {
        return registerGlobal(API_NAME4, propagator, DiagAPI.instance());
      };
      PropagationAPI2.prototype.inject = function(context2, carrier, setter) {
        if (setter === void 0) {
          setter = defaultTextMapSetter;
        }
        return this._getGlobalPropagator().inject(context2, carrier, setter);
      };
      PropagationAPI2.prototype.extract = function(context2, carrier, getter) {
        if (getter === void 0) {
          getter = defaultTextMapGetter;
        }
        return this._getGlobalPropagator().extract(context2, carrier, getter);
      };
      PropagationAPI2.prototype.fields = function() {
        return this._getGlobalPropagator().fields();
      };
      PropagationAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME4, DiagAPI.instance());
      };
      PropagationAPI2.prototype._getGlobalPropagator = function() {
        return getGlobal(API_NAME4) || NOOP_TEXT_MAP_PROPAGATOR;
      };
      return PropagationAPI2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/propagation-api.js
var propagation;
var init_propagation_api = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/propagation-api.js"() {
    init_propagation();
    propagation = PropagationAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME5, TraceAPI;
var init_trace = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME5 = "trace";
    TraceAPI = /** @class */
    (function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME5, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME5) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME5, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    })();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    init_trace();
    trace = TraceAPI.getInstance();
  }
});

// ../../node_modules/@opentelemetry/api/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DiagConsoleLogger: () => DiagConsoleLogger,
  DiagLogLevel: () => DiagLogLevel,
  INVALID_SPANID: () => INVALID_SPANID,
  INVALID_SPAN_CONTEXT: () => INVALID_SPAN_CONTEXT,
  INVALID_TRACEID: () => INVALID_TRACEID,
  ProxyTracer: () => ProxyTracer,
  ProxyTracerProvider: () => ProxyTracerProvider,
  ROOT_CONTEXT: () => ROOT_CONTEXT,
  SamplingDecision: () => SamplingDecision,
  SpanKind: () => SpanKind,
  SpanStatusCode: () => SpanStatusCode,
  TraceFlags: () => TraceFlags,
  ValueType: () => ValueType,
  baggageEntryMetadataFromString: () => baggageEntryMetadataFromString,
  context: () => context,
  createContextKey: () => createContextKey,
  createNoopMeter: () => createNoopMeter,
  createTraceState: () => createTraceState,
  default: () => esm_default,
  defaultTextMapGetter: () => defaultTextMapGetter,
  defaultTextMapSetter: () => defaultTextMapSetter,
  diag: () => diag2,
  isSpanContextValid: () => isSpanContextValid,
  isValidSpanId: () => isValidSpanId,
  isValidTraceId: () => isValidTraceId,
  metrics: () => metrics,
  propagation: () => propagation,
  trace: () => trace
});
var esm_default;
var init_esm = __esm({
  "../../node_modules/@opentelemetry/api/build/esm/index.js"() {
    init_utils();
    init_context();
    init_consoleLogger();
    init_types();
    init_NoopMeter();
    init_Metric();
    init_TextMapPropagator();
    init_ProxyTracer();
    init_ProxyTracerProvider();
    init_SamplingResult();
    init_span_kind();
    init_status();
    init_trace_flags();
    init_utils2();
    init_spancontext_utils();
    init_invalid_span_constants();
    init_context_api();
    init_diag_api();
    init_metrics_api();
    init_propagation_api();
    init_trace_api();
    esm_default = {
      context,
      diag: diag2,
      metrics,
      propagation,
      trace
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js
var require_suppress_tracing = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/suppress-tracing.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTracingSuppressed = exports2.unsuppressTracing = exports2.suppressTracing = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var SUPPRESS_TRACING_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key SUPPRESS_TRACING");
    function suppressTracing(context2) {
      return context2.setValue(SUPPRESS_TRACING_KEY, true);
    }
    exports2.suppressTracing = suppressTracing;
    function unsuppressTracing(context2) {
      return context2.deleteValue(SUPPRESS_TRACING_KEY);
    }
    exports2.unsuppressTracing = unsuppressTracing;
    function isTracingSuppressed(context2) {
      return context2.getValue(SUPPRESS_TRACING_KEY) === true;
    }
    exports2.isTracingSuppressed = isTracingSuppressed;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/constants.js
var require_constants2 = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/baggage/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = exports2.BAGGAGE_HEADER = exports2.BAGGAGE_ITEMS_SEPARATOR = exports2.BAGGAGE_PROPERTIES_SEPARATOR = exports2.BAGGAGE_KEY_PAIR_SEPARATOR = void 0;
    exports2.BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    exports2.BAGGAGE_PROPERTIES_SEPARATOR = ";";
    exports2.BAGGAGE_ITEMS_SEPARATOR = ",";
    exports2.BAGGAGE_HEADER = "baggage";
    exports2.BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;
    exports2.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;
    exports2.BAGGAGE_MAX_TOTAL_LENGTH = 8192;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/utils.js
var require_utils = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/baggage/utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseKeyPairsIntoRecord = exports2.parsePairKeyValue = exports2.getKeyPairs = exports2.serializeKeyPairs = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var constants_1 = require_constants2();
    function serializeKeyPairs(keyPairs) {
      return keyPairs.reduce((hValue, current) => {
        const value = `${hValue}${hValue !== "" ? constants_1.BAGGAGE_ITEMS_SEPARATOR : ""}${current}`;
        return value.length > constants_1.BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;
      }, "");
    }
    exports2.serializeKeyPairs = serializeKeyPairs;
    function getKeyPairs(baggage) {
      return baggage.getAllEntries().map(([key, value]) => {
        let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;
        if (value.metadata !== void 0) {
          entry += constants_1.BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();
        }
        return entry;
      });
    }
    exports2.getKeyPairs = getKeyPairs;
    function parsePairKeyValue(entry) {
      const valueProps = entry.split(constants_1.BAGGAGE_PROPERTIES_SEPARATOR);
      if (valueProps.length <= 0)
        return;
      const keyPairPart = valueProps.shift();
      if (!keyPairPart)
        return;
      const separatorIndex = keyPairPart.indexOf(constants_1.BAGGAGE_KEY_PAIR_SEPARATOR);
      if (separatorIndex <= 0)
        return;
      const key = decodeURIComponent(keyPairPart.substring(0, separatorIndex).trim());
      const value = decodeURIComponent(keyPairPart.substring(separatorIndex + 1).trim());
      let metadata;
      if (valueProps.length > 0) {
        metadata = (0, api_1.baggageEntryMetadataFromString)(valueProps.join(constants_1.BAGGAGE_PROPERTIES_SEPARATOR));
      }
      return { key, value, metadata };
    }
    exports2.parsePairKeyValue = parsePairKeyValue;
    function parseKeyPairsIntoRecord(value) {
      if (typeof value !== "string" || value.length === 0)
        return {};
      return value.split(constants_1.BAGGAGE_ITEMS_SEPARATOR).map((entry) => {
        return parsePairKeyValue(entry);
      }).filter((keyPair) => keyPair !== void 0 && keyPair.value.length > 0).reduce((headers, keyPair) => {
        headers[keyPair.key] = keyPair.value;
        return headers;
      }, {});
    }
    exports2.parseKeyPairsIntoRecord = parseKeyPairsIntoRecord;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js
var require_W3CBaggagePropagator = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/baggage/propagation/W3CBaggagePropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CBaggagePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var constants_1 = require_constants2();
    var utils_1 = require_utils();
    var W3CBaggagePropagator = class {
      inject(context2, carrier, setter) {
        const baggage = api_1.propagation.getBaggage(context2);
        if (!baggage || (0, suppress_tracing_1.isTracingSuppressed)(context2))
          return;
        const keyPairs = (0, utils_1.getKeyPairs)(baggage).filter((pair) => {
          return pair.length <= constants_1.BAGGAGE_MAX_PER_NAME_VALUE_PAIRS;
        }).slice(0, constants_1.BAGGAGE_MAX_NAME_VALUE_PAIRS);
        const headerValue = (0, utils_1.serializeKeyPairs)(keyPairs);
        if (headerValue.length > 0) {
          setter.set(carrier, constants_1.BAGGAGE_HEADER, headerValue);
        }
      }
      extract(context2, carrier, getter) {
        const headerValue = getter.get(carrier, constants_1.BAGGAGE_HEADER);
        const baggageString = Array.isArray(headerValue) ? headerValue.join(constants_1.BAGGAGE_ITEMS_SEPARATOR) : headerValue;
        if (!baggageString)
          return context2;
        const baggage = {};
        if (baggageString.length === 0) {
          return context2;
        }
        const pairs = baggageString.split(constants_1.BAGGAGE_ITEMS_SEPARATOR);
        pairs.forEach((entry) => {
          const keyPair = (0, utils_1.parsePairKeyValue)(entry);
          if (keyPair) {
            const baggageEntry = { value: keyPair.value };
            if (keyPair.metadata) {
              baggageEntry.metadata = keyPair.metadata;
            }
            baggage[keyPair.key] = baggageEntry;
          }
        });
        if (Object.entries(baggage).length === 0) {
          return context2;
        }
        return api_1.propagation.setBaggage(context2, api_1.propagation.createBaggage(baggage));
      }
      fields() {
        return [constants_1.BAGGAGE_HEADER];
      }
    };
    exports2.W3CBaggagePropagator = W3CBaggagePropagator;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/anchored-clock.js
var require_anchored_clock = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/anchored-clock.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AnchoredClock = void 0;
    var AnchoredClock = class {
      /**
       * Create a new AnchoredClock anchored to the current time returned by systemClock.
       *
       * @param systemClock should be a clock that returns the number of milliseconds since January 1 1970 such as Date
       * @param monotonicClock should be a clock that counts milliseconds monotonically such as window.performance or perf_hooks.performance
       */
      constructor(systemClock, monotonicClock) {
        this._monotonicClock = monotonicClock;
        this._epochMillis = systemClock.now();
        this._performanceMillis = monotonicClock.now();
      }
      /**
       * Returns the current time by adding the number of milliseconds since the
       * AnchoredClock was created to the creation epoch time
       */
      now() {
        const delta = this._monotonicClock.now() - this._performanceMillis;
        return this._epochMillis + delta;
      }
    };
    exports2.AnchoredClock = AnchoredClock;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/attributes.js
var require_attributes = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/attributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isAttributeValue = exports2.isAttributeKey = exports2.sanitizeAttributes = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function sanitizeAttributes(attributes) {
      const out = {};
      if (typeof attributes !== "object" || attributes == null) {
        return out;
      }
      for (const [key, val] of Object.entries(attributes)) {
        if (!isAttributeKey(key)) {
          api_1.diag.warn(`Invalid attribute key: ${key}`);
          continue;
        }
        if (!isAttributeValue(val)) {
          api_1.diag.warn(`Invalid attribute value set for key: ${key}`);
          continue;
        }
        if (Array.isArray(val)) {
          out[key] = val.slice();
        } else {
          out[key] = val;
        }
      }
      return out;
    }
    exports2.sanitizeAttributes = sanitizeAttributes;
    function isAttributeKey(key) {
      return typeof key === "string" && key.length > 0;
    }
    exports2.isAttributeKey = isAttributeKey;
    function isAttributeValue(val) {
      if (val == null) {
        return true;
      }
      if (Array.isArray(val)) {
        return isHomogeneousAttributeValueArray(val);
      }
      return isValidPrimitiveAttributeValue(val);
    }
    exports2.isAttributeValue = isAttributeValue;
    function isHomogeneousAttributeValueArray(arr) {
      let type;
      for (const element of arr) {
        if (element == null)
          continue;
        if (!type) {
          if (isValidPrimitiveAttributeValue(element)) {
            type = typeof element;
            continue;
          }
          return false;
        }
        if (typeof element === type) {
          continue;
        }
        return false;
      }
      return true;
    }
    function isValidPrimitiveAttributeValue(val) {
      switch (typeof val) {
        case "number":
        case "boolean":
        case "string":
          return true;
      }
      return false;
    }
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js
var require_logging_error_handler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/logging-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.loggingErrorHandler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    function loggingErrorHandler() {
      return (ex) => {
        api_1.diag.error(stringifyException(ex));
      };
    }
    exports2.loggingErrorHandler = loggingErrorHandler;
    function stringifyException(ex) {
      if (typeof ex === "string") {
        return ex;
      } else {
        return JSON.stringify(flattenException(ex));
      }
    }
    function flattenException(ex) {
      const result = {};
      let current = ex;
      while (current !== null) {
        Object.getOwnPropertyNames(current).forEach((propertyName) => {
          if (result[propertyName])
            return;
          const value = current[propertyName];
          if (value) {
            result[propertyName] = String(value);
          }
        });
        current = Object.getPrototypeOf(current);
      }
      return result;
    }
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/global-error-handler.js
var require_global_error_handler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/global-error-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.globalErrorHandler = exports2.setGlobalErrorHandler = void 0;
    var logging_error_handler_1 = require_logging_error_handler();
    var delegateHandler = (0, logging_error_handler_1.loggingErrorHandler)();
    function setGlobalErrorHandler(handler) {
      delegateHandler = handler;
    }
    exports2.setGlobalErrorHandler = setGlobalErrorHandler;
    function globalErrorHandler(ex) {
      try {
        delegateHandler(ex);
      } catch (_a) {
      }
    }
    exports2.globalErrorHandler = globalErrorHandler;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/sampling.js
var require_sampling = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/sampling.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TracesSamplerValues = void 0;
    var TracesSamplerValues;
    (function(TracesSamplerValues2) {
      TracesSamplerValues2["AlwaysOff"] = "always_off";
      TracesSamplerValues2["AlwaysOn"] = "always_on";
      TracesSamplerValues2["ParentBasedAlwaysOff"] = "parentbased_always_off";
      TracesSamplerValues2["ParentBasedAlwaysOn"] = "parentbased_always_on";
      TracesSamplerValues2["ParentBasedTraceIdRatio"] = "parentbased_traceidratio";
      TracesSamplerValues2["TraceIdRatio"] = "traceidratio";
    })(TracesSamplerValues = exports2.TracesSamplerValues || (exports2.TracesSamplerValues = {}));
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/environment.js
var require_environment = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEnvironment = exports2.DEFAULT_ENVIRONMENT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var sampling_1 = require_sampling();
    var DEFAULT_LIST_SEPARATOR = ",";
    var ENVIRONMENT_BOOLEAN_KEYS = ["OTEL_SDK_DISABLED"];
    function isEnvVarABoolean(key) {
      return ENVIRONMENT_BOOLEAN_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_NUMBERS_KEYS = [
      "OTEL_BSP_EXPORT_TIMEOUT",
      "OTEL_BSP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BSP_MAX_QUEUE_SIZE",
      "OTEL_BSP_SCHEDULE_DELAY",
      "OTEL_BLRP_EXPORT_TIMEOUT",
      "OTEL_BLRP_MAX_EXPORT_BATCH_SIZE",
      "OTEL_BLRP_MAX_QUEUE_SIZE",
      "OTEL_BLRP_SCHEDULE_DELAY",
      "OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT",
      "OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT",
      "OTEL_SPAN_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_LINK_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT",
      "OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT",
      "OTEL_EXPORTER_OTLP_TIMEOUT",
      "OTEL_EXPORTER_OTLP_TRACES_TIMEOUT",
      "OTEL_EXPORTER_OTLP_METRICS_TIMEOUT",
      "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      "OTEL_EXPORTER_JAEGER_AGENT_PORT"
    ];
    function isEnvVarANumber(key) {
      return ENVIRONMENT_NUMBERS_KEYS.indexOf(key) > -1;
    }
    var ENVIRONMENT_LISTS_KEYS = [
      "OTEL_NO_PATCH_MODULES",
      "OTEL_PROPAGATORS",
      "OTEL_SEMCONV_STABILITY_OPT_IN"
    ];
    function isEnvVarAList(key) {
      return ENVIRONMENT_LISTS_KEYS.indexOf(key) > -1;
    }
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = Infinity;
    exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = 128;
    exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = 128;
    exports2.DEFAULT_ENVIRONMENT = {
      OTEL_SDK_DISABLED: false,
      CONTAINER_NAME: "",
      ECS_CONTAINER_METADATA_URI_V4: "",
      ECS_CONTAINER_METADATA_URI: "",
      HOSTNAME: "",
      KUBERNETES_SERVICE_HOST: "",
      NAMESPACE: "",
      OTEL_BSP_EXPORT_TIMEOUT: 3e4,
      OTEL_BSP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BSP_MAX_QUEUE_SIZE: 2048,
      OTEL_BSP_SCHEDULE_DELAY: 5e3,
      OTEL_BLRP_EXPORT_TIMEOUT: 3e4,
      OTEL_BLRP_MAX_EXPORT_BATCH_SIZE: 512,
      OTEL_BLRP_MAX_QUEUE_SIZE: 2048,
      OTEL_BLRP_SCHEDULE_DELAY: 5e3,
      OTEL_EXPORTER_JAEGER_AGENT_HOST: "",
      OTEL_EXPORTER_JAEGER_AGENT_PORT: 6832,
      OTEL_EXPORTER_JAEGER_ENDPOINT: "",
      OTEL_EXPORTER_JAEGER_PASSWORD: "",
      OTEL_EXPORTER_JAEGER_USER: "",
      OTEL_EXPORTER_OTLP_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_TRACES_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_METRICS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_LOGS_ENDPOINT: "",
      OTEL_EXPORTER_OTLP_HEADERS: "",
      OTEL_EXPORTER_OTLP_TRACES_HEADERS: "",
      OTEL_EXPORTER_OTLP_METRICS_HEADERS: "",
      OTEL_EXPORTER_OTLP_LOGS_HEADERS: "",
      OTEL_EXPORTER_OTLP_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_TRACES_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_METRICS_TIMEOUT: 1e4,
      OTEL_EXPORTER_OTLP_LOGS_TIMEOUT: 1e4,
      OTEL_EXPORTER_ZIPKIN_ENDPOINT: "http://localhost:9411/api/v2/spans",
      OTEL_LOG_LEVEL: api_1.DiagLogLevel.INFO,
      OTEL_NO_PATCH_MODULES: [],
      OTEL_PROPAGATORS: ["tracecontext", "baggage"],
      OTEL_RESOURCE_ATTRIBUTES: "",
      OTEL_SERVICE_NAME: "",
      OTEL_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_SPAN_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_VALUE_LENGTH_LIMIT: exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT,
      OTEL_LOGRECORD_ATTRIBUTE_COUNT_LIMIT: exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT,
      OTEL_SPAN_EVENT_COUNT_LIMIT: 128,
      OTEL_SPAN_LINK_COUNT_LIMIT: 128,
      OTEL_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT,
      OTEL_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT: exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT,
      OTEL_TRACES_EXPORTER: "",
      OTEL_TRACES_SAMPLER: sampling_1.TracesSamplerValues.ParentBasedAlwaysOn,
      OTEL_TRACES_SAMPLER_ARG: "",
      OTEL_LOGS_EXPORTER: "",
      OTEL_EXPORTER_OTLP_INSECURE: "",
      OTEL_EXPORTER_OTLP_TRACES_INSECURE: "",
      OTEL_EXPORTER_OTLP_METRICS_INSECURE: "",
      OTEL_EXPORTER_OTLP_LOGS_INSECURE: "",
      OTEL_EXPORTER_OTLP_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_TRACES_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_METRICS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_LOGS_COMPRESSION: "",
      OTEL_EXPORTER_OTLP_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_KEY: "",
      OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_TRACES_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_METRICS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_LOGS_CLIENT_CERTIFICATE: "",
      OTEL_EXPORTER_OTLP_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_TRACES_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_LOGS_PROTOCOL: "http/protobuf",
      OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE: "cumulative",
      OTEL_SEMCONV_STABILITY_OPT_IN: []
    };
    function parseBoolean(key, environment, values) {
      if (typeof values[key] === "undefined") {
        return;
      }
      const value = String(values[key]);
      environment[key] = value.toLowerCase() === "true";
    }
    function parseNumber(name, environment, values, min = -Infinity, max = Infinity) {
      if (typeof values[name] !== "undefined") {
        const value = Number(values[name]);
        if (!isNaN(value)) {
          if (value < min) {
            environment[name] = min;
          } else if (value > max) {
            environment[name] = max;
          } else {
            environment[name] = value;
          }
        }
      }
    }
    function parseStringList(name, output, input, separator = DEFAULT_LIST_SEPARATOR) {
      const givenValue = input[name];
      if (typeof givenValue === "string") {
        output[name] = givenValue.split(separator).map((v) => v.trim());
      }
    }
    var logLevelMap = {
      ALL: api_1.DiagLogLevel.ALL,
      VERBOSE: api_1.DiagLogLevel.VERBOSE,
      DEBUG: api_1.DiagLogLevel.DEBUG,
      INFO: api_1.DiagLogLevel.INFO,
      WARN: api_1.DiagLogLevel.WARN,
      ERROR: api_1.DiagLogLevel.ERROR,
      NONE: api_1.DiagLogLevel.NONE
    };
    function setLogLevelFromEnv(key, environment, values) {
      const value = values[key];
      if (typeof value === "string") {
        const theLevel = logLevelMap[value.toUpperCase()];
        if (theLevel != null) {
          environment[key] = theLevel;
        }
      }
    }
    function parseEnvironment(values) {
      const environment = {};
      for (const env in exports2.DEFAULT_ENVIRONMENT) {
        const key = env;
        switch (key) {
          case "OTEL_LOG_LEVEL":
            setLogLevelFromEnv(key, environment, values);
            break;
          default:
            if (isEnvVarABoolean(key)) {
              parseBoolean(key, environment, values);
            } else if (isEnvVarANumber(key)) {
              parseNumber(key, environment, values);
            } else if (isEnvVarAList(key)) {
              parseStringList(key, environment, values);
            } else {
              const value = values[key];
              if (typeof value !== "undefined" && value !== null) {
                environment[key] = String(value);
              }
            }
        }
      }
      return environment;
    }
    exports2.parseEnvironment = parseEnvironment;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/environment.js
var require_environment2 = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/environment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getEnvWithoutDefaults = exports2.getEnv = void 0;
    var environment_1 = require_environment();
    function getEnv() {
      const processEnv = (0, environment_1.parseEnvironment)(process.env);
      return Object.assign({}, environment_1.DEFAULT_ENVIRONMENT, processEnv);
    }
    exports2.getEnv = getEnv;
    function getEnvWithoutDefaults() {
      return (0, environment_1.parseEnvironment)(process.env);
    }
    exports2.getEnvWithoutDefaults = getEnvWithoutDefaults;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js
var require_globalThis = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js
var require_hex_to_binary = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/hex-to-binary.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBinary = void 0;
    function intValue(charCode) {
      if (charCode >= 48 && charCode <= 57) {
        return charCode - 48;
      }
      if (charCode >= 97 && charCode <= 102) {
        return charCode - 87;
      }
      return charCode - 55;
    }
    function hexToBinary(hexStr) {
      const buf = new Uint8Array(hexStr.length / 2);
      let offset = 0;
      for (let i = 0; i < hexStr.length; i += 2) {
        const hi = intValue(hexStr.charCodeAt(i));
        const lo = intValue(hexStr.charCodeAt(i + 1));
        buf[offset++] = hi << 4 | lo;
      }
      return buf;
    }
    exports2.hexToBinary = hexToBinary;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js
var require_hex_to_base64 = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/hex-to-base64.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hexToBase64 = void 0;
    var hex_to_binary_1 = require_hex_to_binary();
    function hexToBase64(hexStr) {
      return Buffer.from((0, hex_to_binary_1.hexToBinary)(hexStr)).toString("base64");
    }
    exports2.hexToBase64 = hexToBase64;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js
var require_RandomIdGenerator = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/RandomIdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RandomIdGenerator = void 0;
    var SPAN_ID_BYTES = 8;
    var TRACE_ID_BYTES = 16;
    var RandomIdGenerator = class {
      constructor() {
        this.generateTraceId = getIdGenerator(TRACE_ID_BYTES);
        this.generateSpanId = getIdGenerator(SPAN_ID_BYTES);
      }
    };
    exports2.RandomIdGenerator = RandomIdGenerator;
    var SHARED_BUFFER = Buffer.allocUnsafe(TRACE_ID_BYTES);
    function getIdGenerator(bytes) {
      return function generateId() {
        for (let i = 0; i < bytes / 4; i++) {
          SHARED_BUFFER.writeUInt32BE(Math.random() * 2 ** 32 >>> 0, i * 4);
        }
        for (let i = 0; i < bytes; i++) {
          if (SHARED_BUFFER[i] > 0) {
            break;
          } else if (i === bytes - 1) {
            SHARED_BUFFER[bytes - 1] = 1;
          }
        }
        return SHARED_BUFFER.toString("hex", 0, bytes);
      };
    }
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/performance.js
var require_performance = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/performance.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.otperformance = void 0;
    var perf_hooks_1 = __require("perf_hooks");
    exports2.otperformance = perf_hooks_1.performance;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/version.js
var require_version = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VERSION = void 0;
    exports2.VERSION = "1.30.1";
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js
// @__NO_SIDE_EFFECTS__
function createConstMap(values) {
  var res = {};
  var len = values.length;
  for (var lp = 0; lp < len; lp++) {
    var val = values[lp];
    if (val) {
      res[String(val).toUpperCase().replace(/[-.]/g, "_")] = val;
    }
  }
  return res;
}
var init_utils3 = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/internal/utils.js"() {
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js
var TMP_AWS_LAMBDA_INVOKED_ARN, TMP_DB_SYSTEM, TMP_DB_CONNECTION_STRING, TMP_DB_USER, TMP_DB_JDBC_DRIVER_CLASSNAME, TMP_DB_NAME, TMP_DB_STATEMENT, TMP_DB_OPERATION, TMP_DB_MSSQL_INSTANCE_NAME, TMP_DB_CASSANDRA_KEYSPACE, TMP_DB_CASSANDRA_PAGE_SIZE, TMP_DB_CASSANDRA_CONSISTENCY_LEVEL, TMP_DB_CASSANDRA_TABLE, TMP_DB_CASSANDRA_IDEMPOTENCE, TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, TMP_DB_CASSANDRA_COORDINATOR_ID, TMP_DB_CASSANDRA_COORDINATOR_DC, TMP_DB_HBASE_NAMESPACE, TMP_DB_REDIS_DATABASE_INDEX, TMP_DB_MONGODB_COLLECTION, TMP_DB_SQL_TABLE, TMP_EXCEPTION_TYPE, TMP_EXCEPTION_MESSAGE, TMP_EXCEPTION_STACKTRACE, TMP_EXCEPTION_ESCAPED, TMP_FAAS_TRIGGER, TMP_FAAS_EXECUTION, TMP_FAAS_DOCUMENT_COLLECTION, TMP_FAAS_DOCUMENT_OPERATION, TMP_FAAS_DOCUMENT_TIME, TMP_FAAS_DOCUMENT_NAME, TMP_FAAS_TIME, TMP_FAAS_CRON, TMP_FAAS_COLDSTART, TMP_FAAS_INVOKED_NAME, TMP_FAAS_INVOKED_PROVIDER, TMP_FAAS_INVOKED_REGION, TMP_NET_TRANSPORT, TMP_NET_PEER_IP, TMP_NET_PEER_PORT, TMP_NET_PEER_NAME, TMP_NET_HOST_IP, TMP_NET_HOST_PORT, TMP_NET_HOST_NAME, TMP_NET_HOST_CONNECTION_TYPE, TMP_NET_HOST_CONNECTION_SUBTYPE, TMP_NET_HOST_CARRIER_NAME, TMP_NET_HOST_CARRIER_MCC, TMP_NET_HOST_CARRIER_MNC, TMP_NET_HOST_CARRIER_ICC, TMP_PEER_SERVICE, TMP_ENDUSER_ID, TMP_ENDUSER_ROLE, TMP_ENDUSER_SCOPE, TMP_THREAD_ID, TMP_THREAD_NAME, TMP_CODE_FUNCTION, TMP_CODE_NAMESPACE, TMP_CODE_FILEPATH, TMP_CODE_LINENO, TMP_HTTP_METHOD, TMP_HTTP_URL, TMP_HTTP_TARGET, TMP_HTTP_HOST, TMP_HTTP_SCHEME, TMP_HTTP_STATUS_CODE, TMP_HTTP_FLAVOR, TMP_HTTP_USER_AGENT, TMP_HTTP_REQUEST_CONTENT_LENGTH, TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_RESPONSE_CONTENT_LENGTH, TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, TMP_HTTP_SERVER_NAME, TMP_HTTP_ROUTE, TMP_HTTP_CLIENT_IP, TMP_AWS_DYNAMODB_TABLE_NAMES, TMP_AWS_DYNAMODB_CONSUMED_CAPACITY, TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, TMP_AWS_DYNAMODB_CONSISTENT_READ, TMP_AWS_DYNAMODB_PROJECTION, TMP_AWS_DYNAMODB_LIMIT, TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET, TMP_AWS_DYNAMODB_INDEX_NAME, TMP_AWS_DYNAMODB_SELECT, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, TMP_AWS_DYNAMODB_TABLE_COUNT, TMP_AWS_DYNAMODB_SCAN_FORWARD, TMP_AWS_DYNAMODB_SEGMENT, TMP_AWS_DYNAMODB_TOTAL_SEGMENTS, TMP_AWS_DYNAMODB_COUNT, TMP_AWS_DYNAMODB_SCANNED_COUNT, TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, TMP_MESSAGING_SYSTEM, TMP_MESSAGING_DESTINATION, TMP_MESSAGING_DESTINATION_KIND, TMP_MESSAGING_TEMP_DESTINATION, TMP_MESSAGING_PROTOCOL, TMP_MESSAGING_PROTOCOL_VERSION, TMP_MESSAGING_URL, TMP_MESSAGING_MESSAGE_ID, TMP_MESSAGING_CONVERSATION_ID, TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, TMP_MESSAGING_OPERATION, TMP_MESSAGING_CONSUMER_ID, TMP_MESSAGING_RABBITMQ_ROUTING_KEY, TMP_MESSAGING_KAFKA_MESSAGE_KEY, TMP_MESSAGING_KAFKA_CONSUMER_GROUP, TMP_MESSAGING_KAFKA_CLIENT_ID, TMP_MESSAGING_KAFKA_PARTITION, TMP_MESSAGING_KAFKA_TOMBSTONE, TMP_RPC_SYSTEM, TMP_RPC_SERVICE, TMP_RPC_METHOD, TMP_RPC_GRPC_STATUS_CODE, TMP_RPC_JSONRPC_VERSION, TMP_RPC_JSONRPC_REQUEST_ID, TMP_RPC_JSONRPC_ERROR_CODE, TMP_RPC_JSONRPC_ERROR_MESSAGE, TMP_MESSAGE_TYPE, TMP_MESSAGE_ID, TMP_MESSAGE_COMPRESSED_SIZE, TMP_MESSAGE_UNCOMPRESSED_SIZE, SEMATTRS_AWS_LAMBDA_INVOKED_ARN, SEMATTRS_DB_SYSTEM, SEMATTRS_DB_CONNECTION_STRING, SEMATTRS_DB_USER, SEMATTRS_DB_JDBC_DRIVER_CLASSNAME, SEMATTRS_DB_NAME, SEMATTRS_DB_STATEMENT, SEMATTRS_DB_OPERATION, SEMATTRS_DB_MSSQL_INSTANCE_NAME, SEMATTRS_DB_CASSANDRA_KEYSPACE, SEMATTRS_DB_CASSANDRA_PAGE_SIZE, SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL, SEMATTRS_DB_CASSANDRA_TABLE, SEMATTRS_DB_CASSANDRA_IDEMPOTENCE, SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT, SEMATTRS_DB_CASSANDRA_COORDINATOR_ID, SEMATTRS_DB_CASSANDRA_COORDINATOR_DC, SEMATTRS_DB_HBASE_NAMESPACE, SEMATTRS_DB_REDIS_DATABASE_INDEX, SEMATTRS_DB_MONGODB_COLLECTION, SEMATTRS_DB_SQL_TABLE, SEMATTRS_EXCEPTION_TYPE, SEMATTRS_EXCEPTION_MESSAGE, SEMATTRS_EXCEPTION_STACKTRACE, SEMATTRS_EXCEPTION_ESCAPED, SEMATTRS_FAAS_TRIGGER, SEMATTRS_FAAS_EXECUTION, SEMATTRS_FAAS_DOCUMENT_COLLECTION, SEMATTRS_FAAS_DOCUMENT_OPERATION, SEMATTRS_FAAS_DOCUMENT_TIME, SEMATTRS_FAAS_DOCUMENT_NAME, SEMATTRS_FAAS_TIME, SEMATTRS_FAAS_CRON, SEMATTRS_FAAS_COLDSTART, SEMATTRS_FAAS_INVOKED_NAME, SEMATTRS_FAAS_INVOKED_PROVIDER, SEMATTRS_FAAS_INVOKED_REGION, SEMATTRS_NET_TRANSPORT, SEMATTRS_NET_PEER_IP, SEMATTRS_NET_PEER_PORT, SEMATTRS_NET_PEER_NAME, SEMATTRS_NET_HOST_IP, SEMATTRS_NET_HOST_PORT, SEMATTRS_NET_HOST_NAME, SEMATTRS_NET_HOST_CONNECTION_TYPE, SEMATTRS_NET_HOST_CONNECTION_SUBTYPE, SEMATTRS_NET_HOST_CARRIER_NAME, SEMATTRS_NET_HOST_CARRIER_MCC, SEMATTRS_NET_HOST_CARRIER_MNC, SEMATTRS_NET_HOST_CARRIER_ICC, SEMATTRS_PEER_SERVICE, SEMATTRS_ENDUSER_ID, SEMATTRS_ENDUSER_ROLE, SEMATTRS_ENDUSER_SCOPE, SEMATTRS_THREAD_ID, SEMATTRS_THREAD_NAME, SEMATTRS_CODE_FUNCTION, SEMATTRS_CODE_NAMESPACE, SEMATTRS_CODE_FILEPATH, SEMATTRS_CODE_LINENO, SEMATTRS_HTTP_METHOD, SEMATTRS_HTTP_URL, SEMATTRS_HTTP_TARGET, SEMATTRS_HTTP_HOST, SEMATTRS_HTTP_SCHEME, SEMATTRS_HTTP_STATUS_CODE, SEMATTRS_HTTP_FLAVOR, SEMATTRS_HTTP_USER_AGENT, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH, SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH, SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED, SEMATTRS_HTTP_SERVER_NAME, SEMATTRS_HTTP_ROUTE, SEMATTRS_HTTP_CLIENT_IP, SEMATTRS_AWS_DYNAMODB_TABLE_NAMES, SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY, SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS, SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY, SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY, SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ, SEMATTRS_AWS_DYNAMODB_PROJECTION, SEMATTRS_AWS_DYNAMODB_LIMIT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET, SEMATTRS_AWS_DYNAMODB_INDEX_NAME, SEMATTRS_AWS_DYNAMODB_SELECT, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES, SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE, SEMATTRS_AWS_DYNAMODB_TABLE_COUNT, SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD, SEMATTRS_AWS_DYNAMODB_SEGMENT, SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS, SEMATTRS_AWS_DYNAMODB_COUNT, SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT, SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS, SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES, SEMATTRS_MESSAGING_SYSTEM, SEMATTRS_MESSAGING_DESTINATION, SEMATTRS_MESSAGING_DESTINATION_KIND, SEMATTRS_MESSAGING_TEMP_DESTINATION, SEMATTRS_MESSAGING_PROTOCOL, SEMATTRS_MESSAGING_PROTOCOL_VERSION, SEMATTRS_MESSAGING_URL, SEMATTRS_MESSAGING_MESSAGE_ID, SEMATTRS_MESSAGING_CONVERSATION_ID, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES, SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES, SEMATTRS_MESSAGING_OPERATION, SEMATTRS_MESSAGING_CONSUMER_ID, SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY, SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY, SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP, SEMATTRS_MESSAGING_KAFKA_CLIENT_ID, SEMATTRS_MESSAGING_KAFKA_PARTITION, SEMATTRS_MESSAGING_KAFKA_TOMBSTONE, SEMATTRS_RPC_SYSTEM, SEMATTRS_RPC_SERVICE, SEMATTRS_RPC_METHOD, SEMATTRS_RPC_GRPC_STATUS_CODE, SEMATTRS_RPC_JSONRPC_VERSION, SEMATTRS_RPC_JSONRPC_REQUEST_ID, SEMATTRS_RPC_JSONRPC_ERROR_CODE, SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE, SEMATTRS_MESSAGE_TYPE, SEMATTRS_MESSAGE_ID, SEMATTRS_MESSAGE_COMPRESSED_SIZE, SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE, SemanticAttributes, TMP_DBSYSTEMVALUES_OTHER_SQL, TMP_DBSYSTEMVALUES_MSSQL, TMP_DBSYSTEMVALUES_MYSQL, TMP_DBSYSTEMVALUES_ORACLE, TMP_DBSYSTEMVALUES_DB2, TMP_DBSYSTEMVALUES_POSTGRESQL, TMP_DBSYSTEMVALUES_REDSHIFT, TMP_DBSYSTEMVALUES_HIVE, TMP_DBSYSTEMVALUES_CLOUDSCAPE, TMP_DBSYSTEMVALUES_HSQLDB, TMP_DBSYSTEMVALUES_PROGRESS, TMP_DBSYSTEMVALUES_MAXDB, TMP_DBSYSTEMVALUES_HANADB, TMP_DBSYSTEMVALUES_INGRES, TMP_DBSYSTEMVALUES_FIRSTSQL, TMP_DBSYSTEMVALUES_EDB, TMP_DBSYSTEMVALUES_CACHE, TMP_DBSYSTEMVALUES_ADABAS, TMP_DBSYSTEMVALUES_FIREBIRD, TMP_DBSYSTEMVALUES_DERBY, TMP_DBSYSTEMVALUES_FILEMAKER, TMP_DBSYSTEMVALUES_INFORMIX, TMP_DBSYSTEMVALUES_INSTANTDB, TMP_DBSYSTEMVALUES_INTERBASE, TMP_DBSYSTEMVALUES_MARIADB, TMP_DBSYSTEMVALUES_NETEZZA, TMP_DBSYSTEMVALUES_PERVASIVE, TMP_DBSYSTEMVALUES_POINTBASE, TMP_DBSYSTEMVALUES_SQLITE, TMP_DBSYSTEMVALUES_SYBASE, TMP_DBSYSTEMVALUES_TERADATA, TMP_DBSYSTEMVALUES_VERTICA, TMP_DBSYSTEMVALUES_H2, TMP_DBSYSTEMVALUES_COLDFUSION, TMP_DBSYSTEMVALUES_CASSANDRA, TMP_DBSYSTEMVALUES_HBASE, TMP_DBSYSTEMVALUES_MONGODB, TMP_DBSYSTEMVALUES_REDIS, TMP_DBSYSTEMVALUES_COUCHBASE, TMP_DBSYSTEMVALUES_COUCHDB, TMP_DBSYSTEMVALUES_COSMOSDB, TMP_DBSYSTEMVALUES_DYNAMODB, TMP_DBSYSTEMVALUES_NEO4J, TMP_DBSYSTEMVALUES_GEODE, TMP_DBSYSTEMVALUES_ELASTICSEARCH, TMP_DBSYSTEMVALUES_MEMCACHED, TMP_DBSYSTEMVALUES_COCKROACHDB, DBSYSTEMVALUES_OTHER_SQL, DBSYSTEMVALUES_MSSQL, DBSYSTEMVALUES_MYSQL, DBSYSTEMVALUES_ORACLE, DBSYSTEMVALUES_DB2, DBSYSTEMVALUES_POSTGRESQL, DBSYSTEMVALUES_REDSHIFT, DBSYSTEMVALUES_HIVE, DBSYSTEMVALUES_CLOUDSCAPE, DBSYSTEMVALUES_HSQLDB, DBSYSTEMVALUES_PROGRESS, DBSYSTEMVALUES_MAXDB, DBSYSTEMVALUES_HANADB, DBSYSTEMVALUES_INGRES, DBSYSTEMVALUES_FIRSTSQL, DBSYSTEMVALUES_EDB, DBSYSTEMVALUES_CACHE, DBSYSTEMVALUES_ADABAS, DBSYSTEMVALUES_FIREBIRD, DBSYSTEMVALUES_DERBY, DBSYSTEMVALUES_FILEMAKER, DBSYSTEMVALUES_INFORMIX, DBSYSTEMVALUES_INSTANTDB, DBSYSTEMVALUES_INTERBASE, DBSYSTEMVALUES_MARIADB, DBSYSTEMVALUES_NETEZZA, DBSYSTEMVALUES_PERVASIVE, DBSYSTEMVALUES_POINTBASE, DBSYSTEMVALUES_SQLITE, DBSYSTEMVALUES_SYBASE, DBSYSTEMVALUES_TERADATA, DBSYSTEMVALUES_VERTICA, DBSYSTEMVALUES_H2, DBSYSTEMVALUES_COLDFUSION, DBSYSTEMVALUES_CASSANDRA, DBSYSTEMVALUES_HBASE, DBSYSTEMVALUES_MONGODB, DBSYSTEMVALUES_REDIS, DBSYSTEMVALUES_COUCHBASE, DBSYSTEMVALUES_COUCHDB, DBSYSTEMVALUES_COSMOSDB, DBSYSTEMVALUES_DYNAMODB, DBSYSTEMVALUES_NEO4J, DBSYSTEMVALUES_GEODE, DBSYSTEMVALUES_ELASTICSEARCH, DBSYSTEMVALUES_MEMCACHED, DBSYSTEMVALUES_COCKROACHDB, DbSystemValues, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_ALL, DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM, DBCASSANDRACONSISTENCYLEVELVALUES_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_TWO, DBCASSANDRACONSISTENCYLEVELVALUES_THREE, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE, DBCASSANDRACONSISTENCYLEVELVALUES_ANY, DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL, DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL, DbCassandraConsistencyLevelValues, TMP_FAASTRIGGERVALUES_DATASOURCE, TMP_FAASTRIGGERVALUES_HTTP, TMP_FAASTRIGGERVALUES_PUBSUB, TMP_FAASTRIGGERVALUES_TIMER, TMP_FAASTRIGGERVALUES_OTHER, FAASTRIGGERVALUES_DATASOURCE, FAASTRIGGERVALUES_HTTP, FAASTRIGGERVALUES_PUBSUB, FAASTRIGGERVALUES_TIMER, FAASTRIGGERVALUES_OTHER, FaasTriggerValues, TMP_FAASDOCUMENTOPERATIONVALUES_INSERT, TMP_FAASDOCUMENTOPERATIONVALUES_EDIT, TMP_FAASDOCUMENTOPERATIONVALUES_DELETE, FAASDOCUMENTOPERATIONVALUES_INSERT, FAASDOCUMENTOPERATIONVALUES_EDIT, FAASDOCUMENTOPERATIONVALUES_DELETE, FaasDocumentOperationValues, TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, TMP_FAASINVOKEDPROVIDERVALUES_AWS, TMP_FAASINVOKEDPROVIDERVALUES_AZURE, TMP_FAASINVOKEDPROVIDERVALUES_GCP, FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD, FAASINVOKEDPROVIDERVALUES_AWS, FAASINVOKEDPROVIDERVALUES_AZURE, FAASINVOKEDPROVIDERVALUES_GCP, FaasInvokedProviderValues, TMP_NETTRANSPORTVALUES_IP_TCP, TMP_NETTRANSPORTVALUES_IP_UDP, TMP_NETTRANSPORTVALUES_IP, TMP_NETTRANSPORTVALUES_UNIX, TMP_NETTRANSPORTVALUES_PIPE, TMP_NETTRANSPORTVALUES_INPROC, TMP_NETTRANSPORTVALUES_OTHER, NETTRANSPORTVALUES_IP_TCP, NETTRANSPORTVALUES_IP_UDP, NETTRANSPORTVALUES_IP, NETTRANSPORTVALUES_UNIX, NETTRANSPORTVALUES_PIPE, NETTRANSPORTVALUES_INPROC, NETTRANSPORTVALUES_OTHER, NetTransportValues, TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI, TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED, TMP_NETHOSTCONNECTIONTYPEVALUES_CELL, TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NETHOSTCONNECTIONTYPEVALUES_WIFI, NETHOSTCONNECTIONTYPEVALUES_WIRED, NETHOSTCONNECTIONTYPEVALUES_CELL, NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE, NETHOSTCONNECTIONTYPEVALUES_UNKNOWN, NetHostConnectionTypeValues, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NETHOSTCONNECTIONSUBTYPEVALUES_GPRS, NETHOSTCONNECTIONSUBTYPEVALUES_EDGE, NETHOSTCONNECTIONSUBTYPEVALUES_UMTS, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A, NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT, NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA, NETHOSTCONNECTIONSUBTYPEVALUES_HSPA, NETHOSTCONNECTIONSUBTYPEVALUES_IDEN, NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B, NETHOSTCONNECTIONSUBTYPEVALUES_LTE, NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD, NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP, NETHOSTCONNECTIONSUBTYPEVALUES_GSM, NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA, NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN, NETHOSTCONNECTIONSUBTYPEVALUES_NR, NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA, NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA, NetHostConnectionSubtypeValues, TMP_HTTPFLAVORVALUES_HTTP_1_0, TMP_HTTPFLAVORVALUES_HTTP_1_1, TMP_HTTPFLAVORVALUES_HTTP_2_0, TMP_HTTPFLAVORVALUES_SPDY, TMP_HTTPFLAVORVALUES_QUIC, HTTPFLAVORVALUES_HTTP_1_0, HTTPFLAVORVALUES_HTTP_1_1, HTTPFLAVORVALUES_HTTP_2_0, HTTPFLAVORVALUES_SPDY, HTTPFLAVORVALUES_QUIC, HttpFlavorValues, TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE, TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC, MESSAGINGDESTINATIONKINDVALUES_QUEUE, MESSAGINGDESTINATIONKINDVALUES_TOPIC, MessagingDestinationKindValues, TMP_MESSAGINGOPERATIONVALUES_RECEIVE, TMP_MESSAGINGOPERATIONVALUES_PROCESS, MESSAGINGOPERATIONVALUES_RECEIVE, MESSAGINGOPERATIONVALUES_PROCESS, MessagingOperationValues, TMP_RPCGRPCSTATUSCODEVALUES_OK, TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED, TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN, TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND, TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, TMP_RPCGRPCSTATUSCODEVALUES_ABORTED, TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL, TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS, TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RPCGRPCSTATUSCODEVALUES_OK, RPCGRPCSTATUSCODEVALUES_CANCELLED, RPCGRPCSTATUSCODEVALUES_UNKNOWN, RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT, RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED, RPCGRPCSTATUSCODEVALUES_NOT_FOUND, RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS, RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED, RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED, RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION, RPCGRPCSTATUSCODEVALUES_ABORTED, RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE, RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED, RPCGRPCSTATUSCODEVALUES_INTERNAL, RPCGRPCSTATUSCODEVALUES_UNAVAILABLE, RPCGRPCSTATUSCODEVALUES_DATA_LOSS, RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED, RpcGrpcStatusCodeValues, TMP_MESSAGETYPEVALUES_SENT, TMP_MESSAGETYPEVALUES_RECEIVED, MESSAGETYPEVALUES_SENT, MESSAGETYPEVALUES_RECEIVED, MessageTypeValues;
var init_SemanticAttributes = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/SemanticAttributes.js"() {
    init_utils3();
    TMP_AWS_LAMBDA_INVOKED_ARN = "aws.lambda.invoked_arn";
    TMP_DB_SYSTEM = "db.system";
    TMP_DB_CONNECTION_STRING = "db.connection_string";
    TMP_DB_USER = "db.user";
    TMP_DB_JDBC_DRIVER_CLASSNAME = "db.jdbc.driver_classname";
    TMP_DB_NAME = "db.name";
    TMP_DB_STATEMENT = "db.statement";
    TMP_DB_OPERATION = "db.operation";
    TMP_DB_MSSQL_INSTANCE_NAME = "db.mssql.instance_name";
    TMP_DB_CASSANDRA_KEYSPACE = "db.cassandra.keyspace";
    TMP_DB_CASSANDRA_PAGE_SIZE = "db.cassandra.page_size";
    TMP_DB_CASSANDRA_CONSISTENCY_LEVEL = "db.cassandra.consistency_level";
    TMP_DB_CASSANDRA_TABLE = "db.cassandra.table";
    TMP_DB_CASSANDRA_IDEMPOTENCE = "db.cassandra.idempotence";
    TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = "db.cassandra.speculative_execution_count";
    TMP_DB_CASSANDRA_COORDINATOR_ID = "db.cassandra.coordinator.id";
    TMP_DB_CASSANDRA_COORDINATOR_DC = "db.cassandra.coordinator.dc";
    TMP_DB_HBASE_NAMESPACE = "db.hbase.namespace";
    TMP_DB_REDIS_DATABASE_INDEX = "db.redis.database_index";
    TMP_DB_MONGODB_COLLECTION = "db.mongodb.collection";
    TMP_DB_SQL_TABLE = "db.sql.table";
    TMP_EXCEPTION_TYPE = "exception.type";
    TMP_EXCEPTION_MESSAGE = "exception.message";
    TMP_EXCEPTION_STACKTRACE = "exception.stacktrace";
    TMP_EXCEPTION_ESCAPED = "exception.escaped";
    TMP_FAAS_TRIGGER = "faas.trigger";
    TMP_FAAS_EXECUTION = "faas.execution";
    TMP_FAAS_DOCUMENT_COLLECTION = "faas.document.collection";
    TMP_FAAS_DOCUMENT_OPERATION = "faas.document.operation";
    TMP_FAAS_DOCUMENT_TIME = "faas.document.time";
    TMP_FAAS_DOCUMENT_NAME = "faas.document.name";
    TMP_FAAS_TIME = "faas.time";
    TMP_FAAS_CRON = "faas.cron";
    TMP_FAAS_COLDSTART = "faas.coldstart";
    TMP_FAAS_INVOKED_NAME = "faas.invoked_name";
    TMP_FAAS_INVOKED_PROVIDER = "faas.invoked_provider";
    TMP_FAAS_INVOKED_REGION = "faas.invoked_region";
    TMP_NET_TRANSPORT = "net.transport";
    TMP_NET_PEER_IP = "net.peer.ip";
    TMP_NET_PEER_PORT = "net.peer.port";
    TMP_NET_PEER_NAME = "net.peer.name";
    TMP_NET_HOST_IP = "net.host.ip";
    TMP_NET_HOST_PORT = "net.host.port";
    TMP_NET_HOST_NAME = "net.host.name";
    TMP_NET_HOST_CONNECTION_TYPE = "net.host.connection.type";
    TMP_NET_HOST_CONNECTION_SUBTYPE = "net.host.connection.subtype";
    TMP_NET_HOST_CARRIER_NAME = "net.host.carrier.name";
    TMP_NET_HOST_CARRIER_MCC = "net.host.carrier.mcc";
    TMP_NET_HOST_CARRIER_MNC = "net.host.carrier.mnc";
    TMP_NET_HOST_CARRIER_ICC = "net.host.carrier.icc";
    TMP_PEER_SERVICE = "peer.service";
    TMP_ENDUSER_ID = "enduser.id";
    TMP_ENDUSER_ROLE = "enduser.role";
    TMP_ENDUSER_SCOPE = "enduser.scope";
    TMP_THREAD_ID = "thread.id";
    TMP_THREAD_NAME = "thread.name";
    TMP_CODE_FUNCTION = "code.function";
    TMP_CODE_NAMESPACE = "code.namespace";
    TMP_CODE_FILEPATH = "code.filepath";
    TMP_CODE_LINENO = "code.lineno";
    TMP_HTTP_METHOD = "http.method";
    TMP_HTTP_URL = "http.url";
    TMP_HTTP_TARGET = "http.target";
    TMP_HTTP_HOST = "http.host";
    TMP_HTTP_SCHEME = "http.scheme";
    TMP_HTTP_STATUS_CODE = "http.status_code";
    TMP_HTTP_FLAVOR = "http.flavor";
    TMP_HTTP_USER_AGENT = "http.user_agent";
    TMP_HTTP_REQUEST_CONTENT_LENGTH = "http.request_content_length";
    TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = "http.request_content_length_uncompressed";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH = "http.response_content_length";
    TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = "http.response_content_length_uncompressed";
    TMP_HTTP_SERVER_NAME = "http.server_name";
    TMP_HTTP_ROUTE = "http.route";
    TMP_HTTP_CLIENT_IP = "http.client_ip";
    TMP_AWS_DYNAMODB_TABLE_NAMES = "aws.dynamodb.table_names";
    TMP_AWS_DYNAMODB_CONSUMED_CAPACITY = "aws.dynamodb.consumed_capacity";
    TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = "aws.dynamodb.item_collection_metrics";
    TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = "aws.dynamodb.provisioned_read_capacity";
    TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = "aws.dynamodb.provisioned_write_capacity";
    TMP_AWS_DYNAMODB_CONSISTENT_READ = "aws.dynamodb.consistent_read";
    TMP_AWS_DYNAMODB_PROJECTION = "aws.dynamodb.projection";
    TMP_AWS_DYNAMODB_LIMIT = "aws.dynamodb.limit";
    TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET = "aws.dynamodb.attributes_to_get";
    TMP_AWS_DYNAMODB_INDEX_NAME = "aws.dynamodb.index_name";
    TMP_AWS_DYNAMODB_SELECT = "aws.dynamodb.select";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = "aws.dynamodb.global_secondary_indexes";
    TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = "aws.dynamodb.local_secondary_indexes";
    TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = "aws.dynamodb.exclusive_start_table";
    TMP_AWS_DYNAMODB_TABLE_COUNT = "aws.dynamodb.table_count";
    TMP_AWS_DYNAMODB_SCAN_FORWARD = "aws.dynamodb.scan_forward";
    TMP_AWS_DYNAMODB_SEGMENT = "aws.dynamodb.segment";
    TMP_AWS_DYNAMODB_TOTAL_SEGMENTS = "aws.dynamodb.total_segments";
    TMP_AWS_DYNAMODB_COUNT = "aws.dynamodb.count";
    TMP_AWS_DYNAMODB_SCANNED_COUNT = "aws.dynamodb.scanned_count";
    TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = "aws.dynamodb.attribute_definitions";
    TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = "aws.dynamodb.global_secondary_index_updates";
    TMP_MESSAGING_SYSTEM = "messaging.system";
    TMP_MESSAGING_DESTINATION = "messaging.destination";
    TMP_MESSAGING_DESTINATION_KIND = "messaging.destination_kind";
    TMP_MESSAGING_TEMP_DESTINATION = "messaging.temp_destination";
    TMP_MESSAGING_PROTOCOL = "messaging.protocol";
    TMP_MESSAGING_PROTOCOL_VERSION = "messaging.protocol_version";
    TMP_MESSAGING_URL = "messaging.url";
    TMP_MESSAGING_MESSAGE_ID = "messaging.message_id";
    TMP_MESSAGING_CONVERSATION_ID = "messaging.conversation_id";
    TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = "messaging.message_payload_size_bytes";
    TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = "messaging.message_payload_compressed_size_bytes";
    TMP_MESSAGING_OPERATION = "messaging.operation";
    TMP_MESSAGING_CONSUMER_ID = "messaging.consumer_id";
    TMP_MESSAGING_RABBITMQ_ROUTING_KEY = "messaging.rabbitmq.routing_key";
    TMP_MESSAGING_KAFKA_MESSAGE_KEY = "messaging.kafka.message_key";
    TMP_MESSAGING_KAFKA_CONSUMER_GROUP = "messaging.kafka.consumer_group";
    TMP_MESSAGING_KAFKA_CLIENT_ID = "messaging.kafka.client_id";
    TMP_MESSAGING_KAFKA_PARTITION = "messaging.kafka.partition";
    TMP_MESSAGING_KAFKA_TOMBSTONE = "messaging.kafka.tombstone";
    TMP_RPC_SYSTEM = "rpc.system";
    TMP_RPC_SERVICE = "rpc.service";
    TMP_RPC_METHOD = "rpc.method";
    TMP_RPC_GRPC_STATUS_CODE = "rpc.grpc.status_code";
    TMP_RPC_JSONRPC_VERSION = "rpc.jsonrpc.version";
    TMP_RPC_JSONRPC_REQUEST_ID = "rpc.jsonrpc.request_id";
    TMP_RPC_JSONRPC_ERROR_CODE = "rpc.jsonrpc.error_code";
    TMP_RPC_JSONRPC_ERROR_MESSAGE = "rpc.jsonrpc.error_message";
    TMP_MESSAGE_TYPE = "message.type";
    TMP_MESSAGE_ID = "message.id";
    TMP_MESSAGE_COMPRESSED_SIZE = "message.compressed_size";
    TMP_MESSAGE_UNCOMPRESSED_SIZE = "message.uncompressed_size";
    SEMATTRS_AWS_LAMBDA_INVOKED_ARN = TMP_AWS_LAMBDA_INVOKED_ARN;
    SEMATTRS_DB_SYSTEM = TMP_DB_SYSTEM;
    SEMATTRS_DB_CONNECTION_STRING = TMP_DB_CONNECTION_STRING;
    SEMATTRS_DB_USER = TMP_DB_USER;
    SEMATTRS_DB_JDBC_DRIVER_CLASSNAME = TMP_DB_JDBC_DRIVER_CLASSNAME;
    SEMATTRS_DB_NAME = TMP_DB_NAME;
    SEMATTRS_DB_STATEMENT = TMP_DB_STATEMENT;
    SEMATTRS_DB_OPERATION = TMP_DB_OPERATION;
    SEMATTRS_DB_MSSQL_INSTANCE_NAME = TMP_DB_MSSQL_INSTANCE_NAME;
    SEMATTRS_DB_CASSANDRA_KEYSPACE = TMP_DB_CASSANDRA_KEYSPACE;
    SEMATTRS_DB_CASSANDRA_PAGE_SIZE = TMP_DB_CASSANDRA_PAGE_SIZE;
    SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL = TMP_DB_CASSANDRA_CONSISTENCY_LEVEL;
    SEMATTRS_DB_CASSANDRA_TABLE = TMP_DB_CASSANDRA_TABLE;
    SEMATTRS_DB_CASSANDRA_IDEMPOTENCE = TMP_DB_CASSANDRA_IDEMPOTENCE;
    SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT = TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_ID = TMP_DB_CASSANDRA_COORDINATOR_ID;
    SEMATTRS_DB_CASSANDRA_COORDINATOR_DC = TMP_DB_CASSANDRA_COORDINATOR_DC;
    SEMATTRS_DB_HBASE_NAMESPACE = TMP_DB_HBASE_NAMESPACE;
    SEMATTRS_DB_REDIS_DATABASE_INDEX = TMP_DB_REDIS_DATABASE_INDEX;
    SEMATTRS_DB_MONGODB_COLLECTION = TMP_DB_MONGODB_COLLECTION;
    SEMATTRS_DB_SQL_TABLE = TMP_DB_SQL_TABLE;
    SEMATTRS_EXCEPTION_TYPE = TMP_EXCEPTION_TYPE;
    SEMATTRS_EXCEPTION_MESSAGE = TMP_EXCEPTION_MESSAGE;
    SEMATTRS_EXCEPTION_STACKTRACE = TMP_EXCEPTION_STACKTRACE;
    SEMATTRS_EXCEPTION_ESCAPED = TMP_EXCEPTION_ESCAPED;
    SEMATTRS_FAAS_TRIGGER = TMP_FAAS_TRIGGER;
    SEMATTRS_FAAS_EXECUTION = TMP_FAAS_EXECUTION;
    SEMATTRS_FAAS_DOCUMENT_COLLECTION = TMP_FAAS_DOCUMENT_COLLECTION;
    SEMATTRS_FAAS_DOCUMENT_OPERATION = TMP_FAAS_DOCUMENT_OPERATION;
    SEMATTRS_FAAS_DOCUMENT_TIME = TMP_FAAS_DOCUMENT_TIME;
    SEMATTRS_FAAS_DOCUMENT_NAME = TMP_FAAS_DOCUMENT_NAME;
    SEMATTRS_FAAS_TIME = TMP_FAAS_TIME;
    SEMATTRS_FAAS_CRON = TMP_FAAS_CRON;
    SEMATTRS_FAAS_COLDSTART = TMP_FAAS_COLDSTART;
    SEMATTRS_FAAS_INVOKED_NAME = TMP_FAAS_INVOKED_NAME;
    SEMATTRS_FAAS_INVOKED_PROVIDER = TMP_FAAS_INVOKED_PROVIDER;
    SEMATTRS_FAAS_INVOKED_REGION = TMP_FAAS_INVOKED_REGION;
    SEMATTRS_NET_TRANSPORT = TMP_NET_TRANSPORT;
    SEMATTRS_NET_PEER_IP = TMP_NET_PEER_IP;
    SEMATTRS_NET_PEER_PORT = TMP_NET_PEER_PORT;
    SEMATTRS_NET_PEER_NAME = TMP_NET_PEER_NAME;
    SEMATTRS_NET_HOST_IP = TMP_NET_HOST_IP;
    SEMATTRS_NET_HOST_PORT = TMP_NET_HOST_PORT;
    SEMATTRS_NET_HOST_NAME = TMP_NET_HOST_NAME;
    SEMATTRS_NET_HOST_CONNECTION_TYPE = TMP_NET_HOST_CONNECTION_TYPE;
    SEMATTRS_NET_HOST_CONNECTION_SUBTYPE = TMP_NET_HOST_CONNECTION_SUBTYPE;
    SEMATTRS_NET_HOST_CARRIER_NAME = TMP_NET_HOST_CARRIER_NAME;
    SEMATTRS_NET_HOST_CARRIER_MCC = TMP_NET_HOST_CARRIER_MCC;
    SEMATTRS_NET_HOST_CARRIER_MNC = TMP_NET_HOST_CARRIER_MNC;
    SEMATTRS_NET_HOST_CARRIER_ICC = TMP_NET_HOST_CARRIER_ICC;
    SEMATTRS_PEER_SERVICE = TMP_PEER_SERVICE;
    SEMATTRS_ENDUSER_ID = TMP_ENDUSER_ID;
    SEMATTRS_ENDUSER_ROLE = TMP_ENDUSER_ROLE;
    SEMATTRS_ENDUSER_SCOPE = TMP_ENDUSER_SCOPE;
    SEMATTRS_THREAD_ID = TMP_THREAD_ID;
    SEMATTRS_THREAD_NAME = TMP_THREAD_NAME;
    SEMATTRS_CODE_FUNCTION = TMP_CODE_FUNCTION;
    SEMATTRS_CODE_NAMESPACE = TMP_CODE_NAMESPACE;
    SEMATTRS_CODE_FILEPATH = TMP_CODE_FILEPATH;
    SEMATTRS_CODE_LINENO = TMP_CODE_LINENO;
    SEMATTRS_HTTP_METHOD = TMP_HTTP_METHOD;
    SEMATTRS_HTTP_URL = TMP_HTTP_URL;
    SEMATTRS_HTTP_TARGET = TMP_HTTP_TARGET;
    SEMATTRS_HTTP_HOST = TMP_HTTP_HOST;
    SEMATTRS_HTTP_SCHEME = TMP_HTTP_SCHEME;
    SEMATTRS_HTTP_STATUS_CODE = TMP_HTTP_STATUS_CODE;
    SEMATTRS_HTTP_FLAVOR = TMP_HTTP_FLAVOR;
    SEMATTRS_HTTP_USER_AGENT = TMP_HTTP_USER_AGENT;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH = TMP_HTTP_REQUEST_CONTENT_LENGTH;
    SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH = TMP_HTTP_RESPONSE_CONTENT_LENGTH;
    SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED = TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED;
    SEMATTRS_HTTP_SERVER_NAME = TMP_HTTP_SERVER_NAME;
    SEMATTRS_HTTP_ROUTE = TMP_HTTP_ROUTE;
    SEMATTRS_HTTP_CLIENT_IP = TMP_HTTP_CLIENT_IP;
    SEMATTRS_AWS_DYNAMODB_TABLE_NAMES = TMP_AWS_DYNAMODB_TABLE_NAMES;
    SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY = TMP_AWS_DYNAMODB_CONSUMED_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS = TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY = TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY;
    SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ = TMP_AWS_DYNAMODB_CONSISTENT_READ;
    SEMATTRS_AWS_DYNAMODB_PROJECTION = TMP_AWS_DYNAMODB_PROJECTION;
    SEMATTRS_AWS_DYNAMODB_LIMIT = TMP_AWS_DYNAMODB_LIMIT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET = TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET;
    SEMATTRS_AWS_DYNAMODB_INDEX_NAME = TMP_AWS_DYNAMODB_INDEX_NAME;
    SEMATTRS_AWS_DYNAMODB_SELECT = TMP_AWS_DYNAMODB_SELECT;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES = TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES;
    SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE = TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE;
    SEMATTRS_AWS_DYNAMODB_TABLE_COUNT = TMP_AWS_DYNAMODB_TABLE_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD = TMP_AWS_DYNAMODB_SCAN_FORWARD;
    SEMATTRS_AWS_DYNAMODB_SEGMENT = TMP_AWS_DYNAMODB_SEGMENT;
    SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS = TMP_AWS_DYNAMODB_TOTAL_SEGMENTS;
    SEMATTRS_AWS_DYNAMODB_COUNT = TMP_AWS_DYNAMODB_COUNT;
    SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT = TMP_AWS_DYNAMODB_SCANNED_COUNT;
    SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS = TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS;
    SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES = TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES;
    SEMATTRS_MESSAGING_SYSTEM = TMP_MESSAGING_SYSTEM;
    SEMATTRS_MESSAGING_DESTINATION = TMP_MESSAGING_DESTINATION;
    SEMATTRS_MESSAGING_DESTINATION_KIND = TMP_MESSAGING_DESTINATION_KIND;
    SEMATTRS_MESSAGING_TEMP_DESTINATION = TMP_MESSAGING_TEMP_DESTINATION;
    SEMATTRS_MESSAGING_PROTOCOL = TMP_MESSAGING_PROTOCOL;
    SEMATTRS_MESSAGING_PROTOCOL_VERSION = TMP_MESSAGING_PROTOCOL_VERSION;
    SEMATTRS_MESSAGING_URL = TMP_MESSAGING_URL;
    SEMATTRS_MESSAGING_MESSAGE_ID = TMP_MESSAGING_MESSAGE_ID;
    SEMATTRS_MESSAGING_CONVERSATION_ID = TMP_MESSAGING_CONVERSATION_ID;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES;
    SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES = TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES;
    SEMATTRS_MESSAGING_OPERATION = TMP_MESSAGING_OPERATION;
    SEMATTRS_MESSAGING_CONSUMER_ID = TMP_MESSAGING_CONSUMER_ID;
    SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY = TMP_MESSAGING_RABBITMQ_ROUTING_KEY;
    SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY = TMP_MESSAGING_KAFKA_MESSAGE_KEY;
    SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP = TMP_MESSAGING_KAFKA_CONSUMER_GROUP;
    SEMATTRS_MESSAGING_KAFKA_CLIENT_ID = TMP_MESSAGING_KAFKA_CLIENT_ID;
    SEMATTRS_MESSAGING_KAFKA_PARTITION = TMP_MESSAGING_KAFKA_PARTITION;
    SEMATTRS_MESSAGING_KAFKA_TOMBSTONE = TMP_MESSAGING_KAFKA_TOMBSTONE;
    SEMATTRS_RPC_SYSTEM = TMP_RPC_SYSTEM;
    SEMATTRS_RPC_SERVICE = TMP_RPC_SERVICE;
    SEMATTRS_RPC_METHOD = TMP_RPC_METHOD;
    SEMATTRS_RPC_GRPC_STATUS_CODE = TMP_RPC_GRPC_STATUS_CODE;
    SEMATTRS_RPC_JSONRPC_VERSION = TMP_RPC_JSONRPC_VERSION;
    SEMATTRS_RPC_JSONRPC_REQUEST_ID = TMP_RPC_JSONRPC_REQUEST_ID;
    SEMATTRS_RPC_JSONRPC_ERROR_CODE = TMP_RPC_JSONRPC_ERROR_CODE;
    SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE = TMP_RPC_JSONRPC_ERROR_MESSAGE;
    SEMATTRS_MESSAGE_TYPE = TMP_MESSAGE_TYPE;
    SEMATTRS_MESSAGE_ID = TMP_MESSAGE_ID;
    SEMATTRS_MESSAGE_COMPRESSED_SIZE = TMP_MESSAGE_COMPRESSED_SIZE;
    SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE = TMP_MESSAGE_UNCOMPRESSED_SIZE;
    SemanticAttributes = /* @__PURE__ */ createConstMap([
      TMP_AWS_LAMBDA_INVOKED_ARN,
      TMP_DB_SYSTEM,
      TMP_DB_CONNECTION_STRING,
      TMP_DB_USER,
      TMP_DB_JDBC_DRIVER_CLASSNAME,
      TMP_DB_NAME,
      TMP_DB_STATEMENT,
      TMP_DB_OPERATION,
      TMP_DB_MSSQL_INSTANCE_NAME,
      TMP_DB_CASSANDRA_KEYSPACE,
      TMP_DB_CASSANDRA_PAGE_SIZE,
      TMP_DB_CASSANDRA_CONSISTENCY_LEVEL,
      TMP_DB_CASSANDRA_TABLE,
      TMP_DB_CASSANDRA_IDEMPOTENCE,
      TMP_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
      TMP_DB_CASSANDRA_COORDINATOR_ID,
      TMP_DB_CASSANDRA_COORDINATOR_DC,
      TMP_DB_HBASE_NAMESPACE,
      TMP_DB_REDIS_DATABASE_INDEX,
      TMP_DB_MONGODB_COLLECTION,
      TMP_DB_SQL_TABLE,
      TMP_EXCEPTION_TYPE,
      TMP_EXCEPTION_MESSAGE,
      TMP_EXCEPTION_STACKTRACE,
      TMP_EXCEPTION_ESCAPED,
      TMP_FAAS_TRIGGER,
      TMP_FAAS_EXECUTION,
      TMP_FAAS_DOCUMENT_COLLECTION,
      TMP_FAAS_DOCUMENT_OPERATION,
      TMP_FAAS_DOCUMENT_TIME,
      TMP_FAAS_DOCUMENT_NAME,
      TMP_FAAS_TIME,
      TMP_FAAS_CRON,
      TMP_FAAS_COLDSTART,
      TMP_FAAS_INVOKED_NAME,
      TMP_FAAS_INVOKED_PROVIDER,
      TMP_FAAS_INVOKED_REGION,
      TMP_NET_TRANSPORT,
      TMP_NET_PEER_IP,
      TMP_NET_PEER_PORT,
      TMP_NET_PEER_NAME,
      TMP_NET_HOST_IP,
      TMP_NET_HOST_PORT,
      TMP_NET_HOST_NAME,
      TMP_NET_HOST_CONNECTION_TYPE,
      TMP_NET_HOST_CONNECTION_SUBTYPE,
      TMP_NET_HOST_CARRIER_NAME,
      TMP_NET_HOST_CARRIER_MCC,
      TMP_NET_HOST_CARRIER_MNC,
      TMP_NET_HOST_CARRIER_ICC,
      TMP_PEER_SERVICE,
      TMP_ENDUSER_ID,
      TMP_ENDUSER_ROLE,
      TMP_ENDUSER_SCOPE,
      TMP_THREAD_ID,
      TMP_THREAD_NAME,
      TMP_CODE_FUNCTION,
      TMP_CODE_NAMESPACE,
      TMP_CODE_FILEPATH,
      TMP_CODE_LINENO,
      TMP_HTTP_METHOD,
      TMP_HTTP_URL,
      TMP_HTTP_TARGET,
      TMP_HTTP_HOST,
      TMP_HTTP_SCHEME,
      TMP_HTTP_STATUS_CODE,
      TMP_HTTP_FLAVOR,
      TMP_HTTP_USER_AGENT,
      TMP_HTTP_REQUEST_CONTENT_LENGTH,
      TMP_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH,
      TMP_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
      TMP_HTTP_SERVER_NAME,
      TMP_HTTP_ROUTE,
      TMP_HTTP_CLIENT_IP,
      TMP_AWS_DYNAMODB_TABLE_NAMES,
      TMP_AWS_DYNAMODB_CONSUMED_CAPACITY,
      TMP_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
      TMP_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
      TMP_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
      TMP_AWS_DYNAMODB_CONSISTENT_READ,
      TMP_AWS_DYNAMODB_PROJECTION,
      TMP_AWS_DYNAMODB_LIMIT,
      TMP_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
      TMP_AWS_DYNAMODB_INDEX_NAME,
      TMP_AWS_DYNAMODB_SELECT,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
      TMP_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
      TMP_AWS_DYNAMODB_TABLE_COUNT,
      TMP_AWS_DYNAMODB_SCAN_FORWARD,
      TMP_AWS_DYNAMODB_SEGMENT,
      TMP_AWS_DYNAMODB_TOTAL_SEGMENTS,
      TMP_AWS_DYNAMODB_COUNT,
      TMP_AWS_DYNAMODB_SCANNED_COUNT,
      TMP_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
      TMP_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
      TMP_MESSAGING_SYSTEM,
      TMP_MESSAGING_DESTINATION,
      TMP_MESSAGING_DESTINATION_KIND,
      TMP_MESSAGING_TEMP_DESTINATION,
      TMP_MESSAGING_PROTOCOL,
      TMP_MESSAGING_PROTOCOL_VERSION,
      TMP_MESSAGING_URL,
      TMP_MESSAGING_MESSAGE_ID,
      TMP_MESSAGING_CONVERSATION_ID,
      TMP_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
      TMP_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
      TMP_MESSAGING_OPERATION,
      TMP_MESSAGING_CONSUMER_ID,
      TMP_MESSAGING_RABBITMQ_ROUTING_KEY,
      TMP_MESSAGING_KAFKA_MESSAGE_KEY,
      TMP_MESSAGING_KAFKA_CONSUMER_GROUP,
      TMP_MESSAGING_KAFKA_CLIENT_ID,
      TMP_MESSAGING_KAFKA_PARTITION,
      TMP_MESSAGING_KAFKA_TOMBSTONE,
      TMP_RPC_SYSTEM,
      TMP_RPC_SERVICE,
      TMP_RPC_METHOD,
      TMP_RPC_GRPC_STATUS_CODE,
      TMP_RPC_JSONRPC_VERSION,
      TMP_RPC_JSONRPC_REQUEST_ID,
      TMP_RPC_JSONRPC_ERROR_CODE,
      TMP_RPC_JSONRPC_ERROR_MESSAGE,
      TMP_MESSAGE_TYPE,
      TMP_MESSAGE_ID,
      TMP_MESSAGE_COMPRESSED_SIZE,
      TMP_MESSAGE_UNCOMPRESSED_SIZE
    ]);
    TMP_DBSYSTEMVALUES_OTHER_SQL = "other_sql";
    TMP_DBSYSTEMVALUES_MSSQL = "mssql";
    TMP_DBSYSTEMVALUES_MYSQL = "mysql";
    TMP_DBSYSTEMVALUES_ORACLE = "oracle";
    TMP_DBSYSTEMVALUES_DB2 = "db2";
    TMP_DBSYSTEMVALUES_POSTGRESQL = "postgresql";
    TMP_DBSYSTEMVALUES_REDSHIFT = "redshift";
    TMP_DBSYSTEMVALUES_HIVE = "hive";
    TMP_DBSYSTEMVALUES_CLOUDSCAPE = "cloudscape";
    TMP_DBSYSTEMVALUES_HSQLDB = "hsqldb";
    TMP_DBSYSTEMVALUES_PROGRESS = "progress";
    TMP_DBSYSTEMVALUES_MAXDB = "maxdb";
    TMP_DBSYSTEMVALUES_HANADB = "hanadb";
    TMP_DBSYSTEMVALUES_INGRES = "ingres";
    TMP_DBSYSTEMVALUES_FIRSTSQL = "firstsql";
    TMP_DBSYSTEMVALUES_EDB = "edb";
    TMP_DBSYSTEMVALUES_CACHE = "cache";
    TMP_DBSYSTEMVALUES_ADABAS = "adabas";
    TMP_DBSYSTEMVALUES_FIREBIRD = "firebird";
    TMP_DBSYSTEMVALUES_DERBY = "derby";
    TMP_DBSYSTEMVALUES_FILEMAKER = "filemaker";
    TMP_DBSYSTEMVALUES_INFORMIX = "informix";
    TMP_DBSYSTEMVALUES_INSTANTDB = "instantdb";
    TMP_DBSYSTEMVALUES_INTERBASE = "interbase";
    TMP_DBSYSTEMVALUES_MARIADB = "mariadb";
    TMP_DBSYSTEMVALUES_NETEZZA = "netezza";
    TMP_DBSYSTEMVALUES_PERVASIVE = "pervasive";
    TMP_DBSYSTEMVALUES_POINTBASE = "pointbase";
    TMP_DBSYSTEMVALUES_SQLITE = "sqlite";
    TMP_DBSYSTEMVALUES_SYBASE = "sybase";
    TMP_DBSYSTEMVALUES_TERADATA = "teradata";
    TMP_DBSYSTEMVALUES_VERTICA = "vertica";
    TMP_DBSYSTEMVALUES_H2 = "h2";
    TMP_DBSYSTEMVALUES_COLDFUSION = "coldfusion";
    TMP_DBSYSTEMVALUES_CASSANDRA = "cassandra";
    TMP_DBSYSTEMVALUES_HBASE = "hbase";
    TMP_DBSYSTEMVALUES_MONGODB = "mongodb";
    TMP_DBSYSTEMVALUES_REDIS = "redis";
    TMP_DBSYSTEMVALUES_COUCHBASE = "couchbase";
    TMP_DBSYSTEMVALUES_COUCHDB = "couchdb";
    TMP_DBSYSTEMVALUES_COSMOSDB = "cosmosdb";
    TMP_DBSYSTEMVALUES_DYNAMODB = "dynamodb";
    TMP_DBSYSTEMVALUES_NEO4J = "neo4j";
    TMP_DBSYSTEMVALUES_GEODE = "geode";
    TMP_DBSYSTEMVALUES_ELASTICSEARCH = "elasticsearch";
    TMP_DBSYSTEMVALUES_MEMCACHED = "memcached";
    TMP_DBSYSTEMVALUES_COCKROACHDB = "cockroachdb";
    DBSYSTEMVALUES_OTHER_SQL = TMP_DBSYSTEMVALUES_OTHER_SQL;
    DBSYSTEMVALUES_MSSQL = TMP_DBSYSTEMVALUES_MSSQL;
    DBSYSTEMVALUES_MYSQL = TMP_DBSYSTEMVALUES_MYSQL;
    DBSYSTEMVALUES_ORACLE = TMP_DBSYSTEMVALUES_ORACLE;
    DBSYSTEMVALUES_DB2 = TMP_DBSYSTEMVALUES_DB2;
    DBSYSTEMVALUES_POSTGRESQL = TMP_DBSYSTEMVALUES_POSTGRESQL;
    DBSYSTEMVALUES_REDSHIFT = TMP_DBSYSTEMVALUES_REDSHIFT;
    DBSYSTEMVALUES_HIVE = TMP_DBSYSTEMVALUES_HIVE;
    DBSYSTEMVALUES_CLOUDSCAPE = TMP_DBSYSTEMVALUES_CLOUDSCAPE;
    DBSYSTEMVALUES_HSQLDB = TMP_DBSYSTEMVALUES_HSQLDB;
    DBSYSTEMVALUES_PROGRESS = TMP_DBSYSTEMVALUES_PROGRESS;
    DBSYSTEMVALUES_MAXDB = TMP_DBSYSTEMVALUES_MAXDB;
    DBSYSTEMVALUES_HANADB = TMP_DBSYSTEMVALUES_HANADB;
    DBSYSTEMVALUES_INGRES = TMP_DBSYSTEMVALUES_INGRES;
    DBSYSTEMVALUES_FIRSTSQL = TMP_DBSYSTEMVALUES_FIRSTSQL;
    DBSYSTEMVALUES_EDB = TMP_DBSYSTEMVALUES_EDB;
    DBSYSTEMVALUES_CACHE = TMP_DBSYSTEMVALUES_CACHE;
    DBSYSTEMVALUES_ADABAS = TMP_DBSYSTEMVALUES_ADABAS;
    DBSYSTEMVALUES_FIREBIRD = TMP_DBSYSTEMVALUES_FIREBIRD;
    DBSYSTEMVALUES_DERBY = TMP_DBSYSTEMVALUES_DERBY;
    DBSYSTEMVALUES_FILEMAKER = TMP_DBSYSTEMVALUES_FILEMAKER;
    DBSYSTEMVALUES_INFORMIX = TMP_DBSYSTEMVALUES_INFORMIX;
    DBSYSTEMVALUES_INSTANTDB = TMP_DBSYSTEMVALUES_INSTANTDB;
    DBSYSTEMVALUES_INTERBASE = TMP_DBSYSTEMVALUES_INTERBASE;
    DBSYSTEMVALUES_MARIADB = TMP_DBSYSTEMVALUES_MARIADB;
    DBSYSTEMVALUES_NETEZZA = TMP_DBSYSTEMVALUES_NETEZZA;
    DBSYSTEMVALUES_PERVASIVE = TMP_DBSYSTEMVALUES_PERVASIVE;
    DBSYSTEMVALUES_POINTBASE = TMP_DBSYSTEMVALUES_POINTBASE;
    DBSYSTEMVALUES_SQLITE = TMP_DBSYSTEMVALUES_SQLITE;
    DBSYSTEMVALUES_SYBASE = TMP_DBSYSTEMVALUES_SYBASE;
    DBSYSTEMVALUES_TERADATA = TMP_DBSYSTEMVALUES_TERADATA;
    DBSYSTEMVALUES_VERTICA = TMP_DBSYSTEMVALUES_VERTICA;
    DBSYSTEMVALUES_H2 = TMP_DBSYSTEMVALUES_H2;
    DBSYSTEMVALUES_COLDFUSION = TMP_DBSYSTEMVALUES_COLDFUSION;
    DBSYSTEMVALUES_CASSANDRA = TMP_DBSYSTEMVALUES_CASSANDRA;
    DBSYSTEMVALUES_HBASE = TMP_DBSYSTEMVALUES_HBASE;
    DBSYSTEMVALUES_MONGODB = TMP_DBSYSTEMVALUES_MONGODB;
    DBSYSTEMVALUES_REDIS = TMP_DBSYSTEMVALUES_REDIS;
    DBSYSTEMVALUES_COUCHBASE = TMP_DBSYSTEMVALUES_COUCHBASE;
    DBSYSTEMVALUES_COUCHDB = TMP_DBSYSTEMVALUES_COUCHDB;
    DBSYSTEMVALUES_COSMOSDB = TMP_DBSYSTEMVALUES_COSMOSDB;
    DBSYSTEMVALUES_DYNAMODB = TMP_DBSYSTEMVALUES_DYNAMODB;
    DBSYSTEMVALUES_NEO4J = TMP_DBSYSTEMVALUES_NEO4J;
    DBSYSTEMVALUES_GEODE = TMP_DBSYSTEMVALUES_GEODE;
    DBSYSTEMVALUES_ELASTICSEARCH = TMP_DBSYSTEMVALUES_ELASTICSEARCH;
    DBSYSTEMVALUES_MEMCACHED = TMP_DBSYSTEMVALUES_MEMCACHED;
    DBSYSTEMVALUES_COCKROACHDB = TMP_DBSYSTEMVALUES_COCKROACHDB;
    DbSystemValues = /* @__PURE__ */ createConstMap([
      TMP_DBSYSTEMVALUES_OTHER_SQL,
      TMP_DBSYSTEMVALUES_MSSQL,
      TMP_DBSYSTEMVALUES_MYSQL,
      TMP_DBSYSTEMVALUES_ORACLE,
      TMP_DBSYSTEMVALUES_DB2,
      TMP_DBSYSTEMVALUES_POSTGRESQL,
      TMP_DBSYSTEMVALUES_REDSHIFT,
      TMP_DBSYSTEMVALUES_HIVE,
      TMP_DBSYSTEMVALUES_CLOUDSCAPE,
      TMP_DBSYSTEMVALUES_HSQLDB,
      TMP_DBSYSTEMVALUES_PROGRESS,
      TMP_DBSYSTEMVALUES_MAXDB,
      TMP_DBSYSTEMVALUES_HANADB,
      TMP_DBSYSTEMVALUES_INGRES,
      TMP_DBSYSTEMVALUES_FIRSTSQL,
      TMP_DBSYSTEMVALUES_EDB,
      TMP_DBSYSTEMVALUES_CACHE,
      TMP_DBSYSTEMVALUES_ADABAS,
      TMP_DBSYSTEMVALUES_FIREBIRD,
      TMP_DBSYSTEMVALUES_DERBY,
      TMP_DBSYSTEMVALUES_FILEMAKER,
      TMP_DBSYSTEMVALUES_INFORMIX,
      TMP_DBSYSTEMVALUES_INSTANTDB,
      TMP_DBSYSTEMVALUES_INTERBASE,
      TMP_DBSYSTEMVALUES_MARIADB,
      TMP_DBSYSTEMVALUES_NETEZZA,
      TMP_DBSYSTEMVALUES_PERVASIVE,
      TMP_DBSYSTEMVALUES_POINTBASE,
      TMP_DBSYSTEMVALUES_SQLITE,
      TMP_DBSYSTEMVALUES_SYBASE,
      TMP_DBSYSTEMVALUES_TERADATA,
      TMP_DBSYSTEMVALUES_VERTICA,
      TMP_DBSYSTEMVALUES_H2,
      TMP_DBSYSTEMVALUES_COLDFUSION,
      TMP_DBSYSTEMVALUES_CASSANDRA,
      TMP_DBSYSTEMVALUES_HBASE,
      TMP_DBSYSTEMVALUES_MONGODB,
      TMP_DBSYSTEMVALUES_REDIS,
      TMP_DBSYSTEMVALUES_COUCHBASE,
      TMP_DBSYSTEMVALUES_COUCHDB,
      TMP_DBSYSTEMVALUES_COSMOSDB,
      TMP_DBSYSTEMVALUES_DYNAMODB,
      TMP_DBSYSTEMVALUES_NEO4J,
      TMP_DBSYSTEMVALUES_GEODE,
      TMP_DBSYSTEMVALUES_ELASTICSEARCH,
      TMP_DBSYSTEMVALUES_MEMCACHED,
      TMP_DBSYSTEMVALUES_COCKROACHDB
    ]);
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL = "all";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = "each_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = "quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = "local_quorum";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE = "one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO = "two";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE = "three";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = "local_one";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY = "any";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = "serial";
    TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = "local_serial";
    DBCASSANDRACONSISTENCYLEVELVALUES_ALL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL;
    DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM;
    DBCASSANDRACONSISTENCYLEVELVALUES_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_TWO = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO;
    DBCASSANDRACONSISTENCYLEVELVALUES_THREE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE;
    DBCASSANDRACONSISTENCYLEVELVALUES_ANY = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY;
    DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL;
    DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL = TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL;
    DbCassandraConsistencyLevelValues = /* @__PURE__ */ createConstMap([
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
      TMP_DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL
    ]);
    TMP_FAASTRIGGERVALUES_DATASOURCE = "datasource";
    TMP_FAASTRIGGERVALUES_HTTP = "http";
    TMP_FAASTRIGGERVALUES_PUBSUB = "pubsub";
    TMP_FAASTRIGGERVALUES_TIMER = "timer";
    TMP_FAASTRIGGERVALUES_OTHER = "other";
    FAASTRIGGERVALUES_DATASOURCE = TMP_FAASTRIGGERVALUES_DATASOURCE;
    FAASTRIGGERVALUES_HTTP = TMP_FAASTRIGGERVALUES_HTTP;
    FAASTRIGGERVALUES_PUBSUB = TMP_FAASTRIGGERVALUES_PUBSUB;
    FAASTRIGGERVALUES_TIMER = TMP_FAASTRIGGERVALUES_TIMER;
    FAASTRIGGERVALUES_OTHER = TMP_FAASTRIGGERVALUES_OTHER;
    FaasTriggerValues = /* @__PURE__ */ createConstMap([
      TMP_FAASTRIGGERVALUES_DATASOURCE,
      TMP_FAASTRIGGERVALUES_HTTP,
      TMP_FAASTRIGGERVALUES_PUBSUB,
      TMP_FAASTRIGGERVALUES_TIMER,
      TMP_FAASTRIGGERVALUES_OTHER
    ]);
    TMP_FAASDOCUMENTOPERATIONVALUES_INSERT = "insert";
    TMP_FAASDOCUMENTOPERATIONVALUES_EDIT = "edit";
    TMP_FAASDOCUMENTOPERATIONVALUES_DELETE = "delete";
    FAASDOCUMENTOPERATIONVALUES_INSERT = TMP_FAASDOCUMENTOPERATIONVALUES_INSERT;
    FAASDOCUMENTOPERATIONVALUES_EDIT = TMP_FAASDOCUMENTOPERATIONVALUES_EDIT;
    FAASDOCUMENTOPERATIONVALUES_DELETE = TMP_FAASDOCUMENTOPERATIONVALUES_DELETE;
    FaasDocumentOperationValues = /* @__PURE__ */ createConstMap([
      TMP_FAASDOCUMENTOPERATIONVALUES_INSERT,
      TMP_FAASDOCUMENTOPERATIONVALUES_EDIT,
      TMP_FAASDOCUMENTOPERATIONVALUES_DELETE
    ]);
    TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_FAASINVOKEDPROVIDERVALUES_AWS = "aws";
    TMP_FAASINVOKEDPROVIDERVALUES_AZURE = "azure";
    TMP_FAASINVOKEDPROVIDERVALUES_GCP = "gcp";
    FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD = TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD;
    FAASINVOKEDPROVIDERVALUES_AWS = TMP_FAASINVOKEDPROVIDERVALUES_AWS;
    FAASINVOKEDPROVIDERVALUES_AZURE = TMP_FAASINVOKEDPROVIDERVALUES_AZURE;
    FAASINVOKEDPROVIDERVALUES_GCP = TMP_FAASINVOKEDPROVIDERVALUES_GCP;
    FaasInvokedProviderValues = /* @__PURE__ */ createConstMap([
      TMP_FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_FAASINVOKEDPROVIDERVALUES_AWS,
      TMP_FAASINVOKEDPROVIDERVALUES_AZURE,
      TMP_FAASINVOKEDPROVIDERVALUES_GCP
    ]);
    TMP_NETTRANSPORTVALUES_IP_TCP = "ip_tcp";
    TMP_NETTRANSPORTVALUES_IP_UDP = "ip_udp";
    TMP_NETTRANSPORTVALUES_IP = "ip";
    TMP_NETTRANSPORTVALUES_UNIX = "unix";
    TMP_NETTRANSPORTVALUES_PIPE = "pipe";
    TMP_NETTRANSPORTVALUES_INPROC = "inproc";
    TMP_NETTRANSPORTVALUES_OTHER = "other";
    NETTRANSPORTVALUES_IP_TCP = TMP_NETTRANSPORTVALUES_IP_TCP;
    NETTRANSPORTVALUES_IP_UDP = TMP_NETTRANSPORTVALUES_IP_UDP;
    NETTRANSPORTVALUES_IP = TMP_NETTRANSPORTVALUES_IP;
    NETTRANSPORTVALUES_UNIX = TMP_NETTRANSPORTVALUES_UNIX;
    NETTRANSPORTVALUES_PIPE = TMP_NETTRANSPORTVALUES_PIPE;
    NETTRANSPORTVALUES_INPROC = TMP_NETTRANSPORTVALUES_INPROC;
    NETTRANSPORTVALUES_OTHER = TMP_NETTRANSPORTVALUES_OTHER;
    NetTransportValues = /* @__PURE__ */ createConstMap([
      TMP_NETTRANSPORTVALUES_IP_TCP,
      TMP_NETTRANSPORTVALUES_IP_UDP,
      TMP_NETTRANSPORTVALUES_IP,
      TMP_NETTRANSPORTVALUES_UNIX,
      TMP_NETTRANSPORTVALUES_PIPE,
      TMP_NETTRANSPORTVALUES_INPROC,
      TMP_NETTRANSPORTVALUES_OTHER
    ]);
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI = "wifi";
    TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED = "wired";
    TMP_NETHOSTCONNECTIONTYPEVALUES_CELL = "cell";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = "unavailable";
    TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = "unknown";
    NETHOSTCONNECTIONTYPEVALUES_WIFI = TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI;
    NETHOSTCONNECTIONTYPEVALUES_WIRED = TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED;
    NETHOSTCONNECTIONTYPEVALUES_CELL = TMP_NETHOSTCONNECTIONTYPEVALUES_CELL;
    NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE = TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE;
    NETHOSTCONNECTIONTYPEVALUES_UNKNOWN = TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN;
    NetHostConnectionTypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIFI,
      TMP_NETHOSTCONNECTIONTYPEVALUES_WIRED,
      TMP_NETHOSTCONNECTIONTYPEVALUES_CELL,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
      TMP_NETHOSTCONNECTIONTYPEVALUES_UNKNOWN
    ]);
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = "gprs";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = "edge";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = "umts";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = "cdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = "evdo_0";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = "evdo_a";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = "cdma2000_1xrtt";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = "hsdpa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = "hsupa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = "hspa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = "iden";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = "evdo_b";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE = "lte";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = "ehrpd";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = "hspap";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM = "gsm";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = "td_scdma";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = "iwlan";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR = "nr";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = "nrnsa";
    TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = "lte_ca";
    NETHOSTCONNECTIONSUBTYPEVALUES_GPRS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS;
    NETHOSTCONNECTIONSUBTYPEVALUES_EDGE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE;
    NETHOSTCONNECTIONSUBTYPEVALUES_UMTS = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0 = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A;
    NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IDEN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN;
    NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE;
    NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD;
    NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP;
    NETHOSTCONNECTIONSUBTYPEVALUES_GSM = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM;
    NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA;
    NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN;
    NETHOSTCONNECTIONSUBTYPEVALUES_NR = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR;
    NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA;
    NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA = TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA;
    NetHostConnectionSubtypeValues = /* @__PURE__ */ createConstMap([
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NR,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
      TMP_NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA
    ]);
    TMP_HTTPFLAVORVALUES_HTTP_1_0 = "1.0";
    TMP_HTTPFLAVORVALUES_HTTP_1_1 = "1.1";
    TMP_HTTPFLAVORVALUES_HTTP_2_0 = "2.0";
    TMP_HTTPFLAVORVALUES_SPDY = "SPDY";
    TMP_HTTPFLAVORVALUES_QUIC = "QUIC";
    HTTPFLAVORVALUES_HTTP_1_0 = TMP_HTTPFLAVORVALUES_HTTP_1_0;
    HTTPFLAVORVALUES_HTTP_1_1 = TMP_HTTPFLAVORVALUES_HTTP_1_1;
    HTTPFLAVORVALUES_HTTP_2_0 = TMP_HTTPFLAVORVALUES_HTTP_2_0;
    HTTPFLAVORVALUES_SPDY = TMP_HTTPFLAVORVALUES_SPDY;
    HTTPFLAVORVALUES_QUIC = TMP_HTTPFLAVORVALUES_QUIC;
    HttpFlavorValues = {
      HTTP_1_0: TMP_HTTPFLAVORVALUES_HTTP_1_0,
      HTTP_1_1: TMP_HTTPFLAVORVALUES_HTTP_1_1,
      HTTP_2_0: TMP_HTTPFLAVORVALUES_HTTP_2_0,
      SPDY: TMP_HTTPFLAVORVALUES_SPDY,
      QUIC: TMP_HTTPFLAVORVALUES_QUIC
    };
    TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE = "queue";
    TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC = "topic";
    MESSAGINGDESTINATIONKINDVALUES_QUEUE = TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE;
    MESSAGINGDESTINATIONKINDVALUES_TOPIC = TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC;
    MessagingDestinationKindValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGDESTINATIONKINDVALUES_QUEUE,
      TMP_MESSAGINGDESTINATIONKINDVALUES_TOPIC
    ]);
    TMP_MESSAGINGOPERATIONVALUES_RECEIVE = "receive";
    TMP_MESSAGINGOPERATIONVALUES_PROCESS = "process";
    MESSAGINGOPERATIONVALUES_RECEIVE = TMP_MESSAGINGOPERATIONVALUES_RECEIVE;
    MESSAGINGOPERATIONVALUES_PROCESS = TMP_MESSAGINGOPERATIONVALUES_PROCESS;
    MessagingOperationValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGINGOPERATIONVALUES_RECEIVE,
      TMP_MESSAGINGOPERATIONVALUES_PROCESS
    ]);
    TMP_RPCGRPCSTATUSCODEVALUES_OK = 0;
    TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED = 1;
    TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN = 2;
    TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = 3;
    TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = 4;
    TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND = 5;
    TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = 6;
    TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = 7;
    TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = 8;
    TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = 9;
    TMP_RPCGRPCSTATUSCODEVALUES_ABORTED = 10;
    TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = 11;
    TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = 12;
    TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL = 13;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = 14;
    TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS = 15;
    TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = 16;
    RPCGRPCSTATUSCODEVALUES_OK = TMP_RPCGRPCSTATUSCODEVALUES_OK;
    RPCGRPCSTATUSCODEVALUES_CANCELLED = TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED;
    RPCGRPCSTATUSCODEVALUES_UNKNOWN = TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN;
    RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT = TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT;
    RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED = TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED;
    RPCGRPCSTATUSCODEVALUES_NOT_FOUND = TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND;
    RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS = TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS;
    RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED = TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED;
    RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED = TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED;
    RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION = TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION;
    RPCGRPCSTATUSCODEVALUES_ABORTED = TMP_RPCGRPCSTATUSCODEVALUES_ABORTED;
    RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE = TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE;
    RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED = TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED;
    RPCGRPCSTATUSCODEVALUES_INTERNAL = TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL;
    RPCGRPCSTATUSCODEVALUES_UNAVAILABLE = TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE;
    RPCGRPCSTATUSCODEVALUES_DATA_LOSS = TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS;
    RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED = TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED;
    RpcGrpcStatusCodeValues = {
      OK: TMP_RPCGRPCSTATUSCODEVALUES_OK,
      CANCELLED: TMP_RPCGRPCSTATUSCODEVALUES_CANCELLED,
      UNKNOWN: TMP_RPCGRPCSTATUSCODEVALUES_UNKNOWN,
      INVALID_ARGUMENT: TMP_RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
      DEADLINE_EXCEEDED: TMP_RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
      NOT_FOUND: TMP_RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
      ALREADY_EXISTS: TMP_RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
      PERMISSION_DENIED: TMP_RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
      RESOURCE_EXHAUSTED: TMP_RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
      FAILED_PRECONDITION: TMP_RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
      ABORTED: TMP_RPCGRPCSTATUSCODEVALUES_ABORTED,
      OUT_OF_RANGE: TMP_RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
      UNIMPLEMENTED: TMP_RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
      INTERNAL: TMP_RPCGRPCSTATUSCODEVALUES_INTERNAL,
      UNAVAILABLE: TMP_RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
      DATA_LOSS: TMP_RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
      UNAUTHENTICATED: TMP_RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED
    };
    TMP_MESSAGETYPEVALUES_SENT = "SENT";
    TMP_MESSAGETYPEVALUES_RECEIVED = "RECEIVED";
    MESSAGETYPEVALUES_SENT = TMP_MESSAGETYPEVALUES_SENT;
    MESSAGETYPEVALUES_RECEIVED = TMP_MESSAGETYPEVALUES_RECEIVED;
    MessageTypeValues = /* @__PURE__ */ createConstMap([
      TMP_MESSAGETYPEVALUES_SENT,
      TMP_MESSAGETYPEVALUES_RECEIVED
    ]);
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js
var init_trace2 = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/trace/index.js"() {
    init_SemanticAttributes();
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js
var TMP_CLOUD_PROVIDER, TMP_CLOUD_ACCOUNT_ID, TMP_CLOUD_REGION, TMP_CLOUD_AVAILABILITY_ZONE, TMP_CLOUD_PLATFORM, TMP_AWS_ECS_CONTAINER_ARN, TMP_AWS_ECS_CLUSTER_ARN, TMP_AWS_ECS_LAUNCHTYPE, TMP_AWS_ECS_TASK_ARN, TMP_AWS_ECS_TASK_FAMILY, TMP_AWS_ECS_TASK_REVISION, TMP_AWS_EKS_CLUSTER_ARN, TMP_AWS_LOG_GROUP_NAMES, TMP_AWS_LOG_GROUP_ARNS, TMP_AWS_LOG_STREAM_NAMES, TMP_AWS_LOG_STREAM_ARNS, TMP_CONTAINER_NAME, TMP_CONTAINER_ID, TMP_CONTAINER_RUNTIME, TMP_CONTAINER_IMAGE_NAME, TMP_CONTAINER_IMAGE_TAG, TMP_DEPLOYMENT_ENVIRONMENT, TMP_DEVICE_ID, TMP_DEVICE_MODEL_IDENTIFIER, TMP_DEVICE_MODEL_NAME, TMP_FAAS_NAME, TMP_FAAS_ID, TMP_FAAS_VERSION, TMP_FAAS_INSTANCE, TMP_FAAS_MAX_MEMORY, TMP_HOST_ID, TMP_HOST_NAME, TMP_HOST_TYPE, TMP_HOST_ARCH, TMP_HOST_IMAGE_NAME, TMP_HOST_IMAGE_ID, TMP_HOST_IMAGE_VERSION, TMP_K8S_CLUSTER_NAME, TMP_K8S_NODE_NAME, TMP_K8S_NODE_UID, TMP_K8S_NAMESPACE_NAME, TMP_K8S_POD_UID, TMP_K8S_POD_NAME, TMP_K8S_CONTAINER_NAME, TMP_K8S_REPLICASET_UID, TMP_K8S_REPLICASET_NAME, TMP_K8S_DEPLOYMENT_UID, TMP_K8S_DEPLOYMENT_NAME, TMP_K8S_STATEFULSET_UID, TMP_K8S_STATEFULSET_NAME, TMP_K8S_DAEMONSET_UID, TMP_K8S_DAEMONSET_NAME, TMP_K8S_JOB_UID, TMP_K8S_JOB_NAME, TMP_K8S_CRONJOB_UID, TMP_K8S_CRONJOB_NAME, TMP_OS_TYPE, TMP_OS_DESCRIPTION, TMP_OS_NAME, TMP_OS_VERSION, TMP_PROCESS_PID, TMP_PROCESS_EXECUTABLE_NAME, TMP_PROCESS_EXECUTABLE_PATH, TMP_PROCESS_COMMAND, TMP_PROCESS_COMMAND_LINE, TMP_PROCESS_COMMAND_ARGS, TMP_PROCESS_OWNER, TMP_PROCESS_RUNTIME_NAME, TMP_PROCESS_RUNTIME_VERSION, TMP_PROCESS_RUNTIME_DESCRIPTION, TMP_SERVICE_NAME, TMP_SERVICE_NAMESPACE, TMP_SERVICE_INSTANCE_ID, TMP_SERVICE_VERSION, TMP_TELEMETRY_SDK_NAME, TMP_TELEMETRY_SDK_LANGUAGE, TMP_TELEMETRY_SDK_VERSION, TMP_TELEMETRY_AUTO_VERSION, TMP_WEBENGINE_NAME, TMP_WEBENGINE_VERSION, TMP_WEBENGINE_DESCRIPTION, SEMRESATTRS_CLOUD_PROVIDER, SEMRESATTRS_CLOUD_ACCOUNT_ID, SEMRESATTRS_CLOUD_REGION, SEMRESATTRS_CLOUD_AVAILABILITY_ZONE, SEMRESATTRS_CLOUD_PLATFORM, SEMRESATTRS_AWS_ECS_CONTAINER_ARN, SEMRESATTRS_AWS_ECS_CLUSTER_ARN, SEMRESATTRS_AWS_ECS_LAUNCHTYPE, SEMRESATTRS_AWS_ECS_TASK_ARN, SEMRESATTRS_AWS_ECS_TASK_FAMILY, SEMRESATTRS_AWS_ECS_TASK_REVISION, SEMRESATTRS_AWS_EKS_CLUSTER_ARN, SEMRESATTRS_AWS_LOG_GROUP_NAMES, SEMRESATTRS_AWS_LOG_GROUP_ARNS, SEMRESATTRS_AWS_LOG_STREAM_NAMES, SEMRESATTRS_AWS_LOG_STREAM_ARNS, SEMRESATTRS_CONTAINER_NAME, SEMRESATTRS_CONTAINER_ID, SEMRESATTRS_CONTAINER_RUNTIME, SEMRESATTRS_CONTAINER_IMAGE_NAME, SEMRESATTRS_CONTAINER_IMAGE_TAG, SEMRESATTRS_DEPLOYMENT_ENVIRONMENT, SEMRESATTRS_DEVICE_ID, SEMRESATTRS_DEVICE_MODEL_IDENTIFIER, SEMRESATTRS_DEVICE_MODEL_NAME, SEMRESATTRS_FAAS_NAME, SEMRESATTRS_FAAS_ID, SEMRESATTRS_FAAS_VERSION, SEMRESATTRS_FAAS_INSTANCE, SEMRESATTRS_FAAS_MAX_MEMORY, SEMRESATTRS_HOST_ID, SEMRESATTRS_HOST_NAME, SEMRESATTRS_HOST_TYPE, SEMRESATTRS_HOST_ARCH, SEMRESATTRS_HOST_IMAGE_NAME, SEMRESATTRS_HOST_IMAGE_ID, SEMRESATTRS_HOST_IMAGE_VERSION, SEMRESATTRS_K8S_CLUSTER_NAME, SEMRESATTRS_K8S_NODE_NAME, SEMRESATTRS_K8S_NODE_UID, SEMRESATTRS_K8S_NAMESPACE_NAME, SEMRESATTRS_K8S_POD_UID, SEMRESATTRS_K8S_POD_NAME, SEMRESATTRS_K8S_CONTAINER_NAME, SEMRESATTRS_K8S_REPLICASET_UID, SEMRESATTRS_K8S_REPLICASET_NAME, SEMRESATTRS_K8S_DEPLOYMENT_UID, SEMRESATTRS_K8S_DEPLOYMENT_NAME, SEMRESATTRS_K8S_STATEFULSET_UID, SEMRESATTRS_K8S_STATEFULSET_NAME, SEMRESATTRS_K8S_DAEMONSET_UID, SEMRESATTRS_K8S_DAEMONSET_NAME, SEMRESATTRS_K8S_JOB_UID, SEMRESATTRS_K8S_JOB_NAME, SEMRESATTRS_K8S_CRONJOB_UID, SEMRESATTRS_K8S_CRONJOB_NAME, SEMRESATTRS_OS_TYPE, SEMRESATTRS_OS_DESCRIPTION, SEMRESATTRS_OS_NAME, SEMRESATTRS_OS_VERSION, SEMRESATTRS_PROCESS_PID, SEMRESATTRS_PROCESS_EXECUTABLE_NAME, SEMRESATTRS_PROCESS_EXECUTABLE_PATH, SEMRESATTRS_PROCESS_COMMAND, SEMRESATTRS_PROCESS_COMMAND_LINE, SEMRESATTRS_PROCESS_COMMAND_ARGS, SEMRESATTRS_PROCESS_OWNER, SEMRESATTRS_PROCESS_RUNTIME_NAME, SEMRESATTRS_PROCESS_RUNTIME_VERSION, SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION, SEMRESATTRS_SERVICE_NAME, SEMRESATTRS_SERVICE_NAMESPACE, SEMRESATTRS_SERVICE_INSTANCE_ID, SEMRESATTRS_SERVICE_VERSION, SEMRESATTRS_TELEMETRY_SDK_NAME, SEMRESATTRS_TELEMETRY_SDK_LANGUAGE, SEMRESATTRS_TELEMETRY_SDK_VERSION, SEMRESATTRS_TELEMETRY_AUTO_VERSION, SEMRESATTRS_WEBENGINE_NAME, SEMRESATTRS_WEBENGINE_VERSION, SEMRESATTRS_WEBENGINE_DESCRIPTION, SemanticResourceAttributes, TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD, TMP_CLOUDPROVIDERVALUES_AWS, TMP_CLOUDPROVIDERVALUES_AZURE, TMP_CLOUDPROVIDERVALUES_GCP, CLOUDPROVIDERVALUES_ALIBABA_CLOUD, CLOUDPROVIDERVALUES_AWS, CLOUDPROVIDERVALUES_AZURE, CLOUDPROVIDERVALUES_GCP, CloudProviderValues, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, TMP_CLOUDPLATFORMVALUES_AWS_EC2, TMP_CLOUDPLATFORMVALUES_AWS_ECS, TMP_CLOUDPLATFORMVALUES_AWS_EKS, TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA, TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, TMP_CLOUDPLATFORMVALUES_AZURE_VM, TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, TMP_CLOUDPLATFORMVALUES_AZURE_AKS, TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS, CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC, CLOUDPLATFORMVALUES_AWS_EC2, CLOUDPLATFORMVALUES_AWS_ECS, CLOUDPLATFORMVALUES_AWS_EKS, CLOUDPLATFORMVALUES_AWS_LAMBDA, CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK, CLOUDPLATFORMVALUES_AZURE_VM, CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES, CLOUDPLATFORMVALUES_AZURE_AKS, CLOUDPLATFORMVALUES_AZURE_FUNCTIONS, CLOUDPLATFORMVALUES_AZURE_APP_SERVICE, CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_RUN, CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE, CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS, CLOUDPLATFORMVALUES_GCP_APP_ENGINE, CloudPlatformValues, TMP_AWSECSLAUNCHTYPEVALUES_EC2, TMP_AWSECSLAUNCHTYPEVALUES_FARGATE, AWSECSLAUNCHTYPEVALUES_EC2, AWSECSLAUNCHTYPEVALUES_FARGATE, AwsEcsLaunchtypeValues, TMP_HOSTARCHVALUES_AMD64, TMP_HOSTARCHVALUES_ARM32, TMP_HOSTARCHVALUES_ARM64, TMP_HOSTARCHVALUES_IA64, TMP_HOSTARCHVALUES_PPC32, TMP_HOSTARCHVALUES_PPC64, TMP_HOSTARCHVALUES_X86, HOSTARCHVALUES_AMD64, HOSTARCHVALUES_ARM32, HOSTARCHVALUES_ARM64, HOSTARCHVALUES_IA64, HOSTARCHVALUES_PPC32, HOSTARCHVALUES_PPC64, HOSTARCHVALUES_X86, HostArchValues, TMP_OSTYPEVALUES_WINDOWS, TMP_OSTYPEVALUES_LINUX, TMP_OSTYPEVALUES_DARWIN, TMP_OSTYPEVALUES_FREEBSD, TMP_OSTYPEVALUES_NETBSD, TMP_OSTYPEVALUES_OPENBSD, TMP_OSTYPEVALUES_DRAGONFLYBSD, TMP_OSTYPEVALUES_HPUX, TMP_OSTYPEVALUES_AIX, TMP_OSTYPEVALUES_SOLARIS, TMP_OSTYPEVALUES_Z_OS, OSTYPEVALUES_WINDOWS, OSTYPEVALUES_LINUX, OSTYPEVALUES_DARWIN, OSTYPEVALUES_FREEBSD, OSTYPEVALUES_NETBSD, OSTYPEVALUES_OPENBSD, OSTYPEVALUES_DRAGONFLYBSD, OSTYPEVALUES_HPUX, OSTYPEVALUES_AIX, OSTYPEVALUES_SOLARIS, OSTYPEVALUES_Z_OS, OsTypeValues, TMP_TELEMETRYSDKLANGUAGEVALUES_CPP, TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET, TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG, TMP_TELEMETRYSDKLANGUAGEVALUES_GO, TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA, TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS, TMP_TELEMETRYSDKLANGUAGEVALUES_PHP, TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON, TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY, TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS, TELEMETRYSDKLANGUAGEVALUES_CPP, TELEMETRYSDKLANGUAGEVALUES_DOTNET, TELEMETRYSDKLANGUAGEVALUES_ERLANG, TELEMETRYSDKLANGUAGEVALUES_GO, TELEMETRYSDKLANGUAGEVALUES_JAVA, TELEMETRYSDKLANGUAGEVALUES_NODEJS, TELEMETRYSDKLANGUAGEVALUES_PHP, TELEMETRYSDKLANGUAGEVALUES_PYTHON, TELEMETRYSDKLANGUAGEVALUES_RUBY, TELEMETRYSDKLANGUAGEVALUES_WEBJS, TelemetrySdkLanguageValues;
var init_SemanticResourceAttributes = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/SemanticResourceAttributes.js"() {
    init_utils3();
    TMP_CLOUD_PROVIDER = "cloud.provider";
    TMP_CLOUD_ACCOUNT_ID = "cloud.account.id";
    TMP_CLOUD_REGION = "cloud.region";
    TMP_CLOUD_AVAILABILITY_ZONE = "cloud.availability_zone";
    TMP_CLOUD_PLATFORM = "cloud.platform";
    TMP_AWS_ECS_CONTAINER_ARN = "aws.ecs.container.arn";
    TMP_AWS_ECS_CLUSTER_ARN = "aws.ecs.cluster.arn";
    TMP_AWS_ECS_LAUNCHTYPE = "aws.ecs.launchtype";
    TMP_AWS_ECS_TASK_ARN = "aws.ecs.task.arn";
    TMP_AWS_ECS_TASK_FAMILY = "aws.ecs.task.family";
    TMP_AWS_ECS_TASK_REVISION = "aws.ecs.task.revision";
    TMP_AWS_EKS_CLUSTER_ARN = "aws.eks.cluster.arn";
    TMP_AWS_LOG_GROUP_NAMES = "aws.log.group.names";
    TMP_AWS_LOG_GROUP_ARNS = "aws.log.group.arns";
    TMP_AWS_LOG_STREAM_NAMES = "aws.log.stream.names";
    TMP_AWS_LOG_STREAM_ARNS = "aws.log.stream.arns";
    TMP_CONTAINER_NAME = "container.name";
    TMP_CONTAINER_ID = "container.id";
    TMP_CONTAINER_RUNTIME = "container.runtime";
    TMP_CONTAINER_IMAGE_NAME = "container.image.name";
    TMP_CONTAINER_IMAGE_TAG = "container.image.tag";
    TMP_DEPLOYMENT_ENVIRONMENT = "deployment.environment";
    TMP_DEVICE_ID = "device.id";
    TMP_DEVICE_MODEL_IDENTIFIER = "device.model.identifier";
    TMP_DEVICE_MODEL_NAME = "device.model.name";
    TMP_FAAS_NAME = "faas.name";
    TMP_FAAS_ID = "faas.id";
    TMP_FAAS_VERSION = "faas.version";
    TMP_FAAS_INSTANCE = "faas.instance";
    TMP_FAAS_MAX_MEMORY = "faas.max_memory";
    TMP_HOST_ID = "host.id";
    TMP_HOST_NAME = "host.name";
    TMP_HOST_TYPE = "host.type";
    TMP_HOST_ARCH = "host.arch";
    TMP_HOST_IMAGE_NAME = "host.image.name";
    TMP_HOST_IMAGE_ID = "host.image.id";
    TMP_HOST_IMAGE_VERSION = "host.image.version";
    TMP_K8S_CLUSTER_NAME = "k8s.cluster.name";
    TMP_K8S_NODE_NAME = "k8s.node.name";
    TMP_K8S_NODE_UID = "k8s.node.uid";
    TMP_K8S_NAMESPACE_NAME = "k8s.namespace.name";
    TMP_K8S_POD_UID = "k8s.pod.uid";
    TMP_K8S_POD_NAME = "k8s.pod.name";
    TMP_K8S_CONTAINER_NAME = "k8s.container.name";
    TMP_K8S_REPLICASET_UID = "k8s.replicaset.uid";
    TMP_K8S_REPLICASET_NAME = "k8s.replicaset.name";
    TMP_K8S_DEPLOYMENT_UID = "k8s.deployment.uid";
    TMP_K8S_DEPLOYMENT_NAME = "k8s.deployment.name";
    TMP_K8S_STATEFULSET_UID = "k8s.statefulset.uid";
    TMP_K8S_STATEFULSET_NAME = "k8s.statefulset.name";
    TMP_K8S_DAEMONSET_UID = "k8s.daemonset.uid";
    TMP_K8S_DAEMONSET_NAME = "k8s.daemonset.name";
    TMP_K8S_JOB_UID = "k8s.job.uid";
    TMP_K8S_JOB_NAME = "k8s.job.name";
    TMP_K8S_CRONJOB_UID = "k8s.cronjob.uid";
    TMP_K8S_CRONJOB_NAME = "k8s.cronjob.name";
    TMP_OS_TYPE = "os.type";
    TMP_OS_DESCRIPTION = "os.description";
    TMP_OS_NAME = "os.name";
    TMP_OS_VERSION = "os.version";
    TMP_PROCESS_PID = "process.pid";
    TMP_PROCESS_EXECUTABLE_NAME = "process.executable.name";
    TMP_PROCESS_EXECUTABLE_PATH = "process.executable.path";
    TMP_PROCESS_COMMAND = "process.command";
    TMP_PROCESS_COMMAND_LINE = "process.command_line";
    TMP_PROCESS_COMMAND_ARGS = "process.command_args";
    TMP_PROCESS_OWNER = "process.owner";
    TMP_PROCESS_RUNTIME_NAME = "process.runtime.name";
    TMP_PROCESS_RUNTIME_VERSION = "process.runtime.version";
    TMP_PROCESS_RUNTIME_DESCRIPTION = "process.runtime.description";
    TMP_SERVICE_NAME = "service.name";
    TMP_SERVICE_NAMESPACE = "service.namespace";
    TMP_SERVICE_INSTANCE_ID = "service.instance.id";
    TMP_SERVICE_VERSION = "service.version";
    TMP_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    TMP_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TMP_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    TMP_TELEMETRY_AUTO_VERSION = "telemetry.auto.version";
    TMP_WEBENGINE_NAME = "webengine.name";
    TMP_WEBENGINE_VERSION = "webengine.version";
    TMP_WEBENGINE_DESCRIPTION = "webengine.description";
    SEMRESATTRS_CLOUD_PROVIDER = TMP_CLOUD_PROVIDER;
    SEMRESATTRS_CLOUD_ACCOUNT_ID = TMP_CLOUD_ACCOUNT_ID;
    SEMRESATTRS_CLOUD_REGION = TMP_CLOUD_REGION;
    SEMRESATTRS_CLOUD_AVAILABILITY_ZONE = TMP_CLOUD_AVAILABILITY_ZONE;
    SEMRESATTRS_CLOUD_PLATFORM = TMP_CLOUD_PLATFORM;
    SEMRESATTRS_AWS_ECS_CONTAINER_ARN = TMP_AWS_ECS_CONTAINER_ARN;
    SEMRESATTRS_AWS_ECS_CLUSTER_ARN = TMP_AWS_ECS_CLUSTER_ARN;
    SEMRESATTRS_AWS_ECS_LAUNCHTYPE = TMP_AWS_ECS_LAUNCHTYPE;
    SEMRESATTRS_AWS_ECS_TASK_ARN = TMP_AWS_ECS_TASK_ARN;
    SEMRESATTRS_AWS_ECS_TASK_FAMILY = TMP_AWS_ECS_TASK_FAMILY;
    SEMRESATTRS_AWS_ECS_TASK_REVISION = TMP_AWS_ECS_TASK_REVISION;
    SEMRESATTRS_AWS_EKS_CLUSTER_ARN = TMP_AWS_EKS_CLUSTER_ARN;
    SEMRESATTRS_AWS_LOG_GROUP_NAMES = TMP_AWS_LOG_GROUP_NAMES;
    SEMRESATTRS_AWS_LOG_GROUP_ARNS = TMP_AWS_LOG_GROUP_ARNS;
    SEMRESATTRS_AWS_LOG_STREAM_NAMES = TMP_AWS_LOG_STREAM_NAMES;
    SEMRESATTRS_AWS_LOG_STREAM_ARNS = TMP_AWS_LOG_STREAM_ARNS;
    SEMRESATTRS_CONTAINER_NAME = TMP_CONTAINER_NAME;
    SEMRESATTRS_CONTAINER_ID = TMP_CONTAINER_ID;
    SEMRESATTRS_CONTAINER_RUNTIME = TMP_CONTAINER_RUNTIME;
    SEMRESATTRS_CONTAINER_IMAGE_NAME = TMP_CONTAINER_IMAGE_NAME;
    SEMRESATTRS_CONTAINER_IMAGE_TAG = TMP_CONTAINER_IMAGE_TAG;
    SEMRESATTRS_DEPLOYMENT_ENVIRONMENT = TMP_DEPLOYMENT_ENVIRONMENT;
    SEMRESATTRS_DEVICE_ID = TMP_DEVICE_ID;
    SEMRESATTRS_DEVICE_MODEL_IDENTIFIER = TMP_DEVICE_MODEL_IDENTIFIER;
    SEMRESATTRS_DEVICE_MODEL_NAME = TMP_DEVICE_MODEL_NAME;
    SEMRESATTRS_FAAS_NAME = TMP_FAAS_NAME;
    SEMRESATTRS_FAAS_ID = TMP_FAAS_ID;
    SEMRESATTRS_FAAS_VERSION = TMP_FAAS_VERSION;
    SEMRESATTRS_FAAS_INSTANCE = TMP_FAAS_INSTANCE;
    SEMRESATTRS_FAAS_MAX_MEMORY = TMP_FAAS_MAX_MEMORY;
    SEMRESATTRS_HOST_ID = TMP_HOST_ID;
    SEMRESATTRS_HOST_NAME = TMP_HOST_NAME;
    SEMRESATTRS_HOST_TYPE = TMP_HOST_TYPE;
    SEMRESATTRS_HOST_ARCH = TMP_HOST_ARCH;
    SEMRESATTRS_HOST_IMAGE_NAME = TMP_HOST_IMAGE_NAME;
    SEMRESATTRS_HOST_IMAGE_ID = TMP_HOST_IMAGE_ID;
    SEMRESATTRS_HOST_IMAGE_VERSION = TMP_HOST_IMAGE_VERSION;
    SEMRESATTRS_K8S_CLUSTER_NAME = TMP_K8S_CLUSTER_NAME;
    SEMRESATTRS_K8S_NODE_NAME = TMP_K8S_NODE_NAME;
    SEMRESATTRS_K8S_NODE_UID = TMP_K8S_NODE_UID;
    SEMRESATTRS_K8S_NAMESPACE_NAME = TMP_K8S_NAMESPACE_NAME;
    SEMRESATTRS_K8S_POD_UID = TMP_K8S_POD_UID;
    SEMRESATTRS_K8S_POD_NAME = TMP_K8S_POD_NAME;
    SEMRESATTRS_K8S_CONTAINER_NAME = TMP_K8S_CONTAINER_NAME;
    SEMRESATTRS_K8S_REPLICASET_UID = TMP_K8S_REPLICASET_UID;
    SEMRESATTRS_K8S_REPLICASET_NAME = TMP_K8S_REPLICASET_NAME;
    SEMRESATTRS_K8S_DEPLOYMENT_UID = TMP_K8S_DEPLOYMENT_UID;
    SEMRESATTRS_K8S_DEPLOYMENT_NAME = TMP_K8S_DEPLOYMENT_NAME;
    SEMRESATTRS_K8S_STATEFULSET_UID = TMP_K8S_STATEFULSET_UID;
    SEMRESATTRS_K8S_STATEFULSET_NAME = TMP_K8S_STATEFULSET_NAME;
    SEMRESATTRS_K8S_DAEMONSET_UID = TMP_K8S_DAEMONSET_UID;
    SEMRESATTRS_K8S_DAEMONSET_NAME = TMP_K8S_DAEMONSET_NAME;
    SEMRESATTRS_K8S_JOB_UID = TMP_K8S_JOB_UID;
    SEMRESATTRS_K8S_JOB_NAME = TMP_K8S_JOB_NAME;
    SEMRESATTRS_K8S_CRONJOB_UID = TMP_K8S_CRONJOB_UID;
    SEMRESATTRS_K8S_CRONJOB_NAME = TMP_K8S_CRONJOB_NAME;
    SEMRESATTRS_OS_TYPE = TMP_OS_TYPE;
    SEMRESATTRS_OS_DESCRIPTION = TMP_OS_DESCRIPTION;
    SEMRESATTRS_OS_NAME = TMP_OS_NAME;
    SEMRESATTRS_OS_VERSION = TMP_OS_VERSION;
    SEMRESATTRS_PROCESS_PID = TMP_PROCESS_PID;
    SEMRESATTRS_PROCESS_EXECUTABLE_NAME = TMP_PROCESS_EXECUTABLE_NAME;
    SEMRESATTRS_PROCESS_EXECUTABLE_PATH = TMP_PROCESS_EXECUTABLE_PATH;
    SEMRESATTRS_PROCESS_COMMAND = TMP_PROCESS_COMMAND;
    SEMRESATTRS_PROCESS_COMMAND_LINE = TMP_PROCESS_COMMAND_LINE;
    SEMRESATTRS_PROCESS_COMMAND_ARGS = TMP_PROCESS_COMMAND_ARGS;
    SEMRESATTRS_PROCESS_OWNER = TMP_PROCESS_OWNER;
    SEMRESATTRS_PROCESS_RUNTIME_NAME = TMP_PROCESS_RUNTIME_NAME;
    SEMRESATTRS_PROCESS_RUNTIME_VERSION = TMP_PROCESS_RUNTIME_VERSION;
    SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION = TMP_PROCESS_RUNTIME_DESCRIPTION;
    SEMRESATTRS_SERVICE_NAME = TMP_SERVICE_NAME;
    SEMRESATTRS_SERVICE_NAMESPACE = TMP_SERVICE_NAMESPACE;
    SEMRESATTRS_SERVICE_INSTANCE_ID = TMP_SERVICE_INSTANCE_ID;
    SEMRESATTRS_SERVICE_VERSION = TMP_SERVICE_VERSION;
    SEMRESATTRS_TELEMETRY_SDK_NAME = TMP_TELEMETRY_SDK_NAME;
    SEMRESATTRS_TELEMETRY_SDK_LANGUAGE = TMP_TELEMETRY_SDK_LANGUAGE;
    SEMRESATTRS_TELEMETRY_SDK_VERSION = TMP_TELEMETRY_SDK_VERSION;
    SEMRESATTRS_TELEMETRY_AUTO_VERSION = TMP_TELEMETRY_AUTO_VERSION;
    SEMRESATTRS_WEBENGINE_NAME = TMP_WEBENGINE_NAME;
    SEMRESATTRS_WEBENGINE_VERSION = TMP_WEBENGINE_VERSION;
    SEMRESATTRS_WEBENGINE_DESCRIPTION = TMP_WEBENGINE_DESCRIPTION;
    SemanticResourceAttributes = /* @__PURE__ */ createConstMap([
      TMP_CLOUD_PROVIDER,
      TMP_CLOUD_ACCOUNT_ID,
      TMP_CLOUD_REGION,
      TMP_CLOUD_AVAILABILITY_ZONE,
      TMP_CLOUD_PLATFORM,
      TMP_AWS_ECS_CONTAINER_ARN,
      TMP_AWS_ECS_CLUSTER_ARN,
      TMP_AWS_ECS_LAUNCHTYPE,
      TMP_AWS_ECS_TASK_ARN,
      TMP_AWS_ECS_TASK_FAMILY,
      TMP_AWS_ECS_TASK_REVISION,
      TMP_AWS_EKS_CLUSTER_ARN,
      TMP_AWS_LOG_GROUP_NAMES,
      TMP_AWS_LOG_GROUP_ARNS,
      TMP_AWS_LOG_STREAM_NAMES,
      TMP_AWS_LOG_STREAM_ARNS,
      TMP_CONTAINER_NAME,
      TMP_CONTAINER_ID,
      TMP_CONTAINER_RUNTIME,
      TMP_CONTAINER_IMAGE_NAME,
      TMP_CONTAINER_IMAGE_TAG,
      TMP_DEPLOYMENT_ENVIRONMENT,
      TMP_DEVICE_ID,
      TMP_DEVICE_MODEL_IDENTIFIER,
      TMP_DEVICE_MODEL_NAME,
      TMP_FAAS_NAME,
      TMP_FAAS_ID,
      TMP_FAAS_VERSION,
      TMP_FAAS_INSTANCE,
      TMP_FAAS_MAX_MEMORY,
      TMP_HOST_ID,
      TMP_HOST_NAME,
      TMP_HOST_TYPE,
      TMP_HOST_ARCH,
      TMP_HOST_IMAGE_NAME,
      TMP_HOST_IMAGE_ID,
      TMP_HOST_IMAGE_VERSION,
      TMP_K8S_CLUSTER_NAME,
      TMP_K8S_NODE_NAME,
      TMP_K8S_NODE_UID,
      TMP_K8S_NAMESPACE_NAME,
      TMP_K8S_POD_UID,
      TMP_K8S_POD_NAME,
      TMP_K8S_CONTAINER_NAME,
      TMP_K8S_REPLICASET_UID,
      TMP_K8S_REPLICASET_NAME,
      TMP_K8S_DEPLOYMENT_UID,
      TMP_K8S_DEPLOYMENT_NAME,
      TMP_K8S_STATEFULSET_UID,
      TMP_K8S_STATEFULSET_NAME,
      TMP_K8S_DAEMONSET_UID,
      TMP_K8S_DAEMONSET_NAME,
      TMP_K8S_JOB_UID,
      TMP_K8S_JOB_NAME,
      TMP_K8S_CRONJOB_UID,
      TMP_K8S_CRONJOB_NAME,
      TMP_OS_TYPE,
      TMP_OS_DESCRIPTION,
      TMP_OS_NAME,
      TMP_OS_VERSION,
      TMP_PROCESS_PID,
      TMP_PROCESS_EXECUTABLE_NAME,
      TMP_PROCESS_EXECUTABLE_PATH,
      TMP_PROCESS_COMMAND,
      TMP_PROCESS_COMMAND_LINE,
      TMP_PROCESS_COMMAND_ARGS,
      TMP_PROCESS_OWNER,
      TMP_PROCESS_RUNTIME_NAME,
      TMP_PROCESS_RUNTIME_VERSION,
      TMP_PROCESS_RUNTIME_DESCRIPTION,
      TMP_SERVICE_NAME,
      TMP_SERVICE_NAMESPACE,
      TMP_SERVICE_INSTANCE_ID,
      TMP_SERVICE_VERSION,
      TMP_TELEMETRY_SDK_NAME,
      TMP_TELEMETRY_SDK_LANGUAGE,
      TMP_TELEMETRY_SDK_VERSION,
      TMP_TELEMETRY_AUTO_VERSION,
      TMP_WEBENGINE_NAME,
      TMP_WEBENGINE_VERSION,
      TMP_WEBENGINE_DESCRIPTION
    ]);
    TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD = "alibaba_cloud";
    TMP_CLOUDPROVIDERVALUES_AWS = "aws";
    TMP_CLOUDPROVIDERVALUES_AZURE = "azure";
    TMP_CLOUDPROVIDERVALUES_GCP = "gcp";
    CLOUDPROVIDERVALUES_ALIBABA_CLOUD = TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD;
    CLOUDPROVIDERVALUES_AWS = TMP_CLOUDPROVIDERVALUES_AWS;
    CLOUDPROVIDERVALUES_AZURE = TMP_CLOUDPROVIDERVALUES_AZURE;
    CLOUDPROVIDERVALUES_GCP = TMP_CLOUDPROVIDERVALUES_GCP;
    CloudProviderValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
      TMP_CLOUDPROVIDERVALUES_AWS,
      TMP_CLOUDPROVIDERVALUES_AZURE,
      TMP_CLOUDPROVIDERVALUES_GCP
    ]);
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = "alibaba_cloud_ecs";
    TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = "alibaba_cloud_fc";
    TMP_CLOUDPLATFORMVALUES_AWS_EC2 = "aws_ec2";
    TMP_CLOUDPLATFORMVALUES_AWS_ECS = "aws_ecs";
    TMP_CLOUDPLATFORMVALUES_AWS_EKS = "aws_eks";
    TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA = "aws_lambda";
    TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = "aws_elastic_beanstalk";
    TMP_CLOUDPLATFORMVALUES_AZURE_VM = "azure_vm";
    TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = "azure_container_instances";
    TMP_CLOUDPLATFORMVALUES_AZURE_AKS = "azure_aks";
    TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = "azure_functions";
    TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = "azure_app_service";
    TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = "gcp_compute_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = "gcp_cloud_run";
    TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = "gcp_kubernetes_engine";
    TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = "gcp_cloud_functions";
    TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE = "gcp_app_engine";
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS;
    CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC = TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC;
    CLOUDPLATFORMVALUES_AWS_EC2 = TMP_CLOUDPLATFORMVALUES_AWS_EC2;
    CLOUDPLATFORMVALUES_AWS_ECS = TMP_CLOUDPLATFORMVALUES_AWS_ECS;
    CLOUDPLATFORMVALUES_AWS_EKS = TMP_CLOUDPLATFORMVALUES_AWS_EKS;
    CLOUDPLATFORMVALUES_AWS_LAMBDA = TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA;
    CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK = TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK;
    CLOUDPLATFORMVALUES_AZURE_VM = TMP_CLOUDPLATFORMVALUES_AZURE_VM;
    CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES = TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES;
    CLOUDPLATFORMVALUES_AZURE_AKS = TMP_CLOUDPLATFORMVALUES_AZURE_AKS;
    CLOUDPLATFORMVALUES_AZURE_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS;
    CLOUDPLATFORMVALUES_AZURE_APP_SERVICE = TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE;
    CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_RUN = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN;
    CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE;
    CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS = TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS;
    CLOUDPLATFORMVALUES_GCP_APP_ENGINE = TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE;
    CloudPlatformValues = /* @__PURE__ */ createConstMap([
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
      TMP_CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
      TMP_CLOUDPLATFORMVALUES_AWS_EC2,
      TMP_CLOUDPLATFORMVALUES_AWS_ECS,
      TMP_CLOUDPLATFORMVALUES_AWS_EKS,
      TMP_CLOUDPLATFORMVALUES_AWS_LAMBDA,
      TMP_CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
      TMP_CLOUDPLATFORMVALUES_AZURE_VM,
      TMP_CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
      TMP_CLOUDPLATFORMVALUES_AZURE_AKS,
      TMP_CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
      TMP_CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
      TMP_CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
      TMP_CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
      TMP_CLOUDPLATFORMVALUES_GCP_APP_ENGINE
    ]);
    TMP_AWSECSLAUNCHTYPEVALUES_EC2 = "ec2";
    TMP_AWSECSLAUNCHTYPEVALUES_FARGATE = "fargate";
    AWSECSLAUNCHTYPEVALUES_EC2 = TMP_AWSECSLAUNCHTYPEVALUES_EC2;
    AWSECSLAUNCHTYPEVALUES_FARGATE = TMP_AWSECSLAUNCHTYPEVALUES_FARGATE;
    AwsEcsLaunchtypeValues = /* @__PURE__ */ createConstMap([
      TMP_AWSECSLAUNCHTYPEVALUES_EC2,
      TMP_AWSECSLAUNCHTYPEVALUES_FARGATE
    ]);
    TMP_HOSTARCHVALUES_AMD64 = "amd64";
    TMP_HOSTARCHVALUES_ARM32 = "arm32";
    TMP_HOSTARCHVALUES_ARM64 = "arm64";
    TMP_HOSTARCHVALUES_IA64 = "ia64";
    TMP_HOSTARCHVALUES_PPC32 = "ppc32";
    TMP_HOSTARCHVALUES_PPC64 = "ppc64";
    TMP_HOSTARCHVALUES_X86 = "x86";
    HOSTARCHVALUES_AMD64 = TMP_HOSTARCHVALUES_AMD64;
    HOSTARCHVALUES_ARM32 = TMP_HOSTARCHVALUES_ARM32;
    HOSTARCHVALUES_ARM64 = TMP_HOSTARCHVALUES_ARM64;
    HOSTARCHVALUES_IA64 = TMP_HOSTARCHVALUES_IA64;
    HOSTARCHVALUES_PPC32 = TMP_HOSTARCHVALUES_PPC32;
    HOSTARCHVALUES_PPC64 = TMP_HOSTARCHVALUES_PPC64;
    HOSTARCHVALUES_X86 = TMP_HOSTARCHVALUES_X86;
    HostArchValues = /* @__PURE__ */ createConstMap([
      TMP_HOSTARCHVALUES_AMD64,
      TMP_HOSTARCHVALUES_ARM32,
      TMP_HOSTARCHVALUES_ARM64,
      TMP_HOSTARCHVALUES_IA64,
      TMP_HOSTARCHVALUES_PPC32,
      TMP_HOSTARCHVALUES_PPC64,
      TMP_HOSTARCHVALUES_X86
    ]);
    TMP_OSTYPEVALUES_WINDOWS = "windows";
    TMP_OSTYPEVALUES_LINUX = "linux";
    TMP_OSTYPEVALUES_DARWIN = "darwin";
    TMP_OSTYPEVALUES_FREEBSD = "freebsd";
    TMP_OSTYPEVALUES_NETBSD = "netbsd";
    TMP_OSTYPEVALUES_OPENBSD = "openbsd";
    TMP_OSTYPEVALUES_DRAGONFLYBSD = "dragonflybsd";
    TMP_OSTYPEVALUES_HPUX = "hpux";
    TMP_OSTYPEVALUES_AIX = "aix";
    TMP_OSTYPEVALUES_SOLARIS = "solaris";
    TMP_OSTYPEVALUES_Z_OS = "z_os";
    OSTYPEVALUES_WINDOWS = TMP_OSTYPEVALUES_WINDOWS;
    OSTYPEVALUES_LINUX = TMP_OSTYPEVALUES_LINUX;
    OSTYPEVALUES_DARWIN = TMP_OSTYPEVALUES_DARWIN;
    OSTYPEVALUES_FREEBSD = TMP_OSTYPEVALUES_FREEBSD;
    OSTYPEVALUES_NETBSD = TMP_OSTYPEVALUES_NETBSD;
    OSTYPEVALUES_OPENBSD = TMP_OSTYPEVALUES_OPENBSD;
    OSTYPEVALUES_DRAGONFLYBSD = TMP_OSTYPEVALUES_DRAGONFLYBSD;
    OSTYPEVALUES_HPUX = TMP_OSTYPEVALUES_HPUX;
    OSTYPEVALUES_AIX = TMP_OSTYPEVALUES_AIX;
    OSTYPEVALUES_SOLARIS = TMP_OSTYPEVALUES_SOLARIS;
    OSTYPEVALUES_Z_OS = TMP_OSTYPEVALUES_Z_OS;
    OsTypeValues = /* @__PURE__ */ createConstMap([
      TMP_OSTYPEVALUES_WINDOWS,
      TMP_OSTYPEVALUES_LINUX,
      TMP_OSTYPEVALUES_DARWIN,
      TMP_OSTYPEVALUES_FREEBSD,
      TMP_OSTYPEVALUES_NETBSD,
      TMP_OSTYPEVALUES_OPENBSD,
      TMP_OSTYPEVALUES_DRAGONFLYBSD,
      TMP_OSTYPEVALUES_HPUX,
      TMP_OSTYPEVALUES_AIX,
      TMP_OSTYPEVALUES_SOLARIS,
      TMP_OSTYPEVALUES_Z_OS
    ]);
    TMP_TELEMETRYSDKLANGUAGEVALUES_CPP = "cpp";
    TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET = "dotnet";
    TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG = "erlang";
    TMP_TELEMETRYSDKLANGUAGEVALUES_GO = "go";
    TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA = "java";
    TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS = "nodejs";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PHP = "php";
    TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON = "python";
    TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY = "ruby";
    TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS = "webjs";
    TELEMETRYSDKLANGUAGEVALUES_CPP = TMP_TELEMETRYSDKLANGUAGEVALUES_CPP;
    TELEMETRYSDKLANGUAGEVALUES_DOTNET = TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET;
    TELEMETRYSDKLANGUAGEVALUES_ERLANG = TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG;
    TELEMETRYSDKLANGUAGEVALUES_GO = TMP_TELEMETRYSDKLANGUAGEVALUES_GO;
    TELEMETRYSDKLANGUAGEVALUES_JAVA = TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA;
    TELEMETRYSDKLANGUAGEVALUES_NODEJS = TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS;
    TELEMETRYSDKLANGUAGEVALUES_PHP = TMP_TELEMETRYSDKLANGUAGEVALUES_PHP;
    TELEMETRYSDKLANGUAGEVALUES_PYTHON = TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON;
    TELEMETRYSDKLANGUAGEVALUES_RUBY = TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY;
    TELEMETRYSDKLANGUAGEVALUES_WEBJS = TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS;
    TelemetrySdkLanguageValues = /* @__PURE__ */ createConstMap([
      TMP_TELEMETRYSDKLANGUAGEVALUES_CPP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_DOTNET,
      TMP_TELEMETRYSDKLANGUAGEVALUES_ERLANG,
      TMP_TELEMETRYSDKLANGUAGEVALUES_GO,
      TMP_TELEMETRYSDKLANGUAGEVALUES_JAVA,
      TMP_TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PHP,
      TMP_TELEMETRYSDKLANGUAGEVALUES_PYTHON,
      TMP_TELEMETRYSDKLANGUAGEVALUES_RUBY,
      TMP_TELEMETRYSDKLANGUAGEVALUES_WEBJS
    ]);
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js
var init_resource = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/resource/index.js"() {
    init_SemanticResourceAttributes();
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js
var ATTR_ASPNETCORE_RATE_LIMITING_RESULT, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER, ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED, ATTR_TELEMETRY_SDK_LANGUAGE, TELEMETRY_SDK_LANGUAGE_VALUE_CPP, TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET, TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG, TELEMETRY_SDK_LANGUAGE_VALUE_GO, TELEMETRY_SDK_LANGUAGE_VALUE_JAVA, TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS, TELEMETRY_SDK_LANGUAGE_VALUE_PHP, TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON, TELEMETRY_SDK_LANGUAGE_VALUE_RUBY, TELEMETRY_SDK_LANGUAGE_VALUE_RUST, TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT, TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS, ATTR_TELEMETRY_SDK_NAME, ATTR_TELEMETRY_SDK_VERSION, ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE, ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED, ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED, ATTR_ASPNETCORE_RATE_LIMITING_POLICY, ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED, ATTR_ASPNETCORE_ROUTING_IS_FALLBACK, ATTR_ASPNETCORE_ROUTING_MATCH_STATUS, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE, ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS, ATTR_CLIENT_ADDRESS, ATTR_CLIENT_PORT, ATTR_ERROR_TYPE, ERROR_TYPE_VALUE_OTHER, ATTR_EXCEPTION_ESCAPED, ATTR_EXCEPTION_MESSAGE, ATTR_EXCEPTION_STACKTRACE, ATTR_EXCEPTION_TYPE, ATTR_HTTP_REQUEST_HEADER, ATTR_HTTP_REQUEST_METHOD, HTTP_REQUEST_METHOD_VALUE_OTHER, HTTP_REQUEST_METHOD_VALUE_CONNECT, HTTP_REQUEST_METHOD_VALUE_DELETE, HTTP_REQUEST_METHOD_VALUE_GET, HTTP_REQUEST_METHOD_VALUE_HEAD, HTTP_REQUEST_METHOD_VALUE_OPTIONS, HTTP_REQUEST_METHOD_VALUE_PATCH, HTTP_REQUEST_METHOD_VALUE_POST, HTTP_REQUEST_METHOD_VALUE_PUT, HTTP_REQUEST_METHOD_VALUE_TRACE, ATTR_HTTP_REQUEST_METHOD_ORIGINAL, ATTR_HTTP_REQUEST_RESEND_COUNT, ATTR_HTTP_RESPONSE_HEADER, ATTR_HTTP_RESPONSE_STATUS_CODE, ATTR_HTTP_ROUTE, ATTR_JVM_GC_ACTION, ATTR_JVM_GC_NAME, ATTR_JVM_MEMORY_POOL_NAME, ATTR_JVM_MEMORY_TYPE, JVM_MEMORY_TYPE_VALUE_HEAP, JVM_MEMORY_TYPE_VALUE_NON_HEAP, ATTR_JVM_THREAD_DAEMON, ATTR_JVM_THREAD_STATE, JVM_THREAD_STATE_VALUE_BLOCKED, JVM_THREAD_STATE_VALUE_NEW, JVM_THREAD_STATE_VALUE_RUNNABLE, JVM_THREAD_STATE_VALUE_TERMINATED, JVM_THREAD_STATE_VALUE_TIMED_WAITING, JVM_THREAD_STATE_VALUE_WAITING, ATTR_NETWORK_LOCAL_ADDRESS, ATTR_NETWORK_LOCAL_PORT, ATTR_NETWORK_PEER_ADDRESS, ATTR_NETWORK_PEER_PORT, ATTR_NETWORK_PROTOCOL_NAME, ATTR_NETWORK_PROTOCOL_VERSION, ATTR_NETWORK_TRANSPORT, NETWORK_TRANSPORT_VALUE_PIPE, NETWORK_TRANSPORT_VALUE_QUIC, NETWORK_TRANSPORT_VALUE_TCP, NETWORK_TRANSPORT_VALUE_UDP, NETWORK_TRANSPORT_VALUE_UNIX, ATTR_NETWORK_TYPE, NETWORK_TYPE_VALUE_IPV4, NETWORK_TYPE_VALUE_IPV6, ATTR_OTEL_SCOPE_NAME, ATTR_OTEL_SCOPE_VERSION, ATTR_OTEL_STATUS_CODE, OTEL_STATUS_CODE_VALUE_ERROR, OTEL_STATUS_CODE_VALUE_OK, ATTR_OTEL_STATUS_DESCRIPTION, ATTR_SERVER_ADDRESS, ATTR_SERVER_PORT, ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION, ATTR_SIGNALR_CONNECTION_STATUS, SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN, SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE, SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT, ATTR_SIGNALR_TRANSPORT, SIGNALR_TRANSPORT_VALUE_LONG_POLLING, SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS, SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS, ATTR_URL_FRAGMENT, ATTR_URL_FULL, ATTR_URL_PATH, ATTR_URL_QUERY, ATTR_URL_SCHEME, ATTR_USER_AGENT_ORIGINAL;
var init_stable_attributes = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_attributes.js"() {
    ATTR_ASPNETCORE_RATE_LIMITING_RESULT = "aspnetcore.rate_limiting.result";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED = "acquired";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER = "endpoint_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER = "global_limiter";
    ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED = "request_canceled";
    ATTR_TELEMETRY_SDK_LANGUAGE = "telemetry.sdk.language";
    TELEMETRY_SDK_LANGUAGE_VALUE_CPP = "cpp";
    TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET = "dotnet";
    TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG = "erlang";
    TELEMETRY_SDK_LANGUAGE_VALUE_GO = "go";
    TELEMETRY_SDK_LANGUAGE_VALUE_JAVA = "java";
    TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS = "nodejs";
    TELEMETRY_SDK_LANGUAGE_VALUE_PHP = "php";
    TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON = "python";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUBY = "ruby";
    TELEMETRY_SDK_LANGUAGE_VALUE_RUST = "rust";
    TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT = "swift";
    TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS = "webjs";
    ATTR_TELEMETRY_SDK_NAME = "telemetry.sdk.name";
    ATTR_TELEMETRY_SDK_VERSION = "telemetry.sdk.version";
    ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE = "aspnetcore.diagnostics.handler.type";
    ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT = "aspnetcore.diagnostics.exception.result";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED = "aborted";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED = "handled";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED = "skipped";
    ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED = "unhandled";
    ATTR_ASPNETCORE_RATE_LIMITING_POLICY = "aspnetcore.rate_limiting.policy";
    ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED = "aspnetcore.request.is_unhandled";
    ATTR_ASPNETCORE_ROUTING_IS_FALLBACK = "aspnetcore.routing.is_fallback";
    ATTR_ASPNETCORE_ROUTING_MATCH_STATUS = "aspnetcore.routing.match_status";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE = "failure";
    ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS = "success";
    ATTR_CLIENT_ADDRESS = "client.address";
    ATTR_CLIENT_PORT = "client.port";
    ATTR_ERROR_TYPE = "error.type";
    ERROR_TYPE_VALUE_OTHER = "_OTHER";
    ATTR_EXCEPTION_ESCAPED = "exception.escaped";
    ATTR_EXCEPTION_MESSAGE = "exception.message";
    ATTR_EXCEPTION_STACKTRACE = "exception.stacktrace";
    ATTR_EXCEPTION_TYPE = "exception.type";
    ATTR_HTTP_REQUEST_HEADER = function(key) {
      return "http.request.header." + key;
    };
    ATTR_HTTP_REQUEST_METHOD = "http.request.method";
    HTTP_REQUEST_METHOD_VALUE_OTHER = "_OTHER";
    HTTP_REQUEST_METHOD_VALUE_CONNECT = "CONNECT";
    HTTP_REQUEST_METHOD_VALUE_DELETE = "DELETE";
    HTTP_REQUEST_METHOD_VALUE_GET = "GET";
    HTTP_REQUEST_METHOD_VALUE_HEAD = "HEAD";
    HTTP_REQUEST_METHOD_VALUE_OPTIONS = "OPTIONS";
    HTTP_REQUEST_METHOD_VALUE_PATCH = "PATCH";
    HTTP_REQUEST_METHOD_VALUE_POST = "POST";
    HTTP_REQUEST_METHOD_VALUE_PUT = "PUT";
    HTTP_REQUEST_METHOD_VALUE_TRACE = "TRACE";
    ATTR_HTTP_REQUEST_METHOD_ORIGINAL = "http.request.method_original";
    ATTR_HTTP_REQUEST_RESEND_COUNT = "http.request.resend_count";
    ATTR_HTTP_RESPONSE_HEADER = function(key) {
      return "http.response.header." + key;
    };
    ATTR_HTTP_RESPONSE_STATUS_CODE = "http.response.status_code";
    ATTR_HTTP_ROUTE = "http.route";
    ATTR_JVM_GC_ACTION = "jvm.gc.action";
    ATTR_JVM_GC_NAME = "jvm.gc.name";
    ATTR_JVM_MEMORY_POOL_NAME = "jvm.memory.pool.name";
    ATTR_JVM_MEMORY_TYPE = "jvm.memory.type";
    JVM_MEMORY_TYPE_VALUE_HEAP = "heap";
    JVM_MEMORY_TYPE_VALUE_NON_HEAP = "non_heap";
    ATTR_JVM_THREAD_DAEMON = "jvm.thread.daemon";
    ATTR_JVM_THREAD_STATE = "jvm.thread.state";
    JVM_THREAD_STATE_VALUE_BLOCKED = "blocked";
    JVM_THREAD_STATE_VALUE_NEW = "new";
    JVM_THREAD_STATE_VALUE_RUNNABLE = "runnable";
    JVM_THREAD_STATE_VALUE_TERMINATED = "terminated";
    JVM_THREAD_STATE_VALUE_TIMED_WAITING = "timed_waiting";
    JVM_THREAD_STATE_VALUE_WAITING = "waiting";
    ATTR_NETWORK_LOCAL_ADDRESS = "network.local.address";
    ATTR_NETWORK_LOCAL_PORT = "network.local.port";
    ATTR_NETWORK_PEER_ADDRESS = "network.peer.address";
    ATTR_NETWORK_PEER_PORT = "network.peer.port";
    ATTR_NETWORK_PROTOCOL_NAME = "network.protocol.name";
    ATTR_NETWORK_PROTOCOL_VERSION = "network.protocol.version";
    ATTR_NETWORK_TRANSPORT = "network.transport";
    NETWORK_TRANSPORT_VALUE_PIPE = "pipe";
    NETWORK_TRANSPORT_VALUE_QUIC = "quic";
    NETWORK_TRANSPORT_VALUE_TCP = "tcp";
    NETWORK_TRANSPORT_VALUE_UDP = "udp";
    NETWORK_TRANSPORT_VALUE_UNIX = "unix";
    ATTR_NETWORK_TYPE = "network.type";
    NETWORK_TYPE_VALUE_IPV4 = "ipv4";
    NETWORK_TYPE_VALUE_IPV6 = "ipv6";
    ATTR_OTEL_SCOPE_NAME = "otel.scope.name";
    ATTR_OTEL_SCOPE_VERSION = "otel.scope.version";
    ATTR_OTEL_STATUS_CODE = "otel.status_code";
    OTEL_STATUS_CODE_VALUE_ERROR = "ERROR";
    OTEL_STATUS_CODE_VALUE_OK = "OK";
    ATTR_OTEL_STATUS_DESCRIPTION = "otel.status_description";
    ATTR_SERVER_ADDRESS = "server.address";
    ATTR_SERVER_PORT = "server.port";
    ATTR_SERVICE_NAME = "service.name";
    ATTR_SERVICE_VERSION = "service.version";
    ATTR_SIGNALR_CONNECTION_STATUS = "signalr.connection.status";
    SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN = "app_shutdown";
    SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE = "normal_closure";
    SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT = "timeout";
    ATTR_SIGNALR_TRANSPORT = "signalr.transport";
    SIGNALR_TRANSPORT_VALUE_LONG_POLLING = "long_polling";
    SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS = "server_sent_events";
    SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS = "web_sockets";
    ATTR_URL_FRAGMENT = "url.fragment";
    ATTR_URL_FULL = "url.full";
    ATTR_URL_PATH = "url.path";
    ATTR_URL_QUERY = "url.query";
    ATTR_URL_SCHEME = "url.scheme";
    ATTR_USER_AGENT_ORIGINAL = "user_agent.original";
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js
var METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS, METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES, METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE, METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION, METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS, METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS, METRIC_HTTP_CLIENT_REQUEST_DURATION, METRIC_HTTP_SERVER_REQUEST_DURATION, METRIC_JVM_CLASS_COUNT, METRIC_JVM_CLASS_LOADED, METRIC_JVM_CLASS_UNLOADED, METRIC_JVM_CPU_COUNT, METRIC_JVM_CPU_RECENT_UTILIZATION, METRIC_JVM_CPU_TIME, METRIC_JVM_GC_DURATION, METRIC_JVM_MEMORY_COMMITTED, METRIC_JVM_MEMORY_LIMIT, METRIC_JVM_MEMORY_USED, METRIC_JVM_MEMORY_USED_AFTER_LAST_GC, METRIC_JVM_THREAD_COUNT, METRIC_KESTREL_ACTIVE_CONNECTIONS, METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES, METRIC_KESTREL_CONNECTION_DURATION, METRIC_KESTREL_QUEUED_CONNECTIONS, METRIC_KESTREL_QUEUED_REQUESTS, METRIC_KESTREL_REJECTED_CONNECTIONS, METRIC_KESTREL_TLS_HANDSHAKE_DURATION, METRIC_KESTREL_UPGRADED_CONNECTIONS, METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS, METRIC_SIGNALR_SERVER_CONNECTION_DURATION;
var init_stable_metrics = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/stable_metrics.js"() {
    METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS = "aspnetcore.diagnostics.exceptions";
    METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES = "aspnetcore.rate_limiting.active_request_leases";
    METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS = "aspnetcore.rate_limiting.queued_requests";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE = "aspnetcore.rate_limiting.request.time_in_queue";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION = "aspnetcore.rate_limiting.request_lease.duration";
    METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS = "aspnetcore.rate_limiting.requests";
    METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS = "aspnetcore.routing.match_attempts";
    METRIC_HTTP_CLIENT_REQUEST_DURATION = "http.client.request.duration";
    METRIC_HTTP_SERVER_REQUEST_DURATION = "http.server.request.duration";
    METRIC_JVM_CLASS_COUNT = "jvm.class.count";
    METRIC_JVM_CLASS_LOADED = "jvm.class.loaded";
    METRIC_JVM_CLASS_UNLOADED = "jvm.class.unloaded";
    METRIC_JVM_CPU_COUNT = "jvm.cpu.count";
    METRIC_JVM_CPU_RECENT_UTILIZATION = "jvm.cpu.recent_utilization";
    METRIC_JVM_CPU_TIME = "jvm.cpu.time";
    METRIC_JVM_GC_DURATION = "jvm.gc.duration";
    METRIC_JVM_MEMORY_COMMITTED = "jvm.memory.committed";
    METRIC_JVM_MEMORY_LIMIT = "jvm.memory.limit";
    METRIC_JVM_MEMORY_USED = "jvm.memory.used";
    METRIC_JVM_MEMORY_USED_AFTER_LAST_GC = "jvm.memory.used_after_last_gc";
    METRIC_JVM_THREAD_COUNT = "jvm.thread.count";
    METRIC_KESTREL_ACTIVE_CONNECTIONS = "kestrel.active_connections";
    METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES = "kestrel.active_tls_handshakes";
    METRIC_KESTREL_CONNECTION_DURATION = "kestrel.connection.duration";
    METRIC_KESTREL_QUEUED_CONNECTIONS = "kestrel.queued_connections";
    METRIC_KESTREL_QUEUED_REQUESTS = "kestrel.queued_requests";
    METRIC_KESTREL_REJECTED_CONNECTIONS = "kestrel.rejected_connections";
    METRIC_KESTREL_TLS_HANDSHAKE_DURATION = "kestrel.tls_handshake.duration";
    METRIC_KESTREL_UPGRADED_CONNECTIONS = "kestrel.upgraded_connections";
    METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS = "signalr.server.active_connections";
    METRIC_SIGNALR_SERVER_CONNECTION_DURATION = "signalr.server.connection.duration";
  }
});

// ../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_ABORTED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_HANDLED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_SKIPPED,
  ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED: () => ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT_VALUE_UNHANDLED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ACQUIRED,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_ENDPOINT_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_GLOBAL_LIMITER,
  ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED: () => ASPNETCORE_RATE_LIMITING_RESULT_VALUE_REQUEST_CANCELED,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_FAILURE,
  ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS: () => ASPNETCORE_ROUTING_MATCH_STATUS_VALUE_SUCCESS,
  ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT: () => ATTR_ASPNETCORE_DIAGNOSTICS_EXCEPTION_RESULT,
  ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE: () => ATTR_ASPNETCORE_DIAGNOSTICS_HANDLER_TYPE,
  ATTR_ASPNETCORE_RATE_LIMITING_POLICY: () => ATTR_ASPNETCORE_RATE_LIMITING_POLICY,
  ATTR_ASPNETCORE_RATE_LIMITING_RESULT: () => ATTR_ASPNETCORE_RATE_LIMITING_RESULT,
  ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED: () => ATTR_ASPNETCORE_REQUEST_IS_UNHANDLED,
  ATTR_ASPNETCORE_ROUTING_IS_FALLBACK: () => ATTR_ASPNETCORE_ROUTING_IS_FALLBACK,
  ATTR_ASPNETCORE_ROUTING_MATCH_STATUS: () => ATTR_ASPNETCORE_ROUTING_MATCH_STATUS,
  ATTR_CLIENT_ADDRESS: () => ATTR_CLIENT_ADDRESS,
  ATTR_CLIENT_PORT: () => ATTR_CLIENT_PORT,
  ATTR_ERROR_TYPE: () => ATTR_ERROR_TYPE,
  ATTR_EXCEPTION_ESCAPED: () => ATTR_EXCEPTION_ESCAPED,
  ATTR_EXCEPTION_MESSAGE: () => ATTR_EXCEPTION_MESSAGE,
  ATTR_EXCEPTION_STACKTRACE: () => ATTR_EXCEPTION_STACKTRACE,
  ATTR_EXCEPTION_TYPE: () => ATTR_EXCEPTION_TYPE,
  ATTR_HTTP_REQUEST_HEADER: () => ATTR_HTTP_REQUEST_HEADER,
  ATTR_HTTP_REQUEST_METHOD: () => ATTR_HTTP_REQUEST_METHOD,
  ATTR_HTTP_REQUEST_METHOD_ORIGINAL: () => ATTR_HTTP_REQUEST_METHOD_ORIGINAL,
  ATTR_HTTP_REQUEST_RESEND_COUNT: () => ATTR_HTTP_REQUEST_RESEND_COUNT,
  ATTR_HTTP_RESPONSE_HEADER: () => ATTR_HTTP_RESPONSE_HEADER,
  ATTR_HTTP_RESPONSE_STATUS_CODE: () => ATTR_HTTP_RESPONSE_STATUS_CODE,
  ATTR_HTTP_ROUTE: () => ATTR_HTTP_ROUTE,
  ATTR_JVM_GC_ACTION: () => ATTR_JVM_GC_ACTION,
  ATTR_JVM_GC_NAME: () => ATTR_JVM_GC_NAME,
  ATTR_JVM_MEMORY_POOL_NAME: () => ATTR_JVM_MEMORY_POOL_NAME,
  ATTR_JVM_MEMORY_TYPE: () => ATTR_JVM_MEMORY_TYPE,
  ATTR_JVM_THREAD_DAEMON: () => ATTR_JVM_THREAD_DAEMON,
  ATTR_JVM_THREAD_STATE: () => ATTR_JVM_THREAD_STATE,
  ATTR_NETWORK_LOCAL_ADDRESS: () => ATTR_NETWORK_LOCAL_ADDRESS,
  ATTR_NETWORK_LOCAL_PORT: () => ATTR_NETWORK_LOCAL_PORT,
  ATTR_NETWORK_PEER_ADDRESS: () => ATTR_NETWORK_PEER_ADDRESS,
  ATTR_NETWORK_PEER_PORT: () => ATTR_NETWORK_PEER_PORT,
  ATTR_NETWORK_PROTOCOL_NAME: () => ATTR_NETWORK_PROTOCOL_NAME,
  ATTR_NETWORK_PROTOCOL_VERSION: () => ATTR_NETWORK_PROTOCOL_VERSION,
  ATTR_NETWORK_TRANSPORT: () => ATTR_NETWORK_TRANSPORT,
  ATTR_NETWORK_TYPE: () => ATTR_NETWORK_TYPE,
  ATTR_OTEL_SCOPE_NAME: () => ATTR_OTEL_SCOPE_NAME,
  ATTR_OTEL_SCOPE_VERSION: () => ATTR_OTEL_SCOPE_VERSION,
  ATTR_OTEL_STATUS_CODE: () => ATTR_OTEL_STATUS_CODE,
  ATTR_OTEL_STATUS_DESCRIPTION: () => ATTR_OTEL_STATUS_DESCRIPTION,
  ATTR_SERVER_ADDRESS: () => ATTR_SERVER_ADDRESS,
  ATTR_SERVER_PORT: () => ATTR_SERVER_PORT,
  ATTR_SERVICE_NAME: () => ATTR_SERVICE_NAME,
  ATTR_SERVICE_VERSION: () => ATTR_SERVICE_VERSION,
  ATTR_SIGNALR_CONNECTION_STATUS: () => ATTR_SIGNALR_CONNECTION_STATUS,
  ATTR_SIGNALR_TRANSPORT: () => ATTR_SIGNALR_TRANSPORT,
  ATTR_TELEMETRY_SDK_LANGUAGE: () => ATTR_TELEMETRY_SDK_LANGUAGE,
  ATTR_TELEMETRY_SDK_NAME: () => ATTR_TELEMETRY_SDK_NAME,
  ATTR_TELEMETRY_SDK_VERSION: () => ATTR_TELEMETRY_SDK_VERSION,
  ATTR_URL_FRAGMENT: () => ATTR_URL_FRAGMENT,
  ATTR_URL_FULL: () => ATTR_URL_FULL,
  ATTR_URL_PATH: () => ATTR_URL_PATH,
  ATTR_URL_QUERY: () => ATTR_URL_QUERY,
  ATTR_URL_SCHEME: () => ATTR_URL_SCHEME,
  ATTR_USER_AGENT_ORIGINAL: () => ATTR_USER_AGENT_ORIGINAL,
  AWSECSLAUNCHTYPEVALUES_EC2: () => AWSECSLAUNCHTYPEVALUES_EC2,
  AWSECSLAUNCHTYPEVALUES_FARGATE: () => AWSECSLAUNCHTYPEVALUES_FARGATE,
  AwsEcsLaunchtypeValues: () => AwsEcsLaunchtypeValues,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_ECS,
  CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC: () => CLOUDPLATFORMVALUES_ALIBABA_CLOUD_FC,
  CLOUDPLATFORMVALUES_AWS_EC2: () => CLOUDPLATFORMVALUES_AWS_EC2,
  CLOUDPLATFORMVALUES_AWS_ECS: () => CLOUDPLATFORMVALUES_AWS_ECS,
  CLOUDPLATFORMVALUES_AWS_EKS: () => CLOUDPLATFORMVALUES_AWS_EKS,
  CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK: () => CLOUDPLATFORMVALUES_AWS_ELASTIC_BEANSTALK,
  CLOUDPLATFORMVALUES_AWS_LAMBDA: () => CLOUDPLATFORMVALUES_AWS_LAMBDA,
  CLOUDPLATFORMVALUES_AZURE_AKS: () => CLOUDPLATFORMVALUES_AZURE_AKS,
  CLOUDPLATFORMVALUES_AZURE_APP_SERVICE: () => CLOUDPLATFORMVALUES_AZURE_APP_SERVICE,
  CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES: () => CLOUDPLATFORMVALUES_AZURE_CONTAINER_INSTANCES,
  CLOUDPLATFORMVALUES_AZURE_FUNCTIONS: () => CLOUDPLATFORMVALUES_AZURE_FUNCTIONS,
  CLOUDPLATFORMVALUES_AZURE_VM: () => CLOUDPLATFORMVALUES_AZURE_VM,
  CLOUDPLATFORMVALUES_GCP_APP_ENGINE: () => CLOUDPLATFORMVALUES_GCP_APP_ENGINE,
  CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS: () => CLOUDPLATFORMVALUES_GCP_CLOUD_FUNCTIONS,
  CLOUDPLATFORMVALUES_GCP_CLOUD_RUN: () => CLOUDPLATFORMVALUES_GCP_CLOUD_RUN,
  CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE: () => CLOUDPLATFORMVALUES_GCP_COMPUTE_ENGINE,
  CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE: () => CLOUDPLATFORMVALUES_GCP_KUBERNETES_ENGINE,
  CLOUDPROVIDERVALUES_ALIBABA_CLOUD: () => CLOUDPROVIDERVALUES_ALIBABA_CLOUD,
  CLOUDPROVIDERVALUES_AWS: () => CLOUDPROVIDERVALUES_AWS,
  CLOUDPROVIDERVALUES_AZURE: () => CLOUDPROVIDERVALUES_AZURE,
  CLOUDPROVIDERVALUES_GCP: () => CLOUDPROVIDERVALUES_GCP,
  CloudPlatformValues: () => CloudPlatformValues,
  CloudProviderValues: () => CloudProviderValues,
  DBCASSANDRACONSISTENCYLEVELVALUES_ALL: () => DBCASSANDRACONSISTENCYLEVELVALUES_ALL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ANY: () => DBCASSANDRACONSISTENCYLEVELVALUES_ANY,
  DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_EACH_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_LOCAL_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_ONE: () => DBCASSANDRACONSISTENCYLEVELVALUES_ONE,
  DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM: () => DBCASSANDRACONSISTENCYLEVELVALUES_QUORUM,
  DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL: () => DBCASSANDRACONSISTENCYLEVELVALUES_SERIAL,
  DBCASSANDRACONSISTENCYLEVELVALUES_THREE: () => DBCASSANDRACONSISTENCYLEVELVALUES_THREE,
  DBCASSANDRACONSISTENCYLEVELVALUES_TWO: () => DBCASSANDRACONSISTENCYLEVELVALUES_TWO,
  DBSYSTEMVALUES_ADABAS: () => DBSYSTEMVALUES_ADABAS,
  DBSYSTEMVALUES_CACHE: () => DBSYSTEMVALUES_CACHE,
  DBSYSTEMVALUES_CASSANDRA: () => DBSYSTEMVALUES_CASSANDRA,
  DBSYSTEMVALUES_CLOUDSCAPE: () => DBSYSTEMVALUES_CLOUDSCAPE,
  DBSYSTEMVALUES_COCKROACHDB: () => DBSYSTEMVALUES_COCKROACHDB,
  DBSYSTEMVALUES_COLDFUSION: () => DBSYSTEMVALUES_COLDFUSION,
  DBSYSTEMVALUES_COSMOSDB: () => DBSYSTEMVALUES_COSMOSDB,
  DBSYSTEMVALUES_COUCHBASE: () => DBSYSTEMVALUES_COUCHBASE,
  DBSYSTEMVALUES_COUCHDB: () => DBSYSTEMVALUES_COUCHDB,
  DBSYSTEMVALUES_DB2: () => DBSYSTEMVALUES_DB2,
  DBSYSTEMVALUES_DERBY: () => DBSYSTEMVALUES_DERBY,
  DBSYSTEMVALUES_DYNAMODB: () => DBSYSTEMVALUES_DYNAMODB,
  DBSYSTEMVALUES_EDB: () => DBSYSTEMVALUES_EDB,
  DBSYSTEMVALUES_ELASTICSEARCH: () => DBSYSTEMVALUES_ELASTICSEARCH,
  DBSYSTEMVALUES_FILEMAKER: () => DBSYSTEMVALUES_FILEMAKER,
  DBSYSTEMVALUES_FIREBIRD: () => DBSYSTEMVALUES_FIREBIRD,
  DBSYSTEMVALUES_FIRSTSQL: () => DBSYSTEMVALUES_FIRSTSQL,
  DBSYSTEMVALUES_GEODE: () => DBSYSTEMVALUES_GEODE,
  DBSYSTEMVALUES_H2: () => DBSYSTEMVALUES_H2,
  DBSYSTEMVALUES_HANADB: () => DBSYSTEMVALUES_HANADB,
  DBSYSTEMVALUES_HBASE: () => DBSYSTEMVALUES_HBASE,
  DBSYSTEMVALUES_HIVE: () => DBSYSTEMVALUES_HIVE,
  DBSYSTEMVALUES_HSQLDB: () => DBSYSTEMVALUES_HSQLDB,
  DBSYSTEMVALUES_INFORMIX: () => DBSYSTEMVALUES_INFORMIX,
  DBSYSTEMVALUES_INGRES: () => DBSYSTEMVALUES_INGRES,
  DBSYSTEMVALUES_INSTANTDB: () => DBSYSTEMVALUES_INSTANTDB,
  DBSYSTEMVALUES_INTERBASE: () => DBSYSTEMVALUES_INTERBASE,
  DBSYSTEMVALUES_MARIADB: () => DBSYSTEMVALUES_MARIADB,
  DBSYSTEMVALUES_MAXDB: () => DBSYSTEMVALUES_MAXDB,
  DBSYSTEMVALUES_MEMCACHED: () => DBSYSTEMVALUES_MEMCACHED,
  DBSYSTEMVALUES_MONGODB: () => DBSYSTEMVALUES_MONGODB,
  DBSYSTEMVALUES_MSSQL: () => DBSYSTEMVALUES_MSSQL,
  DBSYSTEMVALUES_MYSQL: () => DBSYSTEMVALUES_MYSQL,
  DBSYSTEMVALUES_NEO4J: () => DBSYSTEMVALUES_NEO4J,
  DBSYSTEMVALUES_NETEZZA: () => DBSYSTEMVALUES_NETEZZA,
  DBSYSTEMVALUES_ORACLE: () => DBSYSTEMVALUES_ORACLE,
  DBSYSTEMVALUES_OTHER_SQL: () => DBSYSTEMVALUES_OTHER_SQL,
  DBSYSTEMVALUES_PERVASIVE: () => DBSYSTEMVALUES_PERVASIVE,
  DBSYSTEMVALUES_POINTBASE: () => DBSYSTEMVALUES_POINTBASE,
  DBSYSTEMVALUES_POSTGRESQL: () => DBSYSTEMVALUES_POSTGRESQL,
  DBSYSTEMVALUES_PROGRESS: () => DBSYSTEMVALUES_PROGRESS,
  DBSYSTEMVALUES_REDIS: () => DBSYSTEMVALUES_REDIS,
  DBSYSTEMVALUES_REDSHIFT: () => DBSYSTEMVALUES_REDSHIFT,
  DBSYSTEMVALUES_SQLITE: () => DBSYSTEMVALUES_SQLITE,
  DBSYSTEMVALUES_SYBASE: () => DBSYSTEMVALUES_SYBASE,
  DBSYSTEMVALUES_TERADATA: () => DBSYSTEMVALUES_TERADATA,
  DBSYSTEMVALUES_VERTICA: () => DBSYSTEMVALUES_VERTICA,
  DbCassandraConsistencyLevelValues: () => DbCassandraConsistencyLevelValues,
  DbSystemValues: () => DbSystemValues,
  ERROR_TYPE_VALUE_OTHER: () => ERROR_TYPE_VALUE_OTHER,
  FAASDOCUMENTOPERATIONVALUES_DELETE: () => FAASDOCUMENTOPERATIONVALUES_DELETE,
  FAASDOCUMENTOPERATIONVALUES_EDIT: () => FAASDOCUMENTOPERATIONVALUES_EDIT,
  FAASDOCUMENTOPERATIONVALUES_INSERT: () => FAASDOCUMENTOPERATIONVALUES_INSERT,
  FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD: () => FAASINVOKEDPROVIDERVALUES_ALIBABA_CLOUD,
  FAASINVOKEDPROVIDERVALUES_AWS: () => FAASINVOKEDPROVIDERVALUES_AWS,
  FAASINVOKEDPROVIDERVALUES_AZURE: () => FAASINVOKEDPROVIDERVALUES_AZURE,
  FAASINVOKEDPROVIDERVALUES_GCP: () => FAASINVOKEDPROVIDERVALUES_GCP,
  FAASTRIGGERVALUES_DATASOURCE: () => FAASTRIGGERVALUES_DATASOURCE,
  FAASTRIGGERVALUES_HTTP: () => FAASTRIGGERVALUES_HTTP,
  FAASTRIGGERVALUES_OTHER: () => FAASTRIGGERVALUES_OTHER,
  FAASTRIGGERVALUES_PUBSUB: () => FAASTRIGGERVALUES_PUBSUB,
  FAASTRIGGERVALUES_TIMER: () => FAASTRIGGERVALUES_TIMER,
  FaasDocumentOperationValues: () => FaasDocumentOperationValues,
  FaasInvokedProviderValues: () => FaasInvokedProviderValues,
  FaasTriggerValues: () => FaasTriggerValues,
  HOSTARCHVALUES_AMD64: () => HOSTARCHVALUES_AMD64,
  HOSTARCHVALUES_ARM32: () => HOSTARCHVALUES_ARM32,
  HOSTARCHVALUES_ARM64: () => HOSTARCHVALUES_ARM64,
  HOSTARCHVALUES_IA64: () => HOSTARCHVALUES_IA64,
  HOSTARCHVALUES_PPC32: () => HOSTARCHVALUES_PPC32,
  HOSTARCHVALUES_PPC64: () => HOSTARCHVALUES_PPC64,
  HOSTARCHVALUES_X86: () => HOSTARCHVALUES_X86,
  HTTPFLAVORVALUES_HTTP_1_0: () => HTTPFLAVORVALUES_HTTP_1_0,
  HTTPFLAVORVALUES_HTTP_1_1: () => HTTPFLAVORVALUES_HTTP_1_1,
  HTTPFLAVORVALUES_HTTP_2_0: () => HTTPFLAVORVALUES_HTTP_2_0,
  HTTPFLAVORVALUES_QUIC: () => HTTPFLAVORVALUES_QUIC,
  HTTPFLAVORVALUES_SPDY: () => HTTPFLAVORVALUES_SPDY,
  HTTP_REQUEST_METHOD_VALUE_CONNECT: () => HTTP_REQUEST_METHOD_VALUE_CONNECT,
  HTTP_REQUEST_METHOD_VALUE_DELETE: () => HTTP_REQUEST_METHOD_VALUE_DELETE,
  HTTP_REQUEST_METHOD_VALUE_GET: () => HTTP_REQUEST_METHOD_VALUE_GET,
  HTTP_REQUEST_METHOD_VALUE_HEAD: () => HTTP_REQUEST_METHOD_VALUE_HEAD,
  HTTP_REQUEST_METHOD_VALUE_OPTIONS: () => HTTP_REQUEST_METHOD_VALUE_OPTIONS,
  HTTP_REQUEST_METHOD_VALUE_OTHER: () => HTTP_REQUEST_METHOD_VALUE_OTHER,
  HTTP_REQUEST_METHOD_VALUE_PATCH: () => HTTP_REQUEST_METHOD_VALUE_PATCH,
  HTTP_REQUEST_METHOD_VALUE_POST: () => HTTP_REQUEST_METHOD_VALUE_POST,
  HTTP_REQUEST_METHOD_VALUE_PUT: () => HTTP_REQUEST_METHOD_VALUE_PUT,
  HTTP_REQUEST_METHOD_VALUE_TRACE: () => HTTP_REQUEST_METHOD_VALUE_TRACE,
  HostArchValues: () => HostArchValues,
  HttpFlavorValues: () => HttpFlavorValues,
  JVM_MEMORY_TYPE_VALUE_HEAP: () => JVM_MEMORY_TYPE_VALUE_HEAP,
  JVM_MEMORY_TYPE_VALUE_NON_HEAP: () => JVM_MEMORY_TYPE_VALUE_NON_HEAP,
  JVM_THREAD_STATE_VALUE_BLOCKED: () => JVM_THREAD_STATE_VALUE_BLOCKED,
  JVM_THREAD_STATE_VALUE_NEW: () => JVM_THREAD_STATE_VALUE_NEW,
  JVM_THREAD_STATE_VALUE_RUNNABLE: () => JVM_THREAD_STATE_VALUE_RUNNABLE,
  JVM_THREAD_STATE_VALUE_TERMINATED: () => JVM_THREAD_STATE_VALUE_TERMINATED,
  JVM_THREAD_STATE_VALUE_TIMED_WAITING: () => JVM_THREAD_STATE_VALUE_TIMED_WAITING,
  JVM_THREAD_STATE_VALUE_WAITING: () => JVM_THREAD_STATE_VALUE_WAITING,
  MESSAGETYPEVALUES_RECEIVED: () => MESSAGETYPEVALUES_RECEIVED,
  MESSAGETYPEVALUES_SENT: () => MESSAGETYPEVALUES_SENT,
  MESSAGINGDESTINATIONKINDVALUES_QUEUE: () => MESSAGINGDESTINATIONKINDVALUES_QUEUE,
  MESSAGINGDESTINATIONKINDVALUES_TOPIC: () => MESSAGINGDESTINATIONKINDVALUES_TOPIC,
  MESSAGINGOPERATIONVALUES_PROCESS: () => MESSAGINGOPERATIONVALUES_PROCESS,
  MESSAGINGOPERATIONVALUES_RECEIVE: () => MESSAGINGOPERATIONVALUES_RECEIVE,
  METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS: () => METRIC_ASPNETCORE_DIAGNOSTICS_EXCEPTIONS,
  METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES: () => METRIC_ASPNETCORE_RATE_LIMITING_ACTIVE_REQUEST_LEASES,
  METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_QUEUED_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUESTS,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_LEASE_DURATION,
  METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE: () => METRIC_ASPNETCORE_RATE_LIMITING_REQUEST_TIME_IN_QUEUE,
  METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS: () => METRIC_ASPNETCORE_ROUTING_MATCH_ATTEMPTS,
  METRIC_HTTP_CLIENT_REQUEST_DURATION: () => METRIC_HTTP_CLIENT_REQUEST_DURATION,
  METRIC_HTTP_SERVER_REQUEST_DURATION: () => METRIC_HTTP_SERVER_REQUEST_DURATION,
  METRIC_JVM_CLASS_COUNT: () => METRIC_JVM_CLASS_COUNT,
  METRIC_JVM_CLASS_LOADED: () => METRIC_JVM_CLASS_LOADED,
  METRIC_JVM_CLASS_UNLOADED: () => METRIC_JVM_CLASS_UNLOADED,
  METRIC_JVM_CPU_COUNT: () => METRIC_JVM_CPU_COUNT,
  METRIC_JVM_CPU_RECENT_UTILIZATION: () => METRIC_JVM_CPU_RECENT_UTILIZATION,
  METRIC_JVM_CPU_TIME: () => METRIC_JVM_CPU_TIME,
  METRIC_JVM_GC_DURATION: () => METRIC_JVM_GC_DURATION,
  METRIC_JVM_MEMORY_COMMITTED: () => METRIC_JVM_MEMORY_COMMITTED,
  METRIC_JVM_MEMORY_LIMIT: () => METRIC_JVM_MEMORY_LIMIT,
  METRIC_JVM_MEMORY_USED: () => METRIC_JVM_MEMORY_USED,
  METRIC_JVM_MEMORY_USED_AFTER_LAST_GC: () => METRIC_JVM_MEMORY_USED_AFTER_LAST_GC,
  METRIC_JVM_THREAD_COUNT: () => METRIC_JVM_THREAD_COUNT,
  METRIC_KESTREL_ACTIVE_CONNECTIONS: () => METRIC_KESTREL_ACTIVE_CONNECTIONS,
  METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES: () => METRIC_KESTREL_ACTIVE_TLS_HANDSHAKES,
  METRIC_KESTREL_CONNECTION_DURATION: () => METRIC_KESTREL_CONNECTION_DURATION,
  METRIC_KESTREL_QUEUED_CONNECTIONS: () => METRIC_KESTREL_QUEUED_CONNECTIONS,
  METRIC_KESTREL_QUEUED_REQUESTS: () => METRIC_KESTREL_QUEUED_REQUESTS,
  METRIC_KESTREL_REJECTED_CONNECTIONS: () => METRIC_KESTREL_REJECTED_CONNECTIONS,
  METRIC_KESTREL_TLS_HANDSHAKE_DURATION: () => METRIC_KESTREL_TLS_HANDSHAKE_DURATION,
  METRIC_KESTREL_UPGRADED_CONNECTIONS: () => METRIC_KESTREL_UPGRADED_CONNECTIONS,
  METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS: () => METRIC_SIGNALR_SERVER_ACTIVE_CONNECTIONS,
  METRIC_SIGNALR_SERVER_CONNECTION_DURATION: () => METRIC_SIGNALR_SERVER_CONNECTION_DURATION,
  MessageTypeValues: () => MessageTypeValues,
  MessagingDestinationKindValues: () => MessagingDestinationKindValues,
  MessagingOperationValues: () => MessagingOperationValues,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT: () => NETHOSTCONNECTIONSUBTYPEVALUES_CDMA2000_1XRTT,
  NETHOSTCONNECTIONSUBTYPEVALUES_EDGE: () => NETHOSTCONNECTIONSUBTYPEVALUES_EDGE,
  NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD: () => NETHOSTCONNECTIONSUBTYPEVALUES_EHRPD,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_0,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_A,
  NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B: () => NETHOSTCONNECTIONSUBTYPEVALUES_EVDO_B,
  NETHOSTCONNECTIONSUBTYPEVALUES_GPRS: () => NETHOSTCONNECTIONSUBTYPEVALUES_GPRS,
  NETHOSTCONNECTIONSUBTYPEVALUES_GSM: () => NETHOSTCONNECTIONSUBTYPEVALUES_GSM,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSDPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSPAP,
  NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA: () => NETHOSTCONNECTIONSUBTYPEVALUES_HSUPA,
  NETHOSTCONNECTIONSUBTYPEVALUES_IDEN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IDEN,
  NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN: () => NETHOSTCONNECTIONSUBTYPEVALUES_IWLAN,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE,
  NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA: () => NETHOSTCONNECTIONSUBTYPEVALUES_LTE_CA,
  NETHOSTCONNECTIONSUBTYPEVALUES_NR: () => NETHOSTCONNECTIONSUBTYPEVALUES_NR,
  NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA: () => NETHOSTCONNECTIONSUBTYPEVALUES_NRNSA,
  NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA: () => NETHOSTCONNECTIONSUBTYPEVALUES_TD_SCDMA,
  NETHOSTCONNECTIONSUBTYPEVALUES_UMTS: () => NETHOSTCONNECTIONSUBTYPEVALUES_UMTS,
  NETHOSTCONNECTIONTYPEVALUES_CELL: () => NETHOSTCONNECTIONTYPEVALUES_CELL,
  NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE: () => NETHOSTCONNECTIONTYPEVALUES_UNAVAILABLE,
  NETHOSTCONNECTIONTYPEVALUES_UNKNOWN: () => NETHOSTCONNECTIONTYPEVALUES_UNKNOWN,
  NETHOSTCONNECTIONTYPEVALUES_WIFI: () => NETHOSTCONNECTIONTYPEVALUES_WIFI,
  NETHOSTCONNECTIONTYPEVALUES_WIRED: () => NETHOSTCONNECTIONTYPEVALUES_WIRED,
  NETTRANSPORTVALUES_INPROC: () => NETTRANSPORTVALUES_INPROC,
  NETTRANSPORTVALUES_IP: () => NETTRANSPORTVALUES_IP,
  NETTRANSPORTVALUES_IP_TCP: () => NETTRANSPORTVALUES_IP_TCP,
  NETTRANSPORTVALUES_IP_UDP: () => NETTRANSPORTVALUES_IP_UDP,
  NETTRANSPORTVALUES_OTHER: () => NETTRANSPORTVALUES_OTHER,
  NETTRANSPORTVALUES_PIPE: () => NETTRANSPORTVALUES_PIPE,
  NETTRANSPORTVALUES_UNIX: () => NETTRANSPORTVALUES_UNIX,
  NETWORK_TRANSPORT_VALUE_PIPE: () => NETWORK_TRANSPORT_VALUE_PIPE,
  NETWORK_TRANSPORT_VALUE_QUIC: () => NETWORK_TRANSPORT_VALUE_QUIC,
  NETWORK_TRANSPORT_VALUE_TCP: () => NETWORK_TRANSPORT_VALUE_TCP,
  NETWORK_TRANSPORT_VALUE_UDP: () => NETWORK_TRANSPORT_VALUE_UDP,
  NETWORK_TRANSPORT_VALUE_UNIX: () => NETWORK_TRANSPORT_VALUE_UNIX,
  NETWORK_TYPE_VALUE_IPV4: () => NETWORK_TYPE_VALUE_IPV4,
  NETWORK_TYPE_VALUE_IPV6: () => NETWORK_TYPE_VALUE_IPV6,
  NetHostConnectionSubtypeValues: () => NetHostConnectionSubtypeValues,
  NetHostConnectionTypeValues: () => NetHostConnectionTypeValues,
  NetTransportValues: () => NetTransportValues,
  OSTYPEVALUES_AIX: () => OSTYPEVALUES_AIX,
  OSTYPEVALUES_DARWIN: () => OSTYPEVALUES_DARWIN,
  OSTYPEVALUES_DRAGONFLYBSD: () => OSTYPEVALUES_DRAGONFLYBSD,
  OSTYPEVALUES_FREEBSD: () => OSTYPEVALUES_FREEBSD,
  OSTYPEVALUES_HPUX: () => OSTYPEVALUES_HPUX,
  OSTYPEVALUES_LINUX: () => OSTYPEVALUES_LINUX,
  OSTYPEVALUES_NETBSD: () => OSTYPEVALUES_NETBSD,
  OSTYPEVALUES_OPENBSD: () => OSTYPEVALUES_OPENBSD,
  OSTYPEVALUES_SOLARIS: () => OSTYPEVALUES_SOLARIS,
  OSTYPEVALUES_WINDOWS: () => OSTYPEVALUES_WINDOWS,
  OSTYPEVALUES_Z_OS: () => OSTYPEVALUES_Z_OS,
  OTEL_STATUS_CODE_VALUE_ERROR: () => OTEL_STATUS_CODE_VALUE_ERROR,
  OTEL_STATUS_CODE_VALUE_OK: () => OTEL_STATUS_CODE_VALUE_OK,
  OsTypeValues: () => OsTypeValues,
  RPCGRPCSTATUSCODEVALUES_ABORTED: () => RPCGRPCSTATUSCODEVALUES_ABORTED,
  RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS: () => RPCGRPCSTATUSCODEVALUES_ALREADY_EXISTS,
  RPCGRPCSTATUSCODEVALUES_CANCELLED: () => RPCGRPCSTATUSCODEVALUES_CANCELLED,
  RPCGRPCSTATUSCODEVALUES_DATA_LOSS: () => RPCGRPCSTATUSCODEVALUES_DATA_LOSS,
  RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED: () => RPCGRPCSTATUSCODEVALUES_DEADLINE_EXCEEDED,
  RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION: () => RPCGRPCSTATUSCODEVALUES_FAILED_PRECONDITION,
  RPCGRPCSTATUSCODEVALUES_INTERNAL: () => RPCGRPCSTATUSCODEVALUES_INTERNAL,
  RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT: () => RPCGRPCSTATUSCODEVALUES_INVALID_ARGUMENT,
  RPCGRPCSTATUSCODEVALUES_NOT_FOUND: () => RPCGRPCSTATUSCODEVALUES_NOT_FOUND,
  RPCGRPCSTATUSCODEVALUES_OK: () => RPCGRPCSTATUSCODEVALUES_OK,
  RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE: () => RPCGRPCSTATUSCODEVALUES_OUT_OF_RANGE,
  RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED: () => RPCGRPCSTATUSCODEVALUES_PERMISSION_DENIED,
  RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED: () => RPCGRPCSTATUSCODEVALUES_RESOURCE_EXHAUSTED,
  RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED: () => RPCGRPCSTATUSCODEVALUES_UNAUTHENTICATED,
  RPCGRPCSTATUSCODEVALUES_UNAVAILABLE: () => RPCGRPCSTATUSCODEVALUES_UNAVAILABLE,
  RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED: () => RPCGRPCSTATUSCODEVALUES_UNIMPLEMENTED,
  RPCGRPCSTATUSCODEVALUES_UNKNOWN: () => RPCGRPCSTATUSCODEVALUES_UNKNOWN,
  RpcGrpcStatusCodeValues: () => RpcGrpcStatusCodeValues,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTES_TO_GET,
  SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: () => SEMATTRS_AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS,
  SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ: () => SEMATTRS_AWS_DYNAMODB_CONSISTENT_READ,
  SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_CONSUMED_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_COUNT: () => SEMATTRS_AWS_DYNAMODB_COUNT,
  SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE: () => SEMATTRS_AWS_DYNAMODB_EXCLUSIVE_START_TABLE,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: () => SEMATTRS_AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES,
  SEMATTRS_AWS_DYNAMODB_INDEX_NAME: () => SEMATTRS_AWS_DYNAMODB_INDEX_NAME,
  SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS: () => SEMATTRS_AWS_DYNAMODB_ITEM_COLLECTION_METRICS,
  SEMATTRS_AWS_DYNAMODB_LIMIT: () => SEMATTRS_AWS_DYNAMODB_LIMIT,
  SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: () => SEMATTRS_AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES,
  SEMATTRS_AWS_DYNAMODB_PROJECTION: () => SEMATTRS_AWS_DYNAMODB_PROJECTION,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_READ_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: () => SEMATTRS_AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY,
  SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT: () => SEMATTRS_AWS_DYNAMODB_SCANNED_COUNT,
  SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD: () => SEMATTRS_AWS_DYNAMODB_SCAN_FORWARD,
  SEMATTRS_AWS_DYNAMODB_SEGMENT: () => SEMATTRS_AWS_DYNAMODB_SEGMENT,
  SEMATTRS_AWS_DYNAMODB_SELECT: () => SEMATTRS_AWS_DYNAMODB_SELECT,
  SEMATTRS_AWS_DYNAMODB_TABLE_COUNT: () => SEMATTRS_AWS_DYNAMODB_TABLE_COUNT,
  SEMATTRS_AWS_DYNAMODB_TABLE_NAMES: () => SEMATTRS_AWS_DYNAMODB_TABLE_NAMES,
  SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS: () => SEMATTRS_AWS_DYNAMODB_TOTAL_SEGMENTS,
  SEMATTRS_AWS_LAMBDA_INVOKED_ARN: () => SEMATTRS_AWS_LAMBDA_INVOKED_ARN,
  SEMATTRS_CODE_FILEPATH: () => SEMATTRS_CODE_FILEPATH,
  SEMATTRS_CODE_FUNCTION: () => SEMATTRS_CODE_FUNCTION,
  SEMATTRS_CODE_LINENO: () => SEMATTRS_CODE_LINENO,
  SEMATTRS_CODE_NAMESPACE: () => SEMATTRS_CODE_NAMESPACE,
  SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL: () => SEMATTRS_DB_CASSANDRA_CONSISTENCY_LEVEL,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_DC: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_DC,
  SEMATTRS_DB_CASSANDRA_COORDINATOR_ID: () => SEMATTRS_DB_CASSANDRA_COORDINATOR_ID,
  SEMATTRS_DB_CASSANDRA_IDEMPOTENCE: () => SEMATTRS_DB_CASSANDRA_IDEMPOTENCE,
  SEMATTRS_DB_CASSANDRA_KEYSPACE: () => SEMATTRS_DB_CASSANDRA_KEYSPACE,
  SEMATTRS_DB_CASSANDRA_PAGE_SIZE: () => SEMATTRS_DB_CASSANDRA_PAGE_SIZE,
  SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: () => SEMATTRS_DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT,
  SEMATTRS_DB_CASSANDRA_TABLE: () => SEMATTRS_DB_CASSANDRA_TABLE,
  SEMATTRS_DB_CONNECTION_STRING: () => SEMATTRS_DB_CONNECTION_STRING,
  SEMATTRS_DB_HBASE_NAMESPACE: () => SEMATTRS_DB_HBASE_NAMESPACE,
  SEMATTRS_DB_JDBC_DRIVER_CLASSNAME: () => SEMATTRS_DB_JDBC_DRIVER_CLASSNAME,
  SEMATTRS_DB_MONGODB_COLLECTION: () => SEMATTRS_DB_MONGODB_COLLECTION,
  SEMATTRS_DB_MSSQL_INSTANCE_NAME: () => SEMATTRS_DB_MSSQL_INSTANCE_NAME,
  SEMATTRS_DB_NAME: () => SEMATTRS_DB_NAME,
  SEMATTRS_DB_OPERATION: () => SEMATTRS_DB_OPERATION,
  SEMATTRS_DB_REDIS_DATABASE_INDEX: () => SEMATTRS_DB_REDIS_DATABASE_INDEX,
  SEMATTRS_DB_SQL_TABLE: () => SEMATTRS_DB_SQL_TABLE,
  SEMATTRS_DB_STATEMENT: () => SEMATTRS_DB_STATEMENT,
  SEMATTRS_DB_SYSTEM: () => SEMATTRS_DB_SYSTEM,
  SEMATTRS_DB_USER: () => SEMATTRS_DB_USER,
  SEMATTRS_ENDUSER_ID: () => SEMATTRS_ENDUSER_ID,
  SEMATTRS_ENDUSER_ROLE: () => SEMATTRS_ENDUSER_ROLE,
  SEMATTRS_ENDUSER_SCOPE: () => SEMATTRS_ENDUSER_SCOPE,
  SEMATTRS_EXCEPTION_ESCAPED: () => SEMATTRS_EXCEPTION_ESCAPED,
  SEMATTRS_EXCEPTION_MESSAGE: () => SEMATTRS_EXCEPTION_MESSAGE,
  SEMATTRS_EXCEPTION_STACKTRACE: () => SEMATTRS_EXCEPTION_STACKTRACE,
  SEMATTRS_EXCEPTION_TYPE: () => SEMATTRS_EXCEPTION_TYPE,
  SEMATTRS_FAAS_COLDSTART: () => SEMATTRS_FAAS_COLDSTART,
  SEMATTRS_FAAS_CRON: () => SEMATTRS_FAAS_CRON,
  SEMATTRS_FAAS_DOCUMENT_COLLECTION: () => SEMATTRS_FAAS_DOCUMENT_COLLECTION,
  SEMATTRS_FAAS_DOCUMENT_NAME: () => SEMATTRS_FAAS_DOCUMENT_NAME,
  SEMATTRS_FAAS_DOCUMENT_OPERATION: () => SEMATTRS_FAAS_DOCUMENT_OPERATION,
  SEMATTRS_FAAS_DOCUMENT_TIME: () => SEMATTRS_FAAS_DOCUMENT_TIME,
  SEMATTRS_FAAS_EXECUTION: () => SEMATTRS_FAAS_EXECUTION,
  SEMATTRS_FAAS_INVOKED_NAME: () => SEMATTRS_FAAS_INVOKED_NAME,
  SEMATTRS_FAAS_INVOKED_PROVIDER: () => SEMATTRS_FAAS_INVOKED_PROVIDER,
  SEMATTRS_FAAS_INVOKED_REGION: () => SEMATTRS_FAAS_INVOKED_REGION,
  SEMATTRS_FAAS_TIME: () => SEMATTRS_FAAS_TIME,
  SEMATTRS_FAAS_TRIGGER: () => SEMATTRS_FAAS_TRIGGER,
  SEMATTRS_HTTP_CLIENT_IP: () => SEMATTRS_HTTP_CLIENT_IP,
  SEMATTRS_HTTP_FLAVOR: () => SEMATTRS_HTTP_FLAVOR,
  SEMATTRS_HTTP_HOST: () => SEMATTRS_HTTP_HOST,
  SEMATTRS_HTTP_METHOD: () => SEMATTRS_HTTP_METHOD,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH,
  SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH,
  SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: () => SEMATTRS_HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED,
  SEMATTRS_HTTP_ROUTE: () => SEMATTRS_HTTP_ROUTE,
  SEMATTRS_HTTP_SCHEME: () => SEMATTRS_HTTP_SCHEME,
  SEMATTRS_HTTP_SERVER_NAME: () => SEMATTRS_HTTP_SERVER_NAME,
  SEMATTRS_HTTP_STATUS_CODE: () => SEMATTRS_HTTP_STATUS_CODE,
  SEMATTRS_HTTP_TARGET: () => SEMATTRS_HTTP_TARGET,
  SEMATTRS_HTTP_URL: () => SEMATTRS_HTTP_URL,
  SEMATTRS_HTTP_USER_AGENT: () => SEMATTRS_HTTP_USER_AGENT,
  SEMATTRS_MESSAGE_COMPRESSED_SIZE: () => SEMATTRS_MESSAGE_COMPRESSED_SIZE,
  SEMATTRS_MESSAGE_ID: () => SEMATTRS_MESSAGE_ID,
  SEMATTRS_MESSAGE_TYPE: () => SEMATTRS_MESSAGE_TYPE,
  SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE: () => SEMATTRS_MESSAGE_UNCOMPRESSED_SIZE,
  SEMATTRS_MESSAGING_CONSUMER_ID: () => SEMATTRS_MESSAGING_CONSUMER_ID,
  SEMATTRS_MESSAGING_CONVERSATION_ID: () => SEMATTRS_MESSAGING_CONVERSATION_ID,
  SEMATTRS_MESSAGING_DESTINATION: () => SEMATTRS_MESSAGING_DESTINATION,
  SEMATTRS_MESSAGING_DESTINATION_KIND: () => SEMATTRS_MESSAGING_DESTINATION_KIND,
  SEMATTRS_MESSAGING_KAFKA_CLIENT_ID: () => SEMATTRS_MESSAGING_KAFKA_CLIENT_ID,
  SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP: () => SEMATTRS_MESSAGING_KAFKA_CONSUMER_GROUP,
  SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY: () => SEMATTRS_MESSAGING_KAFKA_MESSAGE_KEY,
  SEMATTRS_MESSAGING_KAFKA_PARTITION: () => SEMATTRS_MESSAGING_KAFKA_PARTITION,
  SEMATTRS_MESSAGING_KAFKA_TOMBSTONE: () => SEMATTRS_MESSAGING_KAFKA_TOMBSTONE,
  SEMATTRS_MESSAGING_MESSAGE_ID: () => SEMATTRS_MESSAGING_MESSAGE_ID,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES,
  SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: () => SEMATTRS_MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES,
  SEMATTRS_MESSAGING_OPERATION: () => SEMATTRS_MESSAGING_OPERATION,
  SEMATTRS_MESSAGING_PROTOCOL: () => SEMATTRS_MESSAGING_PROTOCOL,
  SEMATTRS_MESSAGING_PROTOCOL_VERSION: () => SEMATTRS_MESSAGING_PROTOCOL_VERSION,
  SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY: () => SEMATTRS_MESSAGING_RABBITMQ_ROUTING_KEY,
  SEMATTRS_MESSAGING_SYSTEM: () => SEMATTRS_MESSAGING_SYSTEM,
  SEMATTRS_MESSAGING_TEMP_DESTINATION: () => SEMATTRS_MESSAGING_TEMP_DESTINATION,
  SEMATTRS_MESSAGING_URL: () => SEMATTRS_MESSAGING_URL,
  SEMATTRS_NET_HOST_CARRIER_ICC: () => SEMATTRS_NET_HOST_CARRIER_ICC,
  SEMATTRS_NET_HOST_CARRIER_MCC: () => SEMATTRS_NET_HOST_CARRIER_MCC,
  SEMATTRS_NET_HOST_CARRIER_MNC: () => SEMATTRS_NET_HOST_CARRIER_MNC,
  SEMATTRS_NET_HOST_CARRIER_NAME: () => SEMATTRS_NET_HOST_CARRIER_NAME,
  SEMATTRS_NET_HOST_CONNECTION_SUBTYPE: () => SEMATTRS_NET_HOST_CONNECTION_SUBTYPE,
  SEMATTRS_NET_HOST_CONNECTION_TYPE: () => SEMATTRS_NET_HOST_CONNECTION_TYPE,
  SEMATTRS_NET_HOST_IP: () => SEMATTRS_NET_HOST_IP,
  SEMATTRS_NET_HOST_NAME: () => SEMATTRS_NET_HOST_NAME,
  SEMATTRS_NET_HOST_PORT: () => SEMATTRS_NET_HOST_PORT,
  SEMATTRS_NET_PEER_IP: () => SEMATTRS_NET_PEER_IP,
  SEMATTRS_NET_PEER_NAME: () => SEMATTRS_NET_PEER_NAME,
  SEMATTRS_NET_PEER_PORT: () => SEMATTRS_NET_PEER_PORT,
  SEMATTRS_NET_TRANSPORT: () => SEMATTRS_NET_TRANSPORT,
  SEMATTRS_PEER_SERVICE: () => SEMATTRS_PEER_SERVICE,
  SEMATTRS_RPC_GRPC_STATUS_CODE: () => SEMATTRS_RPC_GRPC_STATUS_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_CODE: () => SEMATTRS_RPC_JSONRPC_ERROR_CODE,
  SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE: () => SEMATTRS_RPC_JSONRPC_ERROR_MESSAGE,
  SEMATTRS_RPC_JSONRPC_REQUEST_ID: () => SEMATTRS_RPC_JSONRPC_REQUEST_ID,
  SEMATTRS_RPC_JSONRPC_VERSION: () => SEMATTRS_RPC_JSONRPC_VERSION,
  SEMATTRS_RPC_METHOD: () => SEMATTRS_RPC_METHOD,
  SEMATTRS_RPC_SERVICE: () => SEMATTRS_RPC_SERVICE,
  SEMATTRS_RPC_SYSTEM: () => SEMATTRS_RPC_SYSTEM,
  SEMATTRS_THREAD_ID: () => SEMATTRS_THREAD_ID,
  SEMATTRS_THREAD_NAME: () => SEMATTRS_THREAD_NAME,
  SEMRESATTRS_AWS_ECS_CLUSTER_ARN: () => SEMRESATTRS_AWS_ECS_CLUSTER_ARN,
  SEMRESATTRS_AWS_ECS_CONTAINER_ARN: () => SEMRESATTRS_AWS_ECS_CONTAINER_ARN,
  SEMRESATTRS_AWS_ECS_LAUNCHTYPE: () => SEMRESATTRS_AWS_ECS_LAUNCHTYPE,
  SEMRESATTRS_AWS_ECS_TASK_ARN: () => SEMRESATTRS_AWS_ECS_TASK_ARN,
  SEMRESATTRS_AWS_ECS_TASK_FAMILY: () => SEMRESATTRS_AWS_ECS_TASK_FAMILY,
  SEMRESATTRS_AWS_ECS_TASK_REVISION: () => SEMRESATTRS_AWS_ECS_TASK_REVISION,
  SEMRESATTRS_AWS_EKS_CLUSTER_ARN: () => SEMRESATTRS_AWS_EKS_CLUSTER_ARN,
  SEMRESATTRS_AWS_LOG_GROUP_ARNS: () => SEMRESATTRS_AWS_LOG_GROUP_ARNS,
  SEMRESATTRS_AWS_LOG_GROUP_NAMES: () => SEMRESATTRS_AWS_LOG_GROUP_NAMES,
  SEMRESATTRS_AWS_LOG_STREAM_ARNS: () => SEMRESATTRS_AWS_LOG_STREAM_ARNS,
  SEMRESATTRS_AWS_LOG_STREAM_NAMES: () => SEMRESATTRS_AWS_LOG_STREAM_NAMES,
  SEMRESATTRS_CLOUD_ACCOUNT_ID: () => SEMRESATTRS_CLOUD_ACCOUNT_ID,
  SEMRESATTRS_CLOUD_AVAILABILITY_ZONE: () => SEMRESATTRS_CLOUD_AVAILABILITY_ZONE,
  SEMRESATTRS_CLOUD_PLATFORM: () => SEMRESATTRS_CLOUD_PLATFORM,
  SEMRESATTRS_CLOUD_PROVIDER: () => SEMRESATTRS_CLOUD_PROVIDER,
  SEMRESATTRS_CLOUD_REGION: () => SEMRESATTRS_CLOUD_REGION,
  SEMRESATTRS_CONTAINER_ID: () => SEMRESATTRS_CONTAINER_ID,
  SEMRESATTRS_CONTAINER_IMAGE_NAME: () => SEMRESATTRS_CONTAINER_IMAGE_NAME,
  SEMRESATTRS_CONTAINER_IMAGE_TAG: () => SEMRESATTRS_CONTAINER_IMAGE_TAG,
  SEMRESATTRS_CONTAINER_NAME: () => SEMRESATTRS_CONTAINER_NAME,
  SEMRESATTRS_CONTAINER_RUNTIME: () => SEMRESATTRS_CONTAINER_RUNTIME,
  SEMRESATTRS_DEPLOYMENT_ENVIRONMENT: () => SEMRESATTRS_DEPLOYMENT_ENVIRONMENT,
  SEMRESATTRS_DEVICE_ID: () => SEMRESATTRS_DEVICE_ID,
  SEMRESATTRS_DEVICE_MODEL_IDENTIFIER: () => SEMRESATTRS_DEVICE_MODEL_IDENTIFIER,
  SEMRESATTRS_DEVICE_MODEL_NAME: () => SEMRESATTRS_DEVICE_MODEL_NAME,
  SEMRESATTRS_FAAS_ID: () => SEMRESATTRS_FAAS_ID,
  SEMRESATTRS_FAAS_INSTANCE: () => SEMRESATTRS_FAAS_INSTANCE,
  SEMRESATTRS_FAAS_MAX_MEMORY: () => SEMRESATTRS_FAAS_MAX_MEMORY,
  SEMRESATTRS_FAAS_NAME: () => SEMRESATTRS_FAAS_NAME,
  SEMRESATTRS_FAAS_VERSION: () => SEMRESATTRS_FAAS_VERSION,
  SEMRESATTRS_HOST_ARCH: () => SEMRESATTRS_HOST_ARCH,
  SEMRESATTRS_HOST_ID: () => SEMRESATTRS_HOST_ID,
  SEMRESATTRS_HOST_IMAGE_ID: () => SEMRESATTRS_HOST_IMAGE_ID,
  SEMRESATTRS_HOST_IMAGE_NAME: () => SEMRESATTRS_HOST_IMAGE_NAME,
  SEMRESATTRS_HOST_IMAGE_VERSION: () => SEMRESATTRS_HOST_IMAGE_VERSION,
  SEMRESATTRS_HOST_NAME: () => SEMRESATTRS_HOST_NAME,
  SEMRESATTRS_HOST_TYPE: () => SEMRESATTRS_HOST_TYPE,
  SEMRESATTRS_K8S_CLUSTER_NAME: () => SEMRESATTRS_K8S_CLUSTER_NAME,
  SEMRESATTRS_K8S_CONTAINER_NAME: () => SEMRESATTRS_K8S_CONTAINER_NAME,
  SEMRESATTRS_K8S_CRONJOB_NAME: () => SEMRESATTRS_K8S_CRONJOB_NAME,
  SEMRESATTRS_K8S_CRONJOB_UID: () => SEMRESATTRS_K8S_CRONJOB_UID,
  SEMRESATTRS_K8S_DAEMONSET_NAME: () => SEMRESATTRS_K8S_DAEMONSET_NAME,
  SEMRESATTRS_K8S_DAEMONSET_UID: () => SEMRESATTRS_K8S_DAEMONSET_UID,
  SEMRESATTRS_K8S_DEPLOYMENT_NAME: () => SEMRESATTRS_K8S_DEPLOYMENT_NAME,
  SEMRESATTRS_K8S_DEPLOYMENT_UID: () => SEMRESATTRS_K8S_DEPLOYMENT_UID,
  SEMRESATTRS_K8S_JOB_NAME: () => SEMRESATTRS_K8S_JOB_NAME,
  SEMRESATTRS_K8S_JOB_UID: () => SEMRESATTRS_K8S_JOB_UID,
  SEMRESATTRS_K8S_NAMESPACE_NAME: () => SEMRESATTRS_K8S_NAMESPACE_NAME,
  SEMRESATTRS_K8S_NODE_NAME: () => SEMRESATTRS_K8S_NODE_NAME,
  SEMRESATTRS_K8S_NODE_UID: () => SEMRESATTRS_K8S_NODE_UID,
  SEMRESATTRS_K8S_POD_NAME: () => SEMRESATTRS_K8S_POD_NAME,
  SEMRESATTRS_K8S_POD_UID: () => SEMRESATTRS_K8S_POD_UID,
  SEMRESATTRS_K8S_REPLICASET_NAME: () => SEMRESATTRS_K8S_REPLICASET_NAME,
  SEMRESATTRS_K8S_REPLICASET_UID: () => SEMRESATTRS_K8S_REPLICASET_UID,
  SEMRESATTRS_K8S_STATEFULSET_NAME: () => SEMRESATTRS_K8S_STATEFULSET_NAME,
  SEMRESATTRS_K8S_STATEFULSET_UID: () => SEMRESATTRS_K8S_STATEFULSET_UID,
  SEMRESATTRS_OS_DESCRIPTION: () => SEMRESATTRS_OS_DESCRIPTION,
  SEMRESATTRS_OS_NAME: () => SEMRESATTRS_OS_NAME,
  SEMRESATTRS_OS_TYPE: () => SEMRESATTRS_OS_TYPE,
  SEMRESATTRS_OS_VERSION: () => SEMRESATTRS_OS_VERSION,
  SEMRESATTRS_PROCESS_COMMAND: () => SEMRESATTRS_PROCESS_COMMAND,
  SEMRESATTRS_PROCESS_COMMAND_ARGS: () => SEMRESATTRS_PROCESS_COMMAND_ARGS,
  SEMRESATTRS_PROCESS_COMMAND_LINE: () => SEMRESATTRS_PROCESS_COMMAND_LINE,
  SEMRESATTRS_PROCESS_EXECUTABLE_NAME: () => SEMRESATTRS_PROCESS_EXECUTABLE_NAME,
  SEMRESATTRS_PROCESS_EXECUTABLE_PATH: () => SEMRESATTRS_PROCESS_EXECUTABLE_PATH,
  SEMRESATTRS_PROCESS_OWNER: () => SEMRESATTRS_PROCESS_OWNER,
  SEMRESATTRS_PROCESS_PID: () => SEMRESATTRS_PROCESS_PID,
  SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION: () => SEMRESATTRS_PROCESS_RUNTIME_DESCRIPTION,
  SEMRESATTRS_PROCESS_RUNTIME_NAME: () => SEMRESATTRS_PROCESS_RUNTIME_NAME,
  SEMRESATTRS_PROCESS_RUNTIME_VERSION: () => SEMRESATTRS_PROCESS_RUNTIME_VERSION,
  SEMRESATTRS_SERVICE_INSTANCE_ID: () => SEMRESATTRS_SERVICE_INSTANCE_ID,
  SEMRESATTRS_SERVICE_NAME: () => SEMRESATTRS_SERVICE_NAME,
  SEMRESATTRS_SERVICE_NAMESPACE: () => SEMRESATTRS_SERVICE_NAMESPACE,
  SEMRESATTRS_SERVICE_VERSION: () => SEMRESATTRS_SERVICE_VERSION,
  SEMRESATTRS_TELEMETRY_AUTO_VERSION: () => SEMRESATTRS_TELEMETRY_AUTO_VERSION,
  SEMRESATTRS_TELEMETRY_SDK_LANGUAGE: () => SEMRESATTRS_TELEMETRY_SDK_LANGUAGE,
  SEMRESATTRS_TELEMETRY_SDK_NAME: () => SEMRESATTRS_TELEMETRY_SDK_NAME,
  SEMRESATTRS_TELEMETRY_SDK_VERSION: () => SEMRESATTRS_TELEMETRY_SDK_VERSION,
  SEMRESATTRS_WEBENGINE_DESCRIPTION: () => SEMRESATTRS_WEBENGINE_DESCRIPTION,
  SEMRESATTRS_WEBENGINE_NAME: () => SEMRESATTRS_WEBENGINE_NAME,
  SEMRESATTRS_WEBENGINE_VERSION: () => SEMRESATTRS_WEBENGINE_VERSION,
  SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN: () => SIGNALR_CONNECTION_STATUS_VALUE_APP_SHUTDOWN,
  SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE: () => SIGNALR_CONNECTION_STATUS_VALUE_NORMAL_CLOSURE,
  SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT: () => SIGNALR_CONNECTION_STATUS_VALUE_TIMEOUT,
  SIGNALR_TRANSPORT_VALUE_LONG_POLLING: () => SIGNALR_TRANSPORT_VALUE_LONG_POLLING,
  SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS: () => SIGNALR_TRANSPORT_VALUE_SERVER_SENT_EVENTS,
  SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS: () => SIGNALR_TRANSPORT_VALUE_WEB_SOCKETS,
  SemanticAttributes: () => SemanticAttributes,
  SemanticResourceAttributes: () => SemanticResourceAttributes,
  TELEMETRYSDKLANGUAGEVALUES_CPP: () => TELEMETRYSDKLANGUAGEVALUES_CPP,
  TELEMETRYSDKLANGUAGEVALUES_DOTNET: () => TELEMETRYSDKLANGUAGEVALUES_DOTNET,
  TELEMETRYSDKLANGUAGEVALUES_ERLANG: () => TELEMETRYSDKLANGUAGEVALUES_ERLANG,
  TELEMETRYSDKLANGUAGEVALUES_GO: () => TELEMETRYSDKLANGUAGEVALUES_GO,
  TELEMETRYSDKLANGUAGEVALUES_JAVA: () => TELEMETRYSDKLANGUAGEVALUES_JAVA,
  TELEMETRYSDKLANGUAGEVALUES_NODEJS: () => TELEMETRYSDKLANGUAGEVALUES_NODEJS,
  TELEMETRYSDKLANGUAGEVALUES_PHP: () => TELEMETRYSDKLANGUAGEVALUES_PHP,
  TELEMETRYSDKLANGUAGEVALUES_PYTHON: () => TELEMETRYSDKLANGUAGEVALUES_PYTHON,
  TELEMETRYSDKLANGUAGEVALUES_RUBY: () => TELEMETRYSDKLANGUAGEVALUES_RUBY,
  TELEMETRYSDKLANGUAGEVALUES_WEBJS: () => TELEMETRYSDKLANGUAGEVALUES_WEBJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_CPP: () => TELEMETRY_SDK_LANGUAGE_VALUE_CPP,
  TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET: () => TELEMETRY_SDK_LANGUAGE_VALUE_DOTNET,
  TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG: () => TELEMETRY_SDK_LANGUAGE_VALUE_ERLANG,
  TELEMETRY_SDK_LANGUAGE_VALUE_GO: () => TELEMETRY_SDK_LANGUAGE_VALUE_GO,
  TELEMETRY_SDK_LANGUAGE_VALUE_JAVA: () => TELEMETRY_SDK_LANGUAGE_VALUE_JAVA,
  TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_NODEJS,
  TELEMETRY_SDK_LANGUAGE_VALUE_PHP: () => TELEMETRY_SDK_LANGUAGE_VALUE_PHP,
  TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON: () => TELEMETRY_SDK_LANGUAGE_VALUE_PYTHON,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUBY: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUBY,
  TELEMETRY_SDK_LANGUAGE_VALUE_RUST: () => TELEMETRY_SDK_LANGUAGE_VALUE_RUST,
  TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT: () => TELEMETRY_SDK_LANGUAGE_VALUE_SWIFT,
  TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS: () => TELEMETRY_SDK_LANGUAGE_VALUE_WEBJS,
  TelemetrySdkLanguageValues: () => TelemetrySdkLanguageValues
});
var init_esm2 = __esm({
  "../../node_modules/@opentelemetry/core/node_modules/@opentelemetry/semantic-conventions/build/esm/index.js"() {
    init_trace2();
    init_resource();
    init_stable_attributes();
    init_stable_metrics();
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js
var require_sdk_info = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/sdk-info.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SDK_INFO = void 0;
    var version_1 = require_version();
    var semantic_conventions_1 = (init_esm2(), __toCommonJS(esm_exports2));
    exports2.SDK_INFO = {
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_NAME]: "opentelemetry",
      [semantic_conventions_1.SEMRESATTRS_PROCESS_RUNTIME_NAME]: "node",
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_LANGUAGE]: semantic_conventions_1.TELEMETRYSDKLANGUAGEVALUES_NODEJS,
      [semantic_conventions_1.SEMRESATTRS_TELEMETRY_SDK_VERSION]: version_1.VERSION
    };
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js
var require_timer_util = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/timer-util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = void 0;
    function unrefTimer(timer) {
      timer.unref();
    }
    exports2.unrefTimer = unrefTimer;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/node/index.js
var require_node = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = exports2.SDK_INFO = exports2.otperformance = exports2.RandomIdGenerator = exports2.hexToBase64 = exports2._globalThis = exports2.getEnv = exports2.getEnvWithoutDefaults = void 0;
    var environment_1 = require_environment2();
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return environment_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return environment_1.getEnv;
    } });
    var globalThis_1 = require_globalThis();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return globalThis_1._globalThis;
    } });
    var hex_to_base64_1 = require_hex_to_base64();
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return hex_to_base64_1.hexToBase64;
    } });
    var RandomIdGenerator_1 = require_RandomIdGenerator();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return RandomIdGenerator_1.RandomIdGenerator;
    } });
    var performance_1 = require_performance();
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return performance_1.otperformance;
    } });
    var sdk_info_1 = require_sdk_info();
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return sdk_info_1.SDK_INFO;
    } });
    var timer_util_1 = require_timer_util();
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return timer_util_1.unrefTimer;
    } });
  }
});

// ../../node_modules/@opentelemetry/core/build/src/platform/index.js
var require_platform = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = void 0;
    var node_1 = require_node();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return node_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return node_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return node_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return node_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return node_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return node_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return node_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return node_1.unrefTimer;
    } });
  }
});

// ../../node_modules/@opentelemetry/core/build/src/common/time.js
var require_time = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/common/time.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addHrTimes = exports2.isTimeInput = exports2.isTimeInputHrTime = exports2.hrTimeToMicroseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToNanoseconds = exports2.hrTimeToTimeStamp = exports2.hrTimeDuration = exports2.timeInputToHrTime = exports2.hrTime = exports2.getTimeOrigin = exports2.millisToHrTime = void 0;
    var platform_1 = require_platform();
    var NANOSECOND_DIGITS = 9;
    var NANOSECOND_DIGITS_IN_MILLIS = 6;
    var MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    var SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
    function millisToHrTime(epochMillis) {
      const epochSeconds = epochMillis / 1e3;
      const seconds = Math.trunc(epochSeconds);
      const nanos = Math.round(epochMillis % 1e3 * MILLISECONDS_TO_NANOSECONDS);
      return [seconds, nanos];
    }
    exports2.millisToHrTime = millisToHrTime;
    function getTimeOrigin() {
      let timeOrigin = platform_1.otperformance.timeOrigin;
      if (typeof timeOrigin !== "number") {
        const perf = platform_1.otperformance;
        timeOrigin = perf.timing && perf.timing.fetchStart;
      }
      return timeOrigin;
    }
    exports2.getTimeOrigin = getTimeOrigin;
    function hrTime(performanceNow) {
      const timeOrigin = millisToHrTime(getTimeOrigin());
      const now = millisToHrTime(typeof performanceNow === "number" ? performanceNow : platform_1.otperformance.now());
      return addHrTimes(timeOrigin, now);
    }
    exports2.hrTime = hrTime;
    function timeInputToHrTime(time) {
      if (isTimeInputHrTime(time)) {
        return time;
      } else if (typeof time === "number") {
        if (time < getTimeOrigin()) {
          return hrTime(time);
        } else {
          return millisToHrTime(time);
        }
      } else if (time instanceof Date) {
        return millisToHrTime(time.getTime());
      } else {
        throw TypeError("Invalid input type");
      }
    }
    exports2.timeInputToHrTime = timeInputToHrTime;
    function hrTimeDuration(startTime, endTime) {
      let seconds = endTime[0] - startTime[0];
      let nanos = endTime[1] - startTime[1];
      if (nanos < 0) {
        seconds -= 1;
        nanos += SECOND_TO_NANOSECONDS;
      }
      return [seconds, nanos];
    }
    exports2.hrTimeDuration = hrTimeDuration;
    function hrTimeToTimeStamp(time) {
      const precision = NANOSECOND_DIGITS;
      const tmp = `${"0".repeat(precision)}${time[1]}Z`;
      const nanoString = tmp.substring(tmp.length - precision - 1);
      const date = new Date(time[0] * 1e3).toISOString();
      return date.replace("000Z", nanoString);
    }
    exports2.hrTimeToTimeStamp = hrTimeToTimeStamp;
    function hrTimeToNanoseconds(time) {
      return time[0] * SECOND_TO_NANOSECONDS + time[1];
    }
    exports2.hrTimeToNanoseconds = hrTimeToNanoseconds;
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    exports2.hrTimeToMilliseconds = hrTimeToMilliseconds;
    function hrTimeToMicroseconds(time) {
      return time[0] * 1e6 + time[1] / 1e3;
    }
    exports2.hrTimeToMicroseconds = hrTimeToMicroseconds;
    function isTimeInputHrTime(value) {
      return Array.isArray(value) && value.length === 2 && typeof value[0] === "number" && typeof value[1] === "number";
    }
    exports2.isTimeInputHrTime = isTimeInputHrTime;
    function isTimeInput(value) {
      return isTimeInputHrTime(value) || typeof value === "number" || value instanceof Date;
    }
    exports2.isTimeInput = isTimeInput;
    function addHrTimes(time1, time2) {
      const out = [time1[0] + time2[0], time1[1] + time2[1]];
      if (out[1] >= SECOND_TO_NANOSECONDS) {
        out[1] -= SECOND_TO_NANOSECONDS;
        out[0] += 1;
      }
      return out;
    }
    exports2.addHrTimes = addHrTimes;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/ExportResult.js
var require_ExportResult = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/ExportResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExportResultCode = void 0;
    var ExportResultCode;
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode = exports2.ExportResultCode || (exports2.ExportResultCode = {}));
  }
});

// ../../node_modules/@opentelemetry/core/build/src/propagation/composite.js
var require_composite = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/propagation/composite.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CompositePropagator = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var CompositePropagator = class {
      /**
       * Construct a composite propagator from a list of propagators.
       *
       * @param [config] Configuration object for composite propagator
       */
      constructor(config = {}) {
        var _a;
        this._propagators = (_a = config.propagators) !== null && _a !== void 0 ? _a : [];
        this._fields = Array.from(new Set(this._propagators.map((p) => typeof p.fields === "function" ? p.fields() : []).reduce((x, y) => x.concat(y), [])));
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same carrier key, the propagator later in the list
       * will "win".
       *
       * @param context Context to inject
       * @param carrier Carrier into which context will be injected
       */
      inject(context2, carrier, setter) {
        for (const propagator of this._propagators) {
          try {
            propagator.inject(context2, carrier, setter);
          } catch (err) {
            api_1.diag.warn(`Failed to inject with ${propagator.constructor.name}. Err: ${err.message}`);
          }
        }
      }
      /**
       * Run each of the configured propagators with the given context and carrier.
       * Propagators are run in the order they are configured, so if multiple
       * propagators write the same context key, the propagator later in the list
       * will "win".
       *
       * @param context Context to add values to
       * @param carrier Carrier from which to extract context
       */
      extract(context2, carrier, getter) {
        return this._propagators.reduce((ctx, propagator) => {
          try {
            return propagator.extract(ctx, carrier, getter);
          } catch (err) {
            api_1.diag.warn(`Failed to extract with ${propagator.constructor.name}. Err: ${err.message}`);
          }
          return ctx;
        }, context2);
      }
      fields() {
        return this._fields.slice();
      }
    };
    exports2.CompositePropagator = CompositePropagator;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/internal/validators.js
var require_validators = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/internal/validators.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateValue = exports2.validateKey = void 0;
    var VALID_KEY_CHAR_RANGE2 = "[_0-9a-z-*/]";
    var VALID_KEY2 = `[a-z]${VALID_KEY_CHAR_RANGE2}{0,255}`;
    var VALID_VENDOR_KEY2 = `[a-z0-9]${VALID_KEY_CHAR_RANGE2}{0,240}@[a-z]${VALID_KEY_CHAR_RANGE2}{0,13}`;
    var VALID_KEY_REGEX2 = new RegExp(`^(?:${VALID_KEY2}|${VALID_VENDOR_KEY2})$`);
    var VALID_VALUE_BASE_REGEX2 = /^[ -~]{0,255}[!-~]$/;
    var INVALID_VALUE_COMMA_EQUAL_REGEX2 = /,|=/;
    function validateKey2(key) {
      return VALID_KEY_REGEX2.test(key);
    }
    exports2.validateKey = validateKey2;
    function validateValue2(value) {
      return VALID_VALUE_BASE_REGEX2.test(value) && !INVALID_VALUE_COMMA_EQUAL_REGEX2.test(value);
    }
    exports2.validateValue = validateValue2;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/TraceState.js
var require_TraceState = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/TraceState.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceState = void 0;
    var validators_1 = require_validators();
    var MAX_TRACE_STATE_ITEMS2 = 32;
    var MAX_TRACE_STATE_LEN2 = 512;
    var LIST_MEMBERS_SEPARATOR2 = ",";
    var LIST_MEMBER_KEY_VALUE_SPLITTER2 = "=";
    var TraceState = class _TraceState {
      constructor(rawTraceState) {
        this._internalState = /* @__PURE__ */ new Map();
        if (rawTraceState)
          this._parse(rawTraceState);
      }
      set(key, value) {
        const traceState = this._clone();
        if (traceState._internalState.has(key)) {
          traceState._internalState.delete(key);
        }
        traceState._internalState.set(key, value);
        return traceState;
      }
      unset(key) {
        const traceState = this._clone();
        traceState._internalState.delete(key);
        return traceState;
      }
      get(key) {
        return this._internalState.get(key);
      }
      serialize() {
        return this._keys().reduce((agg, key) => {
          agg.push(key + LIST_MEMBER_KEY_VALUE_SPLITTER2 + this.get(key));
          return agg;
        }, []).join(LIST_MEMBERS_SEPARATOR2);
      }
      _parse(rawTraceState) {
        if (rawTraceState.length > MAX_TRACE_STATE_LEN2)
          return;
        this._internalState = rawTraceState.split(LIST_MEMBERS_SEPARATOR2).reverse().reduce((agg, part) => {
          const listMember = part.trim();
          const i = listMember.indexOf(LIST_MEMBER_KEY_VALUE_SPLITTER2);
          if (i !== -1) {
            const key = listMember.slice(0, i);
            const value = listMember.slice(i + 1, part.length);
            if ((0, validators_1.validateKey)(key) && (0, validators_1.validateValue)(value)) {
              agg.set(key, value);
            } else {
            }
          }
          return agg;
        }, /* @__PURE__ */ new Map());
        if (this._internalState.size > MAX_TRACE_STATE_ITEMS2) {
          this._internalState = new Map(Array.from(this._internalState.entries()).reverse().slice(0, MAX_TRACE_STATE_ITEMS2));
        }
      }
      _keys() {
        return Array.from(this._internalState.keys()).reverse();
      }
      _clone() {
        const traceState = new _TraceState();
        traceState._internalState = new Map(this._internalState);
        return traceState;
      }
    };
    exports2.TraceState = TraceState;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js
var require_W3CTraceContextPropagator = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/W3CTraceContextPropagator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.W3CTraceContextPropagator = exports2.parseTraceParent = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    var TraceState_1 = require_TraceState();
    exports2.TRACE_PARENT_HEADER = "traceparent";
    exports2.TRACE_STATE_HEADER = "tracestate";
    var VERSION2 = "00";
    var VERSION_PART = "(?!ff)[\\da-f]{2}";
    var TRACE_ID_PART = "(?![0]{32})[\\da-f]{32}";
    var PARENT_ID_PART = "(?![0]{16})[\\da-f]{16}";
    var FLAGS_PART = "[\\da-f]{2}";
    var TRACE_PARENT_REGEX = new RegExp(`^\\s?(${VERSION_PART})-(${TRACE_ID_PART})-(${PARENT_ID_PART})-(${FLAGS_PART})(-.*)?\\s?$`);
    function parseTraceParent(traceParent) {
      const match = TRACE_PARENT_REGEX.exec(traceParent);
      if (!match)
        return null;
      if (match[1] === "00" && match[5])
        return null;
      return {
        traceId: match[2],
        spanId: match[3],
        traceFlags: parseInt(match[4], 16)
      };
    }
    exports2.parseTraceParent = parseTraceParent;
    var W3CTraceContextPropagator = class {
      inject(context2, carrier, setter) {
        const spanContext = api_1.trace.getSpanContext(context2);
        if (!spanContext || (0, suppress_tracing_1.isTracingSuppressed)(context2) || !(0, api_1.isSpanContextValid)(spanContext))
          return;
        const traceParent = `${VERSION2}-${spanContext.traceId}-${spanContext.spanId}-0${Number(spanContext.traceFlags || api_1.TraceFlags.NONE).toString(16)}`;
        setter.set(carrier, exports2.TRACE_PARENT_HEADER, traceParent);
        if (spanContext.traceState) {
          setter.set(carrier, exports2.TRACE_STATE_HEADER, spanContext.traceState.serialize());
        }
      }
      extract(context2, carrier, getter) {
        const traceParentHeader = getter.get(carrier, exports2.TRACE_PARENT_HEADER);
        if (!traceParentHeader)
          return context2;
        const traceParent = Array.isArray(traceParentHeader) ? traceParentHeader[0] : traceParentHeader;
        if (typeof traceParent !== "string")
          return context2;
        const spanContext = parseTraceParent(traceParent);
        if (!spanContext)
          return context2;
        spanContext.isRemote = true;
        const traceStateHeader = getter.get(carrier, exports2.TRACE_STATE_HEADER);
        if (traceStateHeader) {
          const state = Array.isArray(traceStateHeader) ? traceStateHeader.join(",") : traceStateHeader;
          spanContext.traceState = new TraceState_1.TraceState(typeof state === "string" ? state : void 0);
        }
        return api_1.trace.setSpanContext(context2, spanContext);
      }
      fields() {
        return [exports2.TRACE_PARENT_HEADER, exports2.TRACE_STATE_HEADER];
      }
    };
    exports2.W3CTraceContextPropagator = W3CTraceContextPropagator;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js
var require_rpc_metadata = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/rpc-metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.setRPCMetadata = exports2.RPCType = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var RPC_METADATA_KEY = (0, api_1.createContextKey)("OpenTelemetry SDK Context Key RPC_METADATA");
    var RPCType;
    (function(RPCType2) {
      RPCType2["HTTP"] = "http";
    })(RPCType = exports2.RPCType || (exports2.RPCType = {}));
    function setRPCMetadata(context2, meta) {
      return context2.setValue(RPC_METADATA_KEY, meta);
    }
    exports2.setRPCMetadata = setRPCMetadata;
    function deleteRPCMetadata(context2) {
      return context2.deleteValue(RPC_METADATA_KEY);
    }
    exports2.deleteRPCMetadata = deleteRPCMetadata;
    function getRPCMetadata(context2) {
      return context2.getValue(RPC_METADATA_KEY);
    }
    exports2.getRPCMetadata = getRPCMetadata;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js
var require_AlwaysOffSampler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOffSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOffSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOffSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return "AlwaysOffSampler";
      }
    };
    exports2.AlwaysOffSampler = AlwaysOffSampler;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js
var require_AlwaysOnSampler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/sampler/AlwaysOnSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlwaysOnSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var AlwaysOnSampler = class {
      shouldSample() {
        return {
          decision: api_1.SamplingDecision.RECORD_AND_SAMPLED
        };
      }
      toString() {
        return "AlwaysOnSampler";
      }
    };
    exports2.AlwaysOnSampler = AlwaysOnSampler;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js
var require_ParentBasedSampler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/sampler/ParentBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ParentBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var global_error_handler_1 = require_global_error_handler();
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    var ParentBasedSampler = class {
      constructor(config) {
        var _a, _b, _c, _d;
        this._root = config.root;
        if (!this._root) {
          (0, global_error_handler_1.globalErrorHandler)(new Error("ParentBasedSampler must have a root sampler configured"));
          this._root = new AlwaysOnSampler_1.AlwaysOnSampler();
        }
        this._remoteParentSampled = (_a = config.remoteParentSampled) !== null && _a !== void 0 ? _a : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._remoteParentNotSampled = (_b = config.remoteParentNotSampled) !== null && _b !== void 0 ? _b : new AlwaysOffSampler_1.AlwaysOffSampler();
        this._localParentSampled = (_c = config.localParentSampled) !== null && _c !== void 0 ? _c : new AlwaysOnSampler_1.AlwaysOnSampler();
        this._localParentNotSampled = (_d = config.localParentNotSampled) !== null && _d !== void 0 ? _d : new AlwaysOffSampler_1.AlwaysOffSampler();
      }
      shouldSample(context2, traceId, spanName, spanKind, attributes, links) {
        const parentContext = api_1.trace.getSpanContext(context2);
        if (!parentContext || !(0, api_1.isSpanContextValid)(parentContext)) {
          return this._root.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.isRemote) {
          if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
            return this._remoteParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
          }
          return this._remoteParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        if (parentContext.traceFlags & api_1.TraceFlags.SAMPLED) {
          return this._localParentSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
        }
        return this._localParentNotSampled.shouldSample(context2, traceId, spanName, spanKind, attributes, links);
      }
      toString() {
        return `ParentBased{root=${this._root.toString()}, remoteParentSampled=${this._remoteParentSampled.toString()}, remoteParentNotSampled=${this._remoteParentNotSampled.toString()}, localParentSampled=${this._localParentSampled.toString()}, localParentNotSampled=${this._localParentNotSampled.toString()}}`;
      }
    };
    exports2.ParentBasedSampler = ParentBasedSampler;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js
var require_TraceIdRatioBasedSampler = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/trace/sampler/TraceIdRatioBasedSampler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TraceIdRatioBasedSampler = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var TraceIdRatioBasedSampler = class {
      constructor(_ratio = 0) {
        this._ratio = _ratio;
        this._ratio = this._normalize(_ratio);
        this._upperBound = Math.floor(this._ratio * 4294967295);
      }
      shouldSample(context2, traceId) {
        return {
          decision: (0, api_1.isValidTraceId)(traceId) && this._accumulate(traceId) < this._upperBound ? api_1.SamplingDecision.RECORD_AND_SAMPLED : api_1.SamplingDecision.NOT_RECORD
        };
      }
      toString() {
        return `TraceIdRatioBased{${this._ratio}}`;
      }
      _normalize(ratio) {
        if (typeof ratio !== "number" || isNaN(ratio))
          return 0;
        return ratio >= 1 ? 1 : ratio <= 0 ? 0 : ratio;
      }
      _accumulate(traceId) {
        let accumulation = 0;
        for (let i = 0; i < traceId.length / 8; i++) {
          const pos = i * 8;
          const part = parseInt(traceId.slice(pos, pos + 8), 16);
          accumulation = (accumulation ^ part) >>> 0;
        }
        return accumulation;
      }
    };
    exports2.TraceIdRatioBasedSampler = TraceIdRatioBasedSampler;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js
var require_lodash_merge = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/lodash.merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPlainObject = void 0;
    var objectTag = "[object Object]";
    var nullTag = "[object Null]";
    var undefinedTag = "[object Undefined]";
    var funcProto = Function.prototype;
    var funcToString = funcProto.toString;
    var objectCtorString = funcToString.call(Object);
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var symToStringTag = Symbol ? Symbol.toStringTag : void 0;
    var nativeObjectToString = objectProto.toString;
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) !== objectTag) {
        return false;
      }
      const proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      const Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) === objectCtorString;
    }
    exports2.isPlainObject = isPlainObject;
    function isObjectLike(value) {
      return value != null && typeof value == "object";
    }
    function baseGetTag(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag : nullTag;
      }
      return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
    }
    function getRawTag(value) {
      const isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
      let unmasked = false;
      try {
        value[symToStringTag] = void 0;
        unmasked = true;
      } catch (e) {
      }
      const result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/merge.js
var require_merge = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/merge.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var lodash_merge_1 = require_lodash_merge();
    var MAX_LEVEL = 20;
    function merge(...args) {
      let result = args.shift();
      const objects = /* @__PURE__ */ new WeakMap();
      while (args.length > 0) {
        result = mergeTwoObjects(result, args.shift(), 0, objects);
      }
      return result;
    }
    exports2.merge = merge;
    function takeValue(value) {
      if (isArray(value)) {
        return value.slice();
      }
      return value;
    }
    function mergeTwoObjects(one, two, level = 0, objects) {
      let result;
      if (level > MAX_LEVEL) {
        return void 0;
      }
      level++;
      if (isPrimitive(one) || isPrimitive(two) || isFunction(two)) {
        result = takeValue(two);
      } else if (isArray(one)) {
        result = one.slice();
        if (isArray(two)) {
          for (let i = 0, j = two.length; i < j; i++) {
            result.push(takeValue(two[i]));
          }
        } else if (isObject(two)) {
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            result[key] = takeValue(two[key]);
          }
        }
      } else if (isObject(one)) {
        if (isObject(two)) {
          if (!shouldMerge(one, two)) {
            return two;
          }
          result = Object.assign({}, one);
          const keys = Object.keys(two);
          for (let i = 0, j = keys.length; i < j; i++) {
            const key = keys[i];
            const twoValue = two[key];
            if (isPrimitive(twoValue)) {
              if (typeof twoValue === "undefined") {
                delete result[key];
              } else {
                result[key] = twoValue;
              }
            } else {
              const obj1 = result[key];
              const obj2 = twoValue;
              if (wasObjectReferenced(one, key, objects) || wasObjectReferenced(two, key, objects)) {
                delete result[key];
              } else {
                if (isObject(obj1) && isObject(obj2)) {
                  const arr1 = objects.get(obj1) || [];
                  const arr2 = objects.get(obj2) || [];
                  arr1.push({ obj: one, key });
                  arr2.push({ obj: two, key });
                  objects.set(obj1, arr1);
                  objects.set(obj2, arr2);
                }
                result[key] = mergeTwoObjects(result[key], twoValue, level, objects);
              }
            }
          }
        } else {
          result = two;
        }
      }
      return result;
    }
    function wasObjectReferenced(obj, key, objects) {
      const arr = objects.get(obj[key]) || [];
      for (let i = 0, j = arr.length; i < j; i++) {
        const info = arr[i];
        if (info.key === key && info.obj === obj) {
          return true;
        }
      }
      return false;
    }
    function isArray(value) {
      return Array.isArray(value);
    }
    function isFunction(value) {
      return typeof value === "function";
    }
    function isObject(value) {
      return !isPrimitive(value) && !isArray(value) && !isFunction(value) && typeof value === "object";
    }
    function isPrimitive(value) {
      return typeof value === "string" || typeof value === "number" || typeof value === "boolean" || typeof value === "undefined" || value instanceof Date || value instanceof RegExp || value === null;
    }
    function shouldMerge(one, two) {
      if (!(0, lodash_merge_1.isPlainObject)(one) || !(0, lodash_merge_1.isPlainObject)(two)) {
        return false;
      }
      return true;
    }
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/timeout.js
var require_timeout = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.callWithTimeout = exports2.TimeoutError = void 0;
    var TimeoutError = class _TimeoutError extends Error {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _TimeoutError.prototype);
      }
    };
    exports2.TimeoutError = TimeoutError;
    function callWithTimeout(promise, timeout) {
      let timeoutHandle;
      const timeoutPromise = new Promise(function timeoutFunction(_resolve, reject) {
        timeoutHandle = setTimeout(function timeoutHandler() {
          reject(new TimeoutError("Operation timed out."));
        }, timeout);
      });
      return Promise.race([promise, timeoutPromise]).then((result) => {
        clearTimeout(timeoutHandle);
        return result;
      }, (reason) => {
        clearTimeout(timeoutHandle);
        throw reason;
      });
    }
    exports2.callWithTimeout = callWithTimeout;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/url.js
var require_url = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/url.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isUrlIgnored = exports2.urlMatches = void 0;
    function urlMatches(url, urlToMatch) {
      if (typeof urlToMatch === "string") {
        return url === urlToMatch;
      } else {
        return !!url.match(urlToMatch);
      }
    }
    exports2.urlMatches = urlMatches;
    function isUrlIgnored(url, ignoredUrls) {
      if (!ignoredUrls) {
        return false;
      }
      for (const ignoreUrl of ignoredUrls) {
        if (urlMatches(url, ignoreUrl)) {
          return true;
        }
      }
      return false;
    }
    exports2.isUrlIgnored = isUrlIgnored;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/wrap.js
var require_wrap = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/wrap.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isWrapped = void 0;
    function isWrapped(func) {
      return typeof func === "function" && typeof func.__original === "function" && typeof func.__unwrap === "function" && func.__wrapped === true;
    }
    exports2.isWrapped = isWrapped;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/promise.js
var require_promise = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/promise.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Deferred = void 0;
    var Deferred = class {
      constructor() {
        this._promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
      get promise() {
        return this._promise;
      }
      resolve(val) {
        this._resolve(val);
      }
      reject(err) {
        this._reject(err);
      }
    };
    exports2.Deferred = Deferred;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/utils/callback.js
var require_callback = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/utils/callback.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BindOnceFuture = void 0;
    var promise_1 = require_promise();
    var BindOnceFuture = class {
      constructor(_callback, _that) {
        this._callback = _callback;
        this._that = _that;
        this._isCalled = false;
        this._deferred = new promise_1.Deferred();
      }
      get isCalled() {
        return this._isCalled;
      }
      get promise() {
        return this._deferred.promise;
      }
      call(...args) {
        if (!this._isCalled) {
          this._isCalled = true;
          try {
            Promise.resolve(this._callback.call(this._that, ...args)).then((val) => this._deferred.resolve(val), (err) => this._deferred.reject(err));
          } catch (err) {
            this._deferred.reject(err);
          }
        }
        return this._deferred.promise;
      }
    };
    exports2.BindOnceFuture = BindOnceFuture;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/internal/exporter.js
var require_exporter = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/internal/exporter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._export = void 0;
    var api_1 = (init_esm(), __toCommonJS(esm_exports));
    var suppress_tracing_1 = require_suppress_tracing();
    function _export(exporter, arg) {
      return new Promise((resolve) => {
        api_1.context.with((0, suppress_tracing_1.suppressTracing)(api_1.context.active()), () => {
          exporter.export(arg, (result) => {
            resolve(result);
          });
        });
      });
    }
    exports2._export = _export;
  }
});

// ../../node_modules/@opentelemetry/core/build/src/index.js
var require_src = __commonJS({
  "../../node_modules/@opentelemetry/core/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT = exports2.DEFAULT_ATTRIBUTE_COUNT_LIMIT = exports2.TraceState = exports2.unsuppressTracing = exports2.suppressTracing = exports2.isTracingSuppressed = exports2.TraceIdRatioBasedSampler = exports2.ParentBasedSampler = exports2.AlwaysOnSampler = exports2.AlwaysOffSampler = exports2.setRPCMetadata = exports2.getRPCMetadata = exports2.deleteRPCMetadata = exports2.RPCType = exports2.parseTraceParent = exports2.W3CTraceContextPropagator = exports2.TRACE_STATE_HEADER = exports2.TRACE_PARENT_HEADER = exports2.CompositePropagator = exports2.unrefTimer = exports2.otperformance = exports2.hexToBase64 = exports2.getEnvWithoutDefaults = exports2.getEnv = exports2._globalThis = exports2.SDK_INFO = exports2.RandomIdGenerator = exports2.baggageUtils = exports2.ExportResultCode = exports2.hexToBinary = exports2.timeInputToHrTime = exports2.millisToHrTime = exports2.isTimeInputHrTime = exports2.isTimeInput = exports2.hrTimeToTimeStamp = exports2.hrTimeToNanoseconds = exports2.hrTimeToMilliseconds = exports2.hrTimeToMicroseconds = exports2.hrTimeDuration = exports2.hrTime = exports2.getTimeOrigin = exports2.addHrTimes = exports2.loggingErrorHandler = exports2.setGlobalErrorHandler = exports2.globalErrorHandler = exports2.sanitizeAttributes = exports2.isAttributeValue = exports2.isAttributeKey = exports2.AnchoredClock = exports2.W3CBaggagePropagator = void 0;
    exports2.internal = exports2.VERSION = exports2.BindOnceFuture = exports2.isWrapped = exports2.urlMatches = exports2.isUrlIgnored = exports2.callWithTimeout = exports2.TimeoutError = exports2.TracesSamplerValues = exports2.merge = exports2.parseEnvironment = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT = exports2.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT = exports2.DEFAULT_ENVIRONMENT = void 0;
    var W3CBaggagePropagator_1 = require_W3CBaggagePropagator();
    Object.defineProperty(exports2, "W3CBaggagePropagator", { enumerable: true, get: function() {
      return W3CBaggagePropagator_1.W3CBaggagePropagator;
    } });
    var anchored_clock_1 = require_anchored_clock();
    Object.defineProperty(exports2, "AnchoredClock", { enumerable: true, get: function() {
      return anchored_clock_1.AnchoredClock;
    } });
    var attributes_1 = require_attributes();
    Object.defineProperty(exports2, "isAttributeKey", { enumerable: true, get: function() {
      return attributes_1.isAttributeKey;
    } });
    Object.defineProperty(exports2, "isAttributeValue", { enumerable: true, get: function() {
      return attributes_1.isAttributeValue;
    } });
    Object.defineProperty(exports2, "sanitizeAttributes", { enumerable: true, get: function() {
      return attributes_1.sanitizeAttributes;
    } });
    var global_error_handler_1 = require_global_error_handler();
    Object.defineProperty(exports2, "globalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.globalErrorHandler;
    } });
    Object.defineProperty(exports2, "setGlobalErrorHandler", { enumerable: true, get: function() {
      return global_error_handler_1.setGlobalErrorHandler;
    } });
    var logging_error_handler_1 = require_logging_error_handler();
    Object.defineProperty(exports2, "loggingErrorHandler", { enumerable: true, get: function() {
      return logging_error_handler_1.loggingErrorHandler;
    } });
    var time_1 = require_time();
    Object.defineProperty(exports2, "addHrTimes", { enumerable: true, get: function() {
      return time_1.addHrTimes;
    } });
    Object.defineProperty(exports2, "getTimeOrigin", { enumerable: true, get: function() {
      return time_1.getTimeOrigin;
    } });
    Object.defineProperty(exports2, "hrTime", { enumerable: true, get: function() {
      return time_1.hrTime;
    } });
    Object.defineProperty(exports2, "hrTimeDuration", { enumerable: true, get: function() {
      return time_1.hrTimeDuration;
    } });
    Object.defineProperty(exports2, "hrTimeToMicroseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMicroseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToMilliseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToMilliseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToNanoseconds", { enumerable: true, get: function() {
      return time_1.hrTimeToNanoseconds;
    } });
    Object.defineProperty(exports2, "hrTimeToTimeStamp", { enumerable: true, get: function() {
      return time_1.hrTimeToTimeStamp;
    } });
    Object.defineProperty(exports2, "isTimeInput", { enumerable: true, get: function() {
      return time_1.isTimeInput;
    } });
    Object.defineProperty(exports2, "isTimeInputHrTime", { enumerable: true, get: function() {
      return time_1.isTimeInputHrTime;
    } });
    Object.defineProperty(exports2, "millisToHrTime", { enumerable: true, get: function() {
      return time_1.millisToHrTime;
    } });
    Object.defineProperty(exports2, "timeInputToHrTime", { enumerable: true, get: function() {
      return time_1.timeInputToHrTime;
    } });
    var hex_to_binary_1 = require_hex_to_binary();
    Object.defineProperty(exports2, "hexToBinary", { enumerable: true, get: function() {
      return hex_to_binary_1.hexToBinary;
    } });
    var ExportResult_1 = require_ExportResult();
    Object.defineProperty(exports2, "ExportResultCode", { enumerable: true, get: function() {
      return ExportResult_1.ExportResultCode;
    } });
    var utils_1 = require_utils();
    exports2.baggageUtils = {
      getKeyPairs: utils_1.getKeyPairs,
      serializeKeyPairs: utils_1.serializeKeyPairs,
      parseKeyPairsIntoRecord: utils_1.parseKeyPairsIntoRecord,
      parsePairKeyValue: utils_1.parsePairKeyValue
    };
    var platform_1 = require_platform();
    Object.defineProperty(exports2, "RandomIdGenerator", { enumerable: true, get: function() {
      return platform_1.RandomIdGenerator;
    } });
    Object.defineProperty(exports2, "SDK_INFO", { enumerable: true, get: function() {
      return platform_1.SDK_INFO;
    } });
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return platform_1._globalThis;
    } });
    Object.defineProperty(exports2, "getEnv", { enumerable: true, get: function() {
      return platform_1.getEnv;
    } });
    Object.defineProperty(exports2, "getEnvWithoutDefaults", { enumerable: true, get: function() {
      return platform_1.getEnvWithoutDefaults;
    } });
    Object.defineProperty(exports2, "hexToBase64", { enumerable: true, get: function() {
      return platform_1.hexToBase64;
    } });
    Object.defineProperty(exports2, "otperformance", { enumerable: true, get: function() {
      return platform_1.otperformance;
    } });
    Object.defineProperty(exports2, "unrefTimer", { enumerable: true, get: function() {
      return platform_1.unrefTimer;
    } });
    var composite_1 = require_composite();
    Object.defineProperty(exports2, "CompositePropagator", { enumerable: true, get: function() {
      return composite_1.CompositePropagator;
    } });
    var W3CTraceContextPropagator_1 = require_W3CTraceContextPropagator();
    Object.defineProperty(exports2, "TRACE_PARENT_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_PARENT_HEADER;
    } });
    Object.defineProperty(exports2, "TRACE_STATE_HEADER", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.TRACE_STATE_HEADER;
    } });
    Object.defineProperty(exports2, "W3CTraceContextPropagator", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.W3CTraceContextPropagator;
    } });
    Object.defineProperty(exports2, "parseTraceParent", { enumerable: true, get: function() {
      return W3CTraceContextPropagator_1.parseTraceParent;
    } });
    var rpc_metadata_1 = require_rpc_metadata();
    Object.defineProperty(exports2, "RPCType", { enumerable: true, get: function() {
      return rpc_metadata_1.RPCType;
    } });
    Object.defineProperty(exports2, "deleteRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.deleteRPCMetadata;
    } });
    Object.defineProperty(exports2, "getRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.getRPCMetadata;
    } });
    Object.defineProperty(exports2, "setRPCMetadata", { enumerable: true, get: function() {
      return rpc_metadata_1.setRPCMetadata;
    } });
    var AlwaysOffSampler_1 = require_AlwaysOffSampler();
    Object.defineProperty(exports2, "AlwaysOffSampler", { enumerable: true, get: function() {
      return AlwaysOffSampler_1.AlwaysOffSampler;
    } });
    var AlwaysOnSampler_1 = require_AlwaysOnSampler();
    Object.defineProperty(exports2, "AlwaysOnSampler", { enumerable: true, get: function() {
      return AlwaysOnSampler_1.AlwaysOnSampler;
    } });
    var ParentBasedSampler_1 = require_ParentBasedSampler();
    Object.defineProperty(exports2, "ParentBasedSampler", { enumerable: true, get: function() {
      return ParentBasedSampler_1.ParentBasedSampler;
    } });
    var TraceIdRatioBasedSampler_1 = require_TraceIdRatioBasedSampler();
    Object.defineProperty(exports2, "TraceIdRatioBasedSampler", { enumerable: true, get: function() {
      return TraceIdRatioBasedSampler_1.TraceIdRatioBasedSampler;
    } });
    var suppress_tracing_1 = require_suppress_tracing();
    Object.defineProperty(exports2, "isTracingSuppressed", { enumerable: true, get: function() {
      return suppress_tracing_1.isTracingSuppressed;
    } });
    Object.defineProperty(exports2, "suppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.suppressTracing;
    } });
    Object.defineProperty(exports2, "unsuppressTracing", { enumerable: true, get: function() {
      return suppress_tracing_1.unsuppressTracing;
    } });
    var TraceState_1 = require_TraceState();
    Object.defineProperty(exports2, "TraceState", { enumerable: true, get: function() {
      return TraceState_1.TraceState;
    } });
    var environment_1 = require_environment();
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ATTRIBUTE_VALUE_LENGTH_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_ENVIRONMENT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_ENVIRONMENT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_EVENT_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT", { enumerable: true, get: function() {
      return environment_1.DEFAULT_SPAN_ATTRIBUTE_PER_LINK_COUNT_LIMIT;
    } });
    Object.defineProperty(exports2, "parseEnvironment", { enumerable: true, get: function() {
      return environment_1.parseEnvironment;
    } });
    var merge_1 = require_merge();
    Object.defineProperty(exports2, "merge", { enumerable: true, get: function() {
      return merge_1.merge;
    } });
    var sampling_1 = require_sampling();
    Object.defineProperty(exports2, "TracesSamplerValues", { enumerable: true, get: function() {
      return sampling_1.TracesSamplerValues;
    } });
    var timeout_1 = require_timeout();
    Object.defineProperty(exports2, "TimeoutError", { enumerable: true, get: function() {
      return timeout_1.TimeoutError;
    } });
    Object.defineProperty(exports2, "callWithTimeout", { enumerable: true, get: function() {
      return timeout_1.callWithTimeout;
    } });
    var url_1 = require_url();
    Object.defineProperty(exports2, "isUrlIgnored", { enumerable: true, get: function() {
      return url_1.isUrlIgnored;
    } });
    Object.defineProperty(exports2, "urlMatches", { enumerable: true, get: function() {
      return url_1.urlMatches;
    } });
    var wrap_1 = require_wrap();
    Object.defineProperty(exports2, "isWrapped", { enumerable: true, get: function() {
      return wrap_1.isWrapped;
    } });
    var callback_1 = require_callback();
    Object.defineProperty(exports2, "BindOnceFuture", { enumerable: true, get: function() {
      return callback_1.BindOnceFuture;
    } });
    var version_1 = require_version();
    Object.defineProperty(exports2, "VERSION", { enumerable: true, get: function() {
      return version_1.VERSION;
    } });
    var exporter_1 = require_exporter();
    exports2.internal = {
      _export: exporter_1._export
    };
  }
});

// ../../packages/dd-trace/src/opentelemetry/span_context.js
var require_span_context3 = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/span_context.js"(exports2, module2) {
    "use strict";
    var api = (init_esm(), __toCommonJS(esm_exports));
    var { AUTO_KEEP } = require_priority();
    var DatadogSpanContext = require_span_context();
    var id = require_id();
    function newContext() {
      const spanId = id();
      return new DatadogSpanContext({
        traceId: spanId,
        spanId
      });
    }
    var SpanContext = class {
      constructor(context2) {
        if (!(context2 instanceof DatadogSpanContext)) {
          context2 = context2 ? new DatadogSpanContext(context2) : newContext();
        }
        this._ddContext = context2;
      }
      get traceId() {
        return this._ddContext.toTraceId(true);
      }
      get spanId() {
        return this._ddContext.toSpanId(true);
      }
      get traceFlags() {
        return this._ddContext._sampling.priority >= AUTO_KEEP ? 1 : 0;
      }
      get traceState() {
        const ts = this._ddContext._tracestate;
        return api.createTraceState(ts ? ts.toString() : "");
      }
    };
    module2.exports = SpanContext;
  }
});

// ../../packages/dd-trace/src/opentelemetry/context_manager.js
var require_context_manager = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/context_manager.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var { trace: trace2, ROOT_CONTEXT: ROOT_CONTEXT2, propagation: propagation2 } = (init_esm(), __toCommonJS(esm_exports));
    var DataDogSpanContext = require_span_context();
    var SpanContext = require_span_context3();
    var tracer2 = require_dd_trace();
    var ContextManager = class {
      constructor() {
        this._store = storage("opentelemetry");
      }
      // converts dd to otel
      active() {
        const activeSpan = tracer2.scope().active();
        const store = this._store.getStore();
        const context2 = activeSpan && activeSpan.context() || store || ROOT_CONTEXT2;
        if (!(context2 instanceof DataDogSpanContext)) {
          const span = trace2.getSpan(context2);
          if (span && span._spanContext && span._spanContext._ddContext && span._spanContext._ddContext._baggageItems) {
            const baggages2 = span._spanContext._ddContext._baggageItems;
            const entries2 = {};
            for (const [key, value] of Object.entries(baggages2)) {
              entries2[key] = { value };
            }
            const otelBaggages2 = propagation2.createBaggage(entries2);
            return propagation2.setBaggage(context2, otelBaggages2);
          }
          return context2;
        }
        const baggages = JSON.parse(activeSpan.getAllBaggageItems());
        const entries = {};
        for (const [key, value] of Object.entries(baggages)) {
          entries[key] = { value };
        }
        const otelBaggages = propagation2.createBaggage(entries);
        if (!context2._otelSpanContext) {
          const newSpanContext = new SpanContext(context2);
          context2._otelSpanContext = newSpanContext;
        }
        if (store && trace2.getSpanContext(store) === context2._otelSpanContext) {
          return otelBaggages ? propagation2.setBaggage(store, otelBaggages) : store;
        }
        const wrappedContext = trace2.setSpanContext(store || ROOT_CONTEXT2, context2._otelSpanContext);
        return otelBaggages ? propagation2.setBaggage(wrappedContext, otelBaggages) : wrappedContext;
      }
      // converts otel to dd
      with(context2, fn, thisArg, ...args) {
        const span = trace2.getSpan(context2);
        const ddScope = tracer2.scope();
        const run = () => {
          const cb = thisArg == null ? fn : fn.bind(thisArg);
          return this._store.run(context2, cb, ...args);
        };
        const baggages = propagation2.getBaggage(context2);
        let baggageItems = [];
        if (baggages) {
          baggageItems = baggages.getAllEntries();
        }
        if (span && span._ddSpan) {
          span._ddSpan.removeAllBaggageItems();
          for (const baggage of baggageItems) {
            span._ddSpan.setBaggageItem(baggage[0], baggage[1].value);
          }
          return ddScope.activate(span._ddSpan, run);
        }
        if (span && span._spanContext && span._spanContext._ddContext && span._spanContext._ddContext._baggageItems) {
          span._spanContext._ddContext._baggageItems = {};
          for (const baggage of baggageItems) {
            span._spanContext._ddContext._baggageItems[baggage[0]] = baggage[1].value;
          }
        }
        return run();
      }
      bind(context2, target) {
        const self2 = this;
        return function(...args) {
          return self2.with(context2, target, this, ...args);
        };
      }
      enable() {
      }
      disable() {
      }
    };
    module2.exports = ContextManager;
  }
});

// ../../packages/dd-trace/src/opentelemetry/span_processor.js
var require_span_processor = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/span_processor.js"(exports2, module2) {
    "use strict";
    var NoopSpanProcessor = class {
      forceFlush() {
        return Promise.resolve();
      }
      onStart(span, context2) {
      }
      onEnd(span) {
      }
      shutdown() {
        return Promise.resolve();
      }
    };
    var MultiSpanProcessor = class extends NoopSpanProcessor {
      constructor(spanProcessors) {
        super();
        this._processors = spanProcessors;
      }
      forceFlush() {
        return Promise.all(
          this._processors.map((p) => p.forceFlush())
        );
      }
      onStart(span, context2) {
        for (const processor of this._processors) {
          processor.onStart(span, context2);
        }
      }
      onEnd(span) {
        for (const processor of this._processors) {
          processor.onEnd(span);
        }
      }
      shutdown() {
        return Promise.all(
          this._processors.map((p) => p.shutdown())
        );
      }
    };
    module2.exports = {
      MultiSpanProcessor,
      NoopSpanProcessor
    };
  }
});

// ../../packages/dd-trace/src/opentelemetry/sampler.js
var require_sampler = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/sampler.js"(exports2, module2) {
    "use strict";
    var Sampler = class {
      shouldSample(context2, traceId, spanName, spanKind, attributes, links) {
        return { decision: 2 };
      }
      /** Returns the sampler name or short description with the configuration. */
      toString() {
        return "DatadogSampler";
      }
    };
    module2.exports = Sampler;
  }
});

// ../../node_modules/dc-polyfill/checks.js
var require_checks = __commonJS({
  "../../node_modules/dc-polyfill/checks.js"(exports2, module2) {
    var [MAJOR, MINOR, PATCH] = process.versions.node.split(".").map(Number);
    module2.exports.MAJOR = MAJOR;
    module2.exports.MINOR = MINOR;
    module2.exports.PATCH = PATCH;
    function hasFullSupport() {
      return MAJOR > 20 || MAJOR >= 20 && MINOR >= 6;
    }
    module2.exports.hasFullSupport = hasFullSupport;
    function hasTracingChannel() {
      return MAJOR >= 20 || MAJOR === 18 && MINOR >= 19;
    }
    module2.exports.hasTracingChannel = hasTracingChannel;
    function hasDiagnosticsChannel() {
      return MAJOR >= 16 || MAJOR === 15 && MINOR >= 1 || MAJOR === 14 && MINOR >= 17;
    }
    module2.exports.hasDiagnosticsChannel = hasDiagnosticsChannel;
    function hasTopSubscribeUnsubscribe() {
      return MAJOR >= 20 || MAJOR === 16 && MINOR >= 17 || MAJOR === 18 && MINOR >= 7;
    }
    module2.exports.hasTopSubscribeUnsubscribe = hasTopSubscribeUnsubscribe;
    function hasGarbageCollectionBug() {
      return hasDiagnosticsChannel() && !hasFullSupport();
    }
    module2.exports.hasGarbageCollectionBug = hasGarbageCollectionBug;
    function hasChannelStoreMethods() {
      return MAJOR >= 20 || MAJOR === 19 && MINOR >= 9;
    }
    module2.exports.hasChannelStoreMethods = hasChannelStoreMethods;
    function hasChUnsubscribeReturn() {
      return MAJOR >= 18 || MAJOR === 14 && MINOR >= 19 || MAJOR === 16 && MINOR >= 14 || MAJOR === 17 && MINOR >= 1;
    }
    module2.exports.hasChUnsubscribeReturn = hasChUnsubscribeReturn;
    function hasSyncUnsubscribeBug() {
      return MAJOR === 20 && MINOR <= 5;
    }
    module2.exports.hasSyncUnsubscribeBug = hasSyncUnsubscribeBug;
    function hasTracingChannelHasSubscribers() {
      return MAJOR >= 22 || MAJOR == 20 && MINOR >= 13;
    }
    module2.exports.hasTracingChannelHasSubscribers = hasTracingChannelHasSubscribers;
  }
});

// ../../node_modules/dc-polyfill/primordials.js
var require_primordials = __commonJS({
  "../../node_modules/dc-polyfill/primordials.js"(exports2, module2) {
    var makeCall = (fn) => (...args) => fn.call(...args);
    function arrayAtPolyfill(n) {
      n = Math.trunc(n) || 0;
      if (n < 0) n += this.length;
      if (n < 0 || n >= this.length) return void 0;
      return this[n];
    }
    var ReflectApply = Reflect.apply;
    var PromiseReject = Promise.reject.bind(Promise);
    var PromiseResolve = Promise.resolve;
    var PromisePrototypeThen = makeCall(Promise.prototype.then);
    var ArrayPrototypeSplice = makeCall(Array.prototype.splice);
    var ArrayPrototypeAt = makeCall(Array.prototype.at || arrayAtPolyfill);
    var ObjectDefineProperty = Object.defineProperty;
    var ObjectDefineProperties = Object.defineProperties;
    var ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var ObjectGetPrototypeOf = Object.getPrototypeOf;
    var ObjectSetPrototypeOf = Object.setPrototypeOf;
    var SymbolFor = Symbol.for;
    module2.exports = {
      ReflectApply,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      ArrayPrototypeSplice,
      ArrayPrototypeAt,
      ObjectDefineProperty,
      ObjectDefineProperties,
      ObjectGetOwnPropertyDescriptor,
      ObjectGetPrototypeOf,
      ObjectSetPrototypeOf,
      SymbolFor
    };
  }
});

// ../../node_modules/dc-polyfill/errors.js
var require_errors = __commonJS({
  "../../node_modules/dc-polyfill/errors.js"(exports2, module2) {
    var util = __require("util");
    var { ObjectDefineProperties } = require_primordials();
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(message, actual) {
        super();
        if (actual == null) {
          message += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          message += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          if (actual.constructor && actual.constructor.name) {
            message += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = util.inspect(actual, { depth: -1 });
            message += `. Received ${inspected}`;
          }
        } else {
          let inspected = util.inspect(actual, { colors: false });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          message += `. Received type ${typeof actual} (${inspected})`;
        }
        this.code = this.constructor.name;
        ObjectDefineProperties(this, {
          message: {
            value: message,
            enumerable: false,
            writable: true,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
    module2.exports = {
      ERR_INVALID_ARG_TYPE
    };
  }
});

// ../../node_modules/dc-polyfill/acquire-channel-registry.js
var require_acquire_channel_registry = __commonJS({
  "../../node_modules/dc-polyfill/acquire-channel-registry.js"(exports2, module2) {
    var { ObjectDefineProperty, SymbolFor } = require_primordials();
    var REGISTRY_SYMBOL = SymbolFor("dc-polyfill-v1");
    if (!process[REGISTRY_SYMBOL]) {
      ObjectDefineProperty(process, REGISTRY_SYMBOL, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: {}
      });
    }
    module2.exports = process[REGISTRY_SYMBOL];
  }
});

// ../../node_modules/dc-polyfill/reimplementation.js
var require_reimplementation = __commonJS({
  "../../node_modules/dc-polyfill/reimplementation.js"(exports2, module2) {
    "use strict";
    var {
      ObjectSetPrototypeOf,
      ObjectGetPrototypeOf
    } = require_primordials();
    var { ERR_INVALID_ARG_TYPE } = require_errors();
    var channels = require_acquire_channel_registry();
    var ActiveChannel = class {
      subscribe(subscription) {
        if (typeof subscription !== "function") {
          throw new ERR_INVALID_ARG_TYPE('The "subscription" argument must be of type function', subscription);
        }
        this._subscribers.push(subscription);
      }
      unsubscribe(subscription) {
        const index = this._subscribers.indexOf(subscription);
        if (index === -1) return false;
        this._subscribers.splice(index, 1);
        if (!this._subscribers.length) {
          ObjectSetPrototypeOf(this, Channel.prototype);
        }
        return true;
      }
      get hasSubscribers() {
        return true;
      }
      publish(data) {
        for (let i = 0; i < this._subscribers.length; i++) {
          try {
            const onMessage = this._subscribers[i];
            onMessage(data, this.name);
          } catch (err) {
            process.nextTick(() => {
              throw err;
            });
          }
        }
      }
    };
    var Channel = class _Channel {
      constructor(name) {
        this._subscribers = void 0;
        this.name = name;
      }
      static [Symbol.hasInstance](instance) {
        const prototype = ObjectGetPrototypeOf(instance);
        return prototype === _Channel.prototype || prototype === ActiveChannel.prototype;
      }
      subscribe(subscription) {
        ObjectSetPrototypeOf(this, ActiveChannel.prototype);
        this._subscribers = [];
        this.subscribe(subscription);
      }
      unsubscribe() {
        return false;
      }
      get hasSubscribers() {
        return false;
      }
      publish() {
      }
    };
    function channel(name) {
      const channel2 = channels[name];
      if (channel2) return channel2;
      if (typeof name !== "string" && typeof name !== "symbol") {
        throw new ERR_INVALID_ARG_TYPE('The "channel" argument must be one of type string or symbol', name);
      }
      return channels[name] = new Channel(name);
    }
    function hasSubscribers(name) {
      const channel2 = channels[name];
      if (!channel2) {
        return false;
      }
      return channel2.hasSubscribers;
    }
    function deleteChannel(name) {
      if (channels[name]) {
        channels[name] = null;
        return true;
      }
      return false;
    }
    module2.exports = {
      channel,
      hasSubscribers,
      Channel,
      deleteChannel
    };
  }
});

// ../../node_modules/dc-polyfill/patch-garbage-collection-bug.js
var require_patch_garbage_collection_bug = __commonJS({
  "../../node_modules/dc-polyfill/patch-garbage-collection-bug.js"(exports2, module2) {
    var PHONY_SUBSCRIBE = function AVOID_GARBAGE_COLLECTION() {
    };
    var {
      ObjectDefineProperty,
      ObjectGetOwnPropertyDescriptor
    } = require_primordials();
    module2.exports = function(unpatched) {
      const dc_channel = unpatched.channel;
      const channels = /* @__PURE__ */ new WeakSet();
      const dc = { ...unpatched };
      dc.channel = function() {
        const ch = dc_channel.apply(this, arguments);
        if (channels.has(ch)) return ch;
        dc_channel(arguments[0]).subscribe(PHONY_SUBSCRIBE);
        channels.add(ch);
        if (!ObjectGetOwnPropertyDescriptor(ch, "hasSubscribers")) {
          ObjectDefineProperty(ch, "hasSubscribers", {
            get: function() {
              const subscribers = ch._subscribers;
              if (subscribers.length > 1) return true;
              const stores = ch._stores;
              if (stores.size > 0) return true;
              if (subscribers.length < 1) return false;
              if (subscribers[0] === PHONY_SUBSCRIBE) return false;
              return true;
            }
          });
        }
        return ch;
      };
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/patch-top-subscribe-unsubscribe.js
var require_patch_top_subscribe_unsubscribe = __commonJS({
  "../../node_modules/dc-polyfill/patch-top-subscribe-unsubscribe.js"(exports2, module2) {
    module2.exports = function(unpatched) {
      const dc = { ...unpatched };
      dc.subscribe = (channel, cb) => {
        return dc.channel(channel).subscribe(cb);
      };
      dc.unsubscribe = (channel, cb) => {
        return dc.channel(channel).unsubscribe(cb);
      };
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/patch-channel-unsubscribe-return.js
var require_patch_channel_unsubscribe_return = __commonJS({
  "../../node_modules/dc-polyfill/patch-channel-unsubscribe-return.js"(exports2, module2) {
    var { ObjectGetPrototypeOf } = require_primordials();
    module2.exports = function(unpatched) {
      const channels = /* @__PURE__ */ new WeakSet();
      const dc_channel = unpatched.channel;
      const dc = { ...unpatched };
      dc.channel = function() {
        const ch = dc_channel.apply(this, arguments);
        if (channels.has(ch)) return ch;
        ch.unsubscribe = function() {
          delete ch.unsubscribe;
          const oldSubscriberCount = this._subscribers.length;
          ObjectGetPrototypeOf(ch).unsubscribe.apply(this, arguments);
          return this._subscribers.length < oldSubscriberCount;
        };
        channels.add(ch);
        return ch;
      };
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/patch-channel-store-methods.js
var require_patch_channel_store_methods = __commonJS({
  "../../node_modules/dc-polyfill/patch-channel-store-methods.js"(exports2, module2) {
    var {
      ReflectApply,
      ObjectDefineProperty,
      ObjectGetOwnPropertyDescriptor
    } = require_primordials();
    module2.exports = function(unpatched) {
      const channels = /* @__PURE__ */ new WeakSet();
      const dc_channel = unpatched.channel;
      const dc = { ...unpatched };
      dc.channel = function() {
        const ch = dc_channel.apply(this, arguments);
        if (channels.has(ch)) return ch;
        ch._stores = /* @__PURE__ */ new Map();
        ch.bindStore = function(store, transform) {
          this._stores.set(store, transform);
        };
        ch.unbindStore = function(store) {
          if (!this._stores.has(store)) {
            return false;
          }
          this._stores.delete(store);
          return true;
        };
        ch.runStores = function(data, fn, thisArg, ...args) {
          let run = () => {
            this.publish(data);
            return ReflectApply(fn, thisArg, args);
          };
          for (const entry of this._stores.entries()) {
            const store = entry[0];
            const transform = entry[1];
            run = wrapStoreRun(store, data, run, transform);
          }
          return run();
        };
        if (!ObjectGetOwnPropertyDescriptor(ch, "hasSubscribers")) {
          ObjectDefineProperty(ch, "hasSubscribers", {
            get: function() {
              return this.__proto__.hasSubscribers || ch._stores.size > 0;
            }
          });
        }
        channels.add(ch);
        return ch;
      };
      return dc;
    };
    function wrapStoreRun(store, data, next, transform = defaultTransform) {
      return () => {
        let context2;
        try {
          context2 = transform(data);
        } catch (err) {
          process.nextTick(() => {
            throw err;
          });
          return next();
        }
        return store.run(context2, next);
      };
    }
    function defaultTransform(data) {
      return data;
    }
  }
});

// ../../node_modules/dc-polyfill/patch-tracing-channel.js
var require_patch_tracing_channel = __commonJS({
  "../../node_modules/dc-polyfill/patch-tracing-channel.js"(exports2, module2) {
    var {
      ReflectApply,
      PromiseReject,
      PromiseResolve,
      PromisePrototypeThen,
      ArrayPrototypeSplice,
      ArrayPrototypeAt
    } = require_primordials();
    var { ERR_INVALID_ARG_TYPE } = require_errors();
    var traceEvents = [
      "start",
      "end",
      "asyncStart",
      "asyncEnd",
      "error"
    ];
    module2.exports = function(unpatched) {
      const { channel } = unpatched;
      const dc = { ...unpatched };
      class TracingChannel {
        constructor(nameOrChannels) {
          if (typeof nameOrChannels === "string") {
            this.start = channel(`tracing:${nameOrChannels}:start`);
            this.end = channel(`tracing:${nameOrChannels}:end`);
            this.asyncStart = channel(`tracing:${nameOrChannels}:asyncStart`);
            this.asyncEnd = channel(`tracing:${nameOrChannels}:asyncEnd`);
            this.error = channel(`tracing:${nameOrChannels}:error`);
          } else if (typeof nameOrChannels === "object") {
            const { start, end, asyncStart, asyncEnd, error } = nameOrChannels;
            this.start = start;
            this.end = end;
            this.asyncStart = asyncStart;
            this.asyncEnd = asyncEnd;
            this.error = error;
          } else {
            throw new ERR_INVALID_ARG_TYPE(
              "nameOrChannels",
              ["string", "object", "Channel"],
              nameOrChannels
            );
          }
        }
        subscribe(handlers) {
          for (const name of traceEvents) {
            if (!handlers[name]) continue;
            if (this[name]) this[name].subscribe(handlers[name]);
          }
        }
        unsubscribe(handlers) {
          let done = true;
          for (const name of traceEvents) {
            if (!handlers[name]) continue;
            if (!(this[name] && this[name].unsubscribe(handlers[name]))) {
              done = false;
            }
          }
          return done;
        }
        traceSync(fn, context2 = {}, thisArg, ...args) {
          const { start, end, error } = this;
          return start.runStores(context2, () => {
            try {
              const result = ReflectApply(fn, thisArg, args);
              context2.result = result;
              return result;
            } catch (err) {
              context2.error = err;
              error.publish(context2);
              throw err;
            } finally {
              end.publish(context2);
            }
          });
        }
        tracePromise(fn, context2 = {}, thisArg, ...args) {
          const { start, end, asyncStart, asyncEnd, error } = this;
          function reject(err) {
            context2.error = err;
            error.publish(context2);
            asyncStart.publish(context2);
            asyncEnd.publish(context2);
            return PromiseReject(err);
          }
          function resolve(result) {
            context2.result = result;
            asyncStart.publish(context2);
            asyncEnd.publish(context2);
            return result;
          }
          return start.runStores(context2, () => {
            try {
              let promise = ReflectApply(fn, thisArg, args);
              if (!(promise instanceof Promise)) {
                promise = PromiseResolve(promise);
              }
              return PromisePrototypeThen(promise, resolve, reject);
            } catch (err) {
              context2.error = err;
              error.publish(context2);
              throw err;
            } finally {
              end.publish(context2);
            }
          });
        }
        traceCallback(fn, position = -1, context2 = {}, thisArg, ...args) {
          const { start, end, asyncStart, asyncEnd, error } = this;
          function wrappedCallback(err, res) {
            if (err) {
              context2.error = err;
              error.publish(context2);
            } else {
              context2.result = res;
            }
            asyncStart.runStores(context2, () => {
              try {
                if (callback) {
                  return ReflectApply(callback, this, arguments);
                }
              } finally {
                asyncEnd.publish(context2);
              }
            });
          }
          const callback = ArrayPrototypeAt(args, position);
          if (typeof callback !== "function") {
            throw new ERR_INVALID_ARG_TYPE("callback", ["function"], callback);
          }
          ArrayPrototypeSplice(args, position, 1, wrappedCallback);
          return start.runStores(context2, () => {
            try {
              return ReflectApply(fn, thisArg, args);
            } catch (err) {
              context2.error = err;
              error.publish(context2);
              throw err;
            } finally {
              end.publish(context2);
            }
          });
        }
      }
      function tracingChannel(nameOrChannels) {
        return new TracingChannel(nameOrChannels);
      }
      dc.tracingChannel = tracingChannel;
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/patch-sync-unsubscribe-bug.js
var require_patch_sync_unsubscribe_bug = __commonJS({
  "../../node_modules/dc-polyfill/patch-sync-unsubscribe-bug.js"(exports2, module2) {
    module2.exports = function(unpatched) {
      const channels = /* @__PURE__ */ new WeakSet();
      const dc_channel = unpatched.channel;
      const dc = { ...unpatched };
      dc.channel = function() {
        const ch = dc_channel.apply(this, arguments);
        if (channels.has(ch)) return ch;
        const publish = ch.publish;
        ch.publish = function() {
          if (!ch._subscribers) {
            ch._subscribers = [];
          }
          return publish.apply(ch, arguments);
        };
        return ch;
      };
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/patch-tracing-channel-has-subscribers.js
var require_patch_tracing_channel_has_subscribers = __commonJS({
  "../../node_modules/dc-polyfill/patch-tracing-channel-has-subscribers.js"(exports2, module2) {
    var {
      ObjectDefineProperty,
      ObjectGetPrototypeOf
    } = require_primordials();
    module2.exports = function(unpatched) {
      const dc = { ...unpatched };
      {
        const fauxTrCh = dc.tracingChannel("dc-polyfill-faux");
        const protoTrCh = ObjectGetPrototypeOf(fauxTrCh);
        ObjectDefineProperty(protoTrCh, "hasSubscribers", {
          get: function() {
            return this.start.hasSubscribers || this.end.hasSubscribers || this.asyncStart.hasSubscribers || this.asyncEnd.hasSubscribers || this.error.hasSubscribers;
          },
          configurable: true
        });
      }
      return dc;
    };
  }
});

// ../../node_modules/dc-polyfill/dc-polyfill.js
var require_dc_polyfill = __commonJS({
  "../../node_modules/dc-polyfill/dc-polyfill.js"(exports2, module2) {
    var checks = require_checks();
    require_primordials();
    var dc = checks.hasDiagnosticsChannel() ? __require("diagnostics_channel") : require_reimplementation();
    if (checks.hasGarbageCollectionBug()) {
      dc = require_patch_garbage_collection_bug()(dc);
    }
    if (!checks.hasTopSubscribeUnsubscribe()) {
      dc = require_patch_top_subscribe_unsubscribe()(dc);
    }
    if (!checks.hasChUnsubscribeReturn()) {
      dc = require_patch_channel_unsubscribe_return()(dc);
    }
    if (!checks.hasChannelStoreMethods()) {
      dc = require_patch_channel_store_methods()(dc);
    }
    if (!checks.hasTracingChannel()) {
      dc = require_patch_tracing_channel()(dc);
    }
    if (checks.hasSyncUnsubscribeBug()) {
      dc = require_patch_sync_unsubscribe_bug()(dc);
    }
    if (!checks.hasTracingChannelHasSubscribers()) {
      dc = require_patch_tracing_channel_has_subscribers()(dc);
    }
    module2.exports = dc;
  }
});

// ../../packages/dd-trace/src/log/channels.js
var require_channels = __commonJS({
  "../../packages/dd-trace/src/log/channels.js"(exports2, module2) {
    "use strict";
    var { channel } = require_dc_polyfill();
    var Level = {
      trace: 10,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      critical: 50,
      off: 100
    };
    var traceChannel = channel("datadog:log:trace");
    var debugChannel = channel("datadog:log:debug");
    var infoChannel = channel("datadog:log:info");
    var warnChannel = channel("datadog:log:warn");
    var errorChannel = channel("datadog:log:error");
    var defaultLevel = Level.debug;
    function getChannelLogLevel(level) {
      return level && typeof level === "string" ? Level[level.toLowerCase().trim()] || defaultLevel : defaultLevel;
    }
    var LogChannel = class {
      constructor(level) {
        this._level = getChannelLogLevel(level);
      }
      subscribe(logger) {
        if (Level.trace >= this._level) {
          traceChannel.subscribe(logger.trace);
        }
        if (Level.debug >= this._level) {
          debugChannel.subscribe(logger.debug);
        }
        if (Level.info >= this._level) {
          infoChannel.subscribe(logger.info);
        }
        if (Level.warn >= this._level) {
          warnChannel.subscribe(logger.warn);
        }
        if (Level.error >= this._level) {
          errorChannel.subscribe(logger.error);
        }
      }
      unsubscribe(logger) {
        if (traceChannel.hasSubscribers) {
          traceChannel.unsubscribe(logger.trace);
        }
        if (debugChannel.hasSubscribers) {
          debugChannel.unsubscribe(logger.debug);
        }
        if (infoChannel.hasSubscribers) {
          infoChannel.unsubscribe(logger.info);
        }
        if (warnChannel.hasSubscribers) {
          warnChannel.unsubscribe(logger.warn);
        }
        if (errorChannel.hasSubscribers) {
          errorChannel.unsubscribe(logger.error);
        }
      }
    };
    module2.exports = {
      LogChannel,
      traceChannel,
      debugChannel,
      infoChannel,
      warnChannel,
      errorChannel
    };
  }
});

// ../../packages/dd-trace/src/log/log.js
var require_log = __commonJS({
  "../../packages/dd-trace/src/log/log.js"(exports2, module2) {
    "use strict";
    var { format } = __require("util");
    var NoTransmitError = class extends Error {
    };
    var Log = class _Log {
      constructor(message, args, cause, delegate, sendViaTelemetry = true) {
        this.message = message;
        this.args = args;
        this.cause = cause;
        this.delegate = delegate;
        this.sendViaTelemetry = sendViaTelemetry;
      }
      get formatted() {
        const { message, args } = this;
        let formatted = message;
        if (message && args && args.length) {
          formatted = format(message, ...args);
        }
        return formatted;
      }
      static parse(...args) {
        let message, cause, delegate;
        let sendViaTelemetry = true;
        const maybeLogConfig = args.at(-1);
        if (maybeLogConfig instanceof LogConfig) {
          args.pop();
          sendViaTelemetry = maybeLogConfig.transmit;
        }
        const maybeError = args.at(-1);
        if (maybeError && typeof maybeError === "object" && maybeError.stack) {
          cause = args.pop();
          if (cause instanceof NoTransmitError) sendViaTelemetry = false;
        }
        const firstArg = args.shift();
        if (firstArg) {
          if (typeof firstArg === "string") {
            message = firstArg;
          } else if (typeof firstArg === "object") {
            message = String(firstArg.message || firstArg);
          } else if (typeof firstArg === "function") {
            delegate = firstArg;
          } else {
            message = String(firstArg);
          }
        } else if (!cause) {
          message = String(firstArg);
        }
        return new _Log(message, args, cause, delegate, sendViaTelemetry);
      }
    };
    var LogConfig = class {
      constructor(transmit = true) {
        this.transmit = transmit;
      }
    };
    module2.exports = {
      Log,
      LogConfig,
      NoTransmitError
    };
  }
});

// ../../packages/dd-trace/src/log/writer.js
var require_writer = __commonJS({
  "../../packages/dd-trace/src/log/writer.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var { LogChannel } = require_channels();
    var { Log } = require_log();
    var defaultLogger = {
      debug: (msg) => console.debug(msg),
      /* eslint-disable-line no-console */
      info: (msg) => console.info(msg),
      /* eslint-disable-line no-console */
      warn: (msg) => console.warn(msg),
      /* eslint-disable-line no-console */
      error: (msg) => console.error(msg)
      /* eslint-disable-line no-console */
    };
    var enabled = false;
    var logger = defaultLogger;
    var logChannel = new LogChannel();
    var stackTraceLimitFunction = onError;
    function withNoop(fn) {
      const store = storage("legacy").getStore();
      storage("legacy").enterWith({ noop: true });
      fn();
      storage("legacy").enterWith(store);
    }
    function unsubscribeAll() {
      logChannel.unsubscribe({ trace: onTrace, debug: onDebug, info: onInfo, warn: onWarn, error: onError });
    }
    function toggleSubscription(enable, level) {
      unsubscribeAll();
      if (enable) {
        logChannel = new LogChannel(level);
        logChannel.subscribe({ trace: onTrace, debug: onDebug, info: onInfo, warn: onWarn, error: onError });
      }
    }
    function toggle(enable, level) {
      enabled = enable;
      toggleSubscription(enabled, level);
    }
    function use(newLogger) {
      if (typeof newLogger?.debug === "function" && typeof newLogger.error === "function") {
        logger = newLogger;
      }
    }
    function reset() {
      logger = defaultLogger;
      enabled = false;
      toggleSubscription(false);
    }
    function getErrorLog(err) {
      if (typeof err?.delegate === "function") {
        const result = err.delegate();
        return Array.isArray(result) ? Log.parse(...result) : Log.parse(result);
      }
      return err;
    }
    function setStackTraceLimitFunction(fn) {
      if (typeof fn !== "function") {
        throw new TypeError("stackTraceLimitFunction must be a function");
      }
      stackTraceLimitFunction = fn;
    }
    function onError(err) {
      const { formatted, cause } = getErrorLog(err);
      if (formatted) {
        withNoop(() => {
          const stackTraceLimitBackup = Error.stackTraceLimit;
          Error.stackTraceLimit = 0;
          const newError = new Error(formatted);
          Error.stackTraceLimit = stackTraceLimitBackup;
          Error.captureStackTrace(newError, stackTraceLimitFunction);
          logger.error(newError);
        });
      }
      if (cause) withNoop(() => logger.error(cause));
    }
    function onWarn(log) {
      const { formatted, cause } = getErrorLog(log);
      if (formatted) withNoop(() => logger.warn(formatted));
      if (cause) withNoop(() => logger.warn(cause));
    }
    function onInfo(log) {
      const { formatted, cause } = getErrorLog(log);
      if (formatted) withNoop(() => logger.info(formatted));
      if (cause) withNoop(() => logger.info(cause));
    }
    function onDebug(log) {
      const { formatted, cause } = getErrorLog(log);
      if (formatted) withNoop(() => logger.debug(formatted));
      if (cause) withNoop(() => logger.debug(cause));
    }
    function onTrace(log) {
      const { formatted, cause } = getErrorLog(log);
      if (formatted) withNoop(() => logger.debug(formatted));
      if (cause) withNoop(() => logger.debug(cause));
    }
    function error(...args) {
      onError(Log.parse(...args));
    }
    function warn(...args) {
      const log = Log.parse(...args);
      if (!logger.warn) return onDebug(log);
      onWarn(log);
    }
    function info(...args) {
      const log = Log.parse(...args);
      if (!logger.info) return onDebug(log);
      onInfo(log);
    }
    function debug(...args) {
      onDebug(Log.parse(...args));
    }
    function trace2(...args) {
      onTrace(Log.parse(...args));
    }
    module2.exports = { use, toggle, reset, error, warn, info, debug, trace: trace2, setStackTraceLimitFunction };
  }
});

// ../../packages/dd-trace/src/log/utils.js
var require_utils2 = __commonJS({
  "../../packages/dd-trace/src/log/utils.js"(exports2, module2) {
    "use strict";
    var memoize = (func) => {
      const cache = {};
      const memoized = function(key) {
        if (!cache[key]) {
          cache[key] = func.apply(this, arguments);
        }
        return cache[key];
      };
      return memoized;
    };
    module2.exports = { memoize };
  }
});

// ../../packages/dd-trace/src/log/index.js
var require_log2 = __commonJS({
  "../../packages/dd-trace/src/log/index.js"(exports2, module2) {
    "use strict";
    var { inspect } = __require("util");
    var { isTrue } = require_util();
    var { traceChannel, debugChannel, infoChannel, warnChannel, errorChannel } = require_channels();
    var logWriter = require_writer();
    var { Log, LogConfig, NoTransmitError } = require_log();
    var { memoize } = require_utils2();
    var { getEnvironmentVariable } = require_config_helper();
    var config = {
      enabled: false,
      logger: void 0,
      logLevel: "debug"
    };
    var NO_TRANSMIT = new LogConfig(false);
    var log = {
      LogConfig,
      NO_TRANSMIT,
      NoTransmitError,
      /**
       * @returns Read-only version of logging config. To modify config, call `log.use` and `log.toggle`
       */
      getConfig() {
        return { ...config };
      },
      use(logger) {
        config.logger = logger;
        logWriter.use(logger);
        return this;
      },
      toggle(enabled, logLevel) {
        config.enabled = enabled;
        config.logLevel = logLevel;
        logWriter.toggle(enabled, logLevel);
        return this;
      },
      reset() {
        logWriter.reset();
        this._deprecate = memoize((code, message) => {
          errorChannel.publish(Log.parse(message));
          return true;
        });
        return this;
      },
      trace(...args) {
        if (traceChannel.hasSubscribers) {
          const logRecord = {};
          Error.captureStackTrace(logRecord, this.trace);
          const stack = logRecord.stack.split("\n");
          const fn = stack[1].replace(/^\s+at ([^\s]+) .+/, "$1");
          const options = { depth: 2, breakLength: Infinity, compact: true, maxArrayLength: Infinity };
          const params = args.map((a) => inspect(a, options)).join(", ");
          stack[0] = `Trace: ${fn}(${params})`;
          traceChannel.publish(Log.parse(stack.join("\n")));
        }
        return this;
      },
      debug(...args) {
        if (debugChannel.hasSubscribers) {
          debugChannel.publish(Log.parse(...args));
        }
        return this;
      },
      info(...args) {
        if (infoChannel.hasSubscribers) {
          infoChannel.publish(Log.parse(...args));
        }
        return this;
      },
      warn(...args) {
        if (warnChannel.hasSubscribers) {
          warnChannel.publish(Log.parse(...args));
        }
        return this;
      },
      error(...args) {
        if (errorChannel.hasSubscribers) {
          errorChannel.publish(Log.parse(...args));
        }
        return this;
      },
      errorWithoutTelemetry(...args) {
        args.push(NO_TRANSMIT);
        if (errorChannel.hasSubscribers) {
          errorChannel.publish(Log.parse(...args));
        }
        return this;
      },
      deprecate(code, message) {
        return this._deprecate(code, message);
      },
      isEnabled(fleetStableConfigValue, localStableConfigValue) {
        return isTrue(
          fleetStableConfigValue ?? getEnvironmentVariable("DD_TRACE_DEBUG") ?? (getEnvironmentVariable("OTEL_LOG_LEVEL") === "debug" || void 0) ?? localStableConfigValue ?? config.enabled
        );
      },
      getLogLevel(optionsValue, fleetStableConfigValue, localStableConfigValue) {
        return optionsValue ?? fleetStableConfigValue ?? getEnvironmentVariable("DD_TRACE_LOG_LEVEL") ?? getEnvironmentVariable("OTEL_LOG_LEVEL") ?? localStableConfigValue ?? config.logLevel;
      }
    };
    logWriter.setStackTraceLimitFunction(log.error);
    log.reset();
    log.toggle(log.isEnabled(), log.getLogLevel());
    module2.exports = log;
  }
});

// ../../packages/dd-trace/src/tagger.js
var require_tagger = __commonJS({
  "../../packages/dd-trace/src/tagger.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    function addNonEmpty(carrier, key, value) {
      if (key !== "") {
        carrier[key] = value;
      }
    }
    function add(carrier, keyValuePairs) {
      if (!carrier) return;
      try {
        if (typeof keyValuePairs === "string") {
          let valueStart = 0;
          let keyStart = 0;
          for (let i = 0; i < keyValuePairs.length; i++) {
            const char = keyValuePairs[i];
            if (char === ":") {
              if (valueStart === 0) {
                valueStart = i;
              }
            } else if (char === ",") {
              valueStart ||= i;
              addNonEmpty(
                carrier,
                keyValuePairs.slice(keyStart, valueStart).trim(),
                keyValuePairs.slice(valueStart + 1, i).trim()
              );
              keyStart = i + 1;
              valueStart = 0;
            }
          }
          if (keyValuePairs.at(-1) !== ",") {
            valueStart ||= keyValuePairs.length;
            addNonEmpty(
              carrier,
              keyValuePairs.slice(keyStart, valueStart).trim(),
              keyValuePairs.slice(valueStart + 1).trim()
            );
          }
        } else if (Array.isArray(keyValuePairs)) {
          return keyValuePairs.forEach((tags) => add(carrier, tags));
        } else {
          Object.assign(carrier, keyValuePairs);
        }
      } catch (error) {
        log.error("Error adding tags", error);
      }
    }
    module2.exports = { add };
  }
});

// ../../packages/dd-trace/src/exporters/common/url-to-http-options-polyfill.js
var require_url_to_http_options_polyfill = __commonJS({
  "../../packages/dd-trace/src/exporters/common/url-to-http-options-polyfill.js"(exports2, module2) {
    "use strict";
    var { urlToHttpOptions } = __require("url");
    module2.exports = {
      urlToHttpOptions: urlToHttpOptions ?? function(url) {
        const { hostname, pathname, port, username, password, search } = url;
        const options = {
          __proto__: null,
          ...url,
          // In case the url object was extended by the user.
          protocol: url.protocol,
          hostname: typeof hostname === "string" && hostname.startsWith("[") ? hostname.slice(1, -1) : hostname,
          hash: url.hash,
          search,
          pathname,
          path: `${pathname || ""}${search || ""}`,
          href: url.href
        };
        if (port !== "") {
          options.port = Number(port);
        }
        if (username || password) {
          options.auth = `${decodeURIComponent(username)}:${decodeURIComponent(password)}`;
        }
        return options;
      }
    };
  }
});

// ../../packages/dd-trace/src/exporters/common/docker.js
var require_docker = __commonJS({
  "../../packages/dd-trace/src/exporters/common/docker.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var { getEnvironmentVariable } = require_config_helper();
    var DD_EXTERNAL_ENV = getEnvironmentVariable("DD_EXTERNAL_ENV");
    var uuidSource = "[0-9a-f]{8}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{4}[-_][0-9a-f]{12}|[0-9a-f]{8}(?:-[0-9a-f]{4}){4}$";
    var containerSource = "[0-9a-f]{64}";
    var taskSource = String.raw`[0-9a-f]{32}-\d+`;
    var lineReg = /^(\d+):([^:]*):(.+)$/m;
    var entityReg = new RegExp(`.*(${uuidSource}|${containerSource}|${taskSource})(?:\\.scope)?$`, "m");
    var inode = 0;
    var cgroup = "";
    var entityId;
    try {
      cgroup = fs.readFileSync("/proc/self/cgroup", "utf8").trim();
      entityId = cgroup.match(entityReg)?.[1];
    } catch {
    }
    var inodePath = cgroup.match(lineReg)?.[3];
    if (inodePath) {
      const strippedPath = inodePath.replaceAll(/^\/|\/$/g, "");
      try {
        inode = fs.statSync(`/sys/fs/cgroup/${strippedPath}`).ino;
      } catch {
      }
    }
    module2.exports = {
      inject(carrier) {
        if (entityId) {
          carrier["Datadog-Container-Id"] = entityId;
          carrier["Datadog-Entity-ID"] = `ci-${entityId}`;
        } else if (inode) {
          carrier["Datadog-Entity-ID"] = `in-${inode}`;
        }
        if (DD_EXTERNAL_ENV) {
          carrier["Datadog-External-Env"] = DD_EXTERNAL_ENV;
        }
      }
    };
  }
});

// ../../packages/dd-trace/src/exporters/common/agents.js
var require_agents = __commonJS({
  "../../packages/dd-trace/src/exporters/common/agents.js"(exports2, module2) {
    "use strict";
    var http = __require("http");
    var https = __require("https");
    var { storage } = require_datadog_core();
    var keepAlive = true;
    var maxSockets = 1;
    function createAgentClass(BaseAgent) {
      class CustomAgent extends BaseAgent {
        constructor() {
          super({ keepAlive, maxSockets });
        }
        createConnection(...args) {
          return this._noop(() => super.createConnection(...args));
        }
        keepSocketAlive(...args) {
          return this._noop(() => super.keepSocketAlive(...args));
        }
        reuseSocket(...args) {
          return this._noop(() => super.reuseSocket(...args));
        }
        _noop(callback) {
          return storage("legacy").run({ noop: true }, callback);
        }
      }
      return CustomAgent;
    }
    var HttpAgent = createAgentClass(http.Agent);
    var HttpsAgent = createAgentClass(https.Agent);
    module2.exports = {
      httpAgent: new HttpAgent(),
      HttpsAgent: new HttpsAgent()
    };
  }
});

// ../../packages/dd-trace/src/exporters/common/request.js
var require_request = __commonJS({
  "../../packages/dd-trace/src/exporters/common/request.js"(exports2, module2) {
    "use strict";
    var { Readable } = __require("stream");
    var http = __require("http");
    var https = __require("https");
    var zlib = __require("zlib");
    var { urlToHttpOptions } = require_url_to_http_options_polyfill();
    var docker = require_docker();
    var { httpAgent, httpsAgent } = require_agents();
    var { storage } = require_datadog_core();
    var log = require_log2();
    var maxActiveRequests = 8;
    var activeRequests = 0;
    function parseUrl(urlObjOrString) {
      if (urlObjOrString !== null && typeof urlObjOrString === "object") return urlToHttpOptions(urlObjOrString);
      const url = urlToHttpOptions(new URL(urlObjOrString));
      if (url.protocol === "unix:" && url.hostname === ".") {
        const udsPath = urlObjOrString.slice(5);
        url.path = udsPath;
        url.pathname = udsPath;
      }
      return url;
    }
    function request2(data, options, callback) {
      if (!options.headers) {
        options.headers = {};
      }
      if (options.url) {
        const url = parseUrl(options.url);
        if (url.protocol === "unix:") {
          options.socketPath = url.pathname;
        } else {
          if (!options.path) options.path = url.path;
          options.protocol = url.protocol;
          options.hostname = url.hostname;
          options.port = url.port;
        }
      }
      const isReadable = data instanceof Readable;
      const timeout = options.timeout || 2e3;
      const isSecure = options.protocol === "https:";
      const client = isSecure ? https : http;
      let dataArray = data;
      if (!isReadable) {
        if (!Array.isArray(data)) {
          dataArray = [data];
        }
        options.headers["Content-Length"] = byteLength(dataArray);
      }
      docker.inject(options.headers);
      options.agent = isSecure ? httpsAgent : httpAgent;
      const onResponse = (res) => {
        const chunks = [];
        res.setTimeout(timeout);
        res.on("data", (chunk) => {
          chunks.push(chunk);
        });
        res.on("end", () => {
          activeRequests--;
          const buffer = Buffer.concat(chunks);
          if (res.statusCode >= 200 && res.statusCode <= 299) {
            const isGzip = res.headers["content-encoding"] === "gzip";
            if (isGzip) {
              zlib.gunzip(buffer, (err, result) => {
                if (err) {
                  log.error("Could not gunzip response: %s", err.message);
                  callback(null, "", res.statusCode);
                } else {
                  callback(null, result.toString(), res.statusCode);
                }
              });
            } else {
              callback(null, buffer.toString(), res.statusCode);
            }
          } else {
            let errorMessage = "";
            try {
              const fullUrl = new URL(
                options.path,
                options.url || options.hostname || `http://localhost:${options.port}`
              ).href;
              errorMessage = `Error from ${fullUrl}: ${res.statusCode} ${http.STATUS_CODES[res.statusCode]}.`;
            } catch {
            }
            const responseData = buffer.toString();
            if (responseData) {
              errorMessage += ` Response from the endpoint: "${responseData}"`;
            }
            const error = new log.NoTransmitError(errorMessage);
            error.status = res.statusCode;
            callback(error, null, res.statusCode);
          }
        });
      };
      const makeRequest = (onError) => {
        if (!request2.writable) {
          log.debug("Maximum number of active requests reached: payload is discarded.");
          return callback(null);
        }
        activeRequests++;
        const store = storage("legacy").getStore();
        storage("legacy").enterWith({ noop: true });
        const req = client.request(options, onResponse);
        req.once("error", (err) => {
          activeRequests--;
          onError(err);
        });
        req.setTimeout(timeout, req.abort);
        if (isReadable) {
          data.pipe(req);
        } else {
          dataArray.forEach((buffer) => req.write(buffer));
          req.end();
        }
        storage("legacy").enterWith(store);
      };
      makeRequest(() => setTimeout(() => makeRequest(callback)));
    }
    function byteLength(data) {
      return data.length > 0 ? data.reduce((prev, next) => prev + Buffer.byteLength(next, "utf8"), 0) : 0;
    }
    Object.defineProperty(request2, "writable", {
      get() {
        return activeRequests < maxActiveRequests;
      }
    });
    module2.exports = request2;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js
var require_util2 = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sumOfRange = void 0;
    var sumOfRange = function(array, start, end) {
      var sum = 0;
      for (var i = start; i <= end; i++) {
        sum += array[i];
      }
      return sum;
    };
    exports2.sumOfRange = sumOfRange;
  }
});

// ../../node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "../../node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// ../../node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "../../node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = function length(string) {
      var p = string.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=")
        ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = function encode(buffer, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base64.decode = function decode(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base64.test = function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    };
  }
});

// ../../node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "../../node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    EventEmitter.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// ../../node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "../../node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
  }
});

// ../../node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "../../node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// ../../node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "../../node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// ../../node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "../../node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf;
      };
    }
  }
});

// ../../node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "../../node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign = value < 0;
      if (sign)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash) {
      if (hash === zeroHash)
        return zero;
      return new LongBits(
        (charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0,
        (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0
      );
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(
        this.lo & 255,
        this.lo >>> 8 & 255,
        this.lo >>> 16 & 255,
        this.lo >>> 24,
        this.hi & 255,
        this.hi >>> 8 & 255,
        this.hi >>> 16 & 255,
        this.hi >>> 24
      );
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// ../../node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "../../node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util.isInteger = Number.isInteger || /* istanbul ignore next */
    function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = /**
     * Checks if a property on a message is considered to be present.
     * @param {Object} obj Plain object or message instance
     * @param {string} prop Property name
     * @returns {boolean} `true` if considered to be present, otherwise `false`
     */
    util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = (function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    })();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = /* istanbul ignore next */
    util.global.dcodeIO && /* istanbul ignore next */
    util.global.dcodeIO.Long || /* istanbul ignore next */
    util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash, unsigned) {
      var bits = util.LongBits.fromHash(hash);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src[keys[i]];
      return dst;
    }
    util.merge = merge;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge(this, properties);
      }
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: function get3() {
            return name;
          },
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: function value() {
            return this.name + ": " + this.message;
          },
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "../../node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base64 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create();
    Writer.alloc = function alloc(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp(
        (value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5,
        value
      )).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i)
        buf[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf = Writer.alloc(len = base64.length(value));
        base64.decode(value, buf, 0);
        value = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// ../../node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "../../node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy)
          val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf, pos);
      else if (buf.utf8Write)
        buf.utf8Write(val, pos);
      else
        buf.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// ../../node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "../../node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    } : function create_array2(buffer) {
      if (Array.isArray(buffer))
        return new Reader(buffer);
      throw Error("illegal buffer");
    };
    var create = function create2() {
      return util.Buffer ? function create_buffer_setup(buffer) {
        return (Reader.create = function create_buffer(buffer2) {
          return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        })(buffer);
      } : create_array;
    };
    Reader.create = create();
    Reader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */
    util.Array.prototype.slice;
    Reader.prototype.uint32 = /* @__PURE__ */ (function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    })();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    };
    Reader.prototype.skip = function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len)
          throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// ../../node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "../../node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// ../../node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "../../node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request2, callback) {
      if (!request2)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request2);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(
          method,
          requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request2).finish(),
          function rpcCallback(err, response) {
            if (err) {
              self2.emit("error", err, method);
              return callback(err);
            }
            if (response === null) {
              self2.end(
                /* endedByRPC */
                true
              );
              return void 0;
            }
            if (!(response instanceof responseCtor)) {
              try {
                response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
              } catch (err2) {
                self2.emit("error", err2, method);
                return callback(err2);
              }
            }
            self2.emit("data", response, method);
            return callback(null, response);
          }
        );
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// ../../node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "../../node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// ../../node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "../../node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// ../../node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "../../node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure();
  }
});

// ../../node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "../../node_modules/protobufjs/minimal.js"(exports2, module2) {
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js
var require_compiled = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/proto/compiled.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_minimal2();
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});
    $root.DDSketch = (function() {
      function DDSketch(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      DDSketch.prototype.mapping = null;
      DDSketch.prototype.positiveValues = null;
      DDSketch.prototype.negativeValues = null;
      DDSketch.prototype.zeroCount = 0;
      DDSketch.create = function create(properties) {
        return new DDSketch(properties);
      };
      DDSketch.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.mapping != null && Object.hasOwnProperty.call(message, "mapping"))
          $root.IndexMapping.encode(message.mapping, writer.uint32(
            /* id 1, wireType 2 =*/
            10
          ).fork()).ldelim();
        if (message.positiveValues != null && Object.hasOwnProperty.call(message, "positiveValues"))
          $root.Store.encode(message.positiveValues, writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork()).ldelim();
        if (message.negativeValues != null && Object.hasOwnProperty.call(message, "negativeValues"))
          $root.Store.encode(message.negativeValues, writer.uint32(
            /* id 3, wireType 2 =*/
            26
          ).fork()).ldelim();
        if (message.zeroCount != null && Object.hasOwnProperty.call(message, "zeroCount"))
          writer.uint32(
            /* id 4, wireType 1 =*/
            33
          ).double(message.zeroCount);
        return writer;
      };
      DDSketch.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      DDSketch.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.DDSketch();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.mapping = $root.IndexMapping.decode(reader, reader.uint32());
              break;
            case 2:
              message.positiveValues = $root.Store.decode(reader, reader.uint32());
              break;
            case 3:
              message.negativeValues = $root.Store.decode(reader, reader.uint32());
              break;
            case 4:
              message.zeroCount = reader.double();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      DDSketch.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      DDSketch.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.mapping != null && message.hasOwnProperty("mapping")) {
          var error = $root.IndexMapping.verify(message.mapping);
          if (error)
            return "mapping." + error;
        }
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues")) {
          var error = $root.Store.verify(message.positiveValues);
          if (error)
            return "positiveValues." + error;
        }
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues")) {
          var error = $root.Store.verify(message.negativeValues);
          if (error)
            return "negativeValues." + error;
        }
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount")) {
          if (typeof message.zeroCount !== "number")
            return "zeroCount: number expected";
        }
        return null;
      };
      DDSketch.fromObject = function fromObject(object) {
        if (object instanceof $root.DDSketch)
          return object;
        var message = new $root.DDSketch();
        if (object.mapping != null) {
          if (typeof object.mapping !== "object")
            throw TypeError(".DDSketch.mapping: object expected");
          message.mapping = $root.IndexMapping.fromObject(object.mapping);
        }
        if (object.positiveValues != null) {
          if (typeof object.positiveValues !== "object")
            throw TypeError(".DDSketch.positiveValues: object expected");
          message.positiveValues = $root.Store.fromObject(object.positiveValues);
        }
        if (object.negativeValues != null) {
          if (typeof object.negativeValues !== "object")
            throw TypeError(".DDSketch.negativeValues: object expected");
          message.negativeValues = $root.Store.fromObject(object.negativeValues);
        }
        if (object.zeroCount != null)
          message.zeroCount = Number(object.zeroCount);
        return message;
      };
      DDSketch.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.mapping = null;
          object.positiveValues = null;
          object.negativeValues = null;
          object.zeroCount = 0;
        }
        if (message.mapping != null && message.hasOwnProperty("mapping"))
          object.mapping = $root.IndexMapping.toObject(message.mapping, options);
        if (message.positiveValues != null && message.hasOwnProperty("positiveValues"))
          object.positiveValues = $root.Store.toObject(message.positiveValues, options);
        if (message.negativeValues != null && message.hasOwnProperty("negativeValues"))
          object.negativeValues = $root.Store.toObject(message.negativeValues, options);
        if (message.zeroCount != null && message.hasOwnProperty("zeroCount"))
          object.zeroCount = options.json && !isFinite(message.zeroCount) ? String(message.zeroCount) : message.zeroCount;
        return object;
      };
      DDSketch.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return DDSketch;
    })();
    $root.IndexMapping = (function() {
      function IndexMapping(properties) {
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      IndexMapping.prototype.gamma = 0;
      IndexMapping.prototype.indexOffset = 0;
      IndexMapping.prototype.interpolation = 0;
      IndexMapping.create = function create(properties) {
        return new IndexMapping(properties);
      };
      IndexMapping.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.gamma != null && Object.hasOwnProperty.call(message, "gamma"))
          writer.uint32(
            /* id 1, wireType 1 =*/
            9
          ).double(message.gamma);
        if (message.indexOffset != null && Object.hasOwnProperty.call(message, "indexOffset"))
          writer.uint32(
            /* id 2, wireType 1 =*/
            17
          ).double(message.indexOffset);
        if (message.interpolation != null && Object.hasOwnProperty.call(message, "interpolation"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).int32(message.interpolation);
        return writer;
      };
      IndexMapping.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      IndexMapping.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.IndexMapping();
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              message.gamma = reader.double();
              break;
            case 2:
              message.indexOffset = reader.double();
              break;
            case 3:
              message.interpolation = reader.int32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      IndexMapping.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      IndexMapping.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.gamma != null && message.hasOwnProperty("gamma")) {
          if (typeof message.gamma !== "number")
            return "gamma: number expected";
        }
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset")) {
          if (typeof message.indexOffset !== "number")
            return "indexOffset: number expected";
        }
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
          switch (message.interpolation) {
            default:
              return "interpolation: enum value expected";
            case 0:
            case 1:
            case 2:
            case 3:
              break;
          }
        return null;
      };
      IndexMapping.fromObject = function fromObject(object) {
        if (object instanceof $root.IndexMapping)
          return object;
        var message = new $root.IndexMapping();
        if (object.gamma != null)
          message.gamma = Number(object.gamma);
        if (object.indexOffset != null)
          message.indexOffset = Number(object.indexOffset);
        switch (object.interpolation) {
          case "NONE":
          case 0:
            message.interpolation = 0;
            break;
          case "LINEAR":
          case 1:
            message.interpolation = 1;
            break;
          case "QUADRATIC":
          case 2:
            message.interpolation = 2;
            break;
          case "CUBIC":
          case 3:
            message.interpolation = 3;
            break;
        }
        return message;
      };
      IndexMapping.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.defaults) {
          object.gamma = 0;
          object.indexOffset = 0;
          object.interpolation = options.enums === String ? "NONE" : 0;
        }
        if (message.gamma != null && message.hasOwnProperty("gamma"))
          object.gamma = options.json && !isFinite(message.gamma) ? String(message.gamma) : message.gamma;
        if (message.indexOffset != null && message.hasOwnProperty("indexOffset"))
          object.indexOffset = options.json && !isFinite(message.indexOffset) ? String(message.indexOffset) : message.indexOffset;
        if (message.interpolation != null && message.hasOwnProperty("interpolation"))
          object.interpolation = options.enums === String ? $root.IndexMapping.Interpolation[message.interpolation] : message.interpolation;
        return object;
      };
      IndexMapping.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      IndexMapping.Interpolation = (function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NONE"] = 0;
        values[valuesById[1] = "LINEAR"] = 1;
        values[valuesById[2] = "QUADRATIC"] = 2;
        values[valuesById[3] = "CUBIC"] = 3;
        return values;
      })();
      return IndexMapping;
    })();
    $root.Store = (function() {
      function Store(properties) {
        this.binCounts = {};
        this.contiguousBinCounts = [];
        if (properties) {
          for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
            if (properties[keys[i]] != null)
              this[keys[i]] = properties[keys[i]];
        }
      }
      Store.prototype.binCounts = $util.emptyObject;
      Store.prototype.contiguousBinCounts = $util.emptyArray;
      Store.prototype.contiguousBinIndexOffset = 0;
      Store.create = function create(properties) {
        return new Store(properties);
      };
      Store.encode = function encode(message, writer) {
        if (!writer)
          writer = $Writer.create();
        if (message.binCounts != null && Object.hasOwnProperty.call(message, "binCounts"))
          for (var keys = Object.keys(message.binCounts), i = 0; i < keys.length; ++i)
            writer.uint32(
              /* id 1, wireType 2 =*/
              10
            ).fork().uint32(
              /* id 1, wireType 0 =*/
              8
            ).sint32(keys[i]).uint32(
              /* id 2, wireType 1 =*/
              17
            ).double(message.binCounts[keys[i]]).ldelim();
        if (message.contiguousBinCounts != null && message.contiguousBinCounts.length) {
          writer.uint32(
            /* id 2, wireType 2 =*/
            18
          ).fork();
          for (var i = 0; i < message.contiguousBinCounts.length; ++i)
            writer.double(message.contiguousBinCounts[i]);
          writer.ldelim();
        }
        if (message.contiguousBinIndexOffset != null && Object.hasOwnProperty.call(message, "contiguousBinIndexOffset"))
          writer.uint32(
            /* id 3, wireType 0 =*/
            24
          ).sint32(message.contiguousBinIndexOffset);
        return writer;
      };
      Store.encodeDelimited = function encodeDelimited(message, writer) {
        return this.encode(message, writer).ldelim();
      };
      Store.decode = function decode(reader, length) {
        if (!(reader instanceof $Reader))
          reader = $Reader.create(reader);
        var end = length === void 0 ? reader.len : reader.pos + length, message = new $root.Store(), key, value;
        while (reader.pos < end) {
          var tag = reader.uint32();
          switch (tag >>> 3) {
            case 1:
              if (message.binCounts === $util.emptyObject)
                message.binCounts = {};
              var end2 = reader.uint32() + reader.pos;
              key = 0;
              value = 0;
              while (reader.pos < end2) {
                var tag2 = reader.uint32();
                switch (tag2 >>> 3) {
                  case 1:
                    key = reader.sint32();
                    break;
                  case 2:
                    value = reader.double();
                    break;
                  default:
                    reader.skipType(tag2 & 7);
                    break;
                }
              }
              message.binCounts[key] = value;
              break;
            case 2:
              if (!(message.contiguousBinCounts && message.contiguousBinCounts.length))
                message.contiguousBinCounts = [];
              if ((tag & 7) === 2) {
                var end2 = reader.uint32() + reader.pos;
                while (reader.pos < end2)
                  message.contiguousBinCounts.push(reader.double());
              } else
                message.contiguousBinCounts.push(reader.double());
              break;
            case 3:
              message.contiguousBinIndexOffset = reader.sint32();
              break;
            default:
              reader.skipType(tag & 7);
              break;
          }
        }
        return message;
      };
      Store.decodeDelimited = function decodeDelimited(reader) {
        if (!(reader instanceof $Reader))
          reader = new $Reader(reader);
        return this.decode(reader, reader.uint32());
      };
      Store.verify = function verify(message) {
        if (typeof message !== "object" || message === null)
          return "object expected";
        if (message.binCounts != null && message.hasOwnProperty("binCounts")) {
          if (!$util.isObject(message.binCounts))
            return "binCounts: object expected";
          var key = Object.keys(message.binCounts);
          for (var i = 0; i < key.length; ++i) {
            if (!$util.key32Re.test(key[i]))
              return "binCounts: integer key{k:sint32} expected";
            if (typeof message.binCounts[key[i]] !== "number")
              return "binCounts: number{k:sint32} expected";
          }
        }
        if (message.contiguousBinCounts != null && message.hasOwnProperty("contiguousBinCounts")) {
          if (!Array.isArray(message.contiguousBinCounts))
            return "contiguousBinCounts: array expected";
          for (var i = 0; i < message.contiguousBinCounts.length; ++i)
            if (typeof message.contiguousBinCounts[i] !== "number")
              return "contiguousBinCounts: number[] expected";
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset")) {
          if (!$util.isInteger(message.contiguousBinIndexOffset))
            return "contiguousBinIndexOffset: integer expected";
        }
        return null;
      };
      Store.fromObject = function fromObject(object) {
        if (object instanceof $root.Store)
          return object;
        var message = new $root.Store();
        if (object.binCounts) {
          if (typeof object.binCounts !== "object")
            throw TypeError(".Store.binCounts: object expected");
          message.binCounts = {};
          for (var keys = Object.keys(object.binCounts), i = 0; i < keys.length; ++i)
            message.binCounts[keys[i]] = Number(object.binCounts[keys[i]]);
        }
        if (object.contiguousBinCounts) {
          if (!Array.isArray(object.contiguousBinCounts))
            throw TypeError(".Store.contiguousBinCounts: array expected");
          message.contiguousBinCounts = [];
          for (var i = 0; i < object.contiguousBinCounts.length; ++i)
            message.contiguousBinCounts[i] = Number(object.contiguousBinCounts[i]);
        }
        if (object.contiguousBinIndexOffset != null)
          message.contiguousBinIndexOffset = object.contiguousBinIndexOffset | 0;
        return message;
      };
      Store.toObject = function toObject(message, options) {
        if (!options)
          options = {};
        var object = {};
        if (options.arrays || options.defaults)
          object.contiguousBinCounts = [];
        if (options.objects || options.defaults)
          object.binCounts = {};
        if (options.defaults)
          object.contiguousBinIndexOffset = 0;
        var keys2;
        if (message.binCounts && (keys2 = Object.keys(message.binCounts)).length) {
          object.binCounts = {};
          for (var j = 0; j < keys2.length; ++j)
            object.binCounts[keys2[j]] = options.json && !isFinite(message.binCounts[keys2[j]]) ? String(message.binCounts[keys2[j]]) : message.binCounts[keys2[j]];
        }
        if (message.contiguousBinCounts && message.contiguousBinCounts.length) {
          object.contiguousBinCounts = [];
          for (var j = 0; j < message.contiguousBinCounts.length; ++j)
            object.contiguousBinCounts[j] = options.json && !isFinite(message.contiguousBinCounts[j]) ? String(message.contiguousBinCounts[j]) : message.contiguousBinCounts[j];
        }
        if (message.contiguousBinIndexOffset != null && message.hasOwnProperty("contiguousBinIndexOffset"))
          object.contiguousBinIndexOffset = message.contiguousBinIndexOffset;
        return object;
      };
      Store.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
      };
      return Store;
    })();
    module2.exports = $root;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js
var require_DenseStore = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/DenseStore.js"(exports2) {
    "use strict";
    var __spreadArray5 = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DenseStore = void 0;
    var util_1 = require_util2();
    var CHUNK_SIZE = 128;
    var DenseStore = (
      /** @class */
      (function() {
        function DenseStore2(chunkSize) {
          if (chunkSize === void 0) {
            chunkSize = CHUNK_SIZE;
          }
          this.chunkSize = chunkSize;
          this.bins = [];
          this.count = 0;
          this.minKey = Infinity;
          this.maxKey = -Infinity;
          this.offset = 0;
        }
        DenseStore2.prototype.add = function(key, weight) {
          if (weight === void 0) {
            weight = 1;
          }
          var index = this._getIndex(key);
          this.bins[index] += weight;
          this.count += weight;
        };
        DenseStore2.prototype.keyAtRank = function(rank, lower) {
          if (lower === void 0) {
            lower = true;
          }
          var runningCount = 0;
          for (var i = 0; i < this.length(); i++) {
            var bin = this.bins[i];
            runningCount += bin;
            if (lower && runningCount > rank || !lower && runningCount >= rank + 1) {
              return i + this.offset;
            }
          }
          return this.maxKey;
        };
        DenseStore2.prototype.merge = function(store) {
          if (store.count === 0) {
            return;
          }
          if (this.count === 0) {
            this.copy(store);
            return;
          }
          if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
          }
          var collapseStartIndex = store.minKey - store.offset;
          var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
          if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[0] += collapseCount;
          } else {
            collapseEndIndex = collapseStartIndex;
          }
          for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
          }
          this.count += store.count;
        };
        DenseStore2.prototype.copy = function(store) {
          this.bins = __spreadArray5([], store.bins, true);
          this.count = store.count;
          this.minKey = store.minKey;
          this.maxKey = store.maxKey;
          this.offset = store.offset;
        };
        DenseStore2.prototype.length = function() {
          return this.bins.length;
        };
        DenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
          var desiredLength = newMaxKey - newMinKey + 1;
          return this.chunkSize * Math.ceil(desiredLength / this.chunkSize);
        };
        DenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
          this._centerBins(newMinKey, newMaxKey);
          this.minKey = newMinKey;
          this.maxKey = newMaxKey;
        };
        DenseStore2.prototype._shiftBins = function(shift) {
          var _a, _b;
          if (shift > 0) {
            this.bins = this.bins.slice(0, -shift);
            (_a = this.bins).unshift.apply(_a, new Array(shift).fill(0));
          } else {
            this.bins = this.bins.slice(Math.abs(shift));
            (_b = this.bins).push.apply(_b, new Array(Math.abs(shift)).fill(0));
          }
          this.offset -= shift;
        };
        DenseStore2.prototype._centerBins = function(newMinKey, newMaxKey) {
          var middleKey = newMinKey + Math.floor((newMaxKey - newMinKey + 1) / 2);
          this._shiftBins(Math.floor(this.offset + this.length() / 2) - middleKey);
        };
        DenseStore2.prototype._extendRange = function(key, secondKey) {
          var _a;
          secondKey = secondKey || key;
          var newMinKey = Math.min(key, secondKey, this.minKey);
          var newMaxKey = Math.max(key, secondKey, this.maxKey);
          if (this.length() === 0) {
            this.bins = new Array(this._getNewLength(newMinKey, newMaxKey)).fill(0);
            this.offset = newMinKey;
            this._adjust(newMinKey, newMaxKey);
          } else if (newMinKey >= this.minKey && newMaxKey < this.offset + this.length()) {
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
          } else {
            var newLength = this._getNewLength(newMinKey, newMaxKey);
            if (newLength > this.length()) {
              (_a = this.bins).push.apply(_a, new Array(newLength - this.length()).fill(0));
            }
            this._adjust(newMinKey, newMaxKey);
          }
        };
        DenseStore2.prototype._getIndex = function(key) {
          if (key < this.minKey) {
            this._extendRange(key);
          } else if (key > this.maxKey) {
            this._extendRange(key);
          }
          return key - this.offset;
        };
        DenseStore2.prototype.toProto = function() {
          var ProtoStore = require_compiled().Store;
          return ProtoStore.create({
            contiguousBinCounts: this.bins,
            contiguousBinIndexOffset: this.offset
          });
        };
        DenseStore2.fromProto = function(protoStore) {
          if (!protoStore || /* Double equals (==) is intentional here to check for
           * `null` | `undefined` without including `0` */
          protoStore.contiguousBinCounts == null || protoStore.contiguousBinIndexOffset == null) {
            throw Error("Failed to decode store from protobuf");
          }
          var store = new this();
          var index = protoStore.contiguousBinIndexOffset;
          store.offset = index;
          for (var _i = 0, _a = protoStore.contiguousBinCounts; _i < _a.length; _i++) {
            var count = _a[_i];
            store.add(index, count);
            index += 1;
          }
          return store;
        };
        return DenseStore2;
      })()
    );
    exports2.DenseStore = DenseStore;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js
var require_CollapsingLowestDenseStore = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingLowestDenseStore.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingLowestDenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    var util_1 = require_util2();
    var CollapsingLowestDenseStore = (
      /** @class */
      (function(_super) {
        __extends2(CollapsingLowestDenseStore2, _super);
        function CollapsingLowestDenseStore2(binLimit, chunkSize) {
          var _this = _super.call(this, chunkSize) || this;
          _this.binLimit = binLimit;
          _this.isCollapsed = false;
          return _this;
        }
        CollapsingLowestDenseStore2.prototype.merge = function(store) {
          if (store.count === 0) {
            return;
          }
          if (this.count === 0) {
            this.copy(store);
            return;
          }
          if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
          }
          var collapseStartIndex = store.minKey - store.offset;
          var collapseEndIndex = Math.min(this.minKey, store.maxKey + 1) - store.offset;
          if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[0] += collapseCount;
          } else {
            collapseEndIndex = collapseStartIndex;
          }
          for (var key = collapseEndIndex + store.offset; key < store.maxKey + 1; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
          }
          this.count += store.count;
        };
        CollapsingLowestDenseStore2.prototype.copy = function(store) {
          _super.prototype.copy.call(this, store);
          this.isCollapsed = store.isCollapsed;
        };
        CollapsingLowestDenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
          var desiredLength = newMaxKey - newMinKey + 1;
          return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
        };
        CollapsingLowestDenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
          if (newMaxKey - newMinKey + 1 > this.length()) {
            newMinKey = newMaxKey - this.length() + 1;
            if (newMinKey >= this.maxKey) {
              this.offset = newMinKey;
              this.minKey = newMinKey;
              this.bins.fill(0);
              this.bins[0] = this.count;
            } else {
              var shift = this.offset - newMinKey;
              if (shift < 0) {
                var collapseStartIndex = this.minKey - this.offset;
                var collapseEndIndex = newMinKey - this.offset;
                var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);
                this.bins.fill(0, collapseStartIndex, collapseEndIndex);
                this.bins[collapseEndIndex] += collapsedCount;
                this.minKey = newMinKey;
                this._shiftBins(shift);
              } else {
                this.minKey = newMinKey;
                this._shiftBins(shift);
              }
            }
            this.maxKey = newMaxKey;
            this.isCollapsed = true;
          } else {
            this._centerBins(newMinKey, newMaxKey);
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
          }
        };
        CollapsingLowestDenseStore2.prototype._getIndex = function(key) {
          if (key < this.minKey) {
            if (this.isCollapsed) {
              return 0;
            }
            this._extendRange(key);
            if (this.isCollapsed) {
              return 0;
            }
          } else if (key > this.maxKey) {
            this._extendRange(key);
          }
          return key - this.offset;
        };
        return CollapsingLowestDenseStore2;
      })(DenseStore_1.DenseStore)
    );
    exports2.CollapsingLowestDenseStore = CollapsingLowestDenseStore;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js
var require_CollapsingHighestDenseStore = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/CollapsingHighestDenseStore.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingHighestDenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    var util_1 = require_util2();
    var CollapsingHighestDenseStore = (
      /** @class */
      (function(_super) {
        __extends2(CollapsingHighestDenseStore2, _super);
        function CollapsingHighestDenseStore2(binLimit, chunkSize) {
          var _this = _super.call(this, chunkSize) || this;
          _this.binLimit = binLimit;
          _this.isCollapsed = false;
          return _this;
        }
        CollapsingHighestDenseStore2.prototype.merge = function(store) {
          if (store.count === 0) {
            return;
          }
          if (this.count === 0) {
            this.copy(store);
            return;
          }
          if (store.minKey < this.minKey || store.maxKey > this.maxKey) {
            this._extendRange(store.minKey, store.maxKey);
          }
          var collapseEndIndex = store.maxKey - store.offset + 1;
          var collapseStartIndex = Math.max(this.maxKey + 1, store.minKey) - store.offset;
          if (collapseEndIndex > collapseStartIndex) {
            var collapseCount = (0, util_1.sumOfRange)(store.bins, collapseStartIndex, collapseEndIndex);
            this.bins[this.length() - 1] += collapseCount;
          } else {
            collapseStartIndex = collapseEndIndex;
          }
          for (var key = store.minKey; key < collapseStartIndex + store.offset; key++) {
            this.bins[key - this.offset] += store.bins[key - store.offset];
          }
          this.count += store.count;
        };
        CollapsingHighestDenseStore2.prototype.copy = function(store) {
          _super.prototype.copy.call(this, store);
          this.isCollapsed = store.isCollapsed;
        };
        CollapsingHighestDenseStore2.prototype._getNewLength = function(newMinKey, newMaxKey) {
          var desiredLength = newMaxKey - newMinKey + 1;
          return Math.min(this.chunkSize * Math.ceil(desiredLength / this.chunkSize), this.binLimit);
        };
        CollapsingHighestDenseStore2.prototype._adjust = function(newMinKey, newMaxKey) {
          if (newMaxKey - newMinKey + 1 > this.length()) {
            newMaxKey = newMinKey + this.length() + 1;
            if (newMaxKey <= this.minKey) {
              this.offset = newMinKey;
              this.maxKey = newMaxKey;
              this.bins.fill(0);
              this.bins[this.length() - 1] = this.count;
            } else {
              var shift = this.offset - newMinKey;
              if (shift > 0) {
                var collapseStartIndex = newMaxKey - this.offset + 1;
                var collapseEndIndex = this.maxKey - this.offset + 1;
                var collapsedCount = (0, util_1.sumOfRange)(this.bins, collapseStartIndex, collapseEndIndex);
                this.bins.fill(0, collapseStartIndex, collapseEndIndex);
                this.bins[collapseStartIndex - 1] += collapsedCount;
                this.maxKey = newMaxKey;
                this._shiftBins(shift);
              } else {
                this.maxKey = newMaxKey;
                this._shiftBins(shift);
              }
              this.minKey = newMinKey;
              this.isCollapsed = true;
            }
          } else {
            this._centerBins(newMinKey, newMaxKey);
            this.minKey = newMinKey;
            this.maxKey = newMaxKey;
          }
        };
        CollapsingHighestDenseStore2.prototype._getIndex = function(key) {
          if (key < this.minKey) {
            if (this.isCollapsed) {
              return this.length() - 1;
            }
            this._extendRange(key);
            if (this.isCollapsed) {
              return this.length() - 1;
            }
          } else if (key > this.maxKey) {
            this._extendRange(key);
          }
          return key - this.offset;
        };
        return CollapsingHighestDenseStore2;
      })(DenseStore_1.DenseStore)
    );
    exports2.CollapsingHighestDenseStore = CollapsingHighestDenseStore;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js
var require_store = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/store/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CollapsingHighestDenseStore = exports2.CollapsingLowestDenseStore = exports2.DenseStore = void 0;
    var DenseStore_1 = require_DenseStore();
    Object.defineProperty(exports2, "DenseStore", { enumerable: true, get: function() {
      return DenseStore_1.DenseStore;
    } });
    var CollapsingLowestDenseStore_1 = require_CollapsingLowestDenseStore();
    Object.defineProperty(exports2, "CollapsingLowestDenseStore", { enumerable: true, get: function() {
      return CollapsingLowestDenseStore_1.CollapsingLowestDenseStore;
    } });
    var CollapsingHighestDenseStore_1 = require_CollapsingHighestDenseStore();
    Object.defineProperty(exports2, "CollapsingHighestDenseStore", { enumerable: true, get: function() {
      return CollapsingHighestDenseStore_1.CollapsingHighestDenseStore;
    } });
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js
var require_KeyMapping = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/KeyMapping.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyMapping = void 0;
    var index_1 = require_mapping();
    var MIN_SAFE_FLOAT = Math.pow(2, -1023);
    var MAX_SAFE_FLOAT = Number.MAX_VALUE;
    var KeyMapping = (
      /** @class */
      (function() {
        function KeyMapping2(relativeAccuracy, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          if (relativeAccuracy <= 0 || relativeAccuracy >= 1) {
            throw Error("Relative accuracy must be between 0 and 1 when initializing a KeyMapping");
          }
          this.relativeAccuracy = relativeAccuracy;
          this._offset = offset;
          var gammaMantissa = 2 * relativeAccuracy / (1 - relativeAccuracy);
          this.gamma = 1 + gammaMantissa;
          this._multiplier = 1 / Math.log1p(gammaMantissa);
          this.minPossible = MIN_SAFE_FLOAT * this.gamma;
          this.maxPossible = MAX_SAFE_FLOAT / this.gamma;
        }
        KeyMapping2.fromGammaOffset = function(gamma, indexOffset) {
          var relativeAccuracy = (gamma - 1) / (gamma + 1);
          return new this(relativeAccuracy, indexOffset);
        };
        KeyMapping2.prototype.key = function(value) {
          return Math.ceil(this._logGamma(value)) + this._offset;
        };
        KeyMapping2.prototype.value = function(key) {
          return this._powGamma(key - this._offset) * (2 / (1 + this.gamma));
        };
        KeyMapping2.prototype.toProto = function() {
          var ProtoIndexMapping = require_compiled().IndexMapping;
          return ProtoIndexMapping.create({
            gamma: this.gamma,
            indexOffset: this._offset,
            interpolation: this._protoInterpolation()
          });
        };
        KeyMapping2.fromProto = function(protoMapping) {
          if (!protoMapping || /* Double equals (==) is intentional here to check for
           * `null` | `undefined` without including `0` */
          protoMapping.gamma == null || protoMapping.indexOffset == null) {
            throw Error("Failed to decode mapping from protobuf");
          }
          var Interpolation = require_compiled().IndexMapping.Interpolation;
          var interpolation = protoMapping.interpolation, gamma = protoMapping.gamma, indexOffset = protoMapping.indexOffset;
          switch (interpolation) {
            case Interpolation.NONE:
              return index_1.LogarithmicMapping.fromGammaOffset(gamma, indexOffset);
            case Interpolation.LINEAR:
              return index_1.LinearlyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
            case Interpolation.CUBIC:
              return index_1.CubicallyInterpolatedMapping.fromGammaOffset(gamma, indexOffset);
            default:
              throw Error("Unrecognized mapping when decoding from protobuf");
          }
        };
        KeyMapping2.prototype._logGamma = function(value) {
          return Math.log2(value) * this._multiplier;
        };
        KeyMapping2.prototype._powGamma = function(value) {
          return Math.pow(2, value / this._multiplier);
        };
        KeyMapping2.prototype._protoInterpolation = function() {
          var Interpolation = require_compiled().IndexMapping.Interpolation;
          return Interpolation.NONE;
        };
        return KeyMapping2;
      })()
    );
    exports2.KeyMapping = KeyMapping;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js
var require_LogarithmicMapping = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LogarithmicMapping.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogarithmicMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var LogarithmicMapping = (
      /** @class */
      (function(_super) {
        __extends2(LogarithmicMapping2, _super);
        function LogarithmicMapping2(relativeAccuracy, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          var _this = _super.call(this, relativeAccuracy, offset) || this;
          _this._multiplier *= Math.log(2);
          return _this;
        }
        LogarithmicMapping2.prototype._logGamma = function(value) {
          return Math.log2(value) * this._multiplier;
        };
        LogarithmicMapping2.prototype._powGamma = function(value) {
          return Math.pow(2, value / this._multiplier);
        };
        LogarithmicMapping2.prototype._protoInterpolation = function() {
          var Interpolation = require_compiled().IndexMapping.Interpolation;
          return Interpolation.NONE;
        };
        return LogarithmicMapping2;
      })(KeyMapping_1.KeyMapping)
    );
    exports2.LogarithmicMapping = LogarithmicMapping;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js
var require_math = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/math.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ldexp = exports2.frexp = void 0;
    function frexp(value) {
      if (value === 0 || !Number.isFinite(value))
        return [value, 0];
      var absValue = Math.abs(value);
      var exponent = Math.max(-1023, Math.floor(Math.log2(absValue)) + 1);
      var mantissa = absValue * Math.pow(2, -exponent);
      while (mantissa < 0.5) {
        mantissa *= 2;
        exponent--;
      }
      while (mantissa >= 1) {
        mantissa *= 0.5;
        exponent++;
      }
      if (value < 0) {
        mantissa = -mantissa;
      }
      return [mantissa, exponent];
    }
    exports2.frexp = frexp;
    function ldexp(mantissa, exponent) {
      var iterations = Math.min(3, Math.ceil(Math.abs(exponent) / 1023));
      var result = mantissa;
      for (var i = 0; i < iterations; i++) {
        result *= Math.pow(2, Math.floor((exponent + i) / iterations));
      }
      return result;
    }
    exports2.ldexp = ldexp;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js
var require_LinearlyInterpolatedMapping = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/LinearlyInterpolatedMapping.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinearlyInterpolatedMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var math_1 = require_math();
    var LinearlyInterpolatedMapping = (
      /** @class */
      (function(_super) {
        __extends2(LinearlyInterpolatedMapping2, _super);
        function LinearlyInterpolatedMapping2(relativeAccuracy, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          return _super.call(this, relativeAccuracy, offset) || this;
        }
        LinearlyInterpolatedMapping2.prototype._log2Approx = function(value) {
          var _a = (0, math_1.frexp)(value), mantissa = _a[0], exponent = _a[1];
          var significand = 2 * mantissa - 1;
          return significand + (exponent - 1);
        };
        LinearlyInterpolatedMapping2.prototype._exp2Approx = function(value) {
          var exponent = Math.floor(value) + 1;
          var mantissa = (value - exponent + 2) / 2;
          return (0, math_1.ldexp)(mantissa, exponent);
        };
        LinearlyInterpolatedMapping2.prototype._logGamma = function(value) {
          return Math.log2(value) * this._multiplier;
        };
        LinearlyInterpolatedMapping2.prototype._powGamma = function(value) {
          return Math.pow(2, value / this._multiplier);
        };
        LinearlyInterpolatedMapping2.prototype._protoInterpolation = function() {
          var Interpolation = require_compiled().IndexMapping.Interpolation;
          return Interpolation.LINEAR;
        };
        return LinearlyInterpolatedMapping2;
      })(KeyMapping_1.KeyMapping)
    );
    exports2.LinearlyInterpolatedMapping = LinearlyInterpolatedMapping;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js
var require_CubicallyInterpolatedMapping = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/CubicallyInterpolatedMapping.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CubicallyInterpolatedMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    var math_1 = require_math();
    var CubicallyInterpolatedMapping = (
      /** @class */
      (function(_super) {
        __extends2(CubicallyInterpolatedMapping2, _super);
        function CubicallyInterpolatedMapping2(relativeAccuracy, offset) {
          if (offset === void 0) {
            offset = 0;
          }
          var _this = _super.call(this, relativeAccuracy, offset) || this;
          _this.A = 6 / 35;
          _this.B = -3 / 5;
          _this.C = 10 / 7;
          _this._multiplier /= _this.C;
          return _this;
        }
        CubicallyInterpolatedMapping2.prototype._cubicLog2Approx = function(value) {
          var _a = (0, math_1.frexp)(value), mantissa = _a[0], exponent = _a[1];
          var significand = 2 * mantissa - 1;
          return ((this.A * significand + this.B) * significand + this.C) * significand + (exponent - 1);
        };
        CubicallyInterpolatedMapping2.prototype._cubicExp2Approx = function(value) {
          var exponent = Math.floor(value);
          var delta0 = this.B * this.B - 3 * this.A * this.C;
          var delta1 = 2 * this.B * this.B * this.B - 9 * this.A * this.B * this.C - 27 * this.A * this.A * (value - exponent);
          var cardano = Math.cbrt((delta1 - Math.sqrt(delta1 * delta1 - 4 * delta0 * delta0 * delta0)) / 2);
          var significandPlusOne = -(this.B + cardano + delta0 / cardano) / (3 * this.A) + 1;
          var mantissa = significandPlusOne / 2;
          return (0, math_1.ldexp)(mantissa, exponent + 1);
        };
        CubicallyInterpolatedMapping2.prototype._logGamma = function(value) {
          return this._cubicLog2Approx(value) * this._multiplier;
        };
        CubicallyInterpolatedMapping2.prototype._powGamma = function(value) {
          return this._cubicExp2Approx(value / this._multiplier);
        };
        CubicallyInterpolatedMapping2.prototype._protoInterpolation = function() {
          var Interpolation = require_compiled().IndexMapping.Interpolation;
          return Interpolation.CUBIC;
        };
        return CubicallyInterpolatedMapping2;
      })(KeyMapping_1.KeyMapping)
    );
    exports2.CubicallyInterpolatedMapping = CubicallyInterpolatedMapping;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js
var require_mapping = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/mapping/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CubicallyInterpolatedMapping = exports2.LinearlyInterpolatedMapping = exports2.LogarithmicMapping = exports2.KeyMapping = void 0;
    var KeyMapping_1 = require_KeyMapping();
    Object.defineProperty(exports2, "KeyMapping", { enumerable: true, get: function() {
      return KeyMapping_1.KeyMapping;
    } });
    var LogarithmicMapping_1 = require_LogarithmicMapping();
    Object.defineProperty(exports2, "LogarithmicMapping", { enumerable: true, get: function() {
      return LogarithmicMapping_1.LogarithmicMapping;
    } });
    var LinearlyInterpolatedMapping_1 = require_LinearlyInterpolatedMapping();
    Object.defineProperty(exports2, "LinearlyInterpolatedMapping", { enumerable: true, get: function() {
      return LinearlyInterpolatedMapping_1.LinearlyInterpolatedMapping;
    } });
    var CubicallyInterpolatedMapping_1 = require_CubicallyInterpolatedMapping();
    Object.defineProperty(exports2, "CubicallyInterpolatedMapping", { enumerable: true, get: function() {
      return CubicallyInterpolatedMapping_1.CubicallyInterpolatedMapping;
    } });
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js
var require_DDSketch = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/DDSketch.js"(exports2) {
    "use strict";
    var __extends2 = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogCollapsingHighestDenseDDSketch = exports2.LogCollapsingLowestDenseDDSketch = exports2.DDSketch = void 0;
    var store_1 = require_store();
    var mapping_1 = require_mapping();
    var DEFAULT_RELATIVE_ACCURACY = 0.01;
    var DEFAULT_BIN_LIMIT = 2048;
    var BaseDDSketch = (
      /** @class */
      (function() {
        function BaseDDSketch2(_a) {
          var mapping = _a.mapping, store = _a.store, negativeStore = _a.negativeStore, zeroCount = _a.zeroCount;
          this.mapping = mapping;
          this.store = store;
          this.negativeStore = negativeStore;
          this.zeroCount = zeroCount;
          this.count = this.negativeStore.count + this.zeroCount + this.store.count;
          this.min = Infinity;
          this.max = -Infinity;
          this.sum = 0;
        }
        BaseDDSketch2.prototype.accept = function(value, weight) {
          if (weight === void 0) {
            weight = 1;
          }
          if (weight <= 0) {
            throw Error("Weight must be a positive number");
          }
          if (value > this.mapping.minPossible) {
            var key = this.mapping.key(value);
            this.store.add(key, weight);
          } else if (value < -this.mapping.minPossible) {
            var key = this.mapping.key(-value);
            this.negativeStore.add(key, weight);
          } else {
            this.zeroCount += weight;
          }
          this.count += weight;
          this.sum += value * weight;
          if (value < this.min) {
            this.min = value;
          }
          if (value > this.max) {
            this.max = value;
          }
        };
        BaseDDSketch2.prototype.getValueAtQuantile = function(quantile) {
          if (quantile < 0 || quantile > 1 || this.count === 0) {
            return NaN;
          }
          var rank = quantile * (this.count - 1);
          var quantileValue = 0;
          if (rank < this.negativeStore.count) {
            var reversedRank = this.negativeStore.count - rank - 1;
            var key = this.negativeStore.keyAtRank(reversedRank, false);
            quantileValue = -this.mapping.value(key);
          } else if (rank < this.zeroCount + this.negativeStore.count) {
            return 0;
          } else {
            var key = this.store.keyAtRank(rank - this.zeroCount - this.negativeStore.count);
            quantileValue = this.mapping.value(key);
          }
          return quantileValue;
        };
        BaseDDSketch2.prototype.merge = function(sketch) {
          if (!this.mergeable(sketch)) {
            throw new Error("Cannot merge two DDSketches with different `relativeAccuracy` parameters");
          }
          if (sketch.count === 0) {
            return;
          }
          if (this.count === 0) {
            this._copy(sketch);
            return;
          }
          this.store.merge(sketch.store);
          this.zeroCount += sketch.zeroCount;
          this.count += sketch.count;
          this.sum += sketch.sum;
          if (sketch.min < this.min) {
            this.min = sketch.min;
          }
          if (sketch.max > this.max) {
            this.max = sketch.max;
          }
        };
        BaseDDSketch2.prototype.mergeable = function(sketch) {
          return this.mapping.gamma === sketch.mapping.gamma;
        };
        BaseDDSketch2.prototype._copy = function(sketch) {
          this.store.copy(sketch.store);
          this.negativeStore.copy(sketch.negativeStore);
          this.zeroCount = sketch.zeroCount;
          this.min = sketch.min;
          this.max = sketch.max;
          this.count = sketch.count;
          this.sum = sketch.sum;
        };
        BaseDDSketch2.prototype.toProto = function() {
          var ProtoDDSketch = require_compiled().DDSketch;
          var message = ProtoDDSketch.create({
            mapping: this.mapping.toProto(),
            positiveValues: this.store.toProto(),
            negativeValues: this.negativeStore.toProto(),
            zeroCount: this.zeroCount
          });
          return ProtoDDSketch.encode(message).finish();
        };
        BaseDDSketch2.fromProto = function(buffer) {
          var ProtoDDSketch = require_compiled().DDSketch;
          var decoded = ProtoDDSketch.decode(buffer);
          var mapping = mapping_1.KeyMapping.fromProto(decoded.mapping);
          var store = store_1.DenseStore.fromProto(decoded.positiveValues);
          var negativeStore = store_1.DenseStore.fromProto(decoded.negativeValues);
          var zeroCount = decoded.zeroCount;
          return new BaseDDSketch2({ mapping, store, negativeStore, zeroCount });
        };
        return BaseDDSketch2;
      })()
    );
    var defaultConfig = {
      relativeAccuracy: DEFAULT_RELATIVE_ACCURACY
    };
    var DDSketch = (
      /** @class */
      (function(_super) {
        __extends2(DDSketch2, _super);
        function DDSketch2(_a) {
          var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c;
          var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
          var store = new store_1.DenseStore();
          var negativeStore = new store_1.DenseStore();
          return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
        }
        return DDSketch2;
      })(BaseDDSketch)
    );
    exports2.DDSketch = DDSketch;
    var LogCollapsingLowestDenseDDSketch = (
      /** @class */
      (function(_super) {
        __extends2(LogCollapsingLowestDenseDDSketch2, _super);
        function LogCollapsingLowestDenseDDSketch2(_a) {
          var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c, _d = _b.binLimit, binLimit = _d === void 0 ? DEFAULT_BIN_LIMIT : _d;
          var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
          var store = new store_1.CollapsingLowestDenseStore(binLimit);
          var negativeStore = new store_1.CollapsingLowestDenseStore(binLimit);
          return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
        }
        return LogCollapsingLowestDenseDDSketch2;
      })(BaseDDSketch)
    );
    exports2.LogCollapsingLowestDenseDDSketch = LogCollapsingLowestDenseDDSketch;
    var LogCollapsingHighestDenseDDSketch = (
      /** @class */
      (function(_super) {
        __extends2(LogCollapsingHighestDenseDDSketch2, _super);
        function LogCollapsingHighestDenseDDSketch2(_a) {
          var _b = _a === void 0 ? defaultConfig : _a, _c = _b.relativeAccuracy, relativeAccuracy = _c === void 0 ? DEFAULT_RELATIVE_ACCURACY : _c, _d = _b.binLimit, binLimit = _d === void 0 ? DEFAULT_BIN_LIMIT : _d;
          var mapping = new mapping_1.LogarithmicMapping(relativeAccuracy);
          var store = new store_1.CollapsingHighestDenseStore(binLimit);
          var negativeStore = new store_1.CollapsingHighestDenseStore(binLimit);
          return _super.call(this, { mapping, store, negativeStore, zeroCount: 0 }) || this;
        }
        return LogCollapsingHighestDenseDDSketch2;
      })(BaseDDSketch)
    );
    exports2.LogCollapsingHighestDenseDDSketch = LogCollapsingHighestDenseDDSketch;
  }
});

// ../../node_modules/@datadog/sketches-js/dist/ddsketch/index.js
var require_ddsketch = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/ddsketch/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_DDSketch(), exports2);
  }
});

// ../../node_modules/@datadog/sketches-js/dist/index.js
var require_dist = __commonJS({
  "../../node_modules/@datadog/sketches-js/dist/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ddsketch(), exports2);
  }
});

// ../../packages/dd-trace/src/histogram.js
var require_histogram = __commonJS({
  "../../packages/dd-trace/src/histogram.js"(exports2, module2) {
    "use strict";
    var { DDSketch } = require_dist();
    var Histogram = class {
      constructor() {
        this.reset();
      }
      get min() {
        return this._sketch.count === 0 ? 0 : this._sketch.min;
      }
      get max() {
        return this._sketch.count === 0 ? 0 : this._sketch.max;
      }
      get avg() {
        return this._sketch.count === 0 ? 0 : this._sketch.sum / this._sketch.count;
      }
      get sum() {
        return this._sketch.sum;
      }
      get count() {
        return this._sketch.count;
      }
      get median() {
        return this.percentile(50);
      }
      get p95() {
        return this.percentile(95);
      }
      percentile(percentile) {
        return this._sketch.getValueAtQuantile(percentile / 100) || 0;
      }
      merge(histogram) {
        return this._sketch.merge(histogram._sketch);
      }
      record(value) {
        this._sketch.accept(value);
      }
      reset() {
        this._sketch = new DDSketch();
      }
    };
    module2.exports = Histogram;
  }
});

// ../../packages/dd-trace/src/pkg.js
var require_pkg = __commonJS({
  "../../packages/dd-trace/src/pkg.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    function findRoot() {
      return __require.main && __require.main.filename ? path.dirname(__require.main.filename) : process.cwd();
    }
    function findPkg() {
      const cwd = findRoot();
      const directory = path.resolve(cwd);
      const res = path.parse(directory);
      if (!res) return {};
      const { root } = res;
      const filePath = findUp("package.json", root, directory);
      if (filePath === void 0) return {};
      try {
        return __require(filePath);
      } catch {
        return {};
      }
    }
    function findUp(name, root, directory) {
      while (true) {
        const current = path.resolve(directory, name);
        if (fs.existsSync(current)) return current;
        if (directory === root) return;
        directory = path.dirname(directory);
      }
    }
    module2.exports = Object.assign(findPkg(), { findRoot, findUp });
  }
});

// ../../packages/dd-trace/src/constants.js
var require_constants3 = __commonJS({
  "../../packages/dd-trace/src/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SAMPLING_PRIORITY_KEY: "_sampling_priority_v1",
      ANALYTICS_KEY: "_dd1.sr.eausr",
      ORIGIN_KEY: "_dd.origin",
      HOSTNAME_KEY: "_dd.hostname",
      TOP_LEVEL_KEY: "_dd.top_level",
      SAMPLING_RULE_DECISION: "_dd.rule_psr",
      SAMPLING_LIMIT_DECISION: "_dd.limit_psr",
      SAMPLING_AGENT_DECISION: "_dd.agent_psr",
      SAMPLING_MECHANISM_DEFAULT: 0,
      SAMPLING_MECHANISM_AGENT: 1,
      SAMPLING_MECHANISM_RULE: 3,
      SAMPLING_MECHANISM_MANUAL: 4,
      SAMPLING_MECHANISM_APPSEC: 5,
      SAMPLING_MECHANISM_SPAN: 8,
      SAMPLING_MECHANISM_REMOTE_USER: 11,
      SAMPLING_MECHANISM_REMOTE_DYNAMIC: 12,
      SPAN_SAMPLING_MECHANISM: "_dd.span_sampling.mechanism",
      SPAN_SAMPLING_RULE_RATE: "_dd.span_sampling.rule_rate",
      SPAN_SAMPLING_MAX_PER_SECOND: "_dd.span_sampling.max_per_second",
      DATADOG_LAMBDA_EXTENSION_PATH: "/opt/extensions/datadog-agent",
      DECISION_MAKER_KEY: "_dd.p.dm",
      PROCESS_ID: "process_id",
      ERROR_TYPE: "error.type",
      ERROR_MESSAGE: "error.message",
      ERROR_STACK: "error.stack",
      IGNORE_OTEL_ERROR: Symbol("ignore.otel.error"),
      COMPONENT: "component",
      CLIENT_PORT_KEY: "network.destination.port",
      PEER_SERVICE_KEY: "peer.service",
      PEER_SERVICE_SOURCE_KEY: "_dd.peer.service.source",
      PEER_SERVICE_REMAP_KEY: "_dd.peer.service.remapped_from",
      SCI_REPOSITORY_URL: "_dd.git.repository_url",
      SCI_COMMIT_SHA: "_dd.git.commit.sha",
      APM_TRACING_ENABLED_KEY: "_dd.apm.enabled",
      TRACE_SOURCE_PROPAGATION_KEY: "_dd.p.ts",
      PAYLOAD_TAG_REQUEST_PREFIX: "aws.request.body",
      PAYLOAD_TAG_RESPONSE_PREFIX: "aws.response.body",
      PAYLOAD_TAGGING_MAX_TAGS: 758,
      SCHEMA_DEFINITION: "schema.definition",
      SCHEMA_WEIGHT: "schema.weight",
      SCHEMA_TYPE: "schema.type",
      SCHEMA_ID: "schema.id",
      SCHEMA_TOPIC: "schema.topic",
      SCHEMA_OPERATION: "schema.operation",
      SCHEMA_NAME: "schema.name",
      GRPC_CLIENT_ERROR_STATUSES: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
      GRPC_SERVER_ERROR_STATUSES: [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
      DYNAMODB_PTR_KIND: "aws.dynamodb.item",
      S3_PTR_KIND: "aws.s3.object",
      SPAN_POINTER_DIRECTION: Object.freeze({
        UPSTREAM: "u",
        DOWNSTREAM: "d"
      })
    };
  }
});

// ../../packages/dd-trace/src/config_defaults.js
var require_config_defaults = __commonJS({
  "../../packages/dd-trace/src/config_defaults.js"(exports2, module2) {
    "use strict";
    var pkg = require_pkg();
    var { GRPC_CLIENT_ERROR_STATUSES, GRPC_SERVER_ERROR_STATUSES } = require_constants3();
    var { getEnvironmentVariable: getEnv } = require_config_helper();
    var qsRegex = String.raw`(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?)(?:(?:\s|%20)*(?:=|%3D)[^&]+|(?:"|%22)(?:\s|%20)*(?::|%3A)(?:\s|%20)*(?:"|%22)(?:%2[^2]|%[^2]|[^"%])+(?:"|%22))|bearer(?:\s|%20)+[a-z0-9\._\-]+|token(?::|%3A)[a-z0-9]{13}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L](?:[\w=-]|%3D)+\.ey[I-L](?:[\w=-]|%3D)+(?:\.(?:[\w.+\/=-]|%3D|%2F|%2B)+)?|[\-]{5}BEGIN(?:[a-z\s]|%20)+PRIVATE(?:\s|%20)KEY[\-]{5}[^\-]+[\-]{5}END(?:[a-z\s]|%20)+PRIVATE(?:\s|%20)KEY|ssh-rsa(?:\s|%20)*(?:[a-z0-9\/\.+]|%2F|%5C|%2B){100,}`;
    var defaultWafObfuscatorKeyRegex = String.raw`(?i)pass|pw(?:or)?d|secret|(?:api|private|public|access)[_-]?key|token|consumer[_-]?(?:id|key|secret)|sign(?:ed|ature)|bearer|authorization|jsessionid|phpsessid|asp\.net[_-]sessionid|sid|jwt`;
    var defaultWafObfuscatorValueRegex = String.raw`(?i)(?:p(?:ass)?w(?:or)?d|pass(?:[_-]?phrase)?|secret(?:[_-]?key)?|(?:(?:api|private|public|access)[_-]?)key(?:[_-]?id)?|(?:(?:auth|access|id|refresh)[_-]?)?token|consumer[_-]?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?|jsessionid|phpsessid|asp\.net(?:[_-]|-)sessionid|sid|jwt)(?:\s*=([^;&]+)|"\s*:\s*("[^"]+"|\d+))|bearer\s+([a-z0-9\._\-]+)|token\s*:\s*([a-z0-9]{13})|gh[opsu]_([0-9a-zA-Z]{36})|ey[I-L][\w=-]+\.(ey[I-L][\w=-]+(?:\.[\w.+\/=-]+)?)|[\-]{5}BEGIN[a-z\s]+PRIVATE\sKEY[\-]{5}([^\-]+)[\-]{5}END[a-z\s]+PRIVATE\sKEY|ssh-rsa\s*([a-z0-9\/\.+]{100,})`;
    var service = getEnv("AWS_LAMBDA_FUNCTION_NAME") || getEnv("FUNCTION_NAME") || // Google Cloud Function Name set by deprecated runtimes
    getEnv("K_SERVICE") || // Google Cloud Function Name set by newer runtimes
    getEnv("WEBSITE_SITE_NAME") || // set by Azure Functions
    pkg.name || "node";
    module2.exports = {
      apmTracingEnabled: true,
      "appsec.apiSecurity.enabled": true,
      "appsec.apiSecurity.sampleDelay": 30,
      "appsec.apiSecurity.endpointCollectionEnabled": true,
      "appsec.apiSecurity.endpointCollectionMessageLimit": 300,
      "appsec.blockedTemplateGraphql": void 0,
      "appsec.blockedTemplateHtml": void 0,
      "appsec.blockedTemplateJson": void 0,
      "appsec.enabled": void 0,
      "appsec.eventTracking.mode": "identification",
      // TODO appsec.extendedHeadersCollection is deprecated, to delete in a major
      "appsec.extendedHeadersCollection.enabled": false,
      "appsec.extendedHeadersCollection.redaction": true,
      "appsec.extendedHeadersCollection.maxHeaders": 50,
      "appsec.obfuscatorKeyRegex": defaultWafObfuscatorKeyRegex,
      "appsec.obfuscatorValueRegex": defaultWafObfuscatorValueRegex,
      "appsec.rasp.enabled": true,
      // TODO Deprecated, to delete in a major
      "appsec.rasp.bodyCollection": false,
      "appsec.rateLimit": 100,
      "appsec.rules": void 0,
      "appsec.sca.enabled": null,
      "appsec.stackTrace.enabled": true,
      "appsec.stackTrace.maxDepth": 32,
      "appsec.stackTrace.maxStackTraces": 2,
      "appsec.wafTimeout": 5e3,
      // µs
      baggageMaxBytes: 8192,
      baggageMaxItems: 64,
      baggageTagKeys: "user.id,session.id,account.id",
      clientIpEnabled: false,
      clientIpHeader: null,
      "crashtracking.enabled": true,
      "codeOriginForSpans.enabled": true,
      "codeOriginForSpans.experimental.exit_spans.enabled": false,
      dbmPropagationMode: "disabled",
      "dogstatsd.hostname": "127.0.0.1",
      "dogstatsd.port": "8125",
      dsmEnabled: false,
      "dynamicInstrumentation.enabled": false,
      "dynamicInstrumentation.probeFile": void 0,
      "dynamicInstrumentation.redactedIdentifiers": [],
      "dynamicInstrumentation.redactionExcludedIdentifiers": [],
      "dynamicInstrumentation.uploadIntervalSeconds": 1,
      env: void 0,
      "experimental.aiguard.enabled": false,
      "experimental.aiguard.endpoint": void 0,
      "experimental.aiguard.maxMessagesLength": 16,
      "experimental.aiguard.maxContentSize": 512 * 1024,
      "experimental.aiguard.timeout": 1e4,
      // ms
      "experimental.enableGetRumData": false,
      "experimental.exporter": void 0,
      "experimental.flaggingProvider.enabled": false,
      flushInterval: 2e3,
      flushMinSpans: 1e3,
      gitMetadataEnabled: true,
      graphqlErrorExtensions: [],
      "grpc.client.error.statuses": GRPC_CLIENT_ERROR_STATUSES,
      "grpc.server.error.statuses": GRPC_SERVER_ERROR_STATUSES,
      headerTags: [],
      "heapSnapshot.count": 0,
      "heapSnapshot.destination": "",
      "heapSnapshot.interval": 3600,
      hostname: "127.0.0.1",
      "iast.dbRowsToTaint": 1,
      "iast.deduplicationEnabled": true,
      "iast.enabled": false,
      "iast.maxConcurrentRequests": 2,
      "iast.maxContextOperations": 2,
      "iast.redactionEnabled": true,
      "iast.redactionNamePattern": null,
      "iast.redactionValuePattern": null,
      "iast.requestSampling": 30,
      "iast.securityControlsConfiguration": null,
      "iast.telemetryVerbosity": "INFORMATION",
      "iast.stackTrace.enabled": true,
      injectionEnabled: [],
      instrumentationSource: "manual",
      injectForce: null,
      isAzureFunction: false,
      isCiVisibility: false,
      isEarlyFlakeDetectionEnabled: false,
      isFlakyTestRetriesEnabled: false,
      flakyTestRetriesCount: 5,
      isGCPFunction: false,
      isGitUploadEnabled: false,
      isIntelligentTestRunnerEnabled: false,
      isManualApiEnabled: false,
      "langchain.spanCharLimit": 128,
      "langchain.spanPromptCompletionSampleRate": 1,
      "llmobs.agentlessEnabled": void 0,
      "llmobs.enabled": false,
      "llmobs.mlApp": void 0,
      ciVisibilityTestSessionName: "",
      ciVisAgentlessLogSubmissionEnabled: false,
      legacyBaggageEnabled: true,
      isTestDynamicInstrumentationEnabled: false,
      isServiceUserProvided: false,
      testManagementAttemptToFixRetries: 20,
      isTestManagementEnabled: false,
      isImpactedTestsEnabled: false,
      logInjection: true,
      otelLogsEnabled: false,
      otelUrl: void 0,
      otelLogsUrl: void 0,
      // Will be computed using agent host
      otelHeaders: void 0,
      otelLogsHeaders: "",
      otelProtocol: "http/protobuf",
      otelLogsProtocol: "http/protobuf",
      otelLogsTimeout: 1e4,
      otelTimeout: 1e4,
      otelLogsBatchTimeout: 5e3,
      otelLogsMaxExportBatchSize: 512,
      lookup: void 0,
      inferredProxyServicesEnabled: false,
      memcachedCommandEnabled: false,
      middlewareTracingEnabled: true,
      openAiLogsEnabled: false,
      "openai.spanCharLimit": 128,
      peerServiceMapping: {},
      plugins: true,
      port: "8126",
      "profiling.enabled": void 0,
      "profiling.exporters": "agent",
      "profiling.sourceMap": true,
      "profiling.longLivedThreshold": void 0,
      protocolVersion: "0.4",
      queryStringObfuscation: qsRegex,
      "remoteConfig.enabled": true,
      "remoteConfig.pollInterval": 5,
      // seconds
      reportHostname: false,
      "runtimeMetrics.enabled": false,
      "runtimeMetrics.eventLoop": true,
      "runtimeMetrics.gc": true,
      runtimeMetricsRuntimeId: false,
      sampleRate: void 0,
      "sampler.rateLimit": 100,
      "sampler.rules": [],
      "sampler.spanSamplingRules": [],
      scope: void 0,
      service,
      serviceMapping: {},
      site: "datadoghq.com",
      spanAttributeSchema: "v0",
      spanComputePeerService: false,
      spanLeakDebug: 0,
      spanRemoveIntegrationFromService: false,
      startupLogs: false,
      "stats.enabled": false,
      tags: {},
      tagsHeaderMaxLength: 512,
      "telemetry.debug": false,
      "telemetry.dependencyCollection": true,
      "telemetry.enabled": true,
      "telemetry.heartbeatInterval": 6e4,
      "telemetry.logCollection": true,
      "telemetry.metrics": true,
      traceEnabled: true,
      traceId128BitGenerationEnabled: true,
      traceId128BitLoggingEnabled: true,
      tracePropagationExtractFirst: false,
      tracePropagationBehaviorExtract: "continue",
      "tracePropagationStyle.inject": ["datadog", "tracecontext", "baggage"],
      "tracePropagationStyle.extract": ["datadog", "tracecontext", "baggage"],
      "tracePropagationStyle.otelPropagators": false,
      traceWebsocketMessagesEnabled: false,
      traceWebsocketMessagesInheritSampling: true,
      traceWebsocketMessagesSeparateTraces: true,
      tracing: true,
      url: void 0,
      version: pkg.version,
      instrumentation_config_id: void 0,
      "vertexai.spanCharLimit": 128,
      "vertexai.spanPromptCompletionSampleRate": 1,
      "trace.aws.addSpanPointers": true,
      "trace.dynamoDb.tablePrimaryKeys": void 0,
      "trace.nativeSpanEvents": false
    };
  }
});

// ../../packages/dd-trace/src/dogstatsd.js
var require_dogstatsd2 = __commonJS({
  "../../packages/dd-trace/src/dogstatsd.js"(exports2, module2) {
    "use strict";
    var lookup = __require("dns").lookup;
    var request2 = require_request();
    var dgram = __require("dgram");
    var isIP = __require("net").isIP;
    var log = require_log2();
    var { URL: URL2, format } = __require("url");
    var Histogram = require_histogram();
    var defaults = require_config_defaults();
    var MAX_BUFFER_SIZE = 1024;
    var TYPE_COUNTER = "c";
    var TYPE_GAUGE = "g";
    var TYPE_DISTRIBUTION = "d";
    var TYPE_HISTOGRAM = "h";
    var DogStatsDClient = class {
      constructor(options = {}) {
        if (options.metricsProxyUrl) {
          this._httpOptions = {
            url: options.metricsProxyUrl.toString(),
            path: "/dogstatsd/v2/proxy"
          };
        }
        this._host = options.host || defaults["dogstatsd.hostname"];
        this._family = isIP(this._host);
        this._port = options.port || defaults["dogstatsd.port"];
        this._prefix = options.prefix || "";
        this._tags = options.tags || [];
        this._queue = [];
        this._buffer = "";
        this._offset = 0;
        this._udp4 = this._socket("udp4");
        this._udp6 = this._socket("udp6");
      }
      increment(stat, value, tags) {
        this._add(stat, value, TYPE_COUNTER, tags);
      }
      decrement(stat, value, tags) {
        this._add(stat, -value, TYPE_COUNTER, tags);
      }
      gauge(stat, value, tags) {
        this._add(stat, value, TYPE_GAUGE, tags);
      }
      distribution(stat, value, tags) {
        this._add(stat, value, TYPE_DISTRIBUTION, tags);
      }
      histogram(stat, value, tags) {
        this._add(stat, value, TYPE_HISTOGRAM, tags);
      }
      flush() {
        const queue = this._enqueue();
        log.debug("Flushing %s metrics via", queue.length, this._httpOptions ? "HTTP" : "UDP");
        if (this._queue.length === 0) return;
        this._queue = [];
        if (this._httpOptions) {
          this._sendHttp(queue);
        } else {
          this._sendUdp(queue);
        }
      }
      _sendHttp(queue) {
        const buffer = Buffer.concat(queue);
        request2(buffer, this._httpOptions, (err) => {
          if (err) {
            log.error("DogStatsDClient: HTTP error from agent: %s", err.message, err);
            if (err.status === 404) {
              this._httpOptions = void 0;
            }
            this._sendUdp(queue);
          }
        });
      }
      _sendUdp(queue) {
        if (this._family === 0) {
          lookup(this._host, (err, address, family) => {
            if (err) return log.error("DogStatsDClient: Host not found", err);
            this._sendUdpFromQueue(queue, address, family);
          });
        } else {
          this._sendUdpFromQueue(queue, this._host, this._family);
        }
      }
      _sendUdpFromQueue(queue, address, family) {
        const socket = family === 6 ? this._udp6 : this._udp4;
        queue.forEach((buffer) => {
          log.debug("Sending to DogStatsD: %s", buffer);
          socket.send(buffer, 0, buffer.length, this._port, address);
        });
      }
      _add(stat, value, type, tags) {
        const message = `${this._prefix + stat}:${value}|${type}`;
        tags = tags ? [...this._tags, ...tags] : this._tags;
        if (tags.length > 0) {
          this._write(`${message}|#${tags.join(",")}
`);
        } else {
          this._write(`${message}
`);
        }
      }
      _write(message) {
        const offset = Buffer.byteLength(message);
        if (this._offset + offset > MAX_BUFFER_SIZE) {
          this._enqueue();
        }
        this._offset += offset;
        this._buffer += message;
      }
      _enqueue() {
        if (this._offset > 0) {
          this._queue.push(Buffer.from(this._buffer));
          this._buffer = "";
          this._offset = 0;
        }
        return this._queue;
      }
      _socket(type) {
        const socket = dgram.createSocket(type);
        socket.on("error", () => {
        });
        socket.unref();
        return socket;
      }
      static generateClientConfig(config) {
        const tags = [];
        if (config.tags) {
          for (const [key, value] of Object.entries(config.tags)) {
            if (typeof value === "string" && (key !== "runtime-id" || config.runtimeMetricsRuntimeId)) {
              const valueStripped = value.replaceAll(/[^a-z0-9_:./-]/ig, "_");
              tags.push(`${key}:${valueStripped}`);
            }
          }
        }
        const clientConfig = {
          host: config.dogstatsd.hostname,
          port: config.dogstatsd.port,
          tags
        };
        if (config.url) {
          clientConfig.metricsProxyUrl = config.url;
        } else if (config.port) {
          clientConfig.metricsProxyUrl = new URL2(format({
            protocol: "http:",
            hostname: config.hostname || defaults.hostname,
            port: config.port
          }));
        }
        return clientConfig;
      }
    };
    var MetricsAggregationClient = class {
      constructor(client) {
        this._client = client;
        this.reset();
      }
      flush() {
        this._captureCounters();
        this._captureGauges();
        this._captureHistograms();
        this._client.flush();
      }
      reset() {
        this._counters = /* @__PURE__ */ new Map();
        this._gauges = /* @__PURE__ */ new Map();
        this._histograms = /* @__PURE__ */ new Map();
      }
      // TODO: Aggregate with a histogram and send the buckets to the client.
      distribution(name, value, tags) {
        this._client.distribution(name, value, tags);
      }
      boolean(name, value, tags) {
        this.gauge(name, value ? 1 : 0, tags);
      }
      histogram(name, value, tags) {
        const node = this._ensureTree(this._histograms, name, tags, null);
        if (!node.value) {
          node.value = new Histogram();
        }
        node.value.record(value);
      }
      count(name, count, tags = [], monotonic = true) {
        if (typeof tags === "boolean") {
          monotonic = tags;
          tags = [];
        }
        const container = monotonic ? this._counters : this._gauges;
        const node = this._ensureTree(container, name, tags, 0);
        node.value += count;
      }
      gauge(name, value, tags) {
        const node = this._ensureTree(this._gauges, name, tags, 0);
        node.value = value;
      }
      increment(name, count = 1, tags) {
        this.count(name, count, tags);
      }
      decrement(name, count = 1, tags) {
        this.count(name, -count, tags);
      }
      _captureGauges() {
        this._captureTree(this._gauges, (node, name, tags) => {
          this._client.gauge(name, node.value, tags);
        });
      }
      _captureCounters() {
        this._captureTree(this._counters, (node, name, tags) => {
          this._client.increment(name, node.value, tags);
        });
        this._counters.clear();
      }
      _captureHistograms() {
        this._captureTree(this._histograms, (node, name, tags) => {
          let stats = node.value;
          if (stats.count === 0) {
            stats = { max: 0, min: 0, sum: 0, avg: 0, median: 0, p95: 0, count: 0 };
          }
          this._client.gauge(`${name}.min`, stats.min, tags);
          this._client.gauge(`${name}.max`, stats.max, tags);
          this._client.increment(`${name}.sum`, stats.sum, tags);
          this._client.increment(`${name}.total`, stats.sum, tags);
          this._client.gauge(`${name}.avg`, stats.avg, tags);
          this._client.increment(`${name}.count`, stats.count, tags);
          this._client.gauge(`${name}.median`, stats.median, tags);
          this._client.gauge(`${name}.95percentile`, stats.p95, tags);
          node.value.reset();
        });
      }
      _captureTree(tree, fn) {
        for (const [name, root] of tree) {
          this._captureNode(root, name, [], fn);
        }
      }
      _captureNode(node, name, tags, fn) {
        if (node.touched) {
          fn(node, name, tags);
        }
        for (const [tag, next] of node.nodes) {
          tags.push(tag);
          this._captureNode(next, name, tags, fn);
          tags.pop();
        }
      }
      _ensureTree(tree, name, tags = [], value) {
        if (!Array.isArray(tags)) {
          tags = [tags];
        }
        let node = this._ensureNode(tree, name, value);
        for (const tag of tags) {
          node = this._ensureNode(node.nodes, tag, value);
        }
        node.touched = true;
        return node;
      }
      _ensureNode(container, key, value) {
        let node = container.get(key);
        if (!node) {
          node = { nodes: /* @__PURE__ */ new Map(), touched: false, value };
          if (typeof key === "string") {
            container.set(key, node);
          }
        }
        return node;
      }
    };
    var CustomMetrics = class _CustomMetrics {
      #client;
      constructor(config) {
        const clientConfig = DogStatsDClient.generateClientConfig(config);
        this.#client = new MetricsAggregationClient(new DogStatsDClient(clientConfig));
        const flush = this.flush.bind(this);
        setInterval(flush, 10 * 1e3).unref();
        process.once("beforeExit", flush);
      }
      increment(stat, value = 1, tags) {
        this.#client.increment(stat, value, _CustomMetrics.tagTranslator(tags));
      }
      decrement(stat, value = 1, tags) {
        this.#client.decrement(stat, value, _CustomMetrics.tagTranslator(tags));
      }
      gauge(stat, value, tags) {
        this.#client.gauge(stat, value, _CustomMetrics.tagTranslator(tags));
      }
      distribution(stat, value, tags) {
        this.#client.distribution(stat, value, _CustomMetrics.tagTranslator(tags));
      }
      histogram(stat, value, tags) {
        this.#client.histogram(stat, value, _CustomMetrics.tagTranslator(tags));
      }
      flush() {
        return this.#client.flush();
      }
      /**
       * Exposing { tagName: 'tagValue' } to the end user
       * These are translated into [ 'tagName:tagValue' ] for internal use
       */
      static tagTranslator(objTags) {
        if (Array.isArray(objTags)) return objTags;
        const arrTags = [];
        if (!objTags) return arrTags;
        for (const [key, value] of Object.entries(objTags)) {
          arrTags.push(`${key}:${value}`);
        }
        return arrTags;
      }
    };
    module2.exports = {
      DogStatsDClient,
      CustomMetrics,
      MetricsAggregationClient
    };
  }
});

// ../../package.json
var require_package = __commonJS({
  "../../package.json"(exports2, module2) {
    module2.exports = {
      name: "dd-trace",
      version: "6.0.0-pre",
      description: "Datadog APM tracing client for JavaScript",
      main: "index.js",
      typings: "index.d.ts",
      scripts: {
        env: "bash ./plugin-env",
        preinstall: "node scripts/preinstall.js",
        bench: "node benchmark/index.js",
        "bench:e2e:test-optimization": "node benchmark/e2e-test-optimization/benchmark-run.js",
        "dependencies:dedupe": "yarn-deduplicate yarn.lock",
        "type:check": "tsc --noEmit -p tsconfig.json",
        "type:doc": "cd docs && yarn && yarn build",
        "type:test": "cd docs && yarn && yarn test",
        lint: "node scripts/check_licenses.js && eslint . --concurrency=auto --max-warnings 0",
        "lint:fix": "node scripts/check_licenses.js && eslint . --concurrency=auto --max-warnings 0 --fix",
        "lint:inspect": "npx @eslint/config-inspector@latest",
        "release:proposal": "node scripts/release/proposal",
        services: "node ./scripts/install_plugin_modules && node packages/dd-trace/test/setup/services",
        test: "SERVICES=* yarn services && mocha --expose-gc 'packages/dd-trace/test/setup/node.js' 'packages/*/test/**/*.spec.js'",
        "test:aiguard": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/aiguard/**/*.spec.js"',
        "test:aiguard:ci": 'nyc --no-clean --include "packages/dd-trace/src/aiguard/**/*.js" -- npm run test:aiguard',
        "test:appsec": 'mocha -r "packages/dd-trace/test/setup/mocha.js" --exclude "packages/dd-trace/test/appsec/**/*.plugin.spec.js" "packages/dd-trace/test/appsec/**/*.spec.js"',
        "test:appsec:ci": 'nyc --no-clean --include "packages/dd-trace/src/appsec/**/*.js" --exclude "packages/dd-trace/test/appsec/**/*.plugin.spec.js" -- npm run test:appsec',
        "test:appsec:plugins": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/appsec/**/*.@($(echo $PLUGINS)).plugin.spec.js"',
        "test:appsec:plugins:ci": 'yarn services && nyc --no-clean --include "packages/dd-trace/src/appsec/**/*.js" -- npm run test:appsec:plugins',
        "test:debugger": "mocha -r 'packages/dd-trace/test/setup/mocha.js' 'packages/dd-trace/test/debugger/**/*.spec.js'",
        "test:debugger:ci": "nyc --no-clean --include 'packages/dd-trace/src/debugger/**/*.js' -- npm run test:debugger",
        "test:eslint-rules": "node eslint-rules/*.test.mjs",
        "test:trace:core": 'tap packages/dd-trace/test/*.spec.js "packages/dd-trace/test/{ci-visibility,datastreams,encode,exporters,opentelemetry,opentracing,plugins,remote_config,service-naming,standalone,telemetry,external-logger}/**/*.spec.js"',
        "test:trace:core:ci": 'npm run test:trace:core -- --coverage --nyc-arg=--include="packages/dd-trace/src/**/*.js"',
        "test:trace:guardrails": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/guardrails/**/*.spec.js"',
        "test:trace:guardrails:ci": 'nyc --no-clean --include "packages/dd-trace/src/guardrails/**/*.js" -- npm run test:trace:guardrails',
        "test:esbuild": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-esbuild/test/**/*.spec.js"',
        "test:esbuild:ci": 'nyc --no-clean --include "packages/datadog-esbuild/test/**/*.js" -- npm run test:esbuild',
        "test:instrumentations": `mocha -r 'packages/dd-trace/test/setup/mocha.js' "packages/datadog-instrumentations/test/@($(echo $PLUGINS)).spec.js"`,
        "test:instrumentations:ci": 'yarn services && nyc --no-clean --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS)).js" --include "packages/datadog-instrumentations/src/@($(echo $PLUGINS))/**/*.js" -- npm run test:instrumentations',
        "test:instrumentations:misc": "mocha -r 'packages/dd-trace/test/setup/mocha.js' 'packages/datadog-instrumentations/test/*/**/*.spec.js'",
        "test:instrumentations:misc:ci": "nyc --no-clean --include 'packages/datadog-instrumentations/src/**/*.js' -- npm run test:instrumentations:misc",
        "test:core": 'tap "packages/datadog-core/test/**/*.spec.js"',
        "test:core:ci": 'npm run test:core -- --coverage --nyc-arg=--include="packages/datadog-core/src/**/*.js"',
        "test:lambda": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/lambda/**/*.spec.js"',
        "test:lambda:ci": 'nyc --no-clean --include "packages/dd-trace/src/lambda/**/*.js" -- npm run test:lambda',
        "test:llmobs:sdk": 'mocha -r "packages/dd-trace/test/setup/mocha.js" --exclude "packages/dd-trace/test/llmobs/plugins/**/*.spec.js" "packages/dd-trace/test/llmobs/**/*.spec.js" ',
        "test:llmobs:sdk:ci": 'nyc --no-clean --include "packages/dd-trace/src/llmobs/**/*.js" -- npm run test:llmobs:sdk',
        "test:llmobs:plugins": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/dd-trace/test/llmobs/plugins/@($(echo $PLUGINS))/*.spec.js"',
        "test:llmobs:plugins:ci": 'yarn services && nyc --no-clean --include "packages/dd-trace/src/llmobs/**/*.js" -- npm run test:llmobs:plugins',
        "test:plugins": `mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/**/@($(echo \${SPEC:-'*'})).spec.js"`,
        "test:plugins:ci": 'yarn services && nyc --no-clean --include "packages/datadog-plugin-@($(echo $PLUGINS))/src/**/*.js" -- npm run test:plugins',
        "test:plugins:ci:flaky": 'yarn services && nyc --no-clean --include "packages/datadog-plugin-@($(echo $PLUGINS))/src/**/*.js" -- npm run test:plugins -- --bail --retries 2',
        "test:plugins:upstream": "node ./packages/dd-trace/test/plugins/suite.js",
        "test:profiler": 'tap "packages/dd-trace/test/profiling/**/*.spec.js"',
        "test:profiler:ci": 'npm run test:profiler -- --coverage --nyc-arg=--include="packages/dd-trace/src/profiling/**/*.js"',
        "test:integration": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/*.spec.js"',
        "test:integration:aiguard": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/aiguard/*.spec.js"',
        "test:integration:appsec": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/appsec/*.spec.js"',
        "test:integration:cucumber": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/cucumber/*.spec.js"',
        "test:integration:cypress": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/cypress/*.spec.js"',
        "test:integration:debugger": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/debugger/*.spec.js"',
        "test:integration:esbuild": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/esbuild/*.spec.js"',
        "test:integration:openfeature": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/openfeature/*.spec.js"',
        "test:integration:jest": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/jest/*.spec.js"',
        "test:integration:mocha": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/mocha/*.spec.js"',
        "test:integration:playwright": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/playwright/*.spec.js"',
        "test:integration:selenium": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/selenium/*.spec.js"',
        "test:integration:vitest": 'mocha --timeout 60000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/vitest/*.spec.js"',
        "test:integration:testopt": 'mocha --timeout 90000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/ci-visibility/*.spec.js"',
        "test:integration:profiler": 'mocha --timeout 180000 -r "packages/dd-trace/test/setup/core.js" "integration-tests/profiler/*.spec.js"',
        "test:integration:plugins": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/integration-test/**/*.spec.js"',
        "test:unit:plugins": 'mocha -r "packages/dd-trace/test/setup/mocha.js" "packages/datadog-instrumentations/test/@($(echo $PLUGINS)).spec.js" "packages/datadog-plugin-@($(echo $PLUGINS))/test/**/*.spec.js" --exclude "packages/datadog-plugin-@($(echo $PLUGINS))/test/integration-test/**/*.spec.js"',
        "test:shimmer": "mocha 'packages/datadog-shimmer/test/**/*.spec.js'",
        "test:shimmer:ci": "nyc --no-clean --include 'packages/datadog-shimmer/src/**/*.js' -- npm run test:shimmer"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/DataDog/dd-trace-js.git"
      },
      keywords: [
        "datadog",
        "trace",
        "tracing",
        "profile",
        "profiler",
        "profiling",
        "opentracing",
        "apm"
      ],
      author: "Datadog Inc. <info@datadoghq.com>",
      license: "(Apache-2.0 OR BSD-3-Clause)",
      bugs: {
        url: "https://github.com/DataDog/dd-trace-js/issues"
      },
      homepage: "https://github.com/DataDog/dd-trace-js#readme",
      engines: {
        node: ">=18"
      },
      files: [
        "ci/**/*",
        "cypress/**/*",
        "esbuild.js",
        "ext/**/*",
        "index.d.ts",
        "index.js",
        "init.js",
        "initialize.mjs",
        "LICENSE-3rdparty.csv",
        "LICENSE",
        "LICENSE.Apache",
        "LICENSE.BSD3",
        "loader-hook.mjs",
        "package.json",
        "packages/*/index.js",
        "packages/*/lib/**/*",
        "packages/*/src/**/*",
        "packages/datadog-instrumentations/orchestrion.yml",
        "README.md",
        "register.js",
        "scripts/preinstall.js",
        "vendor/**/*",
        "version.js"
      ],
      dependencies: {
        "@datadog/libdatadog": "0.7.0",
        "@datadog/native-appsec": "10.3.0",
        "@datadog/native-iast-taint-tracking": "4.0.0",
        "@datadog/native-metrics": "3.1.1",
        "@datadog/openfeature-node-server": "0.1.0-preview.12",
        "@datadog/pprof": "5.11.1",
        "@datadog/sketches-js": "2.1.1",
        "@datadog/wasm-js-rewriter": "4.0.1",
        "@isaacs/ttlcache": "^1.4.1",
        "@opentelemetry/api": ">=1.0.0 <1.10.0",
        "@opentelemetry/api-logs": "<1.0.0",
        "@opentelemetry/core": ">=1.14.0 <1.31.0",
        "@opentelemetry/resources": ">=1.0.0 <1.10.0",
        "crypto-randomuuid": "^1.0.0",
        "dc-polyfill": "^0.1.10",
        ignore: "^7.0.5",
        "import-in-the-middle": "^1.14.2",
        "istanbul-lib-coverage": "^3.2.2",
        "jest-docblock": "^29.7.0",
        "jsonpath-plus": "^10.3.0",
        limiter: "^1.1.5",
        "lodash.sortby": "^4.7.0",
        "lru-cache": "^10.4.3",
        "module-details-from-path": "^1.0.4",
        mutexify: "^1.4.0",
        opentracing: ">=0.14.7",
        "path-to-regexp": "^0.1.12",
        "pprof-format": "^2.1.1",
        protobufjs: "^7.5.3",
        retry: "^0.13.1",
        rfdc: "^1.4.1",
        semifies: "^1.0.0",
        "shell-quote": "^1.8.2",
        "source-map": "^0.7.4",
        "tlhunter-sorted-set": "^0.1.0",
        "ttl-set": "^1.0.0"
      },
      devDependencies: {
        "@babel/helpers": "^7.27.6",
        "@eslint/eslintrc": "^3.3.1",
        "@eslint/js": "^9.29.0",
        "@msgpack/msgpack": "^3.1.2",
        "@openfeature/core": "^1.9.0",
        "@openfeature/server-sdk": "^1.20.0",
        "@stylistic/eslint-plugin": "^5.0.0",
        "@types/chai": "^4.3.16",
        "@types/mocha": "^10.0.10",
        "@types/node": "^18.19.106",
        "@types/sinon": "^17.0.4",
        "@types/tap": "^15.0.12",
        axios: "^1.12.2",
        benchmark: "^2.1.4",
        "body-parser": "^2.2.0",
        bun: "1.3.1",
        chai: "^4.5.0",
        eslint: "^9.29.0",
        "eslint-plugin-cypress": "^5.1.0",
        "eslint-plugin-import": "^2.32.0",
        "eslint-plugin-mocha": "^11.1.0",
        "eslint-plugin-n": "^17.20.0",
        "eslint-plugin-promise": "^7.2.1",
        "eslint-plugin-unicorn": "^61.0.2",
        express: "^5.1.0",
        glob: "^10.4.5",
        globals: "^16.3.0",
        graphql: "*",
        jszip: "^3.10.1",
        mocha: "^11.6.0",
        "mocha-junit-reporter": "^2.2.1",
        "mocha-multi-reporters": "^1.5.1",
        multer: "^2.0.2",
        nock: "^13.5.6",
        nyc: "^15.1.0",
        octokit: "^5.0.3",
        proxyquire: "^2.1.3",
        semver: "^7.7.2",
        sinon: "^21.0.0",
        "sinon-chai": "^3.7.0",
        tap: "^16.3.10",
        tiktoken: "^1.0.21",
        typescript: "^5.9.2",
        workerpool: "^10.0.0",
        yaml: "^2.8.0",
        "yarn-deduplicate": "^6.0.2"
      }
    };
  }
});

// ../../version.js
var require_version2 = __commonJS({
  "../../version.js"(exports2, module2) {
    "use strict";
    var version = require_package().version;
    var ddMatches = version.match(/^(\d+)\.(\d+)\.(\d+)/);
    var nodeMatches = process.versions.node.match(/^(\d+)\.(\d+)\.(\d+)/);
    module2.exports = {
      VERSION: version,
      DD_MAJOR: parseInt(ddMatches[1]),
      DD_MINOR: parseInt(ddMatches[2]),
      DD_PATCH: parseInt(ddMatches[3]),
      NODE_MAJOR: parseInt(nodeMatches[1]),
      NODE_MINOR: parseInt(nodeMatches[2]),
      NODE_PATCH: parseInt(nodeMatches[3]),
      NODE_VERSION: nodeMatches[0]
    };
  }
});

// ../../packages/dd-trace/src/runtime_metrics/runtime_metrics.js
var require_runtime_metrics = __commonJS({
  "../../packages/dd-trace/src/runtime_metrics/runtime_metrics.js"(exports2, module2) {
    "use strict";
    var v8 = __require("v8");
    var os = __require("os");
    var process2 = __require("process");
    var { DogStatsDClient, MetricsAggregationClient } = require_dogstatsd2();
    var log = require_log2();
    var { performance: performance2, PerformanceObserver, monitorEventLoopDelay } = __require("perf_hooks");
    var { getEnvironmentVariable } = require_config_helper();
    var { NODE_MAJOR } = require_version2();
    var DD_RUNTIME_METRICS_FLUSH_INTERVAL = getEnvironmentVariable("DD_RUNTIME_METRICS_FLUSH_INTERVAL") ?? "10000";
    var INTERVAL = Number.parseInt(DD_RUNTIME_METRICS_FLUSH_INTERVAL, 10);
    var eventLoopDelayResolution = 4;
    var nativeMetrics = null;
    var gcObserver = null;
    var interval = null;
    var client = null;
    var lastTime = 0n;
    var lastCpuUsage = null;
    var eventLoopDelayObserver = null;
    module2.exports = {
      start(config) {
        this.stop();
        const clientConfig = DogStatsDClient.generateClientConfig(config);
        const trackEventLoop = config.runtimeMetrics.eventLoop !== false;
        const trackGc = config.runtimeMetrics.gc !== false;
        if (trackGc) {
          startGCObserver();
        }
        const watchers = trackEventLoop ? ["loop"] : ["no-gc"];
        try {
          nativeMetrics = __require("@datadog/native-metrics");
          nativeMetrics.start(...watchers);
        } catch (error) {
          log.error("Error starting native metrics", error);
          nativeMetrics = null;
        }
        client = new MetricsAggregationClient(new DogStatsDClient(clientConfig));
        lastTime = performance2.now();
        if (nativeMetrics) {
          interval = setInterval(() => {
            captureNativeMetrics(trackEventLoop, trackGc);
            captureCommonMetrics(trackEventLoop);
            client.flush();
          }, INTERVAL);
        } else {
          lastCpuUsage = process2.cpuUsage();
          if (trackEventLoop) {
            eventLoopDelayObserver = monitorEventLoopDelay({ resolution: eventLoopDelayResolution });
            eventLoopDelayObserver.enable();
          }
          interval = setInterval(() => {
            captureCpuUsage();
            captureCommonMetrics(trackEventLoop);
            captureHeapSpace();
            if (trackEventLoop) {
              captureEventLoopDelay();
            }
            client.flush();
          }, INTERVAL);
        }
        interval.unref();
      },
      stop() {
        nativeMetrics?.stop();
        nativeMetrics = null;
        clearInterval(interval);
        interval = null;
        client = null;
        lastTime = 0n;
        lastCpuUsage = null;
        gcObserver?.disconnect();
        gcObserver = null;
        eventLoopDelayObserver?.disable();
        eventLoopDelayObserver = null;
      },
      track(span) {
        if (nativeMetrics) {
          const handle = nativeMetrics.track(span);
          return {
            finish: () => nativeMetrics.finish(handle)
          };
        }
        return { finish: () => {
        } };
      },
      boolean(name, value, tag) {
        client?.boolean(name, value, tag);
      },
      histogram(name, value, tag) {
        client?.histogram(name, value, tag);
      },
      count(name, count, tag, monotonic = false) {
        client?.count(name, count, tag, monotonic);
      },
      gauge(name, value, tag) {
        client?.gauge(name, value, tag);
      },
      increment(name, tag, monotonic) {
        this.count(name, 1, tag, monotonic);
      },
      decrement(name, tag) {
        this.count(name, -1, tag);
      }
    };
    function captureCpuUsage() {
      const currentCpuUsage = process2.cpuUsage();
      const elapsedUsageUser = currentCpuUsage.user - lastCpuUsage.user;
      const elapsedUsageSystem = currentCpuUsage.system - lastCpuUsage.system;
      const currentTime = performance2.now();
      const elapsedUsDividedBy100 = (currentTime - lastTime) * 10;
      const userPercent = elapsedUsageUser / elapsedUsDividedBy100;
      const systemPercent = elapsedUsageSystem / elapsedUsDividedBy100;
      const totalPercent = userPercent + systemPercent;
      lastTime = currentTime;
      lastCpuUsage = currentCpuUsage;
      client.gauge("runtime.node.cpu.system", systemPercent.toFixed(2));
      client.gauge("runtime.node.cpu.user", userPercent.toFixed(2));
      client.gauge("runtime.node.cpu.total", totalPercent.toFixed(2));
    }
    function captureMemoryUsage() {
      const stats = process2.memoryUsage();
      client.gauge("runtime.node.mem.heap_total", stats.heapTotal);
      client.gauge("runtime.node.mem.heap_used", stats.heapUsed);
      client.gauge("runtime.node.mem.rss", stats.rss);
      client.gauge("runtime.node.mem.total", os.totalmem());
      client.gauge("runtime.node.mem.free", os.freemem());
      client.gauge("runtime.node.mem.external", stats.external);
    }
    function captureUptime() {
      client.gauge("runtime.node.process.uptime", Math.round((lastTime + 499) / 1e3));
    }
    function captureEventLoopDelay() {
      eventLoopDelayObserver.disable();
      if (eventLoopDelayObserver.count !== 0) {
        const minimum = eventLoopDelayResolution * 1e6;
        const avg = Math.max(eventLoopDelayObserver.mean - minimum, 0);
        const sum = Math.round(avg * eventLoopDelayObserver.count);
        if (sum !== 0) {
          const stats = {
            min: Math.max(eventLoopDelayObserver.min - minimum, 0),
            max: Math.max(eventLoopDelayObserver.max - minimum, 0),
            sum,
            total: sum,
            avg,
            count: eventLoopDelayObserver.count,
            p95: Math.max(eventLoopDelayObserver.percentile(95) - minimum, 0)
          };
          histogram("runtime.node.event_loop.delay", stats);
        }
      }
      eventLoopDelayObserver = monitorEventLoopDelay({ resolution: eventLoopDelayResolution });
      eventLoopDelayObserver.enable();
    }
    function captureHeapStats() {
      const stats = v8.getHeapStatistics();
      client.gauge("runtime.node.heap.total_heap_size", stats.total_heap_size);
      client.gauge("runtime.node.heap.total_heap_size_executable", stats.total_heap_size_executable);
      client.gauge("runtime.node.heap.total_physical_size", stats.total_physical_size);
      client.gauge("runtime.node.heap.total_available_size", stats.total_available_size);
      client.gauge("runtime.node.heap.heap_size_limit", stats.heap_size_limit);
      client.gauge("runtime.node.heap.malloced_memory", stats.malloced_memory);
      client.gauge("runtime.node.heap.peak_malloced_memory", stats.peak_malloced_memory);
    }
    function captureHeapSpace() {
      const stats = v8.getHeapSpaceStatistics();
      for (let i = 0, l = stats.length; i < l; i++) {
        const tags = [`space:${stats[i].space_name}`];
        client.gauge("runtime.node.heap.size.by.space", stats[i].space_size, tags);
        client.gauge("runtime.node.heap.used_size.by.space", stats[i].space_used_size, tags);
        client.gauge("runtime.node.heap.available_size.by.space", stats[i].space_available_size, tags);
        client.gauge("runtime.node.heap.physical_size.by.space", stats[i].physical_space_size, tags);
      }
    }
    var lastElu = { idle: 0, active: 0 };
    function captureELU() {
      const elu = performance2.eventLoopUtilization();
      const idle = elu.idle - lastElu.idle;
      const active = elu.active - lastElu.active;
      const utilization = active / (idle + active);
      lastElu = elu;
      client.gauge("runtime.node.event_loop.utilization", utilization);
    }
    function captureCommonMetrics(trackEventLoop) {
      captureMemoryUsage();
      captureUptime();
      captureHeapStats();
      if (trackEventLoop) {
        captureELU();
      }
    }
    function captureNativeMetrics(trackEventLoop, trackGc) {
      const stats = nativeMetrics.stats();
      const spaces = stats.heap.spaces;
      const currentTime = performance2.now();
      const elapsedUsDividedBy100 = (currentTime - lastTime) * 10;
      lastTime = currentTime;
      const userPercent = stats.cpu.user / elapsedUsDividedBy100;
      const systemPercent = stats.cpu.system / elapsedUsDividedBy100;
      const totalPercent = userPercent + systemPercent;
      client.gauge("runtime.node.cpu.system", systemPercent.toFixed(2));
      client.gauge("runtime.node.cpu.user", userPercent.toFixed(2));
      client.gauge("runtime.node.cpu.total", totalPercent.toFixed(2));
      if (trackEventLoop) {
        histogram("runtime.node.event_loop.delay", stats.eventLoop);
      }
      if (trackGc) {
        for (const [type, value] of Object.entries(stats.gc)) {
          if (type === "all") {
            histogram("runtime.node.gc.pause", value);
          } else {
            histogram("runtime.node.gc.pause.by.type", value, `gc_type:${type}`);
          }
        }
      }
      for (let i = 0, l = spaces.length; i < l; i++) {
        const tag = `heap_space:${spaces[i].space_name}`;
        client.gauge("runtime.node.heap.size.by.space", spaces[i].space_size, tag);
        client.gauge("runtime.node.heap.used_size.by.space", spaces[i].space_used_size, tag);
        client.gauge("runtime.node.heap.available_size.by.space", spaces[i].space_available_size, tag);
        client.gauge("runtime.node.heap.physical_size.by.space", spaces[i].physical_space_size, tag);
      }
    }
    function histogram(name, stats, tag) {
      if (stats.count === 0) {
        return;
      }
      client.gauge(`${name}.min`, stats.min, tag);
      client.gauge(`${name}.max`, stats.max, tag);
      client.increment(`${name}.sum`, stats.sum, tag);
      client.increment(`${name}.total`, stats.sum, tag);
      client.gauge(`${name}.avg`, stats.avg, tag);
      client.increment(`${name}.count`, stats.count, tag);
      if (stats.median !== void 0) {
        client.gauge(`${name}.median`, stats.median, tag);
      }
      client.gauge(`${name}.95percentile`, stats.p95, tag);
    }
    function startGCObserver() {
      if (gcObserver) return;
      gcObserver = new PerformanceObserver((list) => {
        for (const entry of list.getEntries()) {
          const type = gcType(entry.detail?.kind || entry.kind);
          const duration = entry.duration * 1e6;
          client.histogram("runtime.node.gc.pause.by.type", duration, `gc_type:${type}`);
          client.histogram("runtime.node.gc.pause", duration);
        }
      });
      gcObserver.observe({ type: "gc" });
    }
    var minorGCType = NODE_MAJOR >= 22 ? "minor_mark_sweep" : "minor_mark_compact";
    function gcType(kind) {
      switch (kind) {
        case 1:
          return "scavenge";
        case 2:
          return minorGCType;
        case 4:
          return "mark_sweep_compact";
        // Deprecated, might be removed soon.
        case 8:
          return "incremental_marking";
        case 16:
          return "process_weak_callbacks";
        case 31:
          return "all";
        default:
          return "unknown";
      }
    }
  }
});

// ../../packages/dd-trace/src/runtime_metrics/index.js
var require_runtime_metrics2 = __commonJS({
  "../../packages/dd-trace/src/runtime_metrics/index.js"(exports2, module2) {
    "use strict";
    var runtimeMetrics;
    var noop = runtimeMetrics = {
      stop() {
      },
      track() {
      },
      boolean() {
      },
      histogram() {
      },
      count() {
      },
      gauge() {
      },
      increment() {
      },
      decrement() {
      }
    };
    module2.exports = {
      start(config) {
        if (!config?.runtimeMetrics.enabled) return;
        runtimeMetrics = require_runtime_metrics();
        Object.setPrototypeOf(module2.exports, runtimeMetrics);
        runtimeMetrics.start(config);
      },
      stop() {
        runtimeMetrics.stop();
        Object.setPrototypeOf(module2.exports, runtimeMetrics = noop);
      }
    };
    Object.setPrototypeOf(module2.exports, noop);
  }
});

// ../../packages/dd-trace/src/telemetry/send-data.js
var require_send_data = __commonJS({
  "../../packages/dd-trace/src/telemetry/send-data.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var log = require_log2();
    var { isTrue } = require_util();
    var { getEnvironmentVariable } = require_config_helper();
    var agentTelemetry = true;
    function getHeaders(config, application, reqType) {
      const headers = {
        "content-type": "application/json",
        "dd-telemetry-api-version": "v2",
        "dd-telemetry-request-type": reqType,
        "dd-client-library-language": application.language_name,
        "dd-client-library-version": application.tracer_version
      };
      const debug = config.telemetry && config.telemetry.debug;
      if (debug) {
        headers["dd-telemetry-debug-enabled"] = "true";
      }
      if (config.apiKey) {
        headers["dd-api-key"] = config.apiKey;
      }
      return headers;
    }
    function getAgentlessTelemetryEndpoint(site) {
      if (site === "datad0g.com") {
        return "https://all-http-intake.logs.datad0g.com";
      }
      return `https://instrumentation-telemetry-intake.${site}`;
    }
    var seqId = 0;
    function getPayload(payload) {
      if (Array.isArray(payload)) {
        return payload;
      }
      const { logger, tags, serviceMapping, ...trimmedPayload } = payload;
      return trimmedPayload;
    }
    function sendData(config, application, host, reqType, payload = {}, cb = () => {
    }) {
      const {
        hostname,
        port,
        isCiVisibility
      } = config;
      let url = config.url;
      const isCiVisibilityAgentlessMode = isCiVisibility && isTrue(getEnvironmentVariable("DD_CIVISIBILITY_AGENTLESS_ENABLED"));
      if (isCiVisibilityAgentlessMode) {
        try {
          url = url || new URL(getAgentlessTelemetryEndpoint(config.site));
        } catch (err) {
          log.error("Telemetry endpoint url is invalid", err);
          return cb(err, { payload, reqType });
        }
      }
      const options = {
        url,
        hostname,
        port,
        method: "POST",
        path: isCiVisibilityAgentlessMode ? "/api/v2/apmtelemetry" : "/telemetry/proxy/api/v2/apmtelemetry",
        headers: getHeaders(config, application, reqType)
      };
      const data = JSON.stringify({
        api_version: "v2",
        naming_schema_version: config.spanAttributeSchema ?? "",
        request_type: reqType,
        tracer_time: Math.floor(Date.now() / 1e3),
        runtime_id: config.tags["runtime-id"],
        seq_id: ++seqId,
        payload: getPayload(payload),
        application,
        host
      });
      request2(data, options, (error) => {
        if (error && getEnvironmentVariable("DD_API_KEY") && config.site) {
          if (agentTelemetry) {
            log.warn("Agent telemetry failed, started agentless telemetry");
            agentTelemetry = false;
          }
          const backendUrl = getAgentlessTelemetryEndpoint(config.site);
          const backendHeader = { ...options.headers, "DD-API-KEY": getEnvironmentVariable("DD_API_KEY") };
          const backendOptions = {
            ...options,
            url: backendUrl,
            headers: backendHeader,
            path: "/api/v2/apmtelemetry"
          };
          if (backendUrl) {
            request2(data, backendOptions, (error2) => {
              if (error2) {
                log.error("Error sending telemetry data", error2);
              }
            });
          } else {
            log.error("Invalid Telemetry URL");
          }
        }
        if (!error && !agentTelemetry) {
          agentTelemetry = true;
          log.info("Started agent telemetry");
        }
        cb(error, { payload, reqType });
      });
    }
    module2.exports = { sendData };
  }
});

// ../../packages/dd-trace/src/telemetry/metrics.js
var require_metrics = __commonJS({
  "../../packages/dd-trace/src/telemetry/metrics.js"(exports2, module2) {
    "use strict";
    var { sendData } = require_send_data();
    function getId(type, namespace2, name, tags) {
      return `${type}:${namespace2}.${name}:${tagArray(tags).sort().join(",")}`;
    }
    function tagArray(tags = {}) {
      if (Array.isArray(tags)) return tags;
      const list = [];
      for (const [key, value] of Object.entries(tags)) {
        list.push(`${key}:${value}`.toLowerCase());
      }
      return list;
    }
    function now() {
      return Date.now() / 1e3;
    }
    function mapToJsonArray(map, filter) {
      const array = [];
      for (const value of map.values()) {
        if (!filter || filter(value)) {
          array.push(value.toJSON());
        }
      }
      return array;
    }
    function hasPoints(metric) {
      return metric.points.length > 0;
    }
    var Metric = class {
      constructor(namespace2, metric, common, tags) {
        this.namespace = namespace2.toString();
        this.metric = common ? metric : `nodejs.${metric}`;
        this.tags = tagArray(tags);
        this.common = common;
        this.points = [];
      }
      toString() {
        const { namespace: namespace2, metric } = this;
        return `${namespace2}.${metric}`;
      }
      reset() {
        this.points = [];
      }
      track() {
        throw new Error("not implemented");
      }
      toJSON() {
        const { metric, points, interval, type, tags, common } = this;
        return {
          metric,
          points,
          interval,
          type,
          tags,
          common
        };
      }
    };
    var CountMetric = class extends Metric {
      get type() {
        return "count";
      }
      inc(value) {
        return this.track(value);
      }
      dec(value = 1) {
        return this.track(-value);
      }
      track(value = 1) {
        if (this.points.length) {
          this.points[0][1] += value;
        } else {
          this.points.push([now(), value]);
        }
      }
    };
    var DistributionMetric = class extends Metric {
      get type() {
        return "distribution";
      }
      track(value = 1) {
        this.points.push(value);
      }
      toJSON() {
        const { metric, points, tags, common } = this;
        return {
          metric,
          points,
          common,
          tags
        };
      }
    };
    var GaugeMetric = class extends Metric {
      get type() {
        return "gauge";
      }
      mark(value) {
        return this.track(value);
      }
      track(value = 1) {
        this.points.push([now(), value]);
      }
    };
    var RateMetric = class extends Metric {
      constructor(namespace2, metric, common, tags, interval) {
        super(namespace2, metric, common, tags);
        this.interval = interval;
        this.rate = 0;
      }
      get type() {
        return "rate";
      }
      reset() {
        super.reset();
        this.rate = 0;
      }
      track(value = 1) {
        this.rate += value;
        const rate = this.interval ? this.rate / this.interval : 0;
        this.points = [[now(), rate]];
      }
    };
    var metricsTypes = {
      count: CountMetric,
      distribution: DistributionMetric,
      gauge: GaugeMetric,
      rate: RateMetric
    };
    var MetricsCollection = class extends Map {
      constructor(namespace2) {
        super();
        this.namespace = namespace2;
      }
      reset() {
        for (const metric of this.values()) {
          metric.reset();
        }
      }
      toString() {
        return this.namespace;
      }
      toJSON() {
        if (!this.size) return;
        const series = mapToJsonArray(this, hasPoints);
        if (!series.length) return;
        const { namespace: namespace2 } = this;
        return {
          namespace: namespace2,
          series
        };
      }
    };
    function getMetric(collection, type, name, tags, interval) {
      const metricId = getId(type, collection, name, tags);
      let metric = collection.get(metricId);
      if (metric) return metric;
      const Factory = metricsTypes[type];
      if (!Factory) {
        throw new Error(`Unknown metric type ${type}`);
      }
      metric = new Factory(collection, name, true, tags, interval);
      collection.set(metricId, metric);
      return metric;
    }
    var Namespace = class {
      constructor(namespace2) {
        this.distributions = new MetricsCollection(namespace2);
        this.metrics = new MetricsCollection(namespace2);
      }
      reset() {
        this.metrics.reset();
        this.distributions.reset();
      }
      count(name, tags) {
        return getMetric(this.metrics, "count", name, tags);
      }
      gauge(name, tags) {
        return getMetric(this.metrics, "gauge", name, tags);
      }
      rate(name, interval, tags) {
        return getMetric(this.metrics, "rate", name, tags, interval);
      }
      distribution(name, tags) {
        return getMetric(this.distributions, "distribution", name, tags);
      }
      toJSON() {
        const { distributions, metrics: metrics2 } = this;
        return {
          distributions: distributions.toJSON(),
          metrics: metrics2.toJSON()
        };
      }
    };
    var NamespaceManager = class extends Map {
      namespace(name) {
        let ns = this.get(name);
        if (ns) return ns;
        ns = new Namespace(name);
        this.set(name, ns);
        return ns;
      }
      toJSON() {
        return mapToJsonArray(this);
      }
      send(config, application, host) {
        for (const namespace2 of this.values()) {
          const { metrics: metrics2, distributions } = namespace2.toJSON();
          if (metrics2) {
            sendData(config, application, host, "generate-metrics", metrics2);
          }
          if (distributions) {
            sendData(config, application, host, "distributions", distributions);
          }
          namespace2.reset();
        }
      }
    };
    var manager = new NamespaceManager();
    module2.exports = {
      CountMetric,
      DistributionMetric,
      GaugeMetric,
      RateMetric,
      MetricsCollection,
      Namespace,
      NamespaceManager,
      manager
    };
  }
});

// ../../node_modules/tlhunter-sorted-set/lib/intersect.js
var require_intersect = __commonJS({
  "../../node_modules/tlhunter-sorted-set/lib/intersect.js"(exports2, module2) {
    function binaryIntersect(a, b) {
      let lookup = /* @__PURE__ */ Object.create(null), result = [];
      for (; a; a = a.next[0].next)
        lookup[a.key] = true;
      for (; b; b = b.next[0].next)
        if (lookup[b.key])
          result.push(b.key);
      return result;
    }
    function ternaryIntersect(a, b, c) {
      let lookup = /* @__PURE__ */ Object.create(null), result = [];
      for (; a; a = a.next[0].next)
        lookup[a.key] = 0;
      for (; b; b = b.next[0].next)
        if (lookup[b.key] === 0)
          lookup[b.key] = 1;
      for (; c; c = c.next[0].next)
        if (lookup[c.key] === 1)
          result.push(c.key);
      return result;
    }
    function intersect(nodes) {
      let result, node, lookup, x, i, j, n;
      if (!nodes.length)
        return [];
      for (i = nodes.length - 1; i >= 0; i--) {
        if (!nodes[i].length)
          return [];
        nodes[i] = nodes[i]._head.next[0].next;
      }
      if (nodes.length === 1)
        return nodes[0].toArray({ field: "key" });
      if (nodes.length === 2)
        return binaryIntersect(nodes[0], nodes[1]);
      if (nodes.length === 3)
        return ternaryIntersect(nodes[0], nodes[1], nodes[2]);
      lookup = /* @__PURE__ */ Object.create(null);
      for (node = nodes.shift(); node; node = node.next[0].next)
        lookup[node.key] = 0;
      for (i = 0, n = nodes.length - 1; i < n; i++) {
        x = 0;
        j = i + 1;
        for (node = nodes[i]; node; node = node.next[0].next) {
          if (lookup[node.key] === i) {
            lookup[node.key] = j;
            x++;
          }
        }
        if (!x)
          return [];
      }
      result = [];
      for (node = nodes[i]; node; node = node.next[0].next)
        if (lookup[node.key] === i)
          result.push(node.key);
      return result;
    }
    module2.exports = intersect;
  }
});

// ../../node_modules/tlhunter-sorted-set/lib/set.js
var require_set = __commonJS({
  "../../node_modules/tlhunter-sorted-set/lib/set.js"(exports2, module2) {
    "use strict";
    var intersect = require_intersect();
    var slice = Array.prototype.slice;
    var P = 1 / Math.E;
    var SortedSet = class _SortedSet {
      constructor(options = {}) {
        this._unique = !!options.unique;
        this.empty();
      }
      static intersect() {
        return intersect.call(_SortedSet, slice.call(arguments));
      }
      add(key, value) {
        let current;
        if (value == null) {
          return this.rem(key);
        }
        current = this._map.get(key);
        if (current !== void 0) {
          if (value === current) {
            return current;
          }
          this._remove(key, current);
        }
        let node = this._insert(key, value);
        if (!node) {
          current === void 0 || this._insert(key, current);
          throw new Error("unique constraint violated");
        }
        this._map.set(key, value);
        return current === void 0 ? null : current;
      }
      card() {
        if (this.length) {
          return this.length;
        }
        return 0;
      }
      count(min, max) {
        if (!this.length) {
          return 0;
        }
        if (min == null) {
          min = -Infinity;
        }
        if (max == null) {
          max = Infinity;
        }
        if (min <= this._head.next[0].next.value && max >= this._tail.value) {
          return this.length;
        }
        if (max < min || min > this._tail.value || max < this._head.next[0].next.value) {
          return 0;
        }
        let i;
        let node = this._first(min);
        let count = 0;
        if (!node) {
          return 0;
        }
        for (i = node.next.length - 1; i >= 0; i -= 1) {
          while (node.next[i].next && node.next[i].next.value <= max) {
            count += node.next[i].span;
            node = node.next[i].next;
          }
        }
        return count && count + 1;
      }
      del(key) {
        return this.rem(key);
      }
      empty() {
        this.length = 0;
        this._level = 1;
        this._map = /* @__PURE__ */ new Map();
        this._head = new Node(32, null, 0);
        this._tail = null;
        for (let i = 0; i < 32; i += 1) {
          this._head.next[i] = new Level(null, 0);
        }
      }
      get(key) {
        return this.score(key);
      }
      has(key) {
        return this._map.has(key);
      }
      incrBy(increment, key) {
        let score = this.score(key);
        if (score) {
          this.add(key, score + increment);
          return score + increment;
        }
        this.add(key, increment);
        return increment;
      }
      intersect() {
        let maps = slice.call(arguments);
        maps.unshift(this);
        return intersect.call(this, maps);
      }
      intersectKeys() {
        let maps = slice.call(arguments);
        maps.unshift(this);
        return intersectKeys.call(this, maps);
      }
      keys() {
        if (!this.length) {
          return [];
        }
        let i;
        let array = new Array(this.length);
        let node = this._head.next[0].next;
        for (i = 0; node; node = node.next[0].next) {
          array[i] = node.key;
          i += 1;
        }
        return array;
      }
      range(start, stop, options) {
        if (this.length === 0) {
          return [];
        }
        if (start == null) {
          start = 0;
        } else if (start < 0) {
          start = Math.max(this.length + start, 0);
        }
        if (stop == null) {
          stop = this.length - 1;
        } else if (stop < 0) {
          stop = this.length + stop;
        }
        if (start > stop || start >= this.length) {
          return [];
        }
        if (stop >= this.length) {
          stop = this.length - 1;
        }
        if (typeof options !== "object") {
          options = {
            withScores: false
          };
        }
        let i = 0;
        let length = stop - start + 1;
        let result;
        try {
          result = new Array(length);
        } catch (e) {
          console.log("start", start);
          console.log("stop", stop);
          console.log("Invalid length", length);
          throw e;
        }
        let node = start > 0 ? this._get(start) : this._head.next[0].next;
        if (options.withScores) {
          for (; length--; node = node.next[0].next) {
            result[i] = [node.key, node.value];
            i += 1;
          }
        } else {
          for (; length--; node = node.next[0].next) {
            result[i] = node.key;
            i += 1;
          }
        }
        return result;
      }
      rangeByScore(min, max, options) {
        if (!this.length) {
          return [];
        }
        if (typeof options !== "object") {
          options = {
            withScores: false
          };
        }
        if (min == null) {
          min = -Infinity;
        }
        if (max == null) {
          max = Infinity;
        }
        if (min <= this._head.next[0].next.value && max >= this._tail.value) {
          return this.toArray({ withScores: options.withScores });
        }
        if (max < min || min > this._tail.value || max < this._head.next[0].next.value) {
          return [];
        }
        let node = this._first(min);
        let result = [];
        if (options.withScores) {
          for (; node && node.value <= max; node = node.next[0].next) {
            result.push([node.key, node.value]);
          }
        } else {
          for (; node && node.value <= max; node = node.next[0].next) {
            result.push(node.key);
          }
        }
        return result;
      }
      rank(key) {
        let value = this._map.get(key);
        if (value === void 0) {
          return null;
        }
        let i;
        let node = this._head;
        let next = null;
        let rank = -1;
        for (i = this._level - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && (next.value < value || next.value === value && next.key <= key)) {
            rank += node.next[i].span;
            node = next;
          }
          if (node.key && node.key === key) {
            return rank;
          }
        }
        return null;
      }
      rem(key) {
        let value = this._map.get(key);
        if (value !== void 0) {
          this._remove(key, value);
          this._map.delete(key);
          return value;
        }
        return null;
      }
      remRangeByRank(start, end) {
        let len = this.length;
        if (!len) {
          return 0;
        }
        if (start == null) {
          start = 0;
        } else if (start < 0) {
          start = Math.max(len + start, 0);
        }
        if (end == null) {
          end = len;
        } else if (end < 0) {
          end = len + end;
        }
        if (start > end || start >= len) {
          return 0;
        }
        if (end > len) {
          end = len;
        }
        if (start === 0 && end === len) {
          this.empty();
          return len;
        }
        let node = this._head;
        let update = new Array(32);
        let result, i, next;
        let traversed = -1;
        for (i = this._level - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && traversed + node.next[i].span < start) {
            traversed += node.next[i].span;
            node = next;
          }
          update[i] = node;
        }
        let removed = 0;
        traversed += 1;
        node = node.next[0].next;
        while (node && traversed < end) {
          next = node.next[0].next;
          this._removeNode(node, update);
          this._map.delete(node.key);
          removed += 1;
          traversed += 1;
          node = next;
        }
        this.length -= removed;
        return removed;
      }
      remRangeByScore(min, max) {
        let result;
        let removed = 0;
        if (!this.length) {
          return 0;
        }
        if (min == null) {
          min = -Infinity;
        }
        if (max == null) {
          max = Infinity;
        }
        if (min <= this._head.next[0].next.value && max >= this._tail.value) {
          removed = this.length;
          this.empty();
          return removed;
        }
        let next, i;
        let node = this._head;
        let update = new Array(32);
        for (i = this._level - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && next.value < min) {
            node = next;
          }
          update[i] = node;
        }
        node = node.next[0].next;
        while (node && node.value <= max) {
          next = node.next[0].next;
          this._removeNode(node, update);
          this._map.delete(node.key);
          removed += 1;
          node = next;
        }
        this.length -= removed;
        return removed;
      }
      score(member) {
        let score = this._map.get(member);
        return score === void 0 ? null : score;
      }
      set(key, value) {
        return this.add(key, value);
      }
      slice(start, end, options) {
        if (typeof end === "number" && end !== 0) {
          end -= 1;
        }
        return this.range(start, end, options);
      }
      toArray(options) {
        if (!this.length) {
          return [];
        }
        if (typeof options !== "object") {
          options = {
            withScores: false
          };
        }
        let i;
        let array = new Array(this.length);
        let node = this._head.next[0].next;
        if (options.withScores) {
          for (i = 0; node; node = node.next[0].next) {
            array[i] = [node.key, node.value];
            i += 1;
          }
        } else {
          for (i = 0; node; node = node.next[0].next) {
            array[i] = node.key;
            i += 1;
          }
        }
        return array;
      }
      values() {
        if (!this.length) {
          return [];
        }
        let i;
        let array = new Array(this.length);
        let node = this._head.next[0].next;
        for (i = 0; node; node = node.next[0].next) {
          array[i] = node.value;
          i += 1;
        }
        return array;
      }
      _first(min) {
        let node = this._tail;
        if (!node || node.value < min) {
          return null;
        }
        node = this._head;
        for (let next = null, i = this._level - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && next.value < min) {
            node = next;
          }
        }
        return node.next[0].next;
      }
      _get(index) {
        let i;
        let node = this._head;
        let distance = -1;
        for (i = this._level - 1; i >= 0; i -= 1) {
          while (node.next[i].next && distance + node.next[i].span <= index) {
            distance += node.next[i].span;
            node = node.next[i].next;
          }
          if (distance === index) {
            return node;
          }
        }
        return null;
      }
      _insert(key, value) {
        let update = new Array(32);
        let rank = new Array(32);
        let node = this._head;
        let next = null;
        let i;
        for (i = this._level - 1; i >= 0; i -= 1) {
          rank[i] = i === this._level - 1 ? 0 : rank[i + 1];
          while ((next = node.next[i].next) && next.value <= value) {
            if (next.value === value) {
              if (this._unique) {
                return null;
              }
              if (next.key >= key) {
                break;
              }
            }
            rank[i] += node.next[i].span;
            node = next;
          }
          if (this._unique && node.value === value) {
            return null;
          }
          update[i] = node;
        }
        if (this._unique && node.value === value) {
          return null;
        }
        let level = randomLevel();
        if (level > this._level) {
          for (i = this._level; i < level; i += 1) {
            rank[i] = 0;
            update[i] = this._head;
            update[i].next[i].span = this.length;
          }
          this._level = level;
        }
        node = new Node(level, key, value);
        for (i = 0; i < level; i += 1) {
          node.next[i] = new Level(update[i].next[i].next, update[i].next[i].span - (rank[0] - rank[i]));
          update[i].next[i].next = node;
          update[i].next[i].span = rank[0] - rank[i] + 1;
        }
        for (i = level; i < this._level; i += 1) {
          update[i].next[i].span++;
        }
        node.prev = update[0] === this._head ? null : update[0];
        if (node.next[0].next) {
          node.next[0].next.prev = node;
        } else {
          this._tail = node;
        }
        this.length += 1;
        return node;
      }
      _next(value, node) {
        let next, i;
        if (!this._tail || this._tail.value < value) {
          return null;
        }
        for (next = null; (next = node.next[node.next.length - 1].next) && next.value < value; ) {
          node = next;
        }
        if (node.value === value) {
          return node;
        }
        for (i = node.next.length - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && next.value < value) {
            node = next;
          }
          if (node.value === value) {
            return node;
          }
        }
        return node.next[0].next;
      }
      _remove(key, value) {
        let update = new Array(32);
        let node = this._head;
        let i, next;
        for (i = this._level - 1; i >= 0; i -= 1) {
          while ((next = node.next[i].next) && (next.value < value || next.value === value && next.key < key)) {
            node = next;
          }
          update[i] = node;
        }
        node = node.next[0].next;
        if (!node || value !== node.value || node.key !== key) {
          return false;
        }
        this._removeNode(node, update);
        this.length -= 1;
      }
      _removeNode(node, update) {
        let next = null;
        let i = 0;
        let n = this._level;
        for (; i < n; i += 1) {
          if (update[i].next[i].next === node) {
            update[i].next[i].span += node.next[i].span - 1;
            update[i].next[i].next = node.next[i].next;
          } else {
            update[i].next[i].span -= 1;
          }
        }
        if (next = node.next[0].next) {
          next.prev = node.prev;
        } else {
          this._tail = node.prev;
        }
        while (this._level > 1 && !this._head.next[this._level - 1].next) {
          this._level -= 1;
        }
      }
    };
    function randomLevel() {
      let level = 1;
      while (Math.random() < P) {
        level += 1;
      }
      return level < 32 ? level : 32;
    }
    function Level(next, span) {
      this.next = next;
      this.span = span;
    }
    function Node(level, key, value) {
      this.key = key;
      this.value = value;
      this.next = new Array(level);
      this.prev = null;
    }
    module2.exports = SortedSet;
  }
});

// ../../packages/dd-trace/src/spanleak.js
var require_spanleak = __commonJS({
  "../../packages/dd-trace/src/spanleak.js"(exports2, module2) {
    "use strict";
    var SortedSet = require_set();
    var INTERVAL = 1e3;
    var LIFETIME = 60 * 1e3;
    var MODES = {
      DISABLED: 0,
      // METRICS_ONLY
      LOG: 1,
      GC_AND_LOG: 2
      // GC
    };
    module2.exports.MODES = MODES;
    var spans = new SortedSet();
    var interval;
    var mode = MODES.DISABLED;
    module2.exports.disable = function() {
      mode = MODES.DISABLED;
    };
    module2.exports.enableLogging = function() {
      mode = MODES.LOG;
    };
    module2.exports.enableGarbageCollection = function() {
      mode = MODES.GC_AND_LOG;
    };
    module2.exports.startScrubber = function() {
      if (!isEnabled()) return;
      interval = setInterval(() => {
        const now = Date.now();
        const expired = spans.rangeByScore(0, now);
        if (!expired.length) return;
        const gc = isGarbageCollecting();
        const expirationsByType = /* @__PURE__ */ Object.create(null);
        for (const wrapped of expired) {
          spans.del(wrapped);
          const span = wrapped.deref();
          if (!span) continue;
          if (!expirationsByType[span._name]) expirationsByType[span._name] = 0;
          expirationsByType[span._name]++;
          if (!gc) continue;
          span.context()._tags = /* @__PURE__ */ Object.create(null);
        }
        console.log("expired spans:" + Object.keys(expirationsByType).reduce((a, c) => `${a} ${c}: ${expirationsByType[c]}`, ""));
      }, INTERVAL);
    };
    module2.exports.stopScrubber = function() {
      clearInterval(interval);
    };
    module2.exports.addSpan = function(span) {
      if (!isEnabled()) return;
      const now = Date.now();
      const expiration = now + LIFETIME;
      const wrapped = new WeakRef(span);
      spans.add(wrapped, expiration);
    };
    function isEnabled() {
      return mode > MODES.DISABLED;
    }
    function isGarbageCollecting() {
      return mode >= MODES.GC_AND_LOG;
    }
  }
});

// ../../packages/dd-trace/src/opentracing/span.js
var require_span2 = __commonJS({
  "../../packages/dd-trace/src/opentracing/span.js"(exports2, module2) {
    "use strict";
    var { performance: performance2 } = __require("perf_hooks");
    var now = performance2.now.bind(performance2);
    var dateNow = Date.now;
    var SpanContext = require_span_context();
    var id = require_id();
    var tagger = require_tagger();
    var runtimeMetrics = require_runtime_metrics2();
    var log = require_log2();
    var { storage } = require_datadog_core();
    var telemetryMetrics = require_metrics();
    var { channel } = require_dc_polyfill();
    var util = __require("util");
    var { getEnvironmentVariable } = require_config_helper();
    var tracerMetrics = telemetryMetrics.manager.namespace("tracers");
    var DD_TRACE_EXPERIMENTAL_STATE_TRACKING = getEnvironmentVariable("DD_TRACE_EXPERIMENTAL_STATE_TRACKING");
    var DD_TRACE_EXPERIMENTAL_SPAN_COUNTS = getEnvironmentVariable("DD_TRACE_EXPERIMENTAL_SPAN_COUNTS");
    var unfinishedRegistry = createRegistry("unfinished");
    var finishedRegistry = createRegistry("finished");
    var OTEL_ENABLED = !!getEnvironmentVariable("DD_TRACE_OTEL_ENABLED");
    var ALLOWED = /* @__PURE__ */ new Set(["string", "number", "boolean"]);
    var integrationCounters = {
      spans_created: {},
      spans_finished: {}
    };
    var startCh = channel("dd-trace:span:start");
    var finishCh = channel("dd-trace:span:finish");
    function getIntegrationCounter(event, integration) {
      const counters = integrationCounters[event];
      if (integration in counters) {
        return counters[integration];
      }
      const counter = tracerMetrics.count(event, [
        `integration_name:${integration.toLowerCase()}`,
        `otel_enabled:${OTEL_ENABLED}`
      ]);
      integrationCounters[event][integration] = counter;
      return counter;
    }
    var DatadogSpan = class {
      constructor(tracer2, processor, prioritySampler, fields, debug) {
        const operationName = fields.operationName;
        const parent = fields.parent || null;
        const tags = Object.assign({}, fields.tags);
        const hostname = fields.hostname;
        this._parentTracer = tracer2;
        this._debug = debug;
        this._processor = processor;
        this._prioritySampler = prioritySampler;
        this._store = storage("legacy").getHandle();
        this._duration = void 0;
        this._events = [];
        this._name = operationName;
        this._integrationName = fields.integrationName || "opentracing";
        getIntegrationCounter("spans_created", this._integrationName).inc();
        this._spanContext = this._createContext(parent, fields);
        this._spanContext._name = operationName;
        this._spanContext._tags = tags;
        this._spanContext._hostname = hostname;
        this._spanContext._trace.started.push(this);
        this._startTime = fields.startTime || this._getTime();
        this._links = fields.links?.map((link) => ({
          context: link.context._ddContext ?? link.context,
          attributes: this._sanitizeAttributes(link.attributes)
        })) ?? [];
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          runtimeMetrics.increment("runtime.node.spans.unfinished");
          runtimeMetrics.increment("runtime.node.spans.unfinished.by.name", `span_name:${operationName}`);
          runtimeMetrics.increment("runtime.node.spans.open");
          runtimeMetrics.increment("runtime.node.spans.open.by.name", `span_name:${operationName}`);
          unfinishedRegistry.register(this, operationName, this);
        }
        if (tracer2?._config?.spanLeakDebug > 0) {
          require_spanleak().addSpan(this, operationName);
        }
        if (startCh.hasSubscribers) {
          startCh.publish({ span: this, fields });
        }
      }
      [util.inspect.custom]() {
        return {
          ...this,
          _parentTracer: `[${this._parentTracer.constructor.name}]`,
          _prioritySampler: `[${this._prioritySampler.constructor.name}]`,
          _processor: `[${this._processor.constructor.name}]`
        };
      }
      toString() {
        const spanContext = this.context();
        const resourceName = spanContext._tags["resource.name"] || "";
        const resource = resourceName.length > 100 ? `${resourceName.slice(0, 97)}...` : resourceName;
        const json = JSON.stringify({
          traceId: spanContext._traceId,
          spanId: spanContext._spanId,
          parentId: spanContext._parentId,
          service: spanContext._tags["service.name"],
          name: spanContext._name,
          resource
        });
        return `Span${json}`;
      }
      /**
       * @returns {import('../priority_sampler').DatadogSpanContext}
       */
      context() {
        return this._spanContext;
      }
      tracer() {
        return this._parentTracer;
      }
      setOperationName(name) {
        this._spanContext._name = name;
        return this;
      }
      setBaggageItem(key, value) {
        this._spanContext._baggageItems[key] = value;
        return this;
      }
      getBaggageItem(key) {
        return this._spanContext._baggageItems[key];
      }
      getAllBaggageItems() {
        return JSON.stringify(this._spanContext._baggageItems);
      }
      removeBaggageItem(key) {
        delete this._spanContext._baggageItems[key];
      }
      removeAllBaggageItems() {
        this._spanContext._baggageItems = {};
      }
      setTag(key, value) {
        this._addTags({ [key]: value });
        return this;
      }
      addTags(keyValueMap) {
        this._addTags(keyValueMap);
        return this;
      }
      log() {
        return this;
      }
      logEvent() {
      }
      addLink(link, attrs) {
        if (link instanceof SpanContext) {
          link = { context: link, attributes: attrs ?? {} };
        }
        const { context: context2, attributes } = link;
        this._links.push({
          context: context2._ddContext ?? context2,
          attributes: this._sanitizeAttributes(attributes)
        });
      }
      addLinks(links) {
        links.forEach((link) => this.addLink(link));
        return this;
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        const zeroContext = new SpanContext({
          traceId: id("0"),
          spanId: id("0")
        });
        const attributes = {
          "ptr.kind": ptrKind,
          "ptr.dir": ptrDir,
          "ptr.hash": ptrHash,
          "link.kind": "span-pointer"
        };
        this.addLink({ context: zeroContext, attributes });
      }
      addEvent(name, attributesOrStartTime, startTime) {
        const event = { name };
        if (attributesOrStartTime) {
          if (typeof attributesOrStartTime === "object") {
            event.attributes = this._sanitizeEventAttributes(attributesOrStartTime);
          } else {
            startTime = attributesOrStartTime;
          }
        }
        event.startTime = startTime || this._getTime();
        this._events.push(event);
      }
      finish(finishTime) {
        if (this._duration !== void 0) {
          return;
        }
        if (DD_TRACE_EXPERIMENTAL_STATE_TRACKING === "true" && !this._spanContext._tags["service.name"]) {
          log.error("Finishing invalid span: %s", this);
        }
        getIntegrationCounter("spans_finished", this._integrationName).inc();
        this._spanContext._tags["_dd.integration"] = this._integrationName;
        if (DD_TRACE_EXPERIMENTAL_SPAN_COUNTS && finishedRegistry) {
          runtimeMetrics.decrement("runtime.node.spans.unfinished");
          runtimeMetrics.decrement("runtime.node.spans.unfinished.by.name", `span_name:${this._name}`);
          runtimeMetrics.increment("runtime.node.spans.finished");
          runtimeMetrics.increment("runtime.node.spans.finished.by.name", `span_name:${this._name}`);
          runtimeMetrics.decrement("runtime.node.spans.open");
          runtimeMetrics.decrement("runtime.node.spans.open.by.name", `span_name:${this._name}`);
          unfinishedRegistry.unregister(this);
          finishedRegistry.register(this, this._name);
        }
        finishTime = Number.parseFloat(finishTime) || this._getTime();
        this._duration = finishTime - this._startTime;
        this._spanContext._trace.finished.push(this);
        this._spanContext._isFinished = true;
        finishCh.publish(this);
        this._processor.process(this);
      }
      _sanitizeAttributes(attributes = {}) {
        const sanitizedAttributes = {};
        const addArrayOrScalarAttributes = (key, maybeArray) => {
          if (Array.isArray(maybeArray)) {
            for (const subkey in maybeArray) {
              addArrayOrScalarAttributes(`${key}.${subkey}`, maybeArray[subkey]);
            }
          } else {
            const maybeScalar = maybeArray;
            if (ALLOWED.has(typeof maybeScalar)) {
              sanitizedAttributes[key] = typeof maybeScalar === "string" ? maybeScalar : String(maybeScalar);
            } else {
              log.warn("Dropping span link attribute. It is not of an allowed type");
            }
          }
        };
        Object.entries(attributes).forEach((entry) => {
          const [key, value] = entry;
          addArrayOrScalarAttributes(key, value);
        });
        return sanitizedAttributes;
      }
      _sanitizeEventAttributes(attributes = {}) {
        const sanitizedAttributes = {};
        for (const key in attributes) {
          const value = attributes[key];
          if (Array.isArray(value)) {
            const newArray = [];
            for (const subkey in value) {
              if (ALLOWED.has(typeof value[subkey])) {
                newArray.push(value[subkey]);
              } else {
                log.warn("Dropping span event attribute. It is not of an allowed type");
              }
            }
            sanitizedAttributes[key] = newArray;
          } else if (ALLOWED.has(typeof value)) {
            sanitizedAttributes[key] = value;
          } else {
            log.warn("Dropping span event attribute. It is not of an allowed type");
          }
        }
        return sanitizedAttributes;
      }
      _createContext(parent, fields) {
        let spanContext;
        let startTime;
        let baggage = {};
        if (parent && parent._isRemote && this._parentTracer?._config?.tracePropagationBehaviorExtract !== "continue") {
          baggage = parent._baggageItems;
          parent = null;
        }
        if (fields.context) {
          spanContext = fields.context;
          if (!spanContext._trace.startTime) {
            startTime = dateNow();
          }
        } else if (parent) {
          spanContext = new SpanContext({
            traceId: parent._traceId,
            spanId: id(),
            parentId: parent._spanId,
            sampling: parent._sampling,
            baggageItems: { ...parent._baggageItems },
            trace: parent._trace,
            tracestate: parent._tracestate
          });
          if (!spanContext._trace.startTime) {
            startTime = dateNow();
          }
        } else {
          const spanId = id();
          startTime = dateNow();
          spanContext = new SpanContext({
            traceId: spanId,
            spanId
          });
          spanContext._trace.startTime = startTime;
          if (fields.traceId128BitGenerationEnabled) {
            spanContext._trace.tags["_dd.p.tid"] = Math.floor(startTime / 1e3).toString(16).padStart(8, "0").padEnd(16, "0");
          }
          if (this._parentTracer?._config?.tracePropagationBehaviorExtract === "restart") {
            spanContext._baggageItems = baggage;
          }
        }
        spanContext._trace.ticks = spanContext._trace.ticks || now();
        if (startTime) {
          spanContext._trace.startTime = startTime;
        }
        spanContext._isRemote = false;
        return spanContext;
      }
      _getTime() {
        const { startTime, ticks } = this._spanContext._trace;
        return startTime + now() - ticks;
      }
      _addTags(keyValuePairs) {
        tagger.add(this._spanContext._tags, keyValuePairs);
        this._prioritySampler.sample(this, false);
      }
    };
    function createRegistry(type) {
      return new global.FinalizationRegistry((name) => {
        runtimeMetrics.decrement(`runtime.node.spans.${type}`);
        runtimeMetrics.decrement(`runtime.node.spans.${type}.by.name`, [`span_name:${name}`]);
      });
    }
    module2.exports = DatadogSpan;
  }
});

// ../../ext/tags.js
var require_tags = __commonJS({
  "../../ext/tags.js"(exports2, module2) {
    "use strict";
    var tags = {
      // Common
      SERVICE_NAME: "service.name",
      RESOURCE_NAME: "resource.name",
      SPAN_TYPE: "span.type",
      SPAN_KIND: "span.kind",
      SAMPLING_PRIORITY: "sampling.priority",
      ANALYTICS: "_dd1.sr.eausr",
      ERROR: "error",
      MANUAL_KEEP: "manual.keep",
      MANUAL_DROP: "manual.drop",
      MEASURED: "_dd.measured",
      BASE_SERVICE: "_dd.base_service",
      DD_PARENT_ID: "_dd.parent_id",
      // HTTP
      HTTP_URL: "http.url",
      HTTP_METHOD: "http.method",
      HTTP_STATUS_CODE: "http.status_code",
      HTTP_ROUTE: "http.route",
      HTTP_REQUEST_HEADERS: "http.request.headers",
      HTTP_RESPONSE_HEADERS: "http.response.headers",
      HTTP_USERAGENT: "http.useragent",
      HTTP_CLIENT_IP: "http.client_ip",
      // Messaging
      // DSM Specific
      PATHWAY_HASH: "pathway.hash"
    };
    tags.ANALYTICS_SAMPLE_RATE = tags.ANALYTICS;
    module2.exports = tags;
  }
});

// ../../ext/kinds.js
var require_kinds = __commonJS({
  "../../ext/kinds.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SERVER: "server",
      CLIENT: "client",
      PRODUCER: "producer",
      CONSUMER: "consumer",
      INTERNAL: "internal"
    };
  }
});

// ../../packages/dd-trace/src/opentelemetry/span.js
var require_span3 = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/span.js"(exports2, module2) {
    "use strict";
    var api = (init_esm(), __toCommonJS(esm_exports));
    var { performance: performance2 } = __require("perf_hooks");
    var { timeOrigin } = performance2;
    var { timeInputToHrTime } = require_src();
    var tracer2 = require_dd_trace();
    var DatadogSpan = require_span2();
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK, IGNORE_OTEL_ERROR } = require_constants3();
    var { SERVICE_NAME, RESOURCE_NAME } = require_tags();
    var kinds = require_kinds();
    var SpanContext = require_span_context3();
    var id = require_id();
    function hrTimeToMilliseconds(time) {
      return time[0] * 1e3 + time[1] / 1e6;
    }
    function isTimeInput(startTime) {
      if (typeof startTime === "number") {
        return true;
      }
      if (startTime instanceof Date) {
        return true;
      }
      if (Array.isArray(startTime) && startTime.length === 2 && typeof startTime[0] === "number" && typeof startTime[1] === "number") {
        return true;
      }
      return false;
    }
    var spanKindNames = {
      [api.SpanKind.INTERNAL]: kinds.INTERNAL,
      [api.SpanKind.SERVER]: kinds.SERVER,
      [api.SpanKind.CLIENT]: kinds.CLIENT,
      [api.SpanKind.PRODUCER]: kinds.PRODUCER,
      [api.SpanKind.CONSUMER]: kinds.CONSUMER
    };
    function spanNameMapper(spanName, kind, attributes) {
      if (spanName) return spanName;
      const opName = attributes["operation.name"];
      if (opName) return opName;
      const { INTERNAL, SERVER, CLIENT } = api.SpanKind;
      for (const key of ["http.method", "http.request.method"]) {
        if (key in attributes) {
          if (kind === SERVER) {
            return "http.server.request";
          }
          if (kind === CLIENT) {
            return "http.client.request";
          }
        }
      }
      const dbSystem = attributes["db.system"];
      if (dbSystem && kind === CLIENT) {
        return `${dbSystem}.query`;
      }
      const msgSys = attributes["messaging.system"];
      const msgOp = attributes["messaging.operation"];
      if (msgSys && msgOp && kind !== INTERNAL) {
        return `${msgSys}.${msgOp}`;
      }
      const rpcSystem = attributes["rpc.system"];
      if (rpcSystem) {
        if (kind === CLIENT) {
          return rpcSystem === "aws-api" ? `aws.${attributes["rpc.service"] || "client"}.request` : `${rpcSystem}.client.request`;
        }
        if (kind === SERVER) {
          return `${rpcSystem}.server.request`;
        }
      }
      const faasProvider = attributes["faas.invoked_provider"];
      const faasName = attributes["faas.invoked_name"];
      const faasTrigger = attributes["faas.trigger"];
      if (kind === CLIENT && faasProvider && faasName) {
        return `${faasProvider}.${faasName}.invoke`;
      }
      if (kind === SERVER && faasTrigger) {
        return `${faasTrigger}.invoke`;
      }
      const isGraphQL = "graphql.operation.type" in attributes;
      if (isGraphQL) return "graphql.server.request";
      const protocol = attributes["network.protocol.name"];
      const protocolPrefix = protocol ? `${protocol}.` : "";
      if (kind === SERVER) return `${protocolPrefix}server.request`;
      if (kind === CLIENT) return `${protocolPrefix}client.request`;
      return spanKindNames[kind];
    }
    var Span = class {
      constructor(parentTracer, context2, spanName, spanContext, kind, links = [], timeInput, attributes) {
        const { _tracer } = tracer2;
        const hrStartTime = timeInputToHrTime(timeInput || performance2.now() + timeOrigin);
        const startTime = hrTimeToMilliseconds(hrStartTime);
        this._ddSpan = new DatadogSpan(_tracer, _tracer._processor, _tracer._prioritySampler, {
          operationName: spanNameMapper(spanName, kind, attributes),
          context: spanContext._ddContext,
          startTime,
          hostname: _tracer._hostname,
          integrationName: parentTracer?._isOtelLibrary ? "otel.library" : "otel",
          tags: {
            [SERVICE_NAME]: _tracer._service,
            [RESOURCE_NAME]: spanName
          },
          links
        }, _tracer._debug);
        if (attributes) {
          this.setAttributes(attributes);
        }
        this._parentTracer = parentTracer;
        this._context = context2;
        this._hasStatus = false;
        this.startTime = hrStartTime;
        this.kind = kind;
        this._spanProcessor.onStart(this, context2);
      }
      get parentSpanId() {
        const { _parentId } = this._ddSpan.context();
        return _parentId && _parentId.toString(16);
      }
      // Expected by OTel
      get resource() {
        return this._parentTracer.resource;
      }
      get instrumentationLibrary() {
        return this._parentTracer.instrumentationLibrary;
      }
      get _spanProcessor() {
        return this._parentTracer.getActiveSpanProcessor();
      }
      get name() {
        return this._ddSpan.context()._name;
      }
      spanContext() {
        return new SpanContext(this._ddSpan.context());
      }
      setAttribute(key, value) {
        if (key === "http.response.status_code") {
          this._ddSpan.setTag("http.status_code", value.toString());
        }
        this._ddSpan.setTag(key, value);
        return this;
      }
      setAttributes(attributes) {
        if ("http.response.status_code" in attributes) {
          attributes["http.status_code"] = attributes["http.response.status_code"].toString();
        }
        this._ddSpan.addTags(attributes);
        return this;
      }
      addLink(link, attrs) {
        if (link instanceof SpanContext) {
          link = { context: link, attributes: attrs ?? {} };
        }
        const { context: context2, attributes } = link;
        const ddSpanContext = context2._ddContext;
        this._ddSpan.addLink({ context: ddSpanContext, attributes });
        return this;
      }
      addLinks(links) {
        links.forEach((link) => this.addLink(link));
        return this;
      }
      addSpanPointer(ptrKind, ptrDir, ptrHash) {
        const zeroContext = new SpanContext({
          traceId: id("0"),
          spanId: id("0")
        });
        const attributes = {
          "ptr.kind": ptrKind,
          "ptr.dir": ptrDir,
          "ptr.hash": ptrHash,
          "link.kind": "span-pointer"
        };
        return this.addLink(zeroContext, attributes);
      }
      setStatus({ code, message }) {
        if (!this.ended && !this._hasStatus && code) {
          this._hasStatus = true;
          if (code === 2) {
            this._ddSpan.addTags({
              [ERROR_MESSAGE]: message,
              [IGNORE_OTEL_ERROR]: false
            });
          }
        }
        return this;
      }
      updateName(name) {
        if (!this.ended) {
          this._ddSpan.setOperationName(name);
        }
        return this;
      }
      end(timeInput) {
        if (this.ended) {
          api.diag.error("You can only call end() on a span once.");
          return;
        }
        const hrEndTime = timeInputToHrTime(timeInput || performance2.now() + timeOrigin);
        const endTime = hrTimeToMilliseconds(hrEndTime);
        this._ddSpan.finish(endTime);
        this._spanProcessor.onEnd(this);
      }
      isRecording() {
        return this.ended === false;
      }
      addEvent(name, attributesOrStartTime, startTime) {
        startTime = attributesOrStartTime && isTimeInput(attributesOrStartTime) ? attributesOrStartTime : startTime;
        const hrStartTime = timeInputToHrTime(startTime || performance2.now() + timeOrigin);
        startTime = hrTimeToMilliseconds(hrStartTime);
        this._ddSpan.addEvent(name, attributesOrStartTime, startTime);
        return this;
      }
      recordException(exception, timeInput) {
        this._ddSpan.addTags({
          [ERROR_TYPE]: exception.name,
          [ERROR_MESSAGE]: exception.message,
          [ERROR_STACK]: exception.stack,
          [IGNORE_OTEL_ERROR]: this._ddSpan.context()._tags[IGNORE_OTEL_ERROR] ?? true
        });
        const attributes = {};
        if (exception.message) attributes["exception.message"] = exception.message;
        if (exception.type) attributes["exception.type"] = exception.type;
        if (exception.escaped) attributes["exception.escaped"] = exception.escaped;
        if (exception.stack) attributes["exception.stacktrace"] = exception.stack;
        this.addEvent(exception.name, attributes, timeInput);
      }
      get duration() {
        return this._ddSpan._duration;
      }
      get ended() {
        return this.duration !== void 0;
      }
    };
    module2.exports = Span;
  }
});

// ../../packages/datadog-core/src/utils/src/pick.js
var require_pick = __commonJS({
  "../../packages/datadog-core/src/utils/src/pick.js"(exports2, module2) {
    "use strict";
    module2.exports = function pick(object, props) {
      const result = {};
      props.forEach((prop) => {
        if (Object.hasOwn(object, prop)) {
          result[prop] = object[prop];
        }
      });
      return result;
    };
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/tracestate.js
var require_tracestate = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/tracestate.js"(exports2, module2) {
    "use strict";
    var traceStateRegex = /[ \t]*([^=]+)=([ \t]*[^, \t]+)[ \t]*(,|$)/gim;
    var traceStateDataRegex = /([^:]+):([^;]+)(;|$)/gim;
    function fromString(Type, regex, value) {
      if (typeof value !== "string" || !value.length) {
        return new Type();
      }
      const values = [];
      for (const row of value.matchAll(regex)) {
        values.unshift(row.slice(1, 3));
      }
      return new Type(values);
    }
    function toString2(map, pairSeparator, fieldSeparator) {
      let result = "";
      for (const [key, value] of map) {
        if (result) {
          result = `${fieldSeparator}${result}`;
        }
        result = `${key}${pairSeparator}${value}${result}`;
      }
      return result;
    }
    var TraceStateData = class _TraceStateData extends Map {
      constructor(...args) {
        super(...args);
        this.changed = false;
      }
      set(...args) {
        if (this.has(args[0]) && this.get(args[0]) === args[1]) {
          return;
        }
        this.changed = true;
        return super.set(...args);
      }
      delete(...args) {
        this.changed = true;
        return super.delete(...args);
      }
      clear(...args) {
        this.changed = true;
        return super.clear(...args);
      }
      static fromString(value) {
        return fromString(_TraceStateData, traceStateDataRegex, value);
      }
      toString() {
        return toString2(this, ":", ";");
      }
    };
    var TraceState = class _TraceState extends Map {
      // Delete entries on update to ensure they're moved to the end of the list
      set(key, value) {
        if (this.has(key)) {
          this.delete(key);
        }
        return super.set(key, value);
      }
      forVendor(vendor, handle) {
        const data = super.get(vendor);
        const state = TraceStateData.fromString(data);
        const result = handle(state);
        if (state.changed) {
          const value = state.toString();
          if (value) {
            this.set(vendor, state.toString());
          } else {
            this.delete(vendor);
          }
        }
        return result;
      }
      static fromString(value) {
        return fromString(_TraceState, traceStateRegex, value);
      }
      toString() {
        return toString2(this, "=", ",");
      }
    };
    module2.exports = TraceState;
  }
});

// ../../packages/dd-trace/src/baggage.js
var require_baggage = __commonJS({
  "../../packages/dd-trace/src/baggage.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var baggageStorage = storage("baggage");
    function setBaggageItem(key, value) {
      storage("baggage").enterWith({ ...baggageStorage.getStore(), [key]: value });
      return storage("baggage").getStore();
    }
    function getBaggageItem(key) {
      return storage("baggage").getStore()?.[key];
    }
    function getAllBaggageItems() {
      return storage("baggage").getStore() ?? {};
    }
    function removeBaggageItem(keyToRemove) {
      const { [keyToRemove]: _2, ...newBaggage } = storage("baggage").getStore();
      storage("baggage").enterWith(newBaggage);
      return newBaggage;
    }
    function removeAllBaggageItems() {
      storage("baggage").enterWith();
      return storage("baggage").getStore();
    }
    module2.exports = {
      setBaggageItem,
      getBaggageItem,
      getAllBaggageItems,
      removeBaggageItem,
      removeAllBaggageItems
    };
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/text_map.js
var require_text_map = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/text_map.js"(exports2, module2) {
    "use strict";
    var pick = require_pick();
    var id = require_id();
    var DatadogSpanContext = require_span_context();
    var log = require_log2();
    var TraceState = require_tracestate();
    var tags = require_tags();
    var { channel } = require_dc_polyfill();
    var { setBaggageItem, getAllBaggageItems, removeAllBaggageItems } = require_baggage();
    var telemetryMetrics = require_metrics();
    var { AUTO_KEEP, AUTO_REJECT, USER_KEEP } = require_priority();
    var tracerMetrics = telemetryMetrics.manager.namespace("tracers");
    var injectCh = channel("dd-trace:span:inject");
    var extractCh = channel("dd-trace:span:extract");
    var traceKey = "x-datadog-trace-id";
    var spanKey = "x-datadog-parent-id";
    var originKey = "x-datadog-origin";
    var samplingKey = "x-datadog-sampling-priority";
    var tagsKey = "x-datadog-tags";
    var baggagePrefix = "ot-baggage-";
    var b3TraceKey = "x-b3-traceid";
    var b3TraceExpr = /^([0-9a-f]{16}){1,2}$/i;
    var b3SpanKey = "x-b3-spanid";
    var b3SpanExpr = /^[0-9a-f]{16}$/i;
    var b3ParentKey = "x-b3-parentspanid";
    var b3SampledKey = "x-b3-sampled";
    var b3FlagsKey = "x-b3-flags";
    var b3HeaderKey = "b3";
    var sqsdHeaderHey = "x-aws-sqsd-attr-_datadog";
    var b3HeaderExpr = /^(([0-9a-f]{16}){1,2}-[0-9a-f]{16}(-[01d](-[0-9a-f]{16})?)?|[01d])$/i;
    var baggageExpr = new RegExp(`^${baggagePrefix}(.+)$`);
    var tagKeyExpr = /^_dd\.p\.[\x21-\x2B\x2D-\x7E]+$/;
    var tagValueExpr = /^[\x20-\x2B\x2D-\x7E]*$/;
    var traceparentExpr = /^([a-f0-9]{2})-([a-f0-9]{32})-([a-f0-9]{16})-([a-f0-9]{2})(-.*)?$/i;
    var traceparentKey = "traceparent";
    var tracestateKey = "tracestate";
    var ddKeys = [traceKey, spanKey, samplingKey, originKey];
    var b3Keys = [b3TraceKey, b3SpanKey, b3ParentKey, b3SampledKey, b3FlagsKey, b3HeaderKey];
    var w3cKeys = [traceparentKey, tracestateKey];
    var logKeys = [...ddKeys, ...b3Keys, ...w3cKeys];
    var tracestateOriginFilter = /[^\x20-\x2B\x2D-\x3A\x3C-\x7D]/g;
    var tracestateTagKeyFilter = /[^\x21-\x2B\x2D-\x3C\x3E-\x7E]/g;
    var tracestateTagValueFilter = /[^\x20-\x2B\x2D-\x3A\x3C-\x7D]/g;
    var invalidSegment = /^0+$/;
    var zeroTraceId = "0000000000000000";
    var hex16 = /^[0-9A-Fa-f]{16}$/;
    var TextMapPropagator = class {
      constructor(config) {
        this._config = config;
      }
      inject(spanContext, carrier) {
        if (!carrier) return;
        this._injectBaggageItems(spanContext, carrier);
        if (!spanContext) return;
        this._injectDatadog(spanContext, carrier);
        this._injectB3MultipleHeaders(spanContext, carrier);
        this._injectB3SingleHeader(spanContext, carrier);
        this._injectTraceparent(spanContext, carrier);
        if (injectCh.hasSubscribers) {
          injectCh.publish({ spanContext, carrier });
        }
        log.debug(() => `Inject into carrier: ${JSON.stringify(pick(carrier, logKeys))}.`);
      }
      extract(carrier) {
        const spanContext = this._extractSpanContext(carrier);
        if (!spanContext) return spanContext;
        if (extractCh.hasSubscribers) {
          extractCh.publish({ spanContext, carrier });
        }
        log.debug(() => {
          const keys = JSON.stringify(pick(carrier, logKeys));
          const styles = this._config.tracePropagationStyle.extract.join(", ");
          return `Extract from carrier (${styles}): ${keys}.`;
        });
        return spanContext;
      }
      _injectDatadog(spanContext, carrier) {
        if (!this._hasPropagationStyle("inject", "datadog")) return;
        carrier[traceKey] = spanContext.toTraceId();
        carrier[spanKey] = spanContext.toSpanId();
        this._injectOrigin(spanContext, carrier);
        this._injectSamplingPriority(spanContext, carrier);
        this._injectTags(spanContext, carrier);
      }
      _injectOrigin(spanContext, carrier) {
        const origin = spanContext._trace.origin;
        if (origin) {
          carrier[originKey] = origin;
        }
      }
      _injectSamplingPriority(spanContext, carrier) {
        const priority = spanContext._sampling.priority;
        if (Number.isInteger(priority)) {
          carrier[samplingKey] = priority.toString();
        }
      }
      _encodeOtelBaggageKey(key) {
        let encoded = encodeURIComponent(key);
        encoded = encoded.replaceAll("(", "%28");
        encoded = encoded.replaceAll(")", "%29");
        return encoded;
      }
      _injectBaggageItems(spanContext, carrier) {
        if (this._config.legacyBaggageEnabled) {
          spanContext?._baggageItems && Object.keys(spanContext._baggageItems).forEach((key) => {
            carrier[baggagePrefix + key] = String(spanContext._baggageItems[key]);
          });
        }
        if (this._hasPropagationStyle("inject", "baggage")) {
          let baggage = "";
          let itemCounter = 0;
          let byteCounter = 0;
          const baggageItems = getAllBaggageItems();
          if (!baggageItems) return;
          for (const [key, value] of Object.entries(baggageItems)) {
            const item = `${this._encodeOtelBaggageKey(String(key).trim())}=${encodeURIComponent(String(value).trim())},`;
            itemCounter += 1;
            byteCounter += Buffer.byteLength(item);
            if (itemCounter > this._config.baggageMaxItems) {
              tracerMetrics.count("context_header.truncated", ["truncation_reason:baggage_item_count_exceeded"]).inc();
              break;
            }
            if (byteCounter > this._config.baggageMaxBytes) {
              tracerMetrics.count("context_header.truncated", ["truncation_reason:baggage_byte_count_exceeded"]).inc();
              break;
            }
            baggage += item;
          }
          baggage = baggage.slice(0, -1);
          if (baggage) {
            carrier.baggage = baggage;
            tracerMetrics.count("context_header_style.injected", ["header_style:baggage"]).inc();
          }
        }
      }
      _injectTags(spanContext, carrier) {
        const trace2 = spanContext._trace;
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug("Trace tag propagation is disabled, skipping injection.");
          return;
        }
        const tags2 = [];
        for (const key in trace2.tags) {
          if (!trace2.tags[key] || !key.startsWith("_dd.p.")) continue;
          if (!this._validateTagKey(key) || !this._validateTagValue(trace2.tags[key])) {
            log.error("Trace tags from span are invalid, skipping injection.");
            return;
          }
          tags2.push(`${key}=${trace2.tags[key]}`);
        }
        const header = tags2.join(",");
        if (header.length > this._config.tagsHeaderMaxLength) {
          log.error("Trace tags from span are too large, skipping injection.");
        } else if (header) {
          carrier[tagsKey] = header;
        }
      }
      _injectB3MultipleHeaders(spanContext, carrier) {
        const hasB3 = this._hasPropagationStyle("inject", "b3");
        const hasB3multi = this._hasPropagationStyle("inject", "b3multi");
        if (!(hasB3 || hasB3multi)) return;
        carrier[b3TraceKey] = this._getB3TraceId(spanContext);
        carrier[b3SpanKey] = spanContext._spanId.toString(16);
        carrier[b3SampledKey] = spanContext._sampling.priority >= AUTO_KEEP ? "1" : "0";
        if (spanContext._sampling.priority > AUTO_KEEP) {
          carrier[b3FlagsKey] = "1";
        }
        if (spanContext._parentId) {
          carrier[b3ParentKey] = spanContext._parentId.toString(16);
        }
      }
      _injectB3SingleHeader(spanContext, carrier) {
        const hasB3SingleHeader = this._hasPropagationStyle("inject", "b3 single header");
        if (!hasB3SingleHeader) return null;
        const traceId = this._getB3TraceId(spanContext);
        const spanId = spanContext._spanId.toString(16);
        const sampled = spanContext._sampling.priority >= AUTO_KEEP ? "1" : "0";
        carrier[b3HeaderKey] = `${traceId}-${spanId}-${sampled}`;
        if (spanContext._parentId) {
          carrier[b3HeaderKey] += "-" + spanContext._parentId.toString(16);
        }
      }
      _injectTraceparent(spanContext, carrier) {
        if (!this._hasPropagationStyle("inject", "tracecontext")) return;
        const {
          _sampling: { priority, mechanism },
          _tracestate: ts = new TraceState(),
          _trace: { origin, tags: tags2 }
        } = spanContext;
        carrier[traceparentKey] = spanContext.toTraceparent();
        ts.forVendor("dd", (state) => {
          if (!spanContext._isRemote) {
            state.set("p", spanContext._spanId);
          } else if (spanContext._trace.tags[tags2.DD_PARENT_ID]) {
            state.set("p", spanContext._trace.tags[tags2.DD_PARENT_ID]);
          }
          state.set("s", priority);
          if (mechanism) {
            state.set("t.dm", `-${mechanism}`);
          }
          if (typeof origin === "string") {
            const originValue = origin.replaceAll(tracestateOriginFilter, "_").replaceAll(/[\x3D]/g, "~");
            state.set("o", originValue);
          }
          for (const key in tags2) {
            if (!tags2[key] || !key.startsWith("_dd.p.")) continue;
            const tagKey = "t." + key.slice(6).replaceAll(tracestateTagKeyFilter, "_");
            const tagValue = tags2[key].toString().replaceAll(tracestateTagValueFilter, "_").replaceAll(/[\x3D]/g, "~");
            state.set(tagKey, tagValue);
          }
        });
        carrier.tracestate = ts.toString();
      }
      _hasPropagationStyle(mode, name) {
        return this._config.tracePropagationStyle[mode].includes(name);
      }
      _hasTraceIdConflict(w3cSpanContext, firstSpanContext) {
        return w3cSpanContext !== null && firstSpanContext.toTraceId(true) === w3cSpanContext.toTraceId(true) && firstSpanContext.toSpanId() !== w3cSpanContext.toSpanId();
      }
      _hasParentIdInTags(spanContext) {
        return tags.DD_PARENT_ID in spanContext._trace.tags;
      }
      _updateParentIdFromDdHeaders(carrier, firstSpanContext) {
        const ddCtx = this._extractDatadogContext(carrier);
        if (ddCtx !== null) {
          firstSpanContext._trace.tags[tags.DD_PARENT_ID] = ddCtx._spanId.toString().padStart(16, "0");
        }
      }
      _resolveTraceContextConflicts(w3cSpanContext, firstSpanContext, carrier) {
        if (!this._hasTraceIdConflict(w3cSpanContext, firstSpanContext)) {
          return firstSpanContext;
        }
        if (this._hasParentIdInTags(w3cSpanContext)) {
          firstSpanContext._trace.tags[tags.DD_PARENT_ID] = w3cSpanContext._trace.tags[tags.DD_PARENT_ID];
        } else {
          this._updateParentIdFromDdHeaders(carrier, firstSpanContext);
        }
        firstSpanContext._spanId = w3cSpanContext._spanId;
        return firstSpanContext;
      }
      _extractSpanContext(carrier) {
        let context2 = null;
        let style = "";
        for (const extractor of this._config.tracePropagationStyle.extract) {
          let extractedContext = null;
          switch (extractor) {
            case "datadog":
              extractedContext = this._extractDatadogContext(carrier);
              break;
            case "tracecontext":
              extractedContext = this._extractTraceparentContext(carrier);
              break;
            case "b3 single header":
              extractedContext = this._extractB3SingleContext(carrier);
              break;
            case "b3":
              extractedContext = this._config.tracePropagationStyle.otelPropagators ? this._extractB3SingleContext(carrier) : this._extractB3MultiContext(carrier);
              break;
            case "b3multi":
              extractedContext = this._extractB3MultiContext(carrier);
              break;
            default:
              if (extractor !== "baggage") log.warn("Unknown propagation style:", extractor);
          }
          if (extractedContext === null) {
            continue;
          }
          if (context2 === null) {
            context2 = extractedContext;
            style = extractor;
            if (this._config.tracePropagationExtractFirst) {
              break;
            }
          } else {
            if (extractor === "tracecontext") {
              context2 = this._resolveTraceContextConflicts(
                this._extractTraceparentContext(carrier),
                context2,
                carrier
              );
            }
            if (extractedContext._traceId && extractedContext._spanId && extractedContext.toTraceId(true) !== context2.toTraceId(true)) {
              const link = {
                context: extractedContext,
                attributes: { reason: "terminated_context", context_headers: extractor }
              };
              context2._links.push(link);
            }
          }
        }
        if (this._config.tracePropagationBehaviorExtract === "ignore") {
          context2._links = [];
        } else {
          if (this._config.tracePropagationBehaviorExtract === "restart") {
            context2._links = [];
            context2._links.push({
              context: context2,
              attributes: {
                reason: "propagation_behavior_extract",
                context_headers: style
              }
            });
          }
          this._extractBaggageItems(carrier, context2);
        }
        return context2 || this._extractSqsdContext(carrier);
      }
      _extractDatadogContext(carrier) {
        const spanContext = this._extractGenericContext(carrier, traceKey, spanKey, 10);
        if (!spanContext) return spanContext;
        this._extractOrigin(carrier, spanContext);
        this._extractLegacyBaggageItems(carrier, spanContext);
        this._extractSamplingPriority(carrier, spanContext);
        this._extractTags(carrier, spanContext);
        if (this._config.tracePropagationExtractFirst) return spanContext;
        const tc = this._extractTraceparentContext(carrier);
        if (tc && spanContext._traceId.equals(tc._traceId)) {
          spanContext._traceparent = tc._traceparent;
          spanContext._tracestate = tc._tracestate;
        }
        return spanContext;
      }
      _extractB3MultiContext(carrier) {
        const b3 = this._extractB3MultipleHeaders(carrier);
        if (!b3) return null;
        return this._extractB3Context(b3);
      }
      _extractB3SingleContext(carrier) {
        if (!b3HeaderExpr.test(carrier[b3HeaderKey])) return null;
        const b3 = this._extractB3SingleHeader(carrier);
        if (!b3) return null;
        return this._extractB3Context(b3);
      }
      _extractB3Context(b3) {
        const debug = b3[b3FlagsKey] === "1";
        const priority = this._getPriority(b3[b3SampledKey], debug);
        const spanContext = this._extractGenericContext(b3, b3TraceKey, b3SpanKey, 16);
        if (priority !== void 0) {
          if (!spanContext) {
            return new DatadogSpanContext({
              traceId: id(),
              spanId: null,
              sampling: { priority },
              isRemote: true
            });
          }
          spanContext._sampling.priority = priority;
        }
        this._extract128BitTraceId(b3[b3TraceKey], spanContext);
        return spanContext;
      }
      _extractSqsdContext(carrier) {
        const headerValue = carrier[sqsdHeaderHey];
        if (!headerValue) {
          return null;
        }
        let parsed;
        try {
          parsed = JSON.parse(headerValue);
        } catch {
          return null;
        }
        return this._extractDatadogContext(parsed);
      }
      _extractTraceparentContext(carrier) {
        const headerValue = carrier[traceparentKey];
        if (!headerValue) {
          return null;
        }
        const matches = headerValue.trim().match(traceparentExpr);
        if (matches?.length) {
          const [version, traceId, spanId, flags, tail] = matches.slice(1);
          const traceparent = { version };
          const tracestate = TraceState.fromString(carrier.tracestate);
          if (invalidSegment.test(traceId)) return null;
          if (invalidSegment.test(spanId)) return null;
          if (version === "ff") return null;
          if (tail && version === "00") return null;
          const spanContext = new DatadogSpanContext({
            traceId: id(traceId, 16),
            spanId: id(spanId, 16),
            isRemote: true,
            sampling: { priority: Number.parseInt(flags, 10) & 1 ? 1 : 0 },
            traceparent,
            tracestate
          });
          this._extract128BitTraceId(traceId, spanContext);
          tracestate.forVendor("dd", (state) => {
            for (const [key, value] of state.entries()) {
              switch (key) {
                case "p": {
                  spanContext._trace.tags[tags.DD_PARENT_ID] = value;
                  break;
                }
                case "s": {
                  const priority = Number.parseInt(value, 10);
                  if (!Number.isInteger(priority)) continue;
                  if (spanContext._sampling.priority === 1 && priority > 0 || spanContext._sampling.priority === 0 && priority < 0) {
                    spanContext._sampling.priority = priority;
                  }
                  break;
                }
                case "o":
                  spanContext._trace.origin = value;
                  break;
                case "t.dm": {
                  const mechanism = Math.abs(Number.parseInt(value, 10));
                  if (Number.isInteger(mechanism)) {
                    spanContext._sampling.mechanism = mechanism;
                    spanContext._trace.tags["_dd.p.dm"] = `-${mechanism}`;
                  }
                  break;
                }
                default: {
                  if (!key.startsWith("t.")) continue;
                  const subKey = key.slice(2);
                  const transformedValue = value.replaceAll(/[\x7E]/gm, "=");
                  if (subKey === "tid") {
                    if (!hex16.test(value) || spanContext._trace.tags["_dd.p.tid"] !== transformedValue) {
                      log.error("Invalid trace id %s in tracestate, skipping", value);
                    }
                    continue;
                  }
                  spanContext._trace.tags[`_dd.p.${subKey}`] = transformedValue;
                }
              }
            }
          });
          this._extractLegacyBaggageItems(carrier, spanContext);
          return spanContext;
        }
        return null;
      }
      _extractGenericContext(carrier, traceKey2, spanKey2, radix) {
        if (carrier && carrier[traceKey2] && carrier[spanKey2]) {
          if (invalidSegment.test(carrier[traceKey2])) return null;
          return new DatadogSpanContext({
            traceId: id(carrier[traceKey2], radix),
            spanId: id(carrier[spanKey2], radix),
            isRemote: true
          });
        }
        return null;
      }
      _extractB3MultipleHeaders(carrier) {
        let empty = true;
        const b3 = {};
        if (b3TraceExpr.test(carrier[b3TraceKey]) && b3SpanExpr.test(carrier[b3SpanKey])) {
          b3[b3TraceKey] = carrier[b3TraceKey];
          b3[b3SpanKey] = carrier[b3SpanKey];
          empty = false;
        }
        if (carrier[b3SampledKey]) {
          b3[b3SampledKey] = carrier[b3SampledKey];
          empty = false;
        }
        if (carrier[b3FlagsKey]) {
          b3[b3FlagsKey] = carrier[b3FlagsKey];
          empty = false;
        }
        return empty ? null : b3;
      }
      _extractB3SingleHeader(carrier) {
        const header = carrier[b3HeaderKey];
        if (!header) return null;
        const parts = header.split("-");
        if (parts[0] === "d") {
          return {
            [b3SampledKey]: "1",
            [b3FlagsKey]: "1"
          };
        } else if (parts.length === 1) {
          return {
            [b3SampledKey]: parts[0]
          };
        }
        const b3 = {
          [b3TraceKey]: parts[0],
          [b3SpanKey]: parts[1]
        };
        if (parts[2]) {
          b3[b3SampledKey] = parts[2] === "0" ? "0" : "1";
          if (parts[2] === "d") {
            b3[b3FlagsKey] = "1";
          }
        }
        return b3;
      }
      _extractOrigin(carrier, spanContext) {
        const origin = carrier[originKey];
        if (typeof carrier[originKey] === "string") {
          spanContext._trace.origin = origin;
        }
      }
      _decodeOtelBaggageKey(key) {
        let decoded = decodeURIComponent(key);
        decoded = decoded.replaceAll("%28", "(");
        decoded = decoded.replaceAll("%29", ")");
        return decoded;
      }
      _extractLegacyBaggageItems(carrier, spanContext) {
        if (this._config.legacyBaggageEnabled) {
          Object.keys(carrier).forEach((key) => {
            const match = key.match(baggageExpr);
            if (match) {
              spanContext._baggageItems[match[1]] = carrier[key];
            }
          });
        }
      }
      _extractBaggageItems(carrier, spanContext) {
        if (!this._hasPropagationStyle("extract", "baggage")) return;
        if (!carrier || !carrier.baggage) return;
        const baggages = carrier.baggage.split(",");
        const keysToSpanTag = this._config.baggageTagKeys === "*" ? void 0 : new Set(this._config.baggageTagKeys.split(","));
        for (const keyValue of baggages) {
          if (!keyValue.includes("=")) {
            tracerMetrics.count("context_header_style.malformed", ["header_style:baggage"]).inc();
            removeAllBaggageItems();
            return;
          }
          let [key, value] = keyValue.split("=");
          key = this._decodeOtelBaggageKey(key.trim());
          value = decodeURIComponent(value.trim());
          if (!key || !value) {
            tracerMetrics.count("context_header_style.malformed", ["header_style:baggage"]).inc();
            removeAllBaggageItems();
            return;
          }
          if (spanContext && (this._config.baggageTagKeys === "*" || keysToSpanTag.has(key))) {
            spanContext._trace.tags["baggage." + key] = value;
          }
          setBaggageItem(key, value);
        }
        tracerMetrics.count("context_header_style.extracted", ["header_style:baggage"]).inc();
      }
      _extractSamplingPriority(carrier, spanContext) {
        const priority = Number.parseInt(carrier[samplingKey], 10);
        if (Number.isInteger(priority)) {
          spanContext._sampling.priority = priority;
        }
      }
      _extractTags(carrier, spanContext) {
        if (!carrier[tagsKey]) return;
        const trace2 = spanContext._trace;
        if (this._config.tagsHeaderMaxLength === 0) {
          log.debug("Trace tag propagation is disabled, skipping extraction.");
        } else if (carrier[tagsKey].length > this._config.tagsHeaderMaxLength) {
          log.error("Trace tags from carrier are too large, skipping extraction.");
        } else {
          const pairs = carrier[tagsKey].split(",");
          const tags2 = {};
          for (const pair of pairs) {
            const [key, ...rest] = pair.split("=");
            const value = rest.join("=");
            if (!this._validateTagKey(key) || !this._validateTagValue(value)) {
              log.error("Trace tags from carrier are invalid, skipping extraction.");
              return;
            }
            if (key === "_dd.p.tid" && !hex16.test(value)) {
              log.error("Invalid _dd.p.tid tag %s, skipping", value);
              continue;
            }
            tags2[key] = value;
          }
          Object.assign(trace2.tags, tags2);
        }
      }
      _extract128BitTraceId(traceId, spanContext) {
        if (!spanContext) return;
        const buffer = spanContext._traceId.toBuffer();
        if (buffer.length !== 16) return;
        const tid = traceId.slice(0, 16);
        if (tid === zeroTraceId) return;
        spanContext._trace.tags["_dd.p.tid"] = tid;
      }
      _validateTagKey(key) {
        return tagKeyExpr.test(key);
      }
      _validateTagValue(value) {
        return tagValueExpr.test(value);
      }
      _getPriority(sampled, debug) {
        if (debug) {
          return USER_KEEP;
        } else if (sampled === "1") {
          return AUTO_KEEP;
        } else if (sampled === "0") {
          return AUTO_REJECT;
        }
      }
      _getB3TraceId(spanContext) {
        if (spanContext._traceId.toBuffer().length <= 8 && spanContext._trace.tags["_dd.p.tid"]) {
          return spanContext._trace.tags["_dd.p.tid"] + spanContext._traceId.toString(16);
        }
        return spanContext._traceId.toString(16);
      }
      static _getSamplingPriority(traceparentSampled, tracestateSamplingPriority, origin = null) {
        const fromRumWithoutPriority = !tracestateSamplingPriority && origin === "rum";
        let samplingPriority;
        if (!fromRumWithoutPriority && traceparentSampled === 0 && (!tracestateSamplingPriority || tracestateSamplingPriority >= 0)) {
          samplingPriority = 0;
        } else if (!fromRumWithoutPriority && traceparentSampled === 1 && (!tracestateSamplingPriority || tracestateSamplingPriority < 0)) {
          samplingPriority = 1;
        } else {
          samplingPriority = tracestateSamplingPriority;
        }
        return samplingPriority;
      }
    };
    module2.exports = TextMapPropagator;
  }
});

// ../../packages/dd-trace/src/opentelemetry/tracer.js
var require_tracer2 = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/tracer.js"(exports2, module2) {
    "use strict";
    var api = (init_esm(), __toCommonJS(esm_exports));
    var { sanitizeAttributes } = require_src();
    var Sampler = require_sampler();
    var Span = require_span3();
    var id = require_id();
    var log = require_log2();
    var SpanContext = require_span_context3();
    var TextMapPropagator = require_text_map();
    var TraceState = require_tracestate();
    var Tracer = class {
      constructor(library, config, tracerProvider) {
        this._sampler = new Sampler();
        this._config = config;
        this._tracerProvider = tracerProvider;
        this.instrumentationLibrary = library;
        this._isOtelLibrary = library?.name?.startsWith("@opentelemetry/instrumentation-");
        this._spanLimits = {};
      }
      get resource() {
        return this._tracerProvider.resource;
      }
      _createSpanContextFromParent(parentSpanContext) {
        return new SpanContext({
          traceId: parentSpanContext._traceId,
          spanId: id(),
          parentId: parentSpanContext._spanId,
          sampling: parentSpanContext._sampling,
          baggageItems: { ...parentSpanContext._baggageItems },
          trace: parentSpanContext._trace,
          tracestate: parentSpanContext._tracestate
        });
      }
      // Extracted method to create span context for a new span
      _createSpanContextForNewSpan(context2) {
        const { traceId, spanId, traceFlags, traceState } = context2;
        return this._convertOtelContextToDatadog(traceId, spanId, traceFlags, traceState);
      }
      _convertOtelContextToDatadog(traceId, spanId, traceFlag, ts, meta = {}) {
        const origin = null;
        let samplingPriority = traceFlag;
        ts = ts?.traceparent || null;
        if (ts) {
          const traceState = TraceState.fromString(ts);
          let ddTraceStateData = null;
          traceState.forVendor("dd", (state) => {
            ddTraceStateData = state;
            return state;
          });
          if (ddTraceStateData) {
            const samplingPriorityTs = ddTraceStateData.get("s");
            const origin2 = ddTraceStateData.get("o");
            const otherPropagatedTags = Object.fromEntries(ddTraceStateData.entries());
            Object.assign(meta, otherPropagatedTags);
            samplingPriority = TextMapPropagator._getSamplingPriority(
              traceFlag,
              Number.parseInt(samplingPriorityTs, 10),
              origin2
            );
          } else {
            log.debug("no dd list member in tracestate from incoming request:", ts);
          }
        }
        const spanContext = new SpanContext({
          traceId: id(traceId, 16),
          spanId: id(),
          tags: meta,
          parentId: id(spanId, 16)
        });
        spanContext._sampling = { priority: samplingPriority };
        spanContext._trace = { origin };
        return spanContext;
      }
      startSpan(name, options = {}, context2 = api.context.active()) {
        if (options.root) {
          context2 = api.trace.deleteSpan(context2);
        }
        const parentSpan = api.trace.getSpan(context2);
        const parentSpanContext = parentSpan && parentSpan.spanContext();
        let spanContext;
        if (parentSpanContext && api.trace.isSpanContextValid(parentSpanContext)) {
          spanContext = parentSpanContext._ddContext ? this._createSpanContextFromParent(parentSpanContext._ddContext) : this._createSpanContextForNewSpan(parentSpanContext);
        } else {
          spanContext = new SpanContext();
        }
        const spanKind = options.kind || api.SpanKind.INTERNAL;
        const links = (options.links || []).map((link) => {
          return {
            context: link.context,
            attributes: sanitizeAttributes(link.attributes)
          };
        });
        const attributes = sanitizeAttributes(options.attributes);
        return new Span(
          this,
          context2,
          name,
          spanContext,
          spanKind,
          links,
          options.startTime,
          // Set initial span attributes. The attributes object may have been mutated
          // by the sampler, so we sanitize the merged attributes before setting them.
          sanitizeAttributes(attributes)
        );
      }
      startActiveSpan(name, options, context2, fn) {
        if (arguments.length === 2) {
          fn = options;
          context2 = void 0;
          options = void 0;
        } else if (arguments.length === 3) {
          fn = context2;
          context2 = void 0;
        } else if (arguments.length !== 4) {
          return;
        }
        const parentContext = context2 || api.context.active();
        const span = this.startSpan(name, options, parentContext);
        const contextWithSpanSet = api.trace.setSpan(parentContext, span);
        return api.context.with(contextWithSpanSet, fn, void 0, span);
      }
      getActiveSpanProcessor() {
        return this._tracerProvider.getActiveSpanProcessor();
      }
      // not used in our codebase but needed for compatibility. See issue #1244
      getSpanLimits() {
        return this._spanLimits;
      }
    };
    module2.exports = Tracer;
  }
});

// ../../packages/dd-trace/src/opentelemetry/tracer_provider.js
var require_tracer_provider = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/tracer_provider.js"(exports2, module2) {
    "use strict";
    var { trace: trace2, context: context2, propagation: propagation2 } = (init_esm(), __toCommonJS(esm_exports));
    var { W3CTraceContextPropagator } = require_src();
    var tracer2 = require_dd_trace();
    var ContextManager = require_context_manager();
    var { MultiSpanProcessor, NoopSpanProcessor } = require_span_processor();
    var Tracer = require_tracer2();
    var TracerProvider = class {
      constructor(config = {}) {
        this.config = config;
        this.resource = config.resource;
        this._processors = [];
        this._tracers = /* @__PURE__ */ new Map();
        this._activeProcessor = new NoopSpanProcessor();
        this._contextManager = new ContextManager();
      }
      getTracer(name = "opentelemetry", version = "0.0.0", options) {
        const key = `${name}@${version}`;
        if (!this._tracers.has(key)) {
          this._tracers.set(key, new Tracer(
            { ...options, name, version },
            this.config,
            this
          ));
        }
        return this._tracers.get(key);
      }
      addSpanProcessor(spanProcessor) {
        if (!this._processors.length) {
          this._activeProcessor.shutdown();
        }
        this._processors.push(spanProcessor);
        this._activeProcessor = new MultiSpanProcessor(
          this._processors
        );
      }
      getActiveSpanProcessor() {
        return this._activeProcessor;
      }
      // Not actually required by the SDK spec, but the official Node.js SDK does
      // this and the docs reflect that so we should do this too for familiarity.
      register(config = {}) {
        context2.setGlobalContextManager(this._contextManager);
        if (!trace2.setGlobalTracerProvider(this)) {
          trace2.getTracerProvider().setDelegate(this);
        }
        if (config.propagator) {
          propagation2.setGlobalPropagator(config.propagator);
        } else {
          propagation2.setGlobalPropagator(new W3CTraceContextPropagator());
        }
      }
      forceFlush() {
        const exporter = tracer2._tracer._exporter;
        if (!exporter) {
          return Promise.reject(new Error("Not started"));
        }
        exporter._writer.flush();
        return this._activeProcessor.forceFlush();
      }
      shutdown() {
        return this._activeProcessor.shutdown();
      }
    };
    module2.exports = TracerProvider;
  }
});

// ../../packages/dd-trace/src/noop/proxy.js
var require_proxy = __commonJS({
  "../../packages/dd-trace/src/noop/proxy.js"(exports2, module2) {
    "use strict";
    var NoopTracer2 = require_tracer();
    var NoopAppsecSdk = require_noop();
    var NoopDogStatsDClient = require_dogstatsd();
    var NoopLLMObsSDK = require_noop2();
    var NoopFlaggingProvider = require_noop3();
    var NoopAIGuardSDK = require_noop4();
    var noop = new NoopTracer2();
    var noopAppsec = new NoopAppsecSdk();
    var noopDogStatsDClient = new NoopDogStatsDClient();
    var noopLLMObs = new NoopLLMObsSDK(noop);
    var noopOpenFeatureProvider = new NoopFlaggingProvider();
    var noopAIGuard = new NoopAIGuardSDK();
    var NoopProxy = class {
      constructor() {
        this._tracer = noop;
        this.appsec = noopAppsec;
        this.dogstatsd = noopDogStatsDClient;
        this.llmobs = noopLLMObs;
        this.openfeature = noopOpenFeatureProvider;
        this.aiguard = noopAIGuard;
        this.setBaggageItem = () => {
        };
        this.getBaggageItem = () => {
        };
        this.getAllBaggageItems = () => {
        };
        this.removeBaggageItem = () => {
        };
        this.removeAllBaggageItems = () => {
        };
      }
      init() {
        return this;
      }
      use() {
        return this;
      }
      profilerStarted() {
        return Promise.resolve(false);
      }
      trace(name, options, fn) {
        if (!fn) {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function") return;
        options = options || {};
        return this._tracer.trace(name, options, fn);
      }
      wrap(name, options, fn) {
        if (!fn) {
          fn = options;
          options = {};
        }
        if (typeof fn !== "function") return fn;
        options = options || {};
        return this._tracer.wrap(name, options, fn);
      }
      setUrl() {
        this._tracer.setUrl.apply(this._tracer, arguments);
        return this;
      }
      startSpan() {
        return this._tracer.startSpan.apply(this._tracer, arguments);
      }
      inject() {
        return this._tracer.inject.apply(this._tracer, arguments);
      }
      extract() {
        return this._tracer.extract.apply(this._tracer, arguments);
      }
      scope() {
        return this._tracer.scope.apply(this._tracer, arguments);
      }
      getRumData() {
        return this._tracer.getRumData.apply(this._tracer, arguments);
      }
      setUser(user) {
        this.appsec.setUser(user);
        return this;
      }
      get TracerProvider() {
        return require_tracer_provider();
      }
    };
    module2.exports = NoopProxy;
  }
});

// ../../packages/dd-trace/src/service-naming/extra-services.js
var require_extra_services = __commonJS({
  "../../packages/dd-trace/src/service-naming/extra-services.js"(exports2, module2) {
    "use strict";
    var maxExtraServices = 64;
    var extraServices = /* @__PURE__ */ new Set();
    function getExtraServices() {
      return [...extraServices];
    }
    function registerExtraService(serviceName) {
      if (serviceName && extraServices.size < maxExtraServices) {
        extraServices.add(serviceName);
      }
    }
    function clear() {
      extraServices.clear();
    }
    module2.exports = {
      registerExtraService,
      getExtraServices,
      clear
    };
  }
});

// ../../packages/dd-trace/src/format.js
var require_format = __commonJS({
  "../../packages/dd-trace/src/format.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var tags = require_tags();
    var id = require_id();
    var { isError } = require_util();
    var { registerExtraService } = require_extra_services();
    var SAMPLING_PRIORITY_KEY = constants.SAMPLING_PRIORITY_KEY;
    var SAMPLING_RULE_DECISION = constants.SAMPLING_RULE_DECISION;
    var SAMPLING_LIMIT_DECISION = constants.SAMPLING_LIMIT_DECISION;
    var SAMPLING_AGENT_DECISION = constants.SAMPLING_AGENT_DECISION;
    var SPAN_SAMPLING_MECHANISM = constants.SPAN_SAMPLING_MECHANISM;
    var SPAN_SAMPLING_RULE_RATE = constants.SPAN_SAMPLING_RULE_RATE;
    var SPAN_SAMPLING_MAX_PER_SECOND = constants.SPAN_SAMPLING_MAX_PER_SECOND;
    var SAMPLING_MECHANISM_SPAN = constants.SAMPLING_MECHANISM_SPAN;
    var { MEASURED, BASE_SERVICE, ANALYTICS } = tags;
    var ORIGIN_KEY = constants.ORIGIN_KEY;
    var HOSTNAME_KEY = constants.HOSTNAME_KEY;
    var TOP_LEVEL_KEY = constants.TOP_LEVEL_KEY;
    var PROCESS_ID = constants.PROCESS_ID;
    var ERROR_MESSAGE = constants.ERROR_MESSAGE;
    var ERROR_STACK = constants.ERROR_STACK;
    var ERROR_TYPE = constants.ERROR_TYPE;
    var { IGNORE_OTEL_ERROR } = constants;
    var map = {
      "operation.name": "name",
      "service.name": "service",
      "span.type": "type",
      "resource.name": "resource"
    };
    function format(span) {
      const formatted = formatSpan(span);
      extractSpanLinks(formatted, span);
      extractSpanEvents(formatted, span);
      extractRootTags(formatted, span);
      extractChunkTags(formatted, span);
      extractTags(formatted, span);
      return formatted;
    }
    function formatSpan(span) {
      const spanContext = span.context();
      return {
        trace_id: spanContext._traceId,
        span_id: spanContext._spanId,
        parent_id: spanContext._parentId || id("0"),
        name: String(spanContext._name),
        resource: String(spanContext._name),
        error: 0,
        meta: {},
        meta_struct: span.meta_struct,
        metrics: {},
        start: Math.round(span._startTime * 1e6),
        duration: Math.round(span._duration * 1e6),
        links: []
      };
    }
    function setSingleSpanIngestionTags(span, options) {
      if (!options) return;
      addTag({}, span.metrics, SPAN_SAMPLING_MECHANISM, SAMPLING_MECHANISM_SPAN);
      addTag({}, span.metrics, SPAN_SAMPLING_RULE_RATE, options.sampleRate);
      addTag({}, span.metrics, SPAN_SAMPLING_MAX_PER_SECOND, options.maxPerSecond);
    }
    function extractSpanLinks(formattedSpan, span) {
      if (!span._links?.length) {
        return;
      }
      const links = span._links.map((link) => {
        const { context: context2, attributes } = link;
        const formattedLink = {
          trace_id: context2.toTraceId(true),
          span_id: context2.toSpanId(true)
        };
        if (attributes && Object.keys(attributes).length > 0) {
          formattedLink.attributes = attributes;
        }
        if (context2?._sampling?.priority >= 0) formattedLink.flags = context2._sampling.priority > 0 ? 1 : 0;
        if (context2?._tracestate) formattedLink.tracestate = context2._tracestate.toString();
        return formattedLink;
      });
      formattedSpan.meta["_dd.span_links"] = JSON.stringify(links);
    }
    function extractSpanEvents(formattedSpan, span) {
      if (!span._events?.length) {
        return;
      }
      const events = span._events.map((event) => {
        return {
          name: event.name,
          time_unix_nano: Math.round(event.startTime * 1e6),
          attributes: event.attributes && Object.keys(event.attributes).length > 0 ? event.attributes : void 0
        };
      });
      formattedSpan.span_events = events;
    }
    function extractTags(formattedSpan, span) {
      const context2 = span.context();
      const origin = context2._trace.origin;
      const tags2 = context2._tags;
      const hostname = context2._hostname;
      const priority = context2._sampling.priority;
      if (tags2["span.kind"] && tags2["span.kind"] !== "internal") {
        addTag({}, formattedSpan.metrics, MEASURED, 1);
      }
      const tracerService = span.tracer()._service.toLowerCase();
      if (tags2["service.name"]?.toLowerCase() !== tracerService) {
        span.setTag(BASE_SERVICE, tracerService);
        registerExtraService(tags2["service.name"]);
      }
      for (const [tag, value] of Object.entries(tags2)) {
        switch (tag) {
          case "service.name":
          case "span.type":
          case "resource.name":
            addTag(formattedSpan, {}, map[tag], value);
            break;
          // HACK: remove when Datadog supports numeric status code
          case "http.status_code":
            addTag(formattedSpan.meta, {}, tag, value && String(value));
            break;
          case "analytics.event":
            addTag({}, formattedSpan.metrics, ANALYTICS, value === void 0 || value ? 1 : 0);
            break;
          case HOSTNAME_KEY:
          case MEASURED:
            addTag({}, formattedSpan.metrics, tag, value === void 0 || value ? 1 : 0);
            break;
          // TODO(BridgeAR)[31.03.2025]: How come we use two different ways to pass
          // through errors? Can we just unify the behavior to always use one way?
          case "error":
            if (context2._name !== "fs.operation") {
              extractError(formattedSpan, value);
            }
            break;
          case ERROR_TYPE:
          case ERROR_MESSAGE:
          case ERROR_STACK:
            if (context2._name === "fs.operation") {
              break;
            }
            if (!tags2[IGNORE_OTEL_ERROR]) {
              formattedSpan.error = 1;
            }
          default:
            addTag(formattedSpan.meta, formattedSpan.metrics, tag, value);
        }
      }
      setSingleSpanIngestionTags(formattedSpan, context2._spanSampling);
      addTag(formattedSpan.meta, formattedSpan.metrics, "language", "javascript");
      addTag(formattedSpan.meta, formattedSpan.metrics, PROCESS_ID, process.pid);
      addTag(formattedSpan.meta, formattedSpan.metrics, SAMPLING_PRIORITY_KEY, priority);
      addTag(formattedSpan.meta, formattedSpan.metrics, ORIGIN_KEY, origin);
      addTag(formattedSpan.meta, formattedSpan.metrics, HOSTNAME_KEY, hostname);
    }
    function extractRootTags(formattedSpan, span) {
      const context2 = span.context();
      const isLocalRoot = span === context2._trace.started[0];
      const parentId = context2._parentId;
      if (!isLocalRoot || parentId && parentId.toString(10) !== "0") return;
      addTag({}, formattedSpan.metrics, SAMPLING_RULE_DECISION, context2._trace[SAMPLING_RULE_DECISION]);
      addTag({}, formattedSpan.metrics, SAMPLING_LIMIT_DECISION, context2._trace[SAMPLING_LIMIT_DECISION]);
      addTag({}, formattedSpan.metrics, SAMPLING_AGENT_DECISION, context2._trace[SAMPLING_AGENT_DECISION]);
      addTag({}, formattedSpan.metrics, TOP_LEVEL_KEY, 1);
    }
    function extractChunkTags(formattedSpan, span) {
      const context2 = span.context();
      const isLocalRoot = span === context2._trace.started[0];
      if (!isLocalRoot) return;
      for (const [key, value] of Object.entries(context2._trace.tags)) {
        addTag(formattedSpan.meta, formattedSpan.metrics, key, value);
      }
    }
    function extractError(formattedSpan, error) {
      if (!error) return;
      formattedSpan.error = 1;
      if (isError(error)) {
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_MESSAGE, error.message || error.code);
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_TYPE, error.name);
        addTag(formattedSpan.meta, formattedSpan.metrics, ERROR_STACK, error.stack);
      }
    }
    function addTag(meta, metrics2, key, value, nested) {
      switch (typeof value) {
        case "string":
          meta[key] = value;
          break;
        case "number":
          if (Number.isNaN(value)) break;
          metrics2[key] = value;
          break;
        case "boolean":
          metrics2[key] = value ? 1 : 0;
          break;
        default:
          if (value == null) break;
          if (isNodeBuffer(value) || isUrl(value)) {
            metrics2[key] = value.toString();
          } else if (!Array.isArray(value) && !nested) {
            for (const [prop, val] of Object.entries(value)) {
              addTag(meta, metrics2, `${key}.${prop}`, val, true);
            }
          }
      }
    }
    function isNodeBuffer(obj) {
      return obj.constructor && obj.constructor.name === "Buffer" && typeof obj.readInt8 === "function" && typeof obj.toString === "function";
    }
    function isUrl(obj) {
      return obj.constructor && obj.constructor.name === "URL" && typeof obj.href === "string" && typeof obj.toString === "function";
    }
    module2.exports = format;
  }
});

// ../../ext/formats.js
var require_formats = __commonJS({
  "../../ext/formats.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      TEXT_MAP: "text_map",
      HTTP_HEADERS: "http_headers",
      BINARY: "binary",
      LOG: "log",
      TEXT_MAP_DSM: "text_map_dsm"
    };
  }
});

// ../../ext/types.js
var require_types = __commonJS({
  "../../ext/types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      HTTP: "http",
      SERVERLESS: "serverless",
      WEB: "web"
    };
  }
});

// ../../ext/exporters.js
var require_exporters = __commonJS({
  "../../ext/exporters.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      LOG: "log",
      AGENT: "agent",
      DATADOG: "datadog",
      AGENT_PROXY: "agent_proxy",
      JEST_WORKER: "jest_worker",
      CUCUMBER_WORKER: "cucumber_worker",
      MOCHA_WORKER: "mocha_worker",
      PLAYWRIGHT_WORKER: "playwright_worker",
      VITEST_WORKER: "vitest_worker"
    };
  }
});

// ../../ext/index.js
var require_ext = __commonJS({
  "../../ext/index.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var kinds = require_kinds();
    var priority = require_priority();
    var tags = require_tags();
    var types = require_types();
    var exporters = require_exporters();
    module2.exports = {
      formats,
      kinds,
      priority,
      tags,
      types,
      exporters
    };
  }
});

// ../../node_modules/limiter/lib/tokenBucket.js
var require_tokenBucket = __commonJS({
  "../../node_modules/limiter/lib/tokenBucket.js"(exports2, module2) {
    var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
      this.bucketSize = bucketSize;
      this.tokensPerInterval = tokensPerInterval;
      if (typeof interval === "string") {
        switch (interval) {
          case "sec":
          case "second":
            this.interval = 1e3;
            break;
          case "min":
          case "minute":
            this.interval = 1e3 * 60;
            break;
          case "hr":
          case "hour":
            this.interval = 1e3 * 60 * 60;
            break;
          case "day":
            this.interval = 1e3 * 60 * 60 * 24;
            break;
          default:
            throw new Error("Invaid interval " + interval);
        }
      } else {
        this.interval = interval;
      }
      this.parentBucket = parentBucket;
      this.content = 0;
      this.lastDrip = +/* @__PURE__ */ new Date();
    };
    TokenBucket.prototype = {
      bucketSize: 1,
      tokensPerInterval: 1,
      interval: 1e3,
      parentBucket: null,
      content: 0,
      lastDrip: 0,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * bucket (and any parent buckets) contains enough tokens this will happen
       * immediately. Otherwise, the removal and callback will happen when enough
       * tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        var self2 = this;
        if (!this.bucketSize) {
          process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
          return true;
        }
        if (count > this.bucketSize) {
          process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
          return false;
        }
        this.drip();
        if (count > this.content)
          return comeBackLater();
        if (this.parentBucket) {
          return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
            if (err) return callback(err, null);
            if (count > self2.content)
              return comeBackLater();
            self2.content -= count;
            callback(null, Math.min(remainingTokens, self2.content));
          });
        } else {
          this.content -= count;
          process.nextTick(callback.bind(null, null, this.content));
          return true;
        }
        function comeBackLater() {
          var waitInterval = Math.ceil(
            (count - self2.content) * (self2.interval / self2.tokensPerInterval)
          );
          setTimeout(function() {
            self2.removeTokens(count, callback);
          }, waitInterval);
          return false;
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens this will
       * return true, otherwise false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (!this.bucketSize)
          return true;
        if (count > this.bucketSize)
          return false;
        this.drip();
        if (count > this.content)
          return false;
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
          return false;
        this.content -= count;
        return true;
      },
      /**
       * Add any new tokens to the bucket since the last drip.
       * @returns {Boolean} True if new tokens were added, otherwise false.
       */
      drip: function() {
        if (!this.tokensPerInterval) {
          this.content = this.bucketSize;
          return;
        }
        var now = +/* @__PURE__ */ new Date();
        var deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
      }
    };
    module2.exports = TokenBucket;
  }
});

// ../../node_modules/limiter/lib/clock.js
var require_clock = __commonJS({
  "../../node_modules/limiter/lib/clock.js"(exports2, module2) {
    var getMilliseconds = function() {
      if (typeof process !== "undefined" && process.hrtime) {
        var hrtime = process.hrtime();
        var seconds = hrtime[0];
        var nanoseconds = hrtime[1];
        return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
      }
      return (/* @__PURE__ */ new Date()).getTime();
    };
    module2.exports = getMilliseconds;
  }
});

// ../../node_modules/limiter/lib/rateLimiter.js
var require_rateLimiter = __commonJS({
  "../../node_modules/limiter/lib/rateLimiter.js"(exports2, module2) {
    var TokenBucket = require_tokenBucket();
    var getMilliseconds = require_clock();
    var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
      this.tokenBucket = new TokenBucket(
        tokensPerInterval,
        tokensPerInterval,
        interval,
        null
      );
      this.tokenBucket.content = tokensPerInterval;
      this.curIntervalStart = getMilliseconds();
      this.tokensThisInterval = 0;
      this.fireImmediately = fireImmediately;
    };
    RateLimiter.prototype = {
      tokenBucket: null,
      curIntervalStart: 0,
      tokensThisInterval: 0,
      fireImmediately: false,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * rate limiter contains enough tokens and we haven't spent too many tokens
       * in this interval already, this will happen immediately. Otherwise, the
       * removal and callback will happen when enough tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        if (count > this.tokenBucket.bucketSize) {
          process.nextTick(callback.bind(
            null,
            "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
            null
          ));
          return false;
        }
        var self2 = this;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
          if (this.fireImmediately) {
            process.nextTick(callback.bind(null, null, -1));
          } else {
            var waitInterval = Math.ceil(
              this.curIntervalStart + this.tokenBucket.interval - now
            );
            setTimeout(function() {
              self2.tokenBucket.removeTokens(count, afterTokensRemoved);
            }, waitInterval);
          }
          return false;
        }
        return this.tokenBucket.removeTokens(count, afterTokensRemoved);
        function afterTokensRemoved(err, tokensRemaining) {
          if (err) return callback(err, null);
          self2.tokensThisInterval += count;
          callback(null, tokensRemaining);
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens and we
       * haven't spent too many tokens in this interval already, this will return
       * true. Otherwise, false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (count > this.tokenBucket.bucketSize)
          return false;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
          return false;
        var removed = this.tokenBucket.tryRemoveTokens(count);
        if (removed) {
          this.tokensThisInterval += count;
        }
        return removed;
      },
      /**
       * Returns the number of tokens remaining in the TokenBucket.
       * @returns {Number} The number of tokens remaining.
       */
      getTokensRemaining: function() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
      }
    };
    module2.exports = RateLimiter;
  }
});

// ../../node_modules/limiter/index.js
var require_limiter = __commonJS({
  "../../node_modules/limiter/index.js"(exports2) {
    exports2.RateLimiter = require_rateLimiter();
    exports2.TokenBucket = require_tokenBucket();
  }
});

// ../../packages/dd-trace/src/rate_limiter.js
var require_rate_limiter = __commonJS({
  "../../packages/dd-trace/src/rate_limiter.js"(exports2, module2) {
    "use strict";
    var limiter = require_limiter();
    var RateLimiter = class {
      /**
       * @param {number} rateLimit - Allowed units per interval. Negative means unlimited, 0 disables.
       * @param {'second'|'minute'|'hour'|'day'} [interval='second'] - Time window for the limiter.
       */
      constructor(rateLimit, interval = "second") {
        this._rateLimit = Number.parseInt(String(rateLimit));
        this._limiter = new limiter.RateLimiter(this._rateLimit, interval);
        this._tokensRequested = 0;
        this._prevIntervalTokens = 0;
        this._prevTokensRequested = 0;
      }
      /**
       * Attempts to consume a token and reports whether it was allowed.
       * Updates internal counters used for effective rate computation.
       *
       * @returns {boolean}
       */
      isAllowed() {
        const curIntervalStart = this._limiter.curIntervalStart;
        const curIntervalTokens = this._limiter.tokensThisInterval;
        const allowed = this._isAllowed();
        if (curIntervalStart === this._limiter.curIntervalStart) {
          this._tokensRequested++;
        } else {
          this._prevIntervalTokens = curIntervalTokens;
          this._prevTokensRequested = this._tokensRequested;
          this._tokensRequested = 1;
        }
        return allowed;
      }
      /**
       * Returns the fraction of allowed requests over requested ones in the
       * current and previous intervals combined.
       *
       * @returns {number}
       */
      effectiveRate() {
        if (this._rateLimit < 0) return 1;
        if (this._rateLimit === 0) return 0;
        if (this._tokensRequested === 0) return 1;
        const allowed = this._prevIntervalTokens + this._limiter.tokensThisInterval;
        const requested = this._prevTokensRequested + this._tokensRequested;
        return allowed / requested;
      }
      /**
       * Internal token consumption without counter side-effects.
       * @returns {boolean}
       */
      _isAllowed() {
        if (this._rateLimit < 0) return true;
        if (this._rateLimit === 0) return false;
        return this._limiter.tryRemoveTokens(1);
      }
      /**
       * Effective rate within the current interval only.
       * @returns {number}
       */
      _currentWindowRate() {
        if (this._rateLimit < 0) return 1;
        if (this._rateLimit === 0) return 0;
        if (this._tokensRequested === 0) return 1;
        return this._limiter.tokensThisInterval / this._tokensRequested;
      }
    };
    module2.exports = RateLimiter;
  }
});

// ../../packages/dd-trace/src/sampler.js
var require_sampler2 = __commonJS({
  "../../packages/dd-trace/src/sampler.js"(exports2, module2) {
    "use strict";
    var MAX_TRACE_ID = 2 ** 64 - 1;
    var UINT64_MODULO = 2n ** 64n;
    var SAMPLING_KNUTH_FACTOR = 1111111111111111111n;
    var Sampler = class {
      #threshold = 0n;
      /**
       * @param {number} rate
       */
      constructor(rate) {
        rate = Math.min(Math.max(rate, 0), 1);
        this._rate = rate;
        this.#threshold = BigInt(Math.floor(rate * MAX_TRACE_ID));
      }
      /**
       * @returns {number}
       */
      rate() {
        return this._rate;
      }
      get threshold() {
        return this.#threshold;
      }
      /**
       * Determines whether a trace/span should be sampled based on the configured sampling rate.
       *
       * @param {Span|SpanContext} span - The span or span context to evaluate.
       * @returns {boolean} `true` if the trace/span should be sampled, otherwise `false`.
       */
      isSampled(span) {
        if (this._rate === 1) {
          return true;
        }
        if (this._rate === 0) {
          return false;
        }
        span = typeof span.context === "function" ? span.context() : span;
        return span._traceId.toBigInt() * SAMPLING_KNUTH_FACTOR % UINT64_MODULO <= this.#threshold;
      }
    };
    module2.exports = Sampler;
  }
});

// ../../packages/dd-trace/src/sampling_rule.js
var require_sampling_rule = __commonJS({
  "../../packages/dd-trace/src/sampling_rule.js"(exports2, module2) {
    "use strict";
    var { globMatch } = require_util();
    var RateLimiter = require_rate_limiter();
    var Sampler = require_sampler2();
    var AlwaysMatcher = class {
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        return true;
      }
    };
    var GlobMatcher = class {
      /**
       * @param {string} pattern - Glob pattern used to match the subject.
       * @param {Locator} locator - Function extracting the subject to match.
       */
      constructor(pattern, locator) {
        this.pattern = pattern;
        this.locator = locator;
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        const subject = this.locator(span);
        if (!subject) return false;
        return globMatch(this.pattern, subject);
      }
    };
    var RegExpMatcher = class {
      /**
       * @param {RegExp} pattern - Regular expression used to test the subject.
       * @param {Locator} locator - Function extracting the subject to test.
       */
      constructor(pattern, locator) {
        this.pattern = pattern;
        this.locator = locator;
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        const subject = this.locator(span);
        if (!subject) return false;
        return this.pattern.test(subject);
      }
    };
    function matcher(pattern, locator) {
      if (pattern instanceof RegExp) {
        return new RegExpMatcher(pattern, locator);
      }
      if (typeof pattern === "string" && pattern !== "*" && pattern !== "**" && pattern !== "***") {
        return new GlobMatcher(pattern, locator);
      }
      return new AlwaysMatcher();
    }
    function makeTagLocator(tag) {
      return (span) => span.context()._tags[tag];
    }
    function nameLocator(span) {
      return span.context()._name;
    }
    function serviceLocator(span) {
      const { _tags: tags } = span.context();
      return tags.service || tags["service.name"] || span.tracer()._service;
    }
    function resourceLocator(span) {
      const { _tags: tags } = span.context();
      return tags.resource || tags["resource.name"];
    }
    var SamplingRule = class _SamplingRule {
      /**
       * @param {SamplingRuleConfig} [config]
       */
      constructor({ name, service, resource, tags, sampleRate = 1, provenance, maxPerSecond } = {}) {
        this.matchers = [];
        if (name) {
          this.matchers.push(matcher(name, nameLocator));
        }
        if (service) {
          this.matchers.push(matcher(service, serviceLocator));
        }
        if (resource) {
          this.matchers.push(matcher(resource, resourceLocator));
        }
        for (const [key, value] of Object.entries(tags || {})) {
          this.matchers.push(matcher(value, makeTagLocator(key)));
        }
        this._sampler = new Sampler(sampleRate);
        this._limiter = void 0;
        this.provenance = provenance;
        if (Number.isFinite(maxPerSecond)) {
          this._limiter = new RateLimiter(maxPerSecond);
        }
      }
      /**
       * Constructs a SamplingRule from the given configuration.
       * @param {SamplingRuleConfig} config
       * @returns {SamplingRule}
       */
      static from(config) {
        return new _SamplingRule(config);
      }
      /**
       * Deterministic sampling rate in [0, 1].
       * @returns {number}
       */
      get sampleRate() {
        return this._sampler.rate();
      }
      /**
       * Effective rate applied by the rate limiter, if configured.
       * @returns {number|undefined}
       */
      get effectiveRate() {
        return this._limiter && this._limiter.effectiveRate();
      }
      /**
       * Maximum samples per second if a limiter is present.
       * @returns {number|undefined}
       */
      get maxPerSecond() {
        return this._limiter && this._limiter._rateLimit;
      }
      /**
       * Checks whether the provided span matches all configured criteria.
       *
       * @param {DatadogSpan} span
       * @returns {boolean}
       */
      match(span) {
        for (const matcher2 of this.matchers) {
          if (!matcher2.match(span)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Determines whether a span should be sampled based on the configured sampling rule.
       *
       * @param {DatadogSpan|DatadogSpanContext} span - The span or span context to evaluate.
       * @returns {boolean} `true` if the span should be sampled, otherwise `false`.
       */
      sample(span) {
        if (!this._sampler.isSampled(span)) {
          return false;
        }
        if (this._limiter) {
          return this._limiter.isAllowed();
        }
        return true;
      }
    };
    module2.exports = SamplingRule;
  }
});

// ../../packages/dd-trace/src/span_sampler.js
var require_span_sampler = __commonJS({
  "../../packages/dd-trace/src/span_sampler.js"(exports2, module2) {
    "use strict";
    var { USER_KEEP, AUTO_KEEP } = require_ext().priority;
    var SamplingRule = require_sampling_rule();
    var SpanSampler = class {
      /**
       * @param {{ spanSamplingRules?: Array<import('./sampling_rule')>|Array<Record<string, unknown>> }} [config]
       */
      constructor({ spanSamplingRules = [] } = {}) {
        this._rules = spanSamplingRules.map(SamplingRule.from);
      }
      /**
       * Finds the first matching span sampling rule for the given span.
       *
       * @param {import('./opentracing/span')} context
       * @returns {import('./sampling_rule')|undefined}
       */
      findRule(context2) {
        for (const rule of this._rules) {
          if (rule.match(context2)) {
            return rule;
          }
        }
      }
      /**
       * Applies span sampling to spans in the trace, tagging matching spans with
       * span sampling metadata when appropriate.
       *
       * @param {import('./opentracing/span_context')} spanContext
       * @returns {void}
       */
      sample(spanContext) {
        const decision = spanContext._sampling.priority;
        if (decision === USER_KEEP || decision === AUTO_KEEP) return;
        const { started } = spanContext._trace;
        for (const span of started) {
          const rule = this.findRule(span);
          if (rule && rule.sample(spanContext)) {
            span.context()._spanSampling = {
              sampleRate: rule.sampleRate,
              maxPerSecond: rule.maxPerSecond
            };
          }
        }
      }
    };
    module2.exports = SpanSampler;
  }
});

// ../../packages/dd-trace/src/git_metadata_tagger.js
var require_git_metadata_tagger = __commonJS({
  "../../packages/dd-trace/src/git_metadata_tagger.js"(exports2, module2) {
    "use strict";
    var { SCI_COMMIT_SHA, SCI_REPOSITORY_URL } = require_constants3();
    var GitMetadataTagger = class {
      constructor(config) {
        this._config = config;
      }
      tagGitMetadata(spanContext) {
        if (this._config.gitMetadataEnabled) {
          spanContext._trace.tags[SCI_COMMIT_SHA] = this._config.commitSHA;
          spanContext._trace.tags[SCI_REPOSITORY_URL] = this._config.repositoryUrl;
        }
      }
    };
    module2.exports = GitMetadataTagger;
  }
});

// ../../packages/dd-trace/src/encode/tags-processors.js
var require_tags_processors = __commonJS({
  "../../packages/dd-trace/src/encode/tags-processors.js"(exports2, module2) {
    "use strict";
    var MAX_RESOURCE_NAME_LENGTH = 5e3;
    var MAX_META_KEY_LENGTH = 200;
    var MAX_META_VALUE_LENGTH = 25e3;
    var MAX_METRIC_KEY_LENGTH = MAX_META_KEY_LENGTH;
    var DEFAULT_SPAN_NAME = "unnamed_operation";
    var DEFAULT_SERVICE_NAME = "unnamed-service";
    var MAX_NAME_LENGTH = 100;
    var MAX_SERVICE_LENGTH = 100;
    var MAX_TYPE_LENGTH = 100;
    function truncateSpan(span, shouldTruncateResourceName = true) {
      if (shouldTruncateResourceName && span.resource && span.resource.length > MAX_RESOURCE_NAME_LENGTH) {
        span.resource = `${span.resource.slice(0, MAX_RESOURCE_NAME_LENGTH)}...`;
      }
      for (let metaKey in span.meta) {
        const val = span.meta[metaKey];
        if (metaKey.length > MAX_META_KEY_LENGTH) {
          delete span.meta[metaKey];
          metaKey = `${metaKey.slice(0, MAX_META_KEY_LENGTH)}...`;
          span.metrics[metaKey] = val;
        }
        if (val && val.length > MAX_META_VALUE_LENGTH) {
          span.meta[metaKey] = `${val.slice(0, MAX_META_VALUE_LENGTH)}...`;
        }
      }
      for (let metricsKey in span.metrics) {
        const val = span.metrics[metricsKey];
        if (metricsKey.length > MAX_METRIC_KEY_LENGTH) {
          delete span.metrics[metricsKey];
          metricsKey = `${metricsKey.slice(0, MAX_METRIC_KEY_LENGTH)}...`;
          span.metrics[metricsKey] = val;
        }
      }
      return span;
    }
    function normalizeSpan(span) {
      span.service = span.service || DEFAULT_SERVICE_NAME;
      if (span.service.length > MAX_SERVICE_LENGTH) {
        span.service = span.service.slice(0, MAX_SERVICE_LENGTH);
      }
      span.name = span.name || DEFAULT_SPAN_NAME;
      if (span.name.length > MAX_NAME_LENGTH) {
        span.name = span.name.slice(0, MAX_NAME_LENGTH);
      }
      if (!span.resource) {
        span.resource = span.name;
      }
      if (span.type && span.type.length > MAX_TYPE_LENGTH) {
        span.type = span.type.slice(0, MAX_TYPE_LENGTH);
      }
      return span;
    }
    module2.exports = {
      truncateSpan,
      normalizeSpan,
      MAX_META_KEY_LENGTH,
      MAX_META_VALUE_LENGTH,
      MAX_METRIC_KEY_LENGTH,
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_TYPE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    };
  }
});

// ../../packages/dd-trace/src/msgpack/chunk.js
var require_chunk = __commonJS({
  "../../packages/dd-trace/src/msgpack/chunk.js"(exports2, module2) {
    "use strict";
    var DEFAULT_MIN_SIZE = 2 * 1024 * 1024;
    var Chunk = class {
      constructor(minSize = DEFAULT_MIN_SIZE) {
        this.buffer = Buffer.allocUnsafe(minSize);
        this.view = new DataView(this.buffer.buffer);
        this.length = 0;
        this._minSize = minSize;
      }
      write(value) {
        const length = Buffer.byteLength(value);
        const offset = this.length;
        if (length < 32) {
          this.reserve(length + 1);
          this.buffer[offset] = length | 160;
        } else if (length < 4294967296) {
          this.reserve(length + 5);
          this.buffer[offset] = 219;
          this.buffer[offset + 1] = length >> 24;
          this.buffer[offset + 2] = length >> 16;
          this.buffer[offset + 3] = length >> 8;
          this.buffer[offset + 4] = length;
        }
        this.buffer.utf8Write(value, this.length - length, length);
        return this.length - offset;
      }
      copy(target, sourceStart, sourceEnd) {
        target.set(new Uint8Array(this.buffer.buffer, sourceStart, sourceEnd - sourceStart));
      }
      set(array) {
        const length = this.length;
        this.reserve(array.length);
        this.buffer.set(array, length);
      }
      reserve(size) {
        if (this.length + size > this.buffer.length) {
          this._resize(this._minSize * Math.ceil((this.length + size) / this._minSize));
        }
        this.length += size;
      }
      _resize(size) {
        const oldBuffer = this.buffer;
        this.buffer = Buffer.allocUnsafe(size);
        this.view = new DataView(this.buffer.buffer);
        oldBuffer.copy(this.buffer, 0, 0, this.length);
      }
    };
    module2.exports = Chunk;
  }
});

// ../../packages/dd-trace/src/msgpack/encoder.js
var require_encoder = __commonJS({
  "../../packages/dd-trace/src/msgpack/encoder.js"(exports2, module2) {
    "use strict";
    var Chunk = require_chunk();
    var MsgpackEncoder = class {
      encode(value) {
        const bytes = new Chunk();
        this.encodeValue(bytes, value);
        return bytes.buffer.subarray(0, bytes.length);
      }
      encodeValue(bytes, value) {
        switch (typeof value) {
          case "bigint":
            this.encodeBigInt(bytes, value);
            break;
          case "boolean":
            this.encodeBoolean(bytes, value);
            break;
          case "number":
            this.encodeNumber(bytes, value);
            break;
          case "object":
            if (value === null) {
              this.encodeNull(bytes, value);
            } else if (Array.isArray(value)) {
              this.encodeArray(bytes, value);
            } else if (Buffer.isBuffer(value) || ArrayBuffer.isView(value)) {
              this.encodeBin(bytes, value);
            } else {
              this.encodeMap(bytes, value);
            }
            break;
          case "string":
            this.encodeString(bytes, value);
            break;
          case "symbol":
            this.encodeString(bytes, value.toString());
            break;
          default:
            this.encodeNull(bytes, value);
            break;
        }
      }
      encodeNull(bytes) {
        const offset = bytes.length;
        bytes.reserve(1);
        bytes.buffer[offset] = 192;
      }
      encodeBoolean(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(1);
        bytes.buffer[offset] = value ? 195 : 194;
      }
      encodeString(bytes, value) {
        bytes.write(value);
      }
      encodeFixArray(bytes, size = 0) {
        const offset = bytes.length;
        bytes.reserve(1);
        bytes.buffer[offset] = 144 + size;
      }
      encodeArrayPrefix(bytes, value) {
        const length = value.length;
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.buffer[offset] = 221;
        bytes.buffer[offset + 1] = length >> 24;
        bytes.buffer[offset + 2] = length >> 16;
        bytes.buffer[offset + 3] = length >> 8;
        bytes.buffer[offset + 4] = length;
      }
      encodeArray(bytes, value) {
        if (value.length < 16) {
          this.encodeFixArray(bytes, value.length);
        } else {
          this.encodeArrayPrefix(bytes, value);
        }
        for (const item of value) {
          this.encodeValue(bytes, item);
        }
      }
      encodeFixMap(bytes, size = 0) {
        const offset = bytes.length;
        bytes.reserve(1);
        bytes.buffer[offset] = 128 + size;
      }
      encodeMapPrefix(bytes, keysLength) {
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.buffer[offset] = 223;
        bytes.buffer[offset + 1] = keysLength >> 24;
        bytes.buffer[offset + 2] = keysLength >> 16;
        bytes.buffer[offset + 3] = keysLength >> 8;
        bytes.buffer[offset + 4] = keysLength;
      }
      encodeByte(bytes, value) {
        bytes.reserve(1);
        bytes.buffer[bytes.length - 1] = value;
      }
      encodeBin(bytes, value) {
        const offset = bytes.length;
        if (value.byteLength < 256) {
          bytes.reserve(2);
          bytes.buffer[offset] = 196;
          bytes.buffer[offset + 1] = value.byteLength;
        } else if (value.byteLength < 65536) {
          bytes.reserve(3);
          bytes.buffer[offset] = 197;
          bytes.buffer[offset + 1] = value.byteLength >> 8;
          bytes.buffer[offset + 2] = value.byteLength;
        } else {
          bytes.reserve(5);
          bytes.buffer[offset] = 198;
          bytes.buffer[offset + 1] = value.byteLength >> 24;
          bytes.buffer[offset + 2] = value.byteLength >> 16;
          bytes.buffer[offset + 3] = value.byteLength >> 8;
          bytes.buffer[offset + 4] = value.byteLength;
        }
        bytes.set(value);
      }
      encodeInteger(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(5);
        bytes.buffer[offset] = 206;
        bytes.buffer[offset + 1] = value >> 24;
        bytes.buffer[offset + 2] = value >> 16;
        bytes.buffer[offset + 3] = value >> 8;
        bytes.buffer[offset + 4] = value;
      }
      encodeShort(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(3);
        bytes.buffer[offset] = 205;
        bytes.buffer[offset + 1] = value >> 8;
        bytes.buffer[offset + 2] = value;
      }
      encodeLong(bytes, value) {
        const offset = bytes.length;
        const hi = value / 2 ** 32 >> 0;
        const lo = value >>> 0;
        bytes.reserve(9);
        bytes.buffer[offset] = 207;
        bytes.buffer[offset + 1] = hi >> 24;
        bytes.buffer[offset + 2] = hi >> 16;
        bytes.buffer[offset + 3] = hi >> 8;
        bytes.buffer[offset + 4] = hi;
        bytes.buffer[offset + 5] = lo >> 24;
        bytes.buffer[offset + 6] = lo >> 16;
        bytes.buffer[offset + 7] = lo >> 8;
        bytes.buffer[offset + 8] = lo;
      }
      encodeNumber(bytes, value) {
        if (Number.isNaN(value)) {
          value = 0;
        }
        if (Number.isInteger(value)) {
          if (value >= 0) {
            this.encodeUnsigned(bytes, value);
          } else {
            this.encodeSigned(bytes, value);
          }
        } else {
          this.encodeFloat(bytes, value);
        }
      }
      encodeSigned(bytes, value) {
        const offset = bytes.length;
        if (value >= -32) {
          bytes.reserve(1);
          bytes.buffer[offset] = value;
        } else if (value >= -128) {
          bytes.reserve(2);
          bytes.buffer[offset] = 208;
          bytes.buffer[offset + 1] = value;
        } else if (value >= -32768) {
          bytes.reserve(3);
          bytes.buffer[offset] = 209;
          bytes.buffer[offset + 1] = value >> 8;
          bytes.buffer[offset + 2] = value;
        } else if (value >= -2147483648) {
          bytes.reserve(5);
          bytes.buffer[offset] = 210;
          bytes.buffer[offset + 1] = value >> 24;
          bytes.buffer[offset + 2] = value >> 16;
          bytes.buffer[offset + 3] = value >> 8;
          bytes.buffer[offset + 4] = value;
        } else {
          const hi = Math.floor(value / 2 ** 32);
          const lo = value >>> 0;
          bytes.reserve(9);
          bytes.buffer[offset] = 211;
          bytes.buffer[offset + 1] = hi >> 24;
          bytes.buffer[offset + 2] = hi >> 16;
          bytes.buffer[offset + 3] = hi >> 8;
          bytes.buffer[offset + 4] = hi;
          bytes.buffer[offset + 5] = lo >> 24;
          bytes.buffer[offset + 6] = lo >> 16;
          bytes.buffer[offset + 7] = lo >> 8;
          bytes.buffer[offset + 8] = lo;
        }
      }
      encodeUnsigned(bytes, value) {
        const offset = bytes.length;
        if (value <= 127) {
          bytes.reserve(1);
          bytes.buffer[offset] = value;
        } else if (value <= 255) {
          bytes.reserve(2);
          bytes.buffer[offset] = 204;
          bytes.buffer[offset + 1] = value;
        } else if (value <= 65535) {
          bytes.reserve(3);
          bytes.buffer[offset] = 205;
          bytes.buffer[offset + 1] = value >> 8;
          bytes.buffer[offset + 2] = value;
        } else if (value <= 4294967295) {
          bytes.reserve(5);
          bytes.buffer[offset] = 206;
          bytes.buffer[offset + 1] = value >> 24;
          bytes.buffer[offset + 2] = value >> 16;
          bytes.buffer[offset + 3] = value >> 8;
          bytes.buffer[offset + 4] = value;
        } else {
          const hi = value / 2 ** 32 >> 0;
          const lo = value >>> 0;
          bytes.reserve(9);
          bytes.buffer[offset] = 207;
          bytes.buffer[offset + 1] = hi >> 24;
          bytes.buffer[offset + 2] = hi >> 16;
          bytes.buffer[offset + 3] = hi >> 8;
          bytes.buffer[offset + 4] = hi;
          bytes.buffer[offset + 5] = lo >> 24;
          bytes.buffer[offset + 6] = lo >> 16;
          bytes.buffer[offset + 7] = lo >> 8;
          bytes.buffer[offset + 8] = lo;
        }
      }
      // TODO: Support BigInt larger than 64bit.
      encodeBigInt(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(9);
        if (value >= 0n) {
          bytes.buffer[offset] = 207;
          bytes.view.setBigUint64(offset + 1, value);
        } else {
          bytes.buffer[offset] = 211;
          bytes.view.setBigInt64(offset + 1, value);
        }
      }
      encodeMap(bytes, value) {
        const keys = Object.keys(value);
        this.encodeMapPrefix(bytes, keys.length);
        for (const key of keys) {
          this.encodeValue(bytes, key);
          this.encodeValue(bytes, value[key]);
        }
      }
      encodeFloat(bytes, value) {
        const offset = bytes.length;
        bytes.reserve(9);
        bytes.buffer[offset] = 203;
        bytes.view.setFloat64(offset + 1, value);
      }
    };
    module2.exports = { MsgpackEncoder };
  }
});

// ../../packages/dd-trace/src/msgpack/index.js
var require_msgpack = __commonJS({
  "../../packages/dd-trace/src/msgpack/index.js"(exports2, module2) {
    "use strict";
    var Chunk = require_chunk();
    var { MsgpackEncoder } = require_encoder();
    module2.exports = { Chunk, MsgpackEncoder };
  }
});

// ../../packages/dd-trace/src/encode/0.4.js
var require__ = __commonJS({
  "../../packages/dd-trace/src/encode/0.4.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var { Chunk, MsgpackEncoder } = require_msgpack();
    var log = require_log2();
    var { isTrue } = require_util();
    var { memoize } = require_utils2();
    var { getEnvironmentVariable } = require_config_helper();
    var SOFT_LIMIT = 8 * 1024 * 1024;
    function formatSpan(span, config) {
      span = normalizeSpan(truncateSpan(span, false));
      if (span.span_events) {
        if (config?.trace?.nativeSpanEvents) {
          formatSpanEvents(span);
        } else {
          span.meta.events = JSON.stringify(span.span_events);
          delete span.span_events;
        }
      }
      return span;
    }
    var AgentEncoder = class {
      constructor(writer, limit = SOFT_LIMIT) {
        this._msgpack = new MsgpackEncoder();
        this._limit = limit;
        this._traceBytes = new Chunk();
        this._stringBytes = new Chunk();
        this._writer = writer;
        this._reset();
        this._debugEncoding = isTrue(getEnvironmentVariable("DD_TRACE_ENCODING_DEBUG"));
        this._config = this._writer?._config;
      }
      count() {
        return this._traceCount;
      }
      encode(trace2) {
        const bytes = this._traceBytes;
        const start = bytes.length;
        this._traceCount++;
        this._encode(bytes, trace2);
        const end = bytes.length;
        if (this._debugEncoding) {
          log.debug(() => {
            const hex = bytes.buffer.subarray(start, end).toString("hex").match(/../g).join(" ");
            return `Adding encoded trace to buffer: ${hex}`;
          });
        }
        if (this._traceBytes.length > this._limit || this._stringBytes.length > this._limit) {
          log.debug("Buffer went over soft limit, flushing");
          this._writer.flush();
        }
      }
      makePayload() {
        const traceSize = this._traceBytes.length + 5;
        const buffer = Buffer.allocUnsafe(traceSize);
        this._writeTraces(buffer);
        this._reset();
        return buffer;
      }
      reset() {
        this._reset();
      }
      _encode(bytes, trace2) {
        this._encodeArrayPrefix(bytes, trace2);
        for (let span of trace2) {
          span = formatSpan(span, this._config);
          bytes.reserve(1);
          let mapSize = 11;
          if (span.type) mapSize += 1;
          if (span.meta_struct) mapSize += 1;
          if (span.span_events) mapSize += 1;
          bytes.buffer[bytes.length - 1] = 128 + mapSize;
          if (span.type) {
            this._encodeString(bytes, "type");
            this._encodeString(bytes, span.type);
          }
          this._encodeString(bytes, "trace_id");
          this._encodeId(bytes, span.trace_id);
          this._encodeString(bytes, "span_id");
          this._encodeId(bytes, span.span_id);
          this._encodeString(bytes, "parent_id");
          this._encodeId(bytes, span.parent_id);
          this._encodeString(bytes, "name");
          this._encodeString(bytes, span.name);
          this._encodeString(bytes, "resource");
          this._encodeString(bytes, span.resource);
          this._encodeString(bytes, "service");
          this._encodeString(bytes, span.service);
          this._encodeString(bytes, "error");
          this._encodeInteger(bytes, span.error);
          this._encodeString(bytes, "start");
          this._encodeLong(bytes, span.start);
          this._encodeString(bytes, "duration");
          this._encodeLong(bytes, span.duration);
          this._encodeString(bytes, "meta");
          this._encodeMap(bytes, span.meta);
          this._encodeString(bytes, "metrics");
          this._encodeMap(bytes, span.metrics);
          if (span.span_events) {
            this._encodeString(bytes, "span_events");
            this._encodeObjectAsArray(bytes, span.span_events, /* @__PURE__ */ new Set());
          }
          if (span.meta_struct) {
            this._encodeString(bytes, "meta_struct");
            this._encodeMetaStruct(bytes, span.meta_struct);
          }
        }
      }
      _reset() {
        this._traceCount = 0;
        this._traceBytes.length = 0;
        this._stringCount = 0;
        this._stringBytes.length = 0;
        this._stringMap = {};
        this._cacheString("");
      }
      _encodeBuffer(bytes, buffer) {
        this._msgpack.encodeBin(bytes, buffer);
      }
      _encodeBool(bytes, value) {
        this._msgpack.encodeBoolean(bytes, value);
      }
      _encodeArrayPrefix(bytes, value) {
        this._msgpack.encodeArrayPrefix(bytes, value);
      }
      _encodeMapPrefix(bytes, keysLength) {
        this._msgpack.encodeMapPrefix(bytes, keysLength);
      }
      _encodeByte(bytes, value) {
        this._msgpack.encodeByte(bytes, value);
      }
      // TODO: Use BigInt instead.
      _encodeId(bytes, id) {
        const offset = bytes.length;
        bytes.reserve(9);
        id = id.toArray();
        bytes.buffer[offset] = 207;
        bytes.buffer[offset + 1] = id[0];
        bytes.buffer[offset + 2] = id[1];
        bytes.buffer[offset + 3] = id[2];
        bytes.buffer[offset + 4] = id[3];
        bytes.buffer[offset + 5] = id[4];
        bytes.buffer[offset + 6] = id[5];
        bytes.buffer[offset + 7] = id[6];
        bytes.buffer[offset + 8] = id[7];
      }
      _encodeNumber(bytes, value) {
        this._msgpack.encodeNumber(bytes, value);
      }
      _encodeInteger(bytes, value) {
        this._msgpack.encodeInteger(bytes, value);
      }
      _encodeLong(bytes, value) {
        this._msgpack.encodeLong(bytes, value);
      }
      _encodeMap(bytes, value) {
        const keys = Object.keys(value);
        const validKeys = keys.filter((key) => typeof value[key] === "string" || typeof value[key] === "number");
        this._encodeMapPrefix(bytes, validKeys.length);
        for (const key of validKeys) {
          this._encodeString(bytes, key);
          this._encodeValue(bytes, value[key]);
        }
      }
      _encodeValue(bytes, value) {
        switch (typeof value) {
          case "string":
            this._encodeString(bytes, value);
            break;
          case "number":
            this._encodeFloat(bytes, value);
            break;
          case "boolean":
            this._encodeBool(bytes, value);
            break;
          default:
        }
      }
      _encodeString(bytes, value = "") {
        this._cacheString(value);
        const { start, end } = this._stringMap[value];
        this._stringBytes.copy(bytes, start, end);
      }
      _encodeFloat(bytes, value) {
        this._msgpack.encodeFloat(bytes, value);
      }
      _encodeMetaStruct(bytes, value) {
        const keys = Array.isArray(value) ? [] : Object.keys(value);
        const validKeys = keys.filter((key) => {
          const v = value[key];
          return typeof v === "string" || typeof v === "number" || v !== null && typeof v === "object";
        });
        this._encodeMapPrefix(bytes, validKeys.length);
        for (const key of validKeys) {
          const v = value[key];
          this._encodeString(bytes, key);
          this._encodeObjectAsByteArray(bytes, v);
        }
      }
      _encodeObjectAsByteArray(bytes, value) {
        const prefixLength = 5;
        const offset = bytes.length;
        bytes.reserve(prefixLength);
        this._encodeObject(bytes, value);
        const length = bytes.length - offset - prefixLength;
        bytes.buffer[offset] = 198;
        bytes.buffer[offset + 1] = length >> 24;
        bytes.buffer[offset + 2] = length >> 16;
        bytes.buffer[offset + 3] = length >> 8;
        bytes.buffer[offset + 4] = length;
      }
      _encodeObject(bytes, value, circularReferencesDetector = /* @__PURE__ */ new Set()) {
        circularReferencesDetector.add(value);
        if (Array.isArray(value)) {
          this._encodeObjectAsArray(bytes, value, circularReferencesDetector);
        } else if (value !== null && typeof value === "object") {
          this._encodeObjectAsMap(bytes, value, circularReferencesDetector);
        } else if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
          this._encodeValue(bytes, value);
        }
      }
      _encodeObjectAsMap(bytes, value, circularReferencesDetector) {
        const keys = Object.keys(value);
        const validKeys = keys.filter((key) => {
          const v = value[key];
          return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || v !== null && typeof v === "object" && !circularReferencesDetector.has(v);
        });
        this._encodeMapPrefix(bytes, validKeys.length);
        for (const key of validKeys) {
          const v = value[key];
          this._encodeString(bytes, key);
          this._encodeObject(bytes, v, circularReferencesDetector);
        }
      }
      _encodeObjectAsArray(bytes, value, circularReferencesDetector) {
        const validValue = value.filter((item) => typeof item === "string" || typeof item === "number" || item !== null && typeof item === "object" && !circularReferencesDetector.has(item));
        this._encodeArrayPrefix(bytes, validValue);
        for (const item of validValue) {
          this._encodeObject(bytes, item, circularReferencesDetector);
        }
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringCount++;
          this._stringMap[value] = {
            start: this._stringBytes.length,
            end: this._stringBytes.length + this._stringBytes.write(value)
          };
        }
      }
      _writeArrayPrefix(buffer, offset, count) {
        buffer[offset++] = 221;
        buffer.writeUInt32BE(count, offset);
        return offset + 4;
      }
      _writeTraces(buffer, offset = 0) {
        offset = this._writeArrayPrefix(buffer, offset, this._traceCount);
        offset += this._traceBytes.buffer.copy(buffer, offset, 0, this._traceBytes.length);
        return offset;
      }
    };
    var memoizedLogDebug = memoize((key, message) => {
      log.debug(message);
      return true;
    });
    function formatSpanEvents(span) {
      for (const spanEvent of span.span_events) {
        if (spanEvent.attributes) {
          let hasAttributes = false;
          for (const [key, value] of Object.entries(spanEvent.attributes)) {
            const newValue = convertSpanEventAttributeValues(key, value);
            if (newValue === void 0) {
              delete spanEvent.attributes[key];
            } else {
              hasAttributes = true;
              spanEvent.attributes[key] = newValue;
            }
          }
          if (!hasAttributes) {
            delete spanEvent.attributes;
          }
        }
      }
    }
    function convertSpanEventAttributeValues(key, value, depth = 0) {
      if (typeof value === "string") {
        return {
          type: 0,
          string_value: value
        };
      }
      if (typeof value === "boolean") {
        return {
          type: 1,
          bool_value: value
        };
      }
      if (typeof value === "number") {
        if (Number.isInteger(value)) {
          return {
            type: 2,
            int_value: value
          };
        }
        return {
          type: 3,
          double_value: value
        };
      }
      if (Array.isArray(value)) {
        if (depth === 0) {
          const convertedArray = [];
          for (const val of value) {
            const convertedVal = convertSpanEventAttributeValues(key, val, 1);
            if (convertedVal !== void 0) {
              convertedArray.push(convertedVal);
            }
          }
          if (convertedArray.length > 0) {
            return {
              type: 4,
              array_value: { values: convertedArray }
            };
          }
        } else {
          memoizedLogDebug(
            key,
            `Encountered nested array data type for span event v0.4 encoding. Skipping encoding key: ${key}: with value: ${typeof value}.`
          );
        }
      } else {
        memoizedLogDebug(
          key,
          `Encountered unsupported data type for span event v0.4 encoding, key: ${key}: with value: ${typeof value}. Skipping encoding of pair.`
        );
      }
    }
    module2.exports = { AgentEncoder };
  }
});

// ../../packages/dd-trace/src/encode/span-stats.js
var require_span_stats = __commonJS({
  "../../packages/dd-trace/src/encode/span-stats.js"(exports2, module2) {
    "use strict";
    var { AgentEncoder } = require__();
    var {
      MAX_NAME_LENGTH,
      MAX_SERVICE_LENGTH,
      MAX_RESOURCE_NAME_LENGTH,
      MAX_TYPE_LENGTH,
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    } = require_tags_processors();
    function truncate(value, maxLength, suffix = "") {
      if (!value) {
        return value;
      }
      if (value.length > maxLength) {
        return `${value.slice(0, maxLength)}${suffix}`;
      }
      return value;
    }
    var SpanStatsEncoder = class extends AgentEncoder {
      makePayload() {
        const traceSize = this._traceBytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        this._traceBytes.copy(buffer, 0, traceSize);
        this._reset();
        return buffer;
      }
      _encodeStat(bytes, stat) {
        this._encodeMapPrefix(bytes, 12);
        this._encodeString(bytes, "Service");
        const service = stat.Service || DEFAULT_SERVICE_NAME;
        this._encodeString(bytes, truncate(service, MAX_SERVICE_LENGTH));
        this._encodeString(bytes, "Name");
        const name = stat.Name || DEFAULT_SPAN_NAME;
        this._encodeString(bytes, truncate(name, MAX_NAME_LENGTH));
        this._encodeString(bytes, "Resource");
        this._encodeString(bytes, truncate(stat.Resource, MAX_RESOURCE_NAME_LENGTH, "..."));
        this._encodeString(bytes, "HTTPStatusCode");
        this._encodeInteger(bytes, stat.HTTPStatusCode);
        this._encodeString(bytes, "Type");
        this._encodeString(bytes, truncate(stat.Type, MAX_TYPE_LENGTH));
        this._encodeString(bytes, "Hits");
        this._encodeLong(bytes, stat.Hits);
        this._encodeString(bytes, "Errors");
        this._encodeLong(bytes, stat.Errors);
        this._encodeString(bytes, "Duration");
        this._encodeLong(bytes, stat.Duration);
        this._encodeString(bytes, "OkSummary");
        this._encodeBuffer(bytes, stat.OkSummary);
        this._encodeString(bytes, "ErrorSummary");
        this._encodeBuffer(bytes, stat.ErrorSummary);
        this._encodeString(bytes, "Synthetics");
        this._encodeBool(bytes, stat.Synthetics);
        this._encodeString(bytes, "TopLevelHits");
        this._encodeLong(bytes, stat.TopLevelHits);
      }
      _encodeBucket(bytes, bucket) {
        this._encodeMapPrefix(bytes, 3);
        this._encodeString(bytes, "Start");
        this._encodeLong(bytes, bucket.Start);
        this._encodeString(bytes, "Duration");
        this._encodeLong(bytes, bucket.Duration);
        this._encodeString(bytes, "Stats");
        this._encodeArrayPrefix(bytes, bucket.Stats);
        for (const stat of bucket.Stats) {
          this._encodeStat(bytes, stat);
        }
      }
      _encode(bytes, stats) {
        this._encodeMapPrefix(bytes, 8);
        this._encodeString(bytes, "Hostname");
        this._encodeString(bytes, stats.Hostname);
        this._encodeString(bytes, "Env");
        this._encodeString(bytes, stats.Env);
        this._encodeString(bytes, "Version");
        this._encodeString(bytes, stats.Version);
        this._encodeString(bytes, "Stats");
        this._encodeArrayPrefix(bytes, stats.Stats);
        for (const bucket of stats.Stats) {
          this._encodeBucket(bytes, bucket);
        }
        this._encodeString(bytes, "Lang");
        this._encodeString(bytes, stats.Lang);
        this._encodeString(bytes, "TracerVersion");
        this._encodeString(bytes, stats.TracerVersion);
        this._encodeString(bytes, "RuntimeID");
        this._encodeString(bytes, stats.RuntimeID);
        this._encodeString(bytes, "Sequence");
        this._encodeLong(bytes, stats.Sequence);
      }
    };
    module2.exports = {
      SpanStatsEncoder
    };
  }
});

// ../../packages/dd-trace/src/exporters/common/util.js
var require_util3 = __commonJS({
  "../../packages/dd-trace/src/exporters/common/util.js"(exports2, module2) {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    function safeJSONStringify(value) {
      return JSON.stringify(
        value,
        (key, value2) => key === "dd-api-key" ? void 0 : value2,
        getEnvironmentVariable("DD_TRACE_BEAUTIFUL_LOGS") ? 2 : void 0
      );
    }
    module2.exports = { safeJSONStringify };
  }
});

// ../../packages/dd-trace/src/exporters/common/writer.js
var require_writer3 = __commonJS({
  "../../packages/dd-trace/src/exporters/common/writer.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var log = require_log2();
    var { safeJSONStringify } = require_util3();
    var Writer = class {
      constructor({ url }) {
        this._url = url;
      }
      flush(done = () => {
      }) {
        const count = this._encoder.count();
        if (!request2.writable) {
          this._encoder.reset();
          done();
        } else if (count > 0) {
          const payload = this._encoder.makePayload();
          this._sendPayload(payload, count, done);
        } else {
          done();
        }
      }
      append(payload) {
        if (!request2.writable) {
          log.debug(() => `Maximum number of active requests reached. Payload discarded: ${safeJSONStringify(payload)}`);
          return;
        }
        log.debug(() => `Encoding payload: ${safeJSONStringify(payload)}`);
        this._encode(payload);
      }
      _encode(payload) {
        this._encoder.encode(payload);
      }
      setUrl(url) {
        this._url = url;
      }
    };
    module2.exports = Writer;
  }
});

// ../../packages/dd-trace/src/exporters/span-stats/writer.js
var require_writer4 = __commonJS({
  "../../packages/dd-trace/src/exporters/span-stats/writer.js"(exports2, module2) {
    "use strict";
    var { SpanStatsEncoder } = require_span_stats();
    var pkg = require_package();
    var BaseWriter = require_writer3();
    var request2 = require_request();
    var log = require_log2();
    var Writer = class extends BaseWriter {
      constructor({ url }) {
        super(...arguments);
        this._url = url;
        this._encoder = new SpanStatsEncoder(this);
      }
      _sendPayload(data, _2, done) {
        makeRequest(data, this._url, (err, res) => {
          if (err) {
            log.error("Error sending span stats", err);
            done();
            return;
          }
          log.debug("Response from the intake:", res);
          done();
        });
      }
    };
    function makeRequest(data, url, cb) {
      const options = {
        path: "/v0.6/stats",
        method: "PUT",
        headers: {
          "Datadog-Meta-Lang": "javascript",
          "Datadog-Meta-Tracer-Version": pkg.version,
          "Content-Type": "application/msgpack"
        }
      };
      options.protocol = url.protocol;
      options.hostname = url.hostname;
      options.port = url.port;
      log.debug("Request to the intake: %j", options);
      request2(data, options, (err, res) => {
        cb(err, res);
      });
    }
    module2.exports = {
      Writer
    };
  }
});

// ../../packages/dd-trace/src/exporters/span-stats/index.js
var require_span_stats2 = __commonJS({
  "../../packages/dd-trace/src/exporters/span-stats/index.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var { Writer } = require_writer4();
    var defaults = require_config_defaults();
    var SpanStatsExporter = class {
      constructor(config) {
        const { hostname = defaults.hostname, port = defaults.port, tags, url } = config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname,
          port
        }));
        this._writer = new Writer({ url: this._url, tags });
      }
      export(payload) {
        this._writer.append(payload);
        this._writer.flush();
      }
    };
    module2.exports = {
      SpanStatsExporter
    };
  }
});

// ../../packages/dd-trace/src/span_stats.js
var require_span_stats3 = __commonJS({
  "../../packages/dd-trace/src/span_stats.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var { version } = require_pkg();
    var pkg = require_package();
    var { LogCollapsingLowestDenseDDSketch } = require_dist();
    var { ORIGIN_KEY, TOP_LEVEL_KEY } = require_constants3();
    var {
      MEASURED,
      HTTP_STATUS_CODE
    } = require_tags();
    var { SpanStatsExporter } = require_span_stats2();
    var {
      DEFAULT_SPAN_NAME,
      DEFAULT_SERVICE_NAME
    } = require_tags_processors();
    var SpanAggStats = class {
      constructor(aggKey) {
        this.aggKey = aggKey;
        this.hits = 0;
        this.topLevelHits = 0;
        this.errors = 0;
        this.duration = 0;
        this.okDistribution = new LogCollapsingLowestDenseDDSketch();
        this.errorDistribution = new LogCollapsingLowestDenseDDSketch();
      }
      record(span) {
        const durationNs = span.duration;
        this.hits++;
        this.duration += durationNs;
        if (span.metrics[TOP_LEVEL_KEY]) {
          this.topLevelHits++;
        }
        if (span.error) {
          this.errors++;
          this.errorDistribution.accept(durationNs);
        } else {
          this.okDistribution.accept(durationNs);
        }
      }
      toJSON() {
        const {
          name,
          service,
          resource,
          type,
          statusCode,
          synthetics
        } = this.aggKey;
        return {
          Name: name,
          Service: service,
          Resource: resource,
          Type: type,
          HTTPStatusCode: statusCode,
          Synthetics: synthetics,
          Hits: this.hits,
          TopLevelHits: this.topLevelHits,
          Errors: this.errors,
          Duration: this.duration,
          OkSummary: this.okDistribution.toProto(),
          // TODO: custom proto encoding
          ErrorSummary: this.errorDistribution.toProto()
          // TODO: custom proto encoding
        };
      }
    };
    var SpanAggKey = class {
      constructor(span) {
        this.name = span.name || DEFAULT_SPAN_NAME;
        this.service = span.service || DEFAULT_SERVICE_NAME;
        this.resource = span.resource || "";
        this.type = span.type || "";
        this.statusCode = span.meta[HTTP_STATUS_CODE] || 0;
        this.synthetics = span.meta[ORIGIN_KEY] === "synthetics";
      }
      toString() {
        return [
          this.name,
          this.service,
          this.resource,
          this.type,
          this.statusCode,
          this.synthetics
        ].join(",");
      }
    };
    var SpanBuckets = class extends Map {
      forSpan(span) {
        const aggKey = new SpanAggKey(span);
        const key = aggKey.toString();
        if (!this.has(key)) {
          this.set(key, new SpanAggStats(aggKey));
        }
        return this.get(key);
      }
    };
    var TimeBuckets = class extends Map {
      forTime(time) {
        if (!this.has(time)) {
          this.set(time, new SpanBuckets());
        }
        return this.get(time);
      }
    };
    var SpanStatsProcessor = class {
      constructor({
        stats: {
          enabled = false,
          interval = 10
        },
        hostname,
        port,
        url,
        env,
        tags,
        version: version2
      } = {}) {
        this.exporter = new SpanStatsExporter({
          hostname,
          port,
          tags,
          url
        });
        this.interval = interval;
        this.bucketSizeNs = interval * 1e9;
        this.buckets = new TimeBuckets();
        this.hostname = os.hostname();
        this.enabled = enabled;
        this.env = env;
        this.tags = tags || {};
        this.sequence = 0;
        this.version = version2;
        if (this.enabled) {
          this.timer = setInterval(this.onInterval.bind(this), interval * 1e3);
          this.timer.unref();
        }
      }
      onInterval() {
        const serialized = this._serializeBuckets();
        if (!serialized) return;
        this.exporter.export({
          Hostname: this.hostname,
          Env: this.env,
          Version: this.version || version,
          Stats: serialized,
          Lang: "javascript",
          TracerVersion: pkg.version,
          RuntimeID: this.tags["runtime-id"],
          Sequence: ++this.sequence
        });
      }
      onSpanFinished(span) {
        if (!this.enabled) return;
        if (!span.metrics[TOP_LEVEL_KEY] && !span.metrics[MEASURED]) return;
        const spanEndNs = span.startTime + span.duration;
        const bucketTime = spanEndNs - spanEndNs % this.bucketSizeNs;
        this.buckets.forTime(bucketTime).forSpan(span).record(span);
      }
      _serializeBuckets() {
        const { bucketSizeNs } = this;
        const serializedBuckets = [];
        for (const [timeNs, bucket] of this.buckets.entries()) {
          const bucketAggStats = [];
          for (const stats of bucket.values()) {
            bucketAggStats.push(stats.toJSON());
          }
          serializedBuckets.push({
            Start: timeNs,
            Duration: bucketSizeNs,
            Stats: bucketAggStats
          });
        }
        this.buckets.clear();
        return serializedBuckets;
      }
    };
    module2.exports = {
      SpanAggStats,
      SpanAggKey,
      SpanBuckets,
      TimeBuckets,
      SpanStatsProcessor
    };
  }
});

// ../../packages/dd-trace/src/span_processor.js
var require_span_processor2 = __commonJS({
  "../../packages/dd-trace/src/span_processor.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var format = require_format();
    var SpanSampler = require_span_sampler();
    var GitMetadataTagger = require_git_metadata_tagger();
    var { getEnvironmentVariable } = require_config_helper();
    var startedSpans = /* @__PURE__ */ new WeakSet();
    var finishedSpans = /* @__PURE__ */ new WeakSet();
    var { channel } = require_dc_polyfill();
    var spanProcessCh = channel("dd-trace:span:process");
    var SpanProcessor = class {
      constructor(exporter, prioritySampler, config) {
        this._exporter = exporter;
        this._prioritySampler = prioritySampler;
        this._config = config;
        this._killAll = false;
        if (config.stats?.enabled && !config.appsec?.standalone?.enabled) {
          const { SpanStatsProcessor } = require_span_stats3();
          this._stats = new SpanStatsProcessor(config);
        }
        this._spanSampler = new SpanSampler(config.sampler);
        this._gitMetadataTagger = new GitMetadataTagger(config);
      }
      process(span) {
        const spanContext = span.context();
        const active = [];
        const formatted = [];
        const trace2 = spanContext._trace;
        const { flushMinSpans, tracing } = this._config;
        const { started, finished } = trace2;
        if (trace2.record === false) return;
        if (tracing === false) {
          this._erase(trace2, active);
          return;
        }
        if (started.length === finished.length || finished.length >= flushMinSpans) {
          this._prioritySampler.sample(spanContext);
          this._spanSampler.sample(spanContext);
          this._gitMetadataTagger.tagGitMetadata(spanContext);
          for (const span2 of started) {
            if (span2._duration === void 0) {
              active.push(span2);
            } else {
              const formattedSpan = format(span2);
              this._stats?.onSpanFinished(formattedSpan);
              formatted.push(formattedSpan);
              spanProcessCh.publish({ span: span2 });
            }
          }
          if (formatted.length !== 0 && trace2.isRecording !== false) {
            this._exporter.export(formatted);
          }
          this._erase(trace2, active);
        }
        if (this._killAll) {
          for (const startedSpan of started) {
            if (!startedSpan._finished) {
              startedSpan.finish();
            }
          }
        }
      }
      killAll() {
        this._killAll = true;
      }
      _erase(trace2, active) {
        if (getEnvironmentVariable("DD_TRACE_EXPERIMENTAL_STATE_TRACKING") === "true") {
          const started = /* @__PURE__ */ new Set();
          const startedIds = /* @__PURE__ */ new Set();
          const finished = /* @__PURE__ */ new Set();
          const finishedIds = /* @__PURE__ */ new Set();
          for (const span of trace2.finished) {
            const context2 = span.context();
            const id = context2.toSpanId();
            if (finished.has(span)) {
              log.error("Span was already finished in the same trace: %s", span);
            } else {
              finished.add(span);
              if (finishedIds.has(id)) {
                log.error("Another span with the same ID was already finished in the same trace: %s", span);
              } else {
                finishedIds.add(id);
              }
              if (context2._trace !== trace2) {
                log.error("A span was finished in the wrong trace: %s", span);
              }
              if (finishedSpans.has(span)) {
                log.error("Span was already finished in a different trace: %s", span);
              } else {
                finishedSpans.add(span);
              }
            }
          }
          for (const span of trace2.started) {
            const context2 = span.context();
            const id = context2.toSpanId();
            if (started.has(span)) {
              log.error("Span was already started in the same trace: %s", span);
            } else {
              started.add(span);
              if (startedIds.has(id)) {
                log.error("Another span with the same ID was already started in the same trace: %s", span);
              } else {
                startedIds.add(id);
              }
              if (context2._trace !== trace2) {
                log.error("A span was started in the wrong trace: %s", span);
              }
              if (startedSpans.has(span)) {
                log.error("Span was already started in a different trace: %s", span);
              } else {
                startedSpans.add(span);
              }
            }
            if (!finished.has(span)) {
              log.error("Span started in one trace but was finished in another trace: %s", span);
            }
          }
          for (const span of trace2.finished) {
            if (!started.has(span)) {
              log.error("Span finished in one trace but was started in another trace: %s", span);
            }
          }
        }
        for (const span of trace2.finished) {
          span.context()._tags = {};
        }
        trace2.started = active;
        trace2.finished = [];
      }
    };
    module2.exports = SpanProcessor;
  }
});

// ../../packages/dd-trace/src/startup-log.js
var require_startup_log = __commonJS({
  "../../packages/dd-trace/src/startup-log.js"(exports2, module2) {
    "use strict";
    var { info, warn } = require_writer();
    var os = __require("os");
    var { inspect } = __require("util");
    var defaults = require_config_defaults();
    var tracerVersion = require_package().version;
    var errors = {};
    var config;
    var pluginManager;
    var samplingRules = [];
    var alreadyRan = false;
    function getIntegrationsAndAnalytics() {
      return {
        integrations_loaded: Object.keys(pluginManager._pluginsByName)
      };
    }
    function startupLog({ agentError } = {}) {
      if (!config || !pluginManager) {
        return;
      }
      if (alreadyRan) {
        return;
      }
      alreadyRan = true;
      if (!config.startupLogs) {
        return;
      }
      const out = tracerInfo();
      if (agentError) {
        out.agent_error = agentError.message;
      }
      info("DATADOG TRACER CONFIGURATION - " + out);
      if (agentError) {
        warn("DATADOG TRACER DIAGNOSTIC - Agent Error: " + agentError.message);
        errors.agentError = {
          code: agentError.code ?? "",
          message: `Agent Error:${agentError.message}`
        };
      }
    }
    function tracerInfo() {
      const url = config.url || `http://${config.hostname || defaults.hostname}:${config.port}`;
      const out = {
        [inspect.custom]() {
          return String(this);
        },
        toString() {
          return JSON.stringify(this, (_key_, value) => {
            return typeof value === "bigint" || typeof value === "symbol" ? String(value) : value;
          });
        }
      };
      out.date = (/* @__PURE__ */ new Date()).toISOString();
      out.os_name = os.type();
      out.os_version = os.release();
      out.architecture = os.arch();
      out.version = tracerVersion;
      out.lang = "nodejs";
      out.lang_version = process.versions.node;
      out.env = config.env;
      out.enabled = config.enabled;
      out.service = config.service;
      out.agent_url = url;
      out.debug = !!config.debug;
      out.sample_rate = config.sampler.sampleRate;
      out.sampling_rules = samplingRules;
      out.tags = config.tags;
      if (config.tags && config.tags.version) {
        out.dd_version = config.tags.version;
      }
      out.log_injection_enabled = !!config.logInjection;
      out.runtime_metrics_enabled = !!config.runtimeMetrics;
      const profilingEnabled = config.profiling?.enabled;
      out.profiling_enabled = profilingEnabled === "true" || profilingEnabled === "auto";
      Object.assign(out, getIntegrationsAndAnalytics());
      out.appsec_enabled = !!config.appsec.enabled;
      return out;
    }
    function setStartupLogConfig(aConfig) {
      config = aConfig;
    }
    function setStartupLogPluginManager(thePluginManager) {
      pluginManager = thePluginManager;
    }
    function setSamplingRules(theRules) {
      samplingRules = theRules;
    }
    module2.exports = {
      startupLog,
      setStartupLogConfig,
      setStartupLogPluginManager,
      setSamplingRules,
      tracerInfo,
      errors
    };
  }
});

// ../../packages/dd-trace/src/priority_sampler.js
var require_priority_sampler = __commonJS({
  "../../packages/dd-trace/src/priority_sampler.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var RateLimiter = require_rate_limiter();
    var Sampler = require_sampler2();
    var { setSamplingRules } = require_startup_log();
    var SamplingRule = require_sampling_rule();
    var {
      SAMPLING_MECHANISM_DEFAULT,
      SAMPLING_MECHANISM_AGENT,
      SAMPLING_MECHANISM_RULE,
      SAMPLING_MECHANISM_MANUAL,
      SAMPLING_MECHANISM_REMOTE_USER,
      SAMPLING_MECHANISM_REMOTE_DYNAMIC,
      SAMPLING_RULE_DECISION,
      SAMPLING_LIMIT_DECISION,
      SAMPLING_AGENT_DECISION,
      DECISION_MAKER_KEY
    } = require_constants3();
    var {
      tags: {
        MANUAL_KEEP,
        MANUAL_DROP,
        SAMPLING_PRIORITY,
        SERVICE_NAME
      },
      priority: {
        AUTO_REJECT,
        AUTO_KEEP,
        USER_REJECT,
        USER_KEEP
      }
    } = require_ext();
    var DEFAULT_KEY = "service:,env:";
    var defaultSampler = new Sampler(AUTO_KEEP);
    var PrioritySampler = class {
      /**
       * Creates an instance of PrioritySampler.
       *
       * @typedef {Object} SamplingConfig
       * @property {number} [sampleRate] - The default sample rate for traces.
       * @property {string} [provenance] - Optional rule provenance ("customer" or "dynamic").
       * @property {number} [rateLimit=100] - The maximum number of traces to sample per second.
       * @property {Array<import('./sampling_rule')>|Array<Record<string, unknown>>} [rules=[]] - Sampling rules or configs.
       *
       * @param {string} env - The environment name (e.g., "production", "staging").
       * @param {SamplingConfig} [config] - The configuration object for sampling.
       */
      constructor(env, config) {
        this.configure(env, config);
        this.update({});
      }
      /**
       *
       * @param {string} env
       * @param {SamplingConfig} config
       */
      configure(env, config = {}) {
        const { sampleRate, provenance, rateLimit = 100, rules } = config;
        this._env = env;
        this._rules = this.#normalizeRules(rules || [], sampleRate, rateLimit, provenance);
        this._limiter = new RateLimiter(rateLimit);
        log.trace(env, config);
        setSamplingRules(this._rules);
      }
      /**
       * @param {DatadogSpan} span
       * @returns {boolean} True if the trace should be sampled based on priority.
       */
      isSampled(span) {
        const priority = this._getPriorityFromAuto(span);
        log.trace(span);
        return priority === USER_KEEP || priority === AUTO_KEEP;
      }
      /**
       * Assigns a sampling priority to a span if not already set.
       *
       * @param {DatadogSpan} span
       * @param {boolean} [auto=true] - Whether to use automatic sampling if no manual tags are present.
       * @returns {void}
       */
      sample(span, auto = true) {
        if (!span) return;
        const context2 = this._getContext(span);
        const root = context2._trace.started[0];
        if (context2._sampling.priority !== void 0) return;
        if (!root) return;
        log.trace(span, auto);
        const tag = this._getPriorityFromTags(context2._tags, context2);
        if (this.validate(tag)) {
          context2._sampling.priority = tag;
          context2._sampling.mechanism = SAMPLING_MECHANISM_MANUAL;
        } else if (auto) {
          context2._sampling.priority = this._getPriorityFromAuto(root);
        } else {
          return;
        }
        this.#addDecisionMaker(root);
      }
      /**
       * Updates agent-provided sampling rates keyed by `service:,env:`.
       *
       * @param {Record<string, number>} rates
       * @returns {void}
       */
      update(rates) {
        const samplers = {};
        for (const key in rates) {
          const rate = rates[key];
          samplers[key] = new Sampler(rate);
        }
        samplers[DEFAULT_KEY] = samplers[DEFAULT_KEY] || defaultSampler;
        this._samplers = samplers;
        log.trace(rates);
      }
      /**
       * Validates that a sampling priority value is one of the allowed constants.
       *
       * @param {SamplingPriority|undefined} samplingPriority
       * @returns {boolean}
       */
      validate(samplingPriority) {
        switch (samplingPriority) {
          case USER_REJECT:
          case USER_KEEP:
          case AUTO_REJECT:
          case AUTO_KEEP:
            return true;
          default:
            return false;
        }
      }
      /**
       * Explicitly sets the priority and mechanism for the span's trace.
       *
       * @param {DatadogSpan} span
       * @param {SamplingPriority} samplingPriority
       * @param {Product} [product]
       */
      setPriority(span, samplingPriority, product) {
        if (!span || !this.validate(samplingPriority)) return;
        const context2 = this._getContext(span);
        const root = context2._trace.started[0];
        if (!root) {
          log.error("Skipping the setPriority on noop span");
          return;
        }
        context2._sampling.priority = samplingPriority;
        const mechanism = product?.mechanism ?? SAMPLING_MECHANISM_MANUAL;
        context2._sampling.mechanism = mechanism;
        log.trace(span, samplingPriority, mechanism);
        this.#addDecisionMaker(root);
      }
      /**
       * Returns the span context, accepting either a span or a span context.
       *
       * @param {DatadogSpan|DatadogSpanContext} span
       * @returns {DatadogSpanContext}
       */
      _getContext(span) {
        return typeof /** @type {DatadogSpan} */
        span.context === "function" ? (
          /** @type {DatadogSpan} */
          span.context()
        ) : (
          /** @type {DatadogSpanContext} */
          span
        );
      }
      /**
       * Computes priority using rules and agent rates when no manual tag is present.
       *
       * @param {DatadogSpan} span
       * @returns {SamplingPriority}
       */
      _getPriorityFromAuto(span) {
        const context2 = this._getContext(span);
        const rule = this.#findRule(span);
        return rule ? this.#getPriorityByRule(context2, rule) : this.#getPriorityByAgent(context2);
      }
      /**
       * Computes priority from manual sampling tags if present.
       * Included for compatibility with {@link import('./standalone/tracesource_priority_sampler')._getPriorityFromTags}
       *
       * @param {Record<string, unknown>} tags
       * @param {DatadogSpanContext} _context
       * @returns {SamplingPriority|undefined}
       */
      _getPriorityFromTags(tags, _context) {
        if (Object.hasOwn(tags, MANUAL_KEEP) && tags[MANUAL_KEEP] !== false) {
          return USER_KEEP;
        } else if (Object.hasOwn(tags, MANUAL_DROP) && tags[MANUAL_DROP] !== false) {
          return USER_REJECT;
        }
        const rawPriority = tags[SAMPLING_PRIORITY];
        if (rawPriority !== void 0) {
          const priority = Number.parseInt(String(rawPriority), 10);
          if (priority === 1 || priority === 2) {
            return USER_KEEP;
          } else if (priority === 0 || priority === -1) {
            return USER_REJECT;
          }
        }
      }
      /**
       * Applies a matching rule and rate limit to compute the sampling priority.
       *
       * @param {DatadogSpanContext} context
       * @param {import('./sampling_rule')} rule
       * @returns {SamplingPriority}
       */
      #getPriorityByRule(context2, rule) {
        context2._trace[SAMPLING_RULE_DECISION] = rule.sampleRate;
        context2._sampling.mechanism = SAMPLING_MECHANISM_RULE;
        if (rule.provenance === "customer") context2._sampling.mechanism = SAMPLING_MECHANISM_REMOTE_USER;
        if (rule.provenance === "dynamic") context2._sampling.mechanism = SAMPLING_MECHANISM_REMOTE_DYNAMIC;
        return rule.sample(context2) && this._isSampledByRateLimit(context2) ? USER_KEEP : USER_REJECT;
      }
      /**
       * Checks if the rate limiter allows sampling for the current window and
       * records the effective rate on the trace.
       *
       * @param {DatadogSpanContext} context
       * @returns {boolean}
       */
      _isSampledByRateLimit(context2) {
        const allowed = this._limiter.isAllowed();
        context2._trace[SAMPLING_LIMIT_DECISION] = this._limiter.effectiveRate();
        return allowed;
      }
      /**
       * Computes priority using agent-provided sampling rates.
       *
       * @param {DatadogSpanContext} context
       * @returns {SamplingPriority}
       */
      #getPriorityByAgent(context2) {
        const key = `service:${context2._tags[SERVICE_NAME]},env:${this._env}`;
        const sampler = this._samplers[key] || this._samplers[DEFAULT_KEY];
        context2._trace[SAMPLING_AGENT_DECISION] = sampler.rate();
        context2._sampling.mechanism = sampler === defaultSampler ? SAMPLING_MECHANISM_DEFAULT : SAMPLING_MECHANISM_AGENT;
        return sampler.isSampled(context2) ? AUTO_KEEP : AUTO_REJECT;
      }
      /**
       * Tags the trace with a decision maker when priority is keep, or removes it otherwise.
       *
       * @param {DatadogSpan} span
       * @returns {void}
       */
      #addDecisionMaker(span) {
        const context2 = span.context();
        const trace2 = context2._trace;
        const priority = context2._sampling.priority;
        const mechanism = context2._sampling.mechanism;
        if (priority >= AUTO_KEEP) {
          if (!trace2.tags[DECISION_MAKER_KEY]) {
            trace2.tags[DECISION_MAKER_KEY] = `-${mechanism}`;
          }
        } else {
          delete trace2.tags[DECISION_MAKER_KEY];
        }
      }
      /**
       * Normalizes rule inputs to SamplingRule instances, applying defaults.
       *
       * @param {Array<SamplingRuleLike>|SamplingRuleLike} rules - Rules to normalize.
       * @param {number|undefined} sampleRate
       * @param {number} rateLimit
       * @param {string|undefined} provenance
       * @returns {Array<import('./sampling_rule')>}
       */
      #normalizeRules(rules, sampleRate, rateLimit, provenance) {
        rules = Array.isArray(rules) ? rules.flat() : [rules];
        rules.push({ sampleRate, maxPerSecond: rateLimit, provenance });
        const result = [];
        for (const rule of rules) {
          const sampleRate2 = Number.parseFloat(String(rule.sampleRate));
          if (!Number.isNaN(sampleRate2)) {
            result.push(SamplingRule.from({ ...rule, sampleRate: sampleRate2 }));
          }
        }
        return result;
      }
      /**
       * Finds the first matching rule for the given span.
       *
       * @param {DatadogSpan} span
       * @returns {import('./sampling_rule')|undefined}
       */
      #findRule(span) {
        for (const rule of this._rules) {
          if (rule.match(span)) return rule;
        }
      }
      /**
       * Convenience helper to keep a trace with an optional product mechanism.
       *
       * @param {DatadogSpan} span
       * @param {Product} [product]
       */
      static keepTrace(span, product) {
        span?._prioritySampler?.setPriority(span, USER_KEEP, product);
      }
    };
    module2.exports = PrioritySampler;
  }
});

// ../../packages/dd-trace/src/datastreams/size.js
var require_size = __commonJS({
  "../../packages/dd-trace/src/datastreams/size.js"(exports2, module2) {
    "use strict";
    var { types } = __require("util");
    function getSizeOrZero(obj) {
      if (typeof obj === "string") {
        return Buffer.from(obj, "utf8").length;
      }
      if (types.isArrayBuffer(obj)) {
        return obj.byteLength;
      }
      if (Buffer.isBuffer(obj)) {
        return obj.length;
      }
      if (Array.isArray(obj) && obj.length > 0) {
        if (typeof obj[0] === "number") return Buffer.from(obj).length;
        let payloadSize = 0;
        obj.forEach((item) => {
          payloadSize += getSizeOrZero(item);
        });
        return payloadSize;
      }
      if (obj !== null && typeof obj === "object") {
        try {
          return getHeadersSize(obj);
        } catch {
        }
      }
      return 0;
    }
    function getHeadersSize(headers) {
      if (headers === void 0) return 0;
      return Object.entries(headers).reduce((prev, [key, val]) => getSizeOrZero(key) + getSizeOrZero(val) + prev, 0);
    }
    function getMessageSize(message) {
      const { key, value, headers } = message;
      return getSizeOrZero(key) + getSizeOrZero(value) + getHeadersSize(headers);
    }
    function getAmqpMessageSize(message) {
      const { headers, content } = message;
      return getSizeOrZero(content) + getHeadersSize(headers);
    }
    module2.exports = {
      getMessageSize,
      getHeadersSize,
      getSizeOrZero,
      getAmqpMessageSize
    };
  }
});

// ../../packages/dd-trace/src/datastreams/encoding.js
var require_encoding = __commonJS({
  "../../packages/dd-trace/src/datastreams/encoding.js"(exports2, module2) {
    "use strict";
    function encodeVarint(v) {
      const sign = v >= 0 ? 0 : 1;
      const double = Math.abs(v) * 2;
      if (double > Number.MAX_SAFE_INTEGER) {
        return;
      }
      const high = Math.floor(double / 4294967296);
      const low = double & 4294967295 | sign;
      return encodeUvarint64(low, high);
    }
    function decodeVarint(b) {
      const [low, high, bytes] = decodeUvarint64(b);
      if (low === void 0 || high === void 0) {
        return [void 0, bytes];
      }
      const positive = (low & 1) === 0;
      const abs = (low >>> 1) + high * 2147483648;
      return [positive ? abs : -abs, bytes];
    }
    var maxVarLen64 = 9;
    function encodeUvarint64(low, high) {
      const result = new Uint8Array(maxVarLen64);
      let i = 0;
      while ((high !== 0 || low < 0 || low > 128) && i < maxVarLen64 - 1) {
        result[i] = low & 127 | 128;
        low >>>= 7;
        low |= (high & 127) << 25;
        high >>>= 7;
        i++;
      }
      result[i] = low & 127;
      return result.slice(0, i + 1);
    }
    function decodeUvarint64(bytes) {
      let low = 0;
      let high = 0;
      let s = 0;
      for (let i = 0; ; i++) {
        if (bytes.length <= i) {
          return [void 0, void 0, bytes.slice(bytes.length)];
        }
        const n = bytes[i];
        if (n < 128 || i === maxVarLen64 - 1) {
          bytes = bytes.slice(i + 1);
          if (s < 32) {
            low |= n << s;
          }
          if (s > 0) {
            high |= s - 32 > 0 ? n << s - 32 : n >> 32 - s;
          }
          return [low, high, bytes];
        }
        if (s < 32) {
          low |= (n & 127) << s;
        }
        if (s > 0) {
          high |= s - 32 > 0 ? (n & 127) << s - 32 : (n & 127) >> 32 - s;
        }
        s += 7;
      }
    }
    module2.exports = {
      encodeVarint,
      decodeVarint
    };
  }
});

// ../../node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "../../node_modules/lru-cache/dist/commonjs/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        onabort;
        _onabort = [];
        reason;
        aborted = false;
        addEventListener(_2, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          warnACPolyfill();
        }
        signal = new AS();
        abort(reason) {
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          this.signal.onabort?.(reason);
        }
      };
      let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class _Stack {
      heap;
      length;
      // private constructor
      static #constructing = false;
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        _Stack.#constructing = true;
        const s = new _Stack(max, HeapCls);
        _Stack.#constructing = false;
        return s;
      }
      constructor(max, HeapCls) {
        if (!_Stack.#constructing) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      // options that cannot be changed without disaster
      #max;
      #maxSize;
      #dispose;
      #disposeAfter;
      #fetchMethod;
      #memoMethod;
      /**
       * {@link LRUCache.OptionsBase.ttl}
       */
      ttl;
      /**
       * {@link LRUCache.OptionsBase.ttlResolution}
       */
      ttlResolution;
      /**
       * {@link LRUCache.OptionsBase.ttlAutopurge}
       */
      ttlAutopurge;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnGet}
       */
      updateAgeOnGet;
      /**
       * {@link LRUCache.OptionsBase.updateAgeOnHas}
       */
      updateAgeOnHas;
      /**
       * {@link LRUCache.OptionsBase.allowStale}
       */
      allowStale;
      /**
       * {@link LRUCache.OptionsBase.noDisposeOnSet}
       */
      noDisposeOnSet;
      /**
       * {@link LRUCache.OptionsBase.noUpdateTTL}
       */
      noUpdateTTL;
      /**
       * {@link LRUCache.OptionsBase.maxEntrySize}
       */
      maxEntrySize;
      /**
       * {@link LRUCache.OptionsBase.sizeCalculation}
       */
      sizeCalculation;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
       */
      noDeleteOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
       */
      noDeleteOnStaleGet;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
       */
      allowStaleOnFetchAbort;
      /**
       * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
       */
      allowStaleOnFetchRejection;
      /**
       * {@link LRUCache.OptionsBase.ignoreFetchAbort}
       */
      ignoreFetchAbort;
      // computed properties
      #size;
      #calculatedSize;
      #keyMap;
      #keyList;
      #valList;
      #next;
      #prev;
      #head;
      #tail;
      #free;
      #disposed;
      #sizes;
      #starts;
      #ttls;
      #hasDispose;
      #hasFetchMethod;
      #hasDisposeAfter;
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: c.#starts,
          ttls: c.#ttls,
          sizes: c.#sizes,
          keyMap: c.#keyMap,
          keyList: c.#keyList,
          valList: c.#valList,
          next: c.#next,
          prev: c.#prev,
          get head() {
            return c.#head;
          },
          get tail() {
            return c.#tail;
          },
          free: c.#free,
          // methods
          isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
          backgroundFetch: (k, index, options, context2) => c.#backgroundFetch(k, index, options, context2),
          moveToTail: (index) => c.#moveToTail(index),
          indexes: (options) => c.#indexes(options),
          rindexes: (options) => c.#rindexes(options),
          isStale: (index) => c.#isStale(index)
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return this.#max;
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return this.#maxSize;
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return this.#calculatedSize;
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return this.#size;
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return this.#fetchMethod;
      }
      get memoMethod() {
        return this.#memoMethod;
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return this.#dispose;
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return this.#disposeAfter;
      }
      constructor(options) {
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.#max = max;
        this.#maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.#maxSize;
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!this.#maxSize && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        this.#memoMethod = memoMethod;
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        this.#fetchMethod = fetchMethod;
        this.#hasFetchMethod = !!fetchMethod;
        this.#keyMap = /* @__PURE__ */ new Map();
        this.#keyList = new Array(max).fill(void 0);
        this.#valList = new Array(max).fill(void 0);
        this.#next = new UintArray(max);
        this.#prev = new UintArray(max);
        this.#head = 0;
        this.#tail = 0;
        this.#free = Stack.create(max);
        this.#size = 0;
        this.#calculatedSize = 0;
        if (typeof dispose === "function") {
          this.#dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.#disposeAfter = disposeAfter;
          this.#disposed = [];
        } else {
          this.#disposeAfter = void 0;
          this.#disposed = void 0;
        }
        this.#hasDispose = !!this.#dispose;
        this.#hasDisposeAfter = !!this.#disposeAfter;
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.#maxSize !== 0) {
            if (!isPosInt(this.#maxSize)) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          this.#initializeSizeTracking();
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          this.#initializeTTLTracking();
        }
        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return this.#keyMap.has(key) ? Infinity : 0;
      }
      #initializeTTLTracking() {
        const ttls = new ZeroArray(this.#max);
        const starts = new ZeroArray(this.#max);
        this.#ttls = ttls;
        this.#starts = starts;
        this.#setItemTTL = (index, ttl, start = perf.now()) => {
          starts[index] = ttl !== 0 ? start : 0;
          ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.#isStale(index)) {
                this.#delete(this.#keyList[index], "expire");
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.#updateItemAge = (index) => {
          starts[index] = ttls[index] !== 0 ? perf.now() : 0;
        };
        this.#statusTTL = (status, index) => {
          if (ttls[index]) {
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start)
              return;
            status.ttl = ttl;
            status.start = start;
            status.now = cachedNow || getNow();
            const age = status.now - start;
            status.remainingTTL = ttl - age;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.#keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start) {
            return Infinity;
          }
          const age = (cachedNow || getNow()) - start;
          return ttl - age;
        };
        this.#isStale = (index) => {
          const s = starts[index];
          const t = ttls[index];
          return !!t && !!s && (cachedNow || getNow()) - s > t;
        };
      }
      // conditionally set private methods related to TTL
      #updateItemAge = () => {
      };
      #statusTTL = () => {
      };
      #setItemTTL = () => {
      };
      /* c8 ignore stop */
      #isStale = () => false;
      #initializeSizeTracking() {
        const sizes = new ZeroArray(this.#max);
        this.#calculatedSize = 0;
        this.#sizes = sizes;
        this.#removeItemSize = (index) => {
          this.#calculatedSize -= sizes[index];
          sizes[index] = 0;
        };
        this.#requireSize = (k, v, size, sizeCalculation) => {
          if (this.#isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError("sizeCalculation return invalid (expect positive integer)");
              }
            } else {
              throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
            }
          }
          return size;
        };
        this.#addItemSize = (index, size, status) => {
          sizes[index] = size;
          if (this.#maxSize) {
            const maxSize = this.#maxSize - sizes[index];
            while (this.#calculatedSize > maxSize) {
              this.#evict(true);
            }
          }
          this.#calculatedSize += sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.#calculatedSize;
          }
        };
      }
      #removeItemSize = (_i) => {
      };
      #addItemSize = (_i, _s, _st) => {
      };
      #requireSize = (_k, _v, size, sizeCalculation) => {
        if (size || sizeCalculation) {
          throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
        }
        return 0;
      };
      *#indexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#tail; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#head) {
              break;
            } else {
              i = this.#prev[i];
            }
          }
        }
      }
      *#rindexes({ allowStale = this.allowStale } = {}) {
        if (this.#size) {
          for (let i = this.#head; true; ) {
            if (!this.#isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.#isStale(i)) {
              yield i;
            }
            if (i === this.#tail) {
              break;
            } else {
              i = this.#next[i];
            }
          }
        }
      }
      #isValidIndex(index) {
        return index !== void 0 && this.#keyMap.get(this.#keyList[index]) === index;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of this.#indexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of this.#rindexes()) {
          if (this.#valList[i] !== void 0 && this.#keyList[i] !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield [this.#keyList[i], this.#valList[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of this.#indexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of this.#rindexes()) {
          const k = this.#keyList[i];
          if (k !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          if (v !== void 0 && !this.#isBackgroundFetch(this.#valList[i])) {
            yield this.#valList[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [Symbol.iterator]() {
        return this.entries();
      }
      /**
       * A String value that is used in the creation of the default string
       * description of an object. Called by the built-in method
       * `Object.prototype.toString`.
       */
      [Symbol.toStringTag] = "LRUCache";
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, this.#keyList[i], this)) {
            return this.get(this.#keyList[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of this.#indexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of this.#rindexes()) {
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, this.#keyList[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of this.#rindexes({ allowStale: true })) {
          if (this.#isStale(i)) {
            this.#delete(this.#keyList[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = this.#keyMap.get(key);
        if (i === void 0)
          return void 0;
        const v = this.#valList[i];
        const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (this.#ttls && this.#starts) {
          const ttl = this.#ttls[i];
          const start = this.#starts[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (this.#sizes) {
          entry.size = this.#sizes[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of this.#indexes({ allowStale: true })) {
          const key = this.#keyList[i];
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            entry.ttl = this.#ttls[i];
            const age = perf.now() - this.#starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.#delete(k, "set");
          return this;
        }
        let index = this.#size === 0 ? void 0 : this.#keyMap.get(k);
        if (index === void 0) {
          index = this.#size === 0 ? this.#tail : this.#free.length !== 0 ? this.#free.pop() : this.#size === this.#max ? this.#evict(false) : this.#size;
          this.#keyList[index] = k;
          this.#valList[index] = v;
          this.#keyMap.set(k, index);
          this.#next[this.#tail] = index;
          this.#prev[index] = this.#tail;
          this.#tail = index;
          this.#size++;
          this.#addItemSize(index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          this.#moveToTail(index);
          const oldVal = this.#valList[index];
          if (v !== oldVal) {
            if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(s, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (this.#hasDispose) {
                this.#dispose?.(oldVal, k, "set");
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([oldVal, k, "set"]);
              }
            }
            this.#removeItemSize(index);
            this.#addItemSize(index, size, status);
            this.#valList[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.#isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !this.#ttls) {
          this.#initializeTTLTracking();
        }
        if (this.#ttls) {
          if (!noUpdateTTL) {
            this.#setItemTTL(index, ttl, start);
          }
          if (status)
            this.#statusTTL(status, index);
        }
        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        try {
          while (this.#size) {
            const val = this.#valList[this.#head];
            this.#evict(true);
            if (this.#isBackgroundFetch(val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while (task = dt?.shift()) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      #evict(free) {
        const head = this.#head;
        const k = this.#keyList[head];
        const v = this.#valList[head];
        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else if (this.#hasDispose || this.#hasDisposeAfter) {
          if (this.#hasDispose) {
            this.#dispose?.(v, k, "evict");
          }
          if (this.#hasDisposeAfter) {
            this.#disposed?.push([v, k, "evict"]);
          }
        }
        this.#removeItemSize(head);
        if (free) {
          this.#keyList[head] = void 0;
          this.#valList[head] = void 0;
          this.#free.push(head);
        }
        if (this.#size === 1) {
          this.#head = this.#tail = 0;
          this.#free.length = 0;
        } else {
          this.#head = this.#next[head];
        }
        this.#keyMap.delete(k);
        this.#size--;
        return head;
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!this.#isStale(index)) {
            if (updateAgeOnHas) {
              this.#updateItemAge(index);
            }
            if (status) {
              status.has = "hit";
              this.#statusTTL(status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            this.#statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = this.#keyMap.get(k);
        if (index === void 0 || !allowStale && this.#isStale(index)) {
          return;
        }
        const v = this.#valList[index];
        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
      }
      #backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.#valList[index];
        if (this.#isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        const { signal } = options;
        signal?.addEventListener("abort", () => ac.abort(signal.reason), {
          signal: ac.signal
        });
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort)
                options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          const bf2 = p;
          if (this.#valList[index] === p) {
            if (v2 === void 0) {
              if (bf2.__staleWhileFetching) {
                this.#valList[index] = bf2.__staleWhileFetching;
              } else {
                this.#delete(k, "fetch");
              }
            } else {
              if (options.status)
                options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          const bf2 = p;
          if (this.#valList[index] === p) {
            const del = !noDelete || bf2.__staleWhileFetching === void 0;
            if (del) {
              this.#delete(k, "fetch");
            } else if (!allowStaleAborted) {
              this.#valList[index] = bf2.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && bf2.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return bf2.__staleWhileFetching;
          } else if (bf2.__returned === bf2) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          const fmp = this.#fetchMethod?.(k, v, fetchOpts);
          if (fmp && fmp instanceof Promise) {
            fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
          }
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res(void 0);
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status)
          options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        const bf = Object.assign(p, {
          __abortController: ac,
          __staleWhileFetching: v,
          __returned: void 0
        });
        if (index === void 0) {
          this.set(k, bf, { ...fetchOpts.options, status: void 0 });
          index = this.#keyMap.get(k);
        } else {
          this.#valList[index] = bf;
        }
        return bf;
      }
      #isBackgroundFetch(p) {
        if (!this.#hasFetchMethod)
          return false;
        const b = p;
        return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context: context2,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!this.#hasFetchMethod) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.#keyMap.get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = this.#backgroundFetch(k, index, options, context2);
          return p.__returned = p;
        } else {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.#isStale(index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            if (status)
              this.#statusTTL(status, index);
            return v;
          }
          const p = this.#backgroundFetch(k, index, options, context2);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = this.#memoMethod;
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context: context2, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context: context2
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = this.#keyMap.get(k);
        if (index !== void 0) {
          const value = this.#valList[index];
          const fetching = this.#isBackgroundFetch(value);
          if (status)
            this.#statusTTL(status, index);
          if (this.#isStale(index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.#delete(k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.#moveToTail(index);
            if (updateAgeOnGet) {
              this.#updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      #connect(p, n) {
        this.#prev[n] = p;
        this.#next[p] = n;
      }
      #moveToTail(index) {
        if (index !== this.#tail) {
          if (index === this.#head) {
            this.#head = this.#next[index];
          } else {
            this.#connect(this.#prev[index], this.#next[index]);
          }
          this.#connect(this.#tail, index);
          this.#tail = index;
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return this.#delete(k, "delete");
      }
      #delete(k, reason) {
        let deleted = false;
        if (this.#size !== 0) {
          const index = this.#keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.#size === 1) {
              this.#clear(reason);
            } else {
              this.#removeItemSize(index);
              const v = this.#valList[index];
              if (this.#isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else if (this.#hasDispose || this.#hasDisposeAfter) {
                if (this.#hasDispose) {
                  this.#dispose?.(v, k, reason);
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([v, k, reason]);
                }
              }
              this.#keyMap.delete(k);
              this.#keyList[index] = void 0;
              this.#valList[index] = void 0;
              if (index === this.#tail) {
                this.#tail = this.#prev[index];
              } else if (index === this.#head) {
                this.#head = this.#next[index];
              } else {
                const pi = this.#prev[index];
                this.#next[pi] = this.#next[index];
                const ni = this.#next[index];
                this.#prev[ni] = this.#prev[index];
              }
              this.#size--;
              this.#free.push(index);
            }
          }
        }
        if (this.#hasDisposeAfter && this.#disposed?.length) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
        return deleted;
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return this.#clear("delete");
      }
      #clear(reason) {
        for (const index of this.#rindexes({ allowStale: true })) {
          const v = this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.#keyList[index];
            if (this.#hasDispose) {
              this.#dispose?.(v, k, reason);
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, reason]);
            }
          }
        }
        this.#keyMap.clear();
        this.#valList.fill(void 0);
        this.#keyList.fill(void 0);
        if (this.#ttls && this.#starts) {
          this.#ttls.fill(0);
          this.#starts.fill(0);
        }
        if (this.#sizes) {
          this.#sizes.fill(0);
        }
        this.#head = 0;
        this.#tail = 0;
        this.#free.length = 0;
        this.#calculatedSize = 0;
        this.#size = 0;
        if (this.#hasDisposeAfter && this.#disposed) {
          const dt = this.#disposed;
          let task;
          while (task = dt?.shift()) {
            this.#disposeAfter?.(...task);
          }
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// ../../packages/dd-trace/src/datastreams/pathway.js
var require_pathway = __commonJS({
  "../../packages/dd-trace/src/datastreams/pathway.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var { encodeVarint, decodeVarint } = require_encoding();
    var { LRUCache } = require_commonjs();
    var log = require_log2();
    var pick = require_pick();
    var cache = new LRUCache({ max: 500 });
    var CONTEXT_PROPAGATION_KEY = "dd-pathway-ctx";
    var CONTEXT_PROPAGATION_KEY_BASE64 = "dd-pathway-ctx-base64";
    var logKeys = [CONTEXT_PROPAGATION_KEY, CONTEXT_PROPAGATION_KEY_BASE64];
    function shaHash(checkpointString) {
      const hash = crypto.createHash("sha256").update(checkpointString).digest("hex").slice(0, 16);
      return Buffer.from(hash, "hex");
    }
    function computeHash(service, env, edgeTags, parentHash) {
      edgeTags.sort();
      const hashableEdgeTags = edgeTags.filter((item) => item !== "manual_checkpoint:true");
      const key = `${service}${env}${hashableEdgeTags.join("")}${parentHash}`;
      let value = cache.get(key);
      if (value) {
        return value;
      }
      const currentHash = shaHash(`${service}${env}` + hashableEdgeTags.join(""));
      const buf = Buffer.concat([currentHash, parentHash], 16);
      value = shaHash(buf.toString());
      cache.set(key, value);
      return value;
    }
    function encodePathwayContext(dataStreamsContext) {
      return Buffer.concat([
        dataStreamsContext.hash,
        Buffer.from(encodeVarint(Math.round(dataStreamsContext.pathwayStartNs / 1e6))),
        Buffer.from(encodeVarint(Math.round(dataStreamsContext.edgeStartNs / 1e6)))
      ], 20);
    }
    function encodePathwayContextBase64(dataStreamsContext) {
      const encodedPathway = encodePathwayContext(dataStreamsContext);
      return encodedPathway.toString("base64");
    }
    function decodePathwayContext(pathwayContext) {
      if (pathwayContext == null || pathwayContext.length < 8) {
        return null;
      }
      const pathwayHash = pathwayContext.subarray(0, 8);
      const encodedTimestamps = pathwayContext.subarray(8);
      const [pathwayStartMs, encodedTimeSincePrev] = decodeVarint(encodedTimestamps);
      if (pathwayStartMs === void 0) {
        return null;
      }
      const [edgeStartMs] = decodeVarint(encodedTimeSincePrev);
      if (edgeStartMs === void 0) {
        return null;
      }
      return { hash: pathwayHash, pathwayStartNs: pathwayStartMs * 1e6, edgeStartNs: edgeStartMs * 1e6 };
    }
    function decodePathwayContextBase64(pathwayContext) {
      if (pathwayContext == null || pathwayContext.length < 8) {
        return;
      }
      if (Buffer.isBuffer(pathwayContext)) {
        pathwayContext = pathwayContext.toString();
      }
      const encodedPathway = Buffer.from(pathwayContext, "base64");
      return decodePathwayContext(encodedPathway);
    }
    var DsmPathwayCodec = {
      // we use a class for encoding / decoding in case we update our encoding/decoding. A class will make updates easier
      // instead of using individual functions.
      encode(dataStreamsContext, carrier) {
        if (!dataStreamsContext || !dataStreamsContext.hash) {
          return;
        }
        carrier[CONTEXT_PROPAGATION_KEY_BASE64] = encodePathwayContextBase64(dataStreamsContext);
        log.debug(() => `Injected into DSM carrier: ${JSON.stringify(pick(carrier, logKeys))}.`);
      },
      decode(carrier) {
        log.debug(() => `Attempting extract from DSM carrier: ${JSON.stringify(pick(carrier, logKeys))}.`);
        if (carrier == null) return;
        let ctx;
        if (CONTEXT_PROPAGATION_KEY_BASE64 in carrier) {
          ctx = decodePathwayContextBase64(carrier[CONTEXT_PROPAGATION_KEY_BASE64]);
        } else if (CONTEXT_PROPAGATION_KEY in carrier) {
          try {
            ctx = decodePathwayContext(carrier[CONTEXT_PROPAGATION_KEY]);
          } catch {
          }
          if (!ctx && CONTEXT_PROPAGATION_KEY in carrier) {
            ctx = decodePathwayContextBase64(carrier[CONTEXT_PROPAGATION_KEY]);
          }
        }
        return ctx;
      }
    };
    module2.exports = {
      computePathwayHash: computeHash,
      encodePathwayContext,
      decodePathwayContext,
      encodePathwayContextBase64,
      decodePathwayContextBase64,
      DsmPathwayCodec
    };
  }
});

// ../../packages/dd-trace/src/datastreams/context.js
var require_context = __commonJS({
  "../../packages/dd-trace/src/datastreams/context.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var log = require_log2();
    function getDataStreamsContext() {
      const store = storage("legacy").getStore();
      return store && store.dataStreamsContext || null;
    }
    function setDataStreamsContext(dataStreamsContext) {
      log.debug("Setting new DSM Context: %j.", dataStreamsContext);
      if (dataStreamsContext) storage("legacy").enterWith({ ...storage("legacy").getStore(), dataStreamsContext });
    }
    module2.exports = {
      getDataStreamsContext,
      setDataStreamsContext
    };
  }
});

// ../../packages/dd-trace/src/datastreams/checkpointer.js
var require_checkpointer = __commonJS({
  "../../packages/dd-trace/src/datastreams/checkpointer.js"(exports2, module2) {
    "use strict";
    var DataStreamsContext = require_context();
    var DataStreamsCheckpointer = class {
      constructor(tracer2) {
        this.tracer = tracer2;
        this.config = tracer2._config;
        this.dsmProcessor = tracer2._dataStreamsProcessor;
      }
      /**
       * @param {string} type - The type of the checkpoint, usually the streaming technology being used.
       *                       Examples include kafka, kinesis, sns etc.
       * @param {string} target - The target of data. This can be a topic, exchange or stream name.
       * @param {Object} carrier - The carrier object to inject context into.
       */
      setProduceCheckpoint(type, target, carrier) {
        if (!this.config.dsmEnabled) return;
        const ctx = this.dsmProcessor.setCheckpoint(
          ["type:" + type, "topic:" + target, "direction:out", "manual_checkpoint:true"],
          null,
          DataStreamsContext.getDataStreamsContext(),
          null
        );
        DataStreamsContext.setDataStreamsContext(ctx);
        this.tracer.inject(ctx, "text_map_dsm", carrier);
      }
      /**
       * @param {string} type - The type of the checkpoint, usually the streaming technology being used.
       *                       Examples include kafka, kinesis, sns etc.
       * @param {string} source - The source of data. This can be a topic, exchange or stream name.
       * @param {Object} carrier - The carrier object to extract context from.
       * @param {boolean} [manualCheckpoint=true] - Whether this checkpoint was manually set. Keep true if manually
       *                                           instrumenting. Manual instrumentation always overrides automatic
       *                                           instrumentation in the case a call is both manually and automatically
       *                                           instrumented.
       */
      setConsumeCheckpoint(type, source, carrier, manualCheckpoint = true) {
        if (!this.config.dsmEnabled) return;
        const parentCtx = this.tracer.extract("text_map_dsm", carrier);
        DataStreamsContext.setDataStreamsContext(parentCtx);
        const tags = ["type:" + type, "topic:" + source, "direction:in"];
        if (manualCheckpoint) {
          tags.push("manual_checkpoint:true");
        }
        const ctx = this.dsmProcessor.setCheckpoint(
          tags,
          null,
          parentCtx,
          null
        );
        DataStreamsContext.setDataStreamsContext(ctx);
        return ctx;
      }
    };
    module2.exports = {
      DataStreamsCheckpointer
    };
  }
});

// ../../packages/dd-trace/src/datastreams/manager.js
var require_manager = __commonJS({
  "../../packages/dd-trace/src/datastreams/manager.js"(exports2, module2) {
    "use strict";
    var { DsmPathwayCodec } = require_pathway();
    var DataStreamsContext = require_context();
    var DataStreamsManager = class {
      constructor(processor) {
        this._dataStreamsProcessor = processor;
      }
      setCheckpoint(edgeTags, span, payloadSize = 0) {
        const ctx = this._dataStreamsProcessor.setCheckpoint(
          edgeTags,
          span,
          DataStreamsContext.getDataStreamsContext(),
          payloadSize
        );
        DataStreamsContext.setDataStreamsContext(ctx);
        return ctx;
      }
      decodeDataStreamsContext(carrier) {
        const ctx = DsmPathwayCodec.decode(carrier);
        DataStreamsContext.setDataStreamsContext(ctx);
        return ctx;
      }
    };
    module2.exports = { DataStreamsManager };
  }
});

// ../../packages/dd-trace/src/datastreams/writer.js
var require_writer5 = __commonJS({
  "../../packages/dd-trace/src/datastreams/writer.js"(exports2, module2) {
    "use strict";
    var pkg = require_package();
    var log = require_log2();
    var request2 = require_request();
    var { URL: URL2, format } = __require("url");
    var { MsgpackEncoder } = require_msgpack();
    var defaults = require_config_defaults();
    var zlib = __require("zlib");
    var msgpack = new MsgpackEncoder();
    function makeRequest(data, url, cb) {
      const options = {
        path: "/v0.1/pipeline_stats",
        method: "POST",
        headers: {
          "Datadog-Meta-Lang": "javascript",
          "Datadog-Meta-Tracer-Version": pkg.version,
          "Content-Type": "application/msgpack",
          "Content-Encoding": "gzip"
        },
        url
      };
      log.debug("Request to the intake: %j", options);
      request2(data, options, (err, res) => {
        cb(err, res);
      });
    }
    var DataStreamsWriter = class {
      constructor(config) {
        const { hostname = defaults.hostname, port = defaults.port, url } = config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname,
          port
        }));
      }
      flush(payload) {
        if (!request2.writable) {
          log.debug("Maximum number of active requests reached. Payload discarded: %j", payload);
          return;
        }
        const encodedPayload = msgpack.encode(payload);
        zlib.gzip(encodedPayload, { level: 1 }, (err, compressedData) => {
          if (err) {
            log.error("Error zipping datastream", err);
            return;
          }
          makeRequest(compressedData, this._url, (err2, res) => {
            log.debug("Response from the agent:", res);
            if (err2) {
              log.error("Error sending datastream", err2);
            }
          });
        });
      }
      setUrl(url) {
        try {
          url = new URL2(url);
          this._url = url;
        } catch (e) {
          log.warn(e.stack);
        }
      }
    };
    module2.exports = {
      DataStreamsWriter
    };
  }
});

// ../../packages/dd-trace/src/datastreams/fnv.js
var require_fnv = __commonJS({
  "../../packages/dd-trace/src/datastreams/fnv.js"(exports2, module2) {
    "use strict";
    var FNV_64_PRIME = 0x100000001B3n;
    var FNV1_64_INIT = 0xCBF29CE484222325n;
    function fnv(data, hvalInit, fnvPrime, fnvSize) {
      let hval = hvalInit;
      for (const byte of data) {
        hval = hval * fnvPrime % fnvSize;
        hval ^= BigInt(byte);
      }
      return hval;
    }
    function fnv64(data) {
      if (!Buffer.isBuffer(data)) {
        data = Buffer.from(data, "utf8");
      }
      const byteArray = new Uint8Array(data);
      return fnv(byteArray, FNV1_64_INIT, FNV_64_PRIME, 2n ** 64n);
    }
    module2.exports = {
      fnv64
    };
  }
});

// ../../packages/dd-trace/src/datastreams/schemas/schema.js
var require_schema = __commonJS({
  "../../packages/dd-trace/src/datastreams/schemas/schema.js"(exports2, module2) {
    "use strict";
    var Schema = class {
      constructor(definition, id) {
        this.definition = definition;
        this.id = id;
      }
    };
    module2.exports = { Schema };
  }
});

// ../../packages/dd-trace/src/datastreams/schemas/schema_builder.js
var require_schema_builder = __commonJS({
  "../../packages/dd-trace/src/datastreams/schemas/schema_builder.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs();
    var { fnv64 } = require_fnv();
    var { Schema } = require_schema();
    var maxDepth = 10;
    var maxProperties = 1e3;
    var CACHE = new LRUCache({ max: 256 });
    var SchemaBuilder = class _SchemaBuilder {
      constructor(iterator) {
        this.schema = new OpenApiSchema();
        this.iterator = iterator;
        this.properties = 0;
      }
      // TODO: This is only used in tests. Let's refactor the code and stop exposing the cache.
      static getCache() {
        return CACHE;
      }
      static getSchemaDefinition(schema) {
        const definition = toJSON(schema);
        const id = fnv64(Buffer.from(definition, "utf8")).toString();
        return new Schema(definition, id);
      }
      static getSchema(schemaName, iterator, builder) {
        let entry = CACHE.get(schemaName);
        if (!entry) {
          entry = (builder ?? new _SchemaBuilder(iterator)).build();
          CACHE.set(schemaName, entry);
        }
        return entry;
      }
      build() {
        this.iterator.iterateOverSchema(this);
        return this.schema;
      }
      addProperty(schemaName, fieldName, isArray, type, description, ref, format, enumValues) {
        if (this.properties >= maxProperties) {
          return false;
        }
        this.properties += 1;
        let property = new OpenApiSchema.PROPERTY(type, description, ref, format, enumValues, null);
        if (isArray) {
          property = new OpenApiSchema.PROPERTY("array", null, null, null, null, property);
        }
        this.schema.components.schemas[schemaName].properties[fieldName] = property;
        return true;
      }
      shouldExtractSchema(schemaName, depth) {
        if (depth > maxDepth) {
          return false;
        }
        if (schemaName in this.schema.components.schemas) {
          return false;
        }
        this.schema.components.schemas[schemaName] = new OpenApiSchema.SCHEMA();
        return true;
      }
    };
    var OpenApiSchema = class {
      openapi = "3.0.0";
      components = new OpenApiComponents();
    };
    OpenApiSchema.SCHEMA = class {
      type = "object";
      properties = {};
    };
    OpenApiSchema.PROPERTY = class {
      constructor(type, description = null, ref = null, format = null, enumValues = null, items = null) {
        this.type = type;
        this.description = description;
        this.$ref = ref;
        this.format = format;
        this.enum = enumValues;
        this.items = items;
      }
    };
    var OpenApiComponents = class {
      constructor() {
        this.schemas = {};
      }
    };
    function toJSON(value) {
      if (typeof value === "object") {
        if (value === null) {
          return "null";
        }
        if (Array.isArray(value)) {
          let result2 = "[";
          for (let i = 0; i < value.length; i++) {
            if (value[i] !== null) {
              if (i !== 0) {
                result2 += ", ";
              }
              result2 += value[i] === void 0 ? "null" : toJSON(value[i]);
            }
          }
          return `${result2}]`;
        }
        let result = "{";
        for (const [key, objectValue] of Object.entries(value)) {
          if (objectValue != null && typeof key === "string") {
            const converted = toJSON(objectValue);
            if (converted !== void 0) {
              if (result !== "{") {
                result += ", ";
              }
              result += `"${key}": ${converted}`;
            }
          }
        }
        return `${result}}`;
      }
      return JSON.stringify(value);
    }
    module2.exports = {
      SchemaBuilder,
      OpenApiSchema
    };
  }
});

// ../../packages/dd-trace/src/datastreams/schemas/schema_sampler.js
var require_schema_sampler = __commonJS({
  "../../packages/dd-trace/src/datastreams/schemas/schema_sampler.js"(exports2, module2) {
    "use strict";
    var SAMPLE_INTERVAL_MILLIS = 30 * 1e3;
    var SchemaSampler = class {
      weight = 0;
      lastSampleMs = 0;
      trySample(currentTimeMs) {
        if (currentTimeMs >= this.lastSampleMs + SAMPLE_INTERVAL_MILLIS) {
          this.lastSampleMs = currentTimeMs;
          const weight = this.weight;
          this.weight = 0;
          return weight;
        }
        return 0;
      }
      canSample(currentTimeMs) {
        this.weight += 1;
        return currentTimeMs >= this.lastSampleMs + SAMPLE_INTERVAL_MILLIS;
      }
    };
    module2.exports = {
      SchemaSampler
    };
  }
});

// ../../packages/dd-trace/src/datastreams/processor.js
var require_processor = __commonJS({
  "../../packages/dd-trace/src/datastreams/processor.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var pkg = require_package();
    var { LogCollapsingLowestDenseDDSketch } = require_dist();
    var { DsmPathwayCodec } = require_pathway();
    var { DataStreamsWriter } = require_writer5();
    var { computePathwayHash } = require_pathway();
    var { getAmqpMessageSize, getHeadersSize, getMessageSize, getSizeOrZero } = require_size();
    var { PATHWAY_HASH } = require_tags();
    var { SchemaBuilder } = require_schema_builder();
    var { SchemaSampler } = require_schema_sampler();
    var log = require_log2();
    var ENTRY_PARENT_HASH = Buffer.from("0000000000000000", "hex");
    var StatsPoint = class {
      constructor(hash, parentHash, edgeTags) {
        this.hash = hash.readBigUInt64LE();
        this.parentHash = parentHash.readBigUInt64LE();
        this.edgeTags = edgeTags;
        this.edgeLatency = new LogCollapsingLowestDenseDDSketch();
        this.pathwayLatency = new LogCollapsingLowestDenseDDSketch();
        this.payloadSize = new LogCollapsingLowestDenseDDSketch();
      }
      addLatencies(checkpoint) {
        const edgeLatencySec = checkpoint.edgeLatencyNs / 1e9;
        const pathwayLatencySec = checkpoint.pathwayLatencyNs / 1e9;
        this.edgeLatency.accept(edgeLatencySec);
        this.pathwayLatency.accept(pathwayLatencySec);
        this.payloadSize.accept(checkpoint.payloadSize);
      }
      encode() {
        return {
          Hash: this.hash,
          ParentHash: this.parentHash,
          EdgeTags: this.edgeTags,
          EdgeLatency: this.edgeLatency.toProto(),
          PathwayLatency: this.pathwayLatency.toProto(),
          PayloadSize: this.payloadSize.toProto()
        };
      }
    };
    var Backlog = class {
      constructor({ offset, ...tags }) {
        this._tags = Object.keys(tags).sort().map((key) => `${key}:${tags[key]}`);
        this._hash = this._tags.join(",");
        this._offset = offset;
      }
      get hash() {
        return this._hash;
      }
      get offset() {
        return this._offset;
      }
      get tags() {
        return this._tags;
      }
      encode() {
        return {
          Tags: this.tags,
          Value: this.offset
        };
      }
    };
    var StatsBucket = class {
      constructor() {
        this._checkpoints = /* @__PURE__ */ new Map();
        this._backlogs = /* @__PURE__ */ new Map();
      }
      get checkpoints() {
        return this._checkpoints;
      }
      get backlogs() {
        return this._backlogs;
      }
      forCheckpoint({ hash, parentHash, edgeTags }) {
        let checkpoint = this._checkpoints.get(hash);
        if (!checkpoint) {
          checkpoint = new StatsPoint(hash, parentHash, edgeTags);
          this._checkpoints.set(hash, checkpoint);
        }
        return checkpoint;
      }
      /**
       * Conditionally add a backlog to the bucket. If there is currently an offset
       * matching the backlog's tags, overwrite the offset IFF the backlog's offset
       * is greater than the recorded offset.
       *
       * @typedef {{[key: string]: string}} BacklogData
       * @property {number} offset
       *
       * @param {BacklogData} backlogData
       * @returns {Backlog}
       */
      forBacklog(backlogData) {
        const backlog = new Backlog(backlogData);
        const existingBacklog = this._backlogs.get(backlog.hash);
        if (existingBacklog !== void 0 && existingBacklog.offset > backlog.offset) {
          return existingBacklog;
        }
        this._backlogs.set(backlog.hash, backlog);
        return backlog;
      }
    };
    var TimeBuckets = class extends Map {
      forTime(time) {
        if (!this.has(time)) {
          this.set(time, new StatsBucket());
        }
        return this.get(time);
      }
    };
    var DataStreamsProcessor = class {
      constructor({
        dsmEnabled,
        hostname,
        port,
        url,
        env,
        tags,
        version,
        service,
        flushInterval
      } = {}) {
        this.writer = new DataStreamsWriter({
          hostname,
          port,
          url
        });
        this.bucketSizeNs = 1e10;
        this.buckets = new TimeBuckets();
        this.hostname = os.hostname();
        this.enabled = dsmEnabled;
        this.env = env;
        this.tags = tags || {};
        this.service = service || "unnamed-nodejs-service";
        this.version = version || "";
        this.sequence = 0;
        this.flushInterval = flushInterval;
        this._schemaSamplers = {};
        if (this.enabled) {
          this.timer = setInterval(this.onInterval.bind(this), flushInterval);
          this.timer.unref();
        }
        process.once("beforeExit", () => this.onInterval());
      }
      onInterval() {
        const { Stats } = this._serializeBuckets();
        if (Stats.length === 0) return;
        const payload = {
          Env: this.env,
          Service: this.service,
          Stats,
          TracerVersion: pkg.version,
          Version: this.version,
          Lang: "javascript",
          Tags: Object.entries(this.tags).map(([key, value]) => `${key}:${value}`)
        };
        this.writer.flush(payload);
      }
      /**
       * Given a timestamp in nanoseconds, compute and return the closest TimeBucket
       * @param {number} timestamp
       * @returns {StatsBucket}
       */
      bucketFromTimestamp(timestamp) {
        const bucketTime = Math.round(timestamp - timestamp % this.bucketSizeNs);
        const bucket = this.buckets.forTime(bucketTime);
        return bucket;
      }
      recordCheckpoint(checkpoint, span = null) {
        if (!this.enabled) return;
        this.bucketFromTimestamp(checkpoint.currentTimestamp).forCheckpoint(checkpoint).addLatencies(checkpoint);
        if (span) {
          span.setTag(PATHWAY_HASH, checkpoint.hash.readBigUInt64LE(0).toString());
        }
      }
      setCheckpoint(edgeTags, span, ctx = null, payloadSize = 0) {
        if (!this.enabled) return null;
        const nowNs = Date.now() * 1e6;
        const direction = edgeTags.find((t) => t.startsWith("direction:"));
        let pathwayStartNs = nowNs;
        let edgeStartNs = nowNs;
        let parentHash = ENTRY_PARENT_HASH;
        let closestOppositeDirectionHash = ENTRY_PARENT_HASH;
        let closestOppositeDirectionEdgeStart = nowNs;
        if (ctx == null) {
          log.debug("Setting DSM Checkpoint with empty parent context.");
        } else {
          pathwayStartNs = ctx.pathwayStartNs;
          edgeStartNs = ctx.edgeStartNs;
          parentHash = ctx.hash;
          closestOppositeDirectionHash = ctx.closestOppositeDirectionHash || ENTRY_PARENT_HASH;
          closestOppositeDirectionEdgeStart = ctx.closestOppositeDirectionEdgeStart || nowNs;
          if (direction === ctx.previousDirection) {
            parentHash = ctx.closestOppositeDirectionHash;
            if (parentHash === ENTRY_PARENT_HASH) {
              edgeStartNs = nowNs;
              pathwayStartNs = nowNs;
            } else {
              edgeStartNs = ctx.closestOppositeDirectionEdgeStart;
            }
          } else {
            closestOppositeDirectionHash = parentHash;
            closestOppositeDirectionEdgeStart = edgeStartNs;
          }
          log.debug(
            () => `Setting DSM Checkpoint from extracted parent context with hash: ${parentHash} and edge tags: ${edgeTags}`
          );
        }
        const hash = computePathwayHash(this.service, this.env, edgeTags, parentHash);
        const edgeLatencyNs = nowNs - edgeStartNs;
        const pathwayLatencyNs = nowNs - pathwayStartNs;
        const dataStreamsContext = {
          hash,
          edgeStartNs,
          pathwayStartNs,
          previousDirection: direction,
          closestOppositeDirectionHash,
          closestOppositeDirectionEdgeStart
        };
        if (direction === "direction:out") {
          const ddInfoContinued = {};
          DsmPathwayCodec.encode(dataStreamsContext, ddInfoContinued);
          payloadSize += getSizeOrZero(JSON.stringify(ddInfoContinued)) - 1;
        }
        const checkpoint = {
          currentTimestamp: nowNs,
          parentHash,
          hash,
          edgeTags,
          edgeLatencyNs,
          pathwayLatencyNs,
          payloadSize
        };
        this.recordCheckpoint(checkpoint, span);
        return dataStreamsContext;
      }
      recordOffset({ timestamp, ...backlogData }) {
        if (!this.enabled) return;
        return this.bucketFromTimestamp(timestamp).forBacklog(backlogData);
      }
      setOffset(offsetObj) {
        if (!this.enabled) return;
        const nowNs = Date.now() * 1e6;
        const backlogData = {
          ...offsetObj,
          timestamp: nowNs
        };
        this.recordOffset(backlogData);
      }
      _serializeBuckets() {
        const serializedBuckets = [];
        for (const [timeNs, bucket] of this.buckets.entries()) {
          const points = [];
          for (const stats of bucket._checkpoints.values()) {
            points.push(stats.encode());
          }
          const backlogs = [];
          for (const backlog of bucket._backlogs.values()) {
            backlogs.push(backlog.encode());
          }
          serializedBuckets.push({
            Start: BigInt(timeNs),
            Duration: BigInt(this.bucketSizeNs),
            Stats: points,
            Backlogs: backlogs
          });
        }
        this.buckets.clear();
        return {
          Stats: serializedBuckets
        };
      }
      setUrl(url) {
        this.writer.setUrl(url);
      }
      trySampleSchema(topic) {
        const nowMs = Date.now();
        if (!this._schemaSamplers[topic]) {
          this._schemaSamplers[topic] = new SchemaSampler();
        }
        const sampler = this._schemaSamplers[topic];
        return sampler.trySample(nowMs);
      }
      canSampleSchema(topic) {
        const nowMs = Date.now();
        if (!this._schemaSamplers[topic]) {
          this._schemaSamplers[topic] = new SchemaSampler();
        }
        const sampler = this._schemaSamplers[topic];
        return sampler.canSample(nowMs);
      }
      getSchema(schemaName, iterator) {
        return SchemaBuilder.getSchema(schemaName, iterator);
      }
    };
    module2.exports = {
      DataStreamsProcessor,
      StatsPoint,
      StatsBucket,
      Backlog,
      TimeBuckets,
      getMessageSize,
      getHeadersSize,
      getSizeOrZero,
      getAmqpMessageSize,
      ENTRY_PARENT_HASH
    };
  }
});

// ../../packages/dd-trace/src/datastreams/index.js
var require_datastreams = __commonJS({
  "../../packages/dd-trace/src/datastreams/index.js"(exports2, module2) {
    "use strict";
    var {
      getAmqpMessageSize,
      getHeadersSize,
      getMessageSize,
      getSizeOrZero
    } = require_size();
    function lazyClass(classGetter, methods = [], staticMethods = []) {
      let constructorArgs;
      let ActiveClass;
      const LazyClass = function(...args) {
        constructorArgs = args;
      };
      const activate = () => {
        return ActiveClass = ActiveClass || classGetter();
      };
      for (const method of methods) {
        LazyClass.prototype[method] = function(...args) {
          const instance = activate() && new ActiveClass(...constructorArgs);
          Object.setPrototypeOf(this, instance);
          return this[method](...args);
        };
      }
      for (const method of staticMethods) {
        LazyClass[method] = function(...args) {
          LazyClass[method] = activate() && ActiveClass[method];
          return LazyClass[method](...args);
        };
      }
      return LazyClass;
    }
    var DsmPathwayCodec = lazyClass(() => require_pathway().DsmPathwayCodec, [], [
      "encode",
      "decode"
    ]);
    var DataStreamsCheckpointer = lazyClass(() => require_checkpointer().DataStreamsCheckpointer, [
      "setProduceCheckpoint",
      "setConsumeCheckpoint"
    ]);
    var DataStreamsManager = lazyClass(() => require_manager().DataStreamsManager, [
      "setCheckpoint",
      "decodeDataStreamsContext"
    ]);
    var DataStreamsProcessor = lazyClass(() => require_processor().DataStreamsProcessor, [
      "onInterval",
      "bucketFromTimestamp",
      "recordCheckpoint",
      "setCheckpoint",
      "recordOffset",
      "setOffset",
      "setUrl",
      "trySampleSchema",
      "canSampleSchema",
      "getSchema"
    ]);
    var SchemaBuilder = lazyClass(() => require_schema_builder().SchemaBuilder, [
      "build",
      "addProperty",
      "shouldExtractSchema"
    ], [
      "getCache",
      "getSchemaDefinition",
      "getSchema"
    ]);
    module2.exports = {
      DsmPathwayCodec,
      DataStreamsCheckpointer,
      DataStreamsManager,
      DataStreamsProcessor,
      SchemaBuilder,
      // These are small functions so they are exposed directly and not lazy loaded.
      getAmqpMessageSize,
      getHeadersSize,
      getMessageSize,
      getSizeOrZero
    };
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/text_map_dsm.js
var require_text_map_dsm = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/text_map_dsm.js"(exports2, module2) {
    "use strict";
    var pick = require_pick();
    var log = require_log2();
    var { DsmPathwayCodec } = require_datastreams();
    var base64Key = "dd-pathway-ctx-base64";
    var logKeys = [base64Key];
    var DSMTextMapPropagator = class {
      constructor(config) {
        this.config = config;
      }
      inject(ctx, carrier) {
        if (!this.config.dsmEnabled) return;
        this._injectDatadogDSMContext(ctx, carrier);
        log.debug(() => `Inject into carrier (DSM): ${JSON.stringify(pick(carrier, logKeys))}.`);
      }
      extract(carrier) {
        if (!this.config.dsmEnabled) return;
        const dsmContext = this._extractDatadogDSMContext(carrier);
        if (!dsmContext) return dsmContext;
        log.debug(() => `Extract from carrier (DSM): ${JSON.stringify(pick(carrier, logKeys))}.`);
        return dsmContext;
      }
      _injectDatadogDSMContext(ctx, carrier) {
        DsmPathwayCodec.encode(ctx, carrier);
      }
      _extractDatadogDSMContext(carrier) {
        const ctx = DsmPathwayCodec.decode(carrier);
        return ctx;
      }
    };
    module2.exports = DSMTextMapPropagator;
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/http.js
var require_http = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/http.js"(exports2, module2) {
    "use strict";
    var TextMapPropagator = require_text_map();
    var HttpPropagator = class extends TextMapPropagator {
    };
    module2.exports = HttpPropagator;
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/binary.js
var require_binary = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/binary.js"(exports2, module2) {
    "use strict";
    var BinaryPropagator = class {
      inject(spanContext, carrier) {
      }
      extract(carrier) {
        return null;
      }
    };
    module2.exports = BinaryPropagator;
  }
});

// ../../packages/dd-trace/src/opentracing/propagation/log.js
var require_log3 = __commonJS({
  "../../packages/dd-trace/src/opentracing/propagation/log.js"(exports2, module2) {
    "use strict";
    var id = require_id();
    var DatadogSpanContext = require_span_context();
    var LogPropagator = class {
      constructor(config) {
        this._config = config;
      }
      inject(spanContext, carrier) {
        if (!carrier) return;
        carrier.dd = {};
        if (spanContext) {
          carrier.dd.trace_id = this._config.traceId128BitGenerationEnabled && this._config.traceId128BitLoggingEnabled && spanContext._trace.tags["_dd.p.tid"] ? spanContext.toTraceId(true) : spanContext.toTraceId();
          carrier.dd.span_id = spanContext.toSpanId();
        }
        if (this._config.service) carrier.dd.service = this._config.service;
        if (this._config.version) carrier.dd.version = this._config.version;
        if (this._config.env) carrier.dd.env = this._config.env;
      }
      extract(carrier) {
        if (!carrier || !carrier.dd || !carrier.dd.trace_id || !carrier.dd.span_id) {
          return null;
        }
        if (carrier.dd.trace_id.length === 32) {
          const hi = carrier.dd.trace_id.slice(0, 16);
          const lo = carrier.dd.trace_id.slice(16, 32);
          const spanContext = new DatadogSpanContext({
            traceId: id(lo, 16),
            spanId: id(carrier.dd.span_id, 10)
          });
          spanContext._trace.tags["_dd.p.tid"] = hi;
          return spanContext;
        }
        return new DatadogSpanContext({
          traceId: id(carrier.dd.trace_id, 10),
          spanId: id(carrier.dd.span_id, 10)
        });
      }
    };
    module2.exports = LogPropagator;
  }
});

// ../../packages/dd-trace/src/exporters/log/index.js
var require_log4 = __commonJS({
  "../../packages/dd-trace/src/exporters/log/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var TRACE_PREFIX = '{"traces":[[';
    var TRACE_SUFFIX = "]]}\n";
    var TRACE_FORMAT_OVERHEAD = TRACE_PREFIX.length + TRACE_SUFFIX.length;
    var MAX_SIZE = 64 * 1024;
    var LogExporter = class {
      export(spans) {
        log.debug("Adding trace to queue: %j", spans);
        let size = TRACE_FORMAT_OVERHEAD;
        let queue = [];
        for (const span of spans) {
          const spanStr = JSON.stringify(span);
          if (spanStr.length + TRACE_FORMAT_OVERHEAD > MAX_SIZE) {
            log.debug("Span too large to send to logs, dropping");
            continue;
          }
          if (spanStr.length + size > MAX_SIZE) {
            this._printSpans(queue);
            queue = [];
            size = TRACE_FORMAT_OVERHEAD;
          }
          size += spanStr.length + 1;
          queue.push(spanStr);
        }
        if (queue.length > 0) {
          this._printSpans(queue);
        }
      }
      _printSpans(queue) {
        let logLine = TRACE_PREFIX;
        let firstTrace = true;
        for (const spanStr of queue) {
          if (firstTrace) {
            firstTrace = false;
            logLine += spanStr;
          } else {
            logLine += "," + spanStr;
          }
        }
        logLine += TRACE_SUFFIX;
        process.stdout.write(logLine);
      }
    };
    module2.exports = LogExporter;
  }
});

// ../../packages/dd-trace/src/encode/0.5.js
var require__2 = __commonJS({
  "../../packages/dd-trace/src/encode/0.5.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var { AgentEncoder: BaseEncoder } = require__();
    var ARRAY_OF_TWO = 146;
    var ARRAY_OF_TWELVE = 156;
    function formatSpan(span) {
      span = normalizeSpan(truncateSpan(span, false));
      if (span.span_events) {
        span.meta.events = JSON.stringify(span.span_events);
        delete span.span_events;
      }
      return span;
    }
    var AgentEncoder = class extends BaseEncoder {
      makePayload() {
        const prefixSize = 1;
        const stringSize = this._stringBytes.length + 5;
        const traceSize = this._traceBytes.length + 5;
        const buffer = Buffer.allocUnsafe(prefixSize + stringSize + traceSize);
        buffer[0] = ARRAY_OF_TWO;
        const offset = this._writeStrings(buffer, 1);
        this._writeTraces(buffer, offset);
        this._reset();
        return buffer;
      }
      _encode(bytes, trace2) {
        this._encodeArrayPrefix(bytes, trace2);
        for (let span of trace2) {
          span = formatSpan(span);
          this._encodeByte(bytes, ARRAY_OF_TWELVE);
          this._encodeString(bytes, span.service);
          this._encodeString(bytes, span.name);
          this._encodeString(bytes, span.resource);
          this._encodeId(bytes, span.trace_id);
          this._encodeId(bytes, span.span_id);
          this._encodeId(bytes, span.parent_id);
          this._encodeLong(bytes, span.start || 0);
          this._encodeLong(bytes, span.duration || 0);
          this._encodeInteger(bytes, span.error);
          this._encodeMap(bytes, span.meta || {});
          this._encodeMap(bytes, span.metrics || {});
          this._encodeString(bytes, span.type);
        }
      }
      _encodeString(bytes, value = "") {
        this._cacheString(value);
        this._encodeInteger(bytes, this._stringMap[value]);
      }
      _cacheString(value) {
        if (!(value in this._stringMap)) {
          this._stringMap[value] = this._stringCount++;
          this._stringBytes.write(value);
        }
      }
      _writeStrings(buffer, offset) {
        offset = this._writeArrayPrefix(buffer, offset, this._stringCount);
        offset += this._stringBytes.buffer.copy(buffer, offset, 0, this._stringBytes.length);
        return offset;
      }
    };
    module2.exports = { AgentEncoder };
  }
});

// ../../packages/dd-trace/src/exporters/agent/writer.js
var require_writer6 = __commonJS({
  "../../packages/dd-trace/src/exporters/agent/writer.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var { startupLog } = require_startup_log();
    var runtimeMetrics = require_runtime_metrics2();
    var log = require_log2();
    var tracerVersion = require_package().version;
    var BaseWriter = require_writer3();
    var METRIC_PREFIX = "datadog.tracer.node.exporter.agent";
    var Writer = class extends BaseWriter {
      constructor({ prioritySampler, lookup, protocolVersion, headers, config = {} }) {
        super(...arguments);
        const AgentEncoder = getEncoder(protocolVersion);
        this._prioritySampler = prioritySampler;
        this._lookup = lookup;
        this._protocolVersion = protocolVersion;
        this._headers = headers;
        this._config = config;
        this._encoder = new AgentEncoder(this);
      }
      _sendPayload(data, count, done) {
        runtimeMetrics.increment(`${METRIC_PREFIX}.requests`, true);
        const { _headers, _lookup, _protocolVersion, _url } = this;
        makeRequest(_protocolVersion, data, count, _url, _headers, _lookup, true, (err, res, status) => {
          if (status) {
            runtimeMetrics.increment(`${METRIC_PREFIX}.responses`, true);
            runtimeMetrics.increment(`${METRIC_PREFIX}.responses.by.status`, `status:${status}`, true);
          } else if (err) {
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors`, true);
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${err.name}`, true);
            if (err.code) {
              runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.code`, `code:${err.code}`, true);
            }
          }
          startupLog({ agentError: err });
          if (err) {
            log.errorWithoutTelemetry("Error sending payload to the agent (status code: %s)", err.status, err);
            done();
            return;
          }
          log.debug("Response from the agent: %s", res);
          try {
            this._prioritySampler.update(JSON.parse(res).rate_by_service);
          } catch (e) {
            log.error("Error updating prioritySampler rates", e);
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors`, true);
            runtimeMetrics.increment(`${METRIC_PREFIX}.errors.by.name`, `name:${e.name}`, true);
          }
          done();
        });
      }
    };
    function setHeader(headers, key, value) {
      if (value) {
        headers[key] = value;
      }
    }
    function getEncoder(protocolVersion) {
      return protocolVersion === "0.5" ? require__2().AgentEncoder : require__().AgentEncoder;
    }
    function makeRequest(version, data, count, url, headers, lookup, needsStartupLog, cb) {
      const options = {
        path: `/v${version}/traces`,
        method: "PUT",
        headers: {
          ...headers,
          "Content-Type": "application/msgpack",
          "Datadog-Meta-Tracer-Version": tracerVersion,
          "X-Datadog-Trace-Count": String(count)
        },
        lookup,
        url
      };
      setHeader(options.headers, "Datadog-Meta-Lang", "nodejs");
      setHeader(options.headers, "Datadog-Meta-Lang-Version", process.version);
      setHeader(options.headers, "Datadog-Meta-Lang-Interpreter", process.jsEngine || "v8");
      log.debug("Request to the agent: %j", options);
      request2(data, options, (err, res, status) => {
        if (needsStartupLog) {
          startupLog({
            agentError: status !== 404 && status !== 200 ? err : void 0
          });
        }
        cb(err, res, status);
      });
    }
    module2.exports = Writer;
  }
});

// ../../packages/dd-trace/src/exporters/agent/index.js
var require_agent = __commonJS({
  "../../packages/dd-trace/src/exporters/agent/index.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var log = require_log2();
    var Writer = require_writer6();
    var defaults = require_config_defaults();
    var AgentExporter = class {
      #timer;
      constructor(config, prioritySampler) {
        this._config = config;
        const { url, hostname = defaults.hostname, port, lookup, protocolVersion, stats = {}, apmTracingEnabled } = config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname,
          port
        }));
        const headers = {};
        if (stats.enabled || apmTracingEnabled === false) {
          headers["Datadog-Client-Computed-Stats"] = "yes";
        }
        this._writer = new Writer({
          url: this._url,
          prioritySampler,
          lookup,
          protocolVersion,
          headers,
          config
        });
        process.once("beforeExit", () => {
          this.flush();
        });
      }
      setUrl(url) {
        try {
          url = new URL2(url);
          this._url = url;
          this._writer.setUrl(url);
        } catch (e) {
          log.warn(e.stack);
        }
      }
      export(spans) {
        this._writer.append(spans);
        const { flushInterval } = this._config;
        if (flushInterval === 0) {
          this._writer.flush();
        } else if (this.#timer === void 0) {
          this.#timer = setTimeout(() => {
            this._writer.flush();
            this.#timer = void 0;
          }, flushInterval).unref();
        }
      }
      flush(done = () => {
      }) {
        clearTimeout(this.#timer);
        this.#timer = void 0;
        this._writer.flush(done);
      }
    };
    module2.exports = AgentExporter;
  }
});

// ../../node_modules/semifies/index.js
var require_semifies = __commonJS({
  "../../node_modules/semifies/index.js"(exports2, module2) {
    module2.exports = satisfies;
    function satisfies(v, t) {
      const [version] = parse(v, "");
      for (const checks of compile(t)) {
        if (checkAll(checks, version)) return true;
      }
      return false;
    }
    function checkAll(checks, v) {
      for (const [ok2, t] of checks) {
        if (!test(v, t, ok2)) return false;
      }
      return true;
    }
    function match(t) {
      if (t === "latest") t = ">=0";
      return t.match(/^([^\d+]*)(\d.*)$/) || [null, "", "*.*.*"];
    }
    function compile(t) {
      const result = [];
      let checks = [];
      const tokens = t.trim().split(/\s+/);
      for (let i = 0; i < tokens.length; i++) {
        const t2 = tokens[i];
        if (t2 === "-") continue;
        if (t2 === "||") {
          result.push(checks);
          checks = [];
          continue;
        }
        if (/^[<>=~v^]+$/.test(t2) && i + 1 < tokens.length) {
          tokens[i + 1] = t2 + tokens[i + 1];
          continue;
        }
        const res = match(t2);
        let cmp = res[1] || "=";
        if (cmp.endsWith("v")) cmp = cmp.slice(0, -1);
        let [v, c] = parse(res[2], cmp);
        if (i + 2 < tokens.length && tokens[i + 1] === "-") {
          const m = match(tokens[i + 2]);
          tokens[i + 2] = "<=" + (m[2].indexOf("-") === -1 ? m[2] + ".*.*" : m[2]);
          c = ">=";
        }
        if (c[0] === "~") {
          const digs = res[2].split("-")[0].split(".").length;
          checks.push([">=", v]);
          checks.push(["<", digs === 1 ? inc(v, 0) : digs === 2 ? inc(v, 1) : inc(v, 1)]);
        } else if (c[0] === "^") {
          const digs = v[0] !== 0 ? 0 : v[1] !== 0 ? 1 : 2;
          checks.push([">=", v]);
          checks.push(["<", digs === 0 ? inc(v, 0) : digs === 1 ? inc(v, 1) : inc(v, 2)]);
        } else {
          checks.push([c.replace("~", "").replace("^", ""), v]);
        }
      }
      if (checks.length) result.push(checks);
      return result;
    }
    function inc(v, n) {
      const cpy = v.slice(0);
      if (v[n] === -1) return cpy;
      cpy[n++]++;
      for (; n < 3; n++) cpy[n] = 0;
      return cpy;
    }
    function num(n) {
      return n === "x" || n === "X" || n === "*" || n === "latest" ? -1 : Number(n);
    }
    function numOrString(s) {
      return /^\d+$/.test(s) ? Number(s) : s;
    }
    function ok(c, a, b) {
      return b === -1 ? c !== "<" : c === "=" ? a === b : c === ">" ? a > b : c === ">=" ? a >= b : c === "<" ? a < b : c === "<=" ? a <= b : false;
    }
    function parse(v, c) {
      v = v.split("+")[0];
      const [a, b] = v.split("-");
      const nums = a.split(".").map(num).slice(0, 3);
      const last = Math.max(nums.length - 1, 0);
      if (c === ">") {
        c = ">=";
        nums.push(0, 0, 0);
        nums[last]++;
      } else if (c === "") {
        nums.push(0, 0, 0);
      } else {
        nums.push(-1, -1, -1);
      }
      if (!b) return [nums.slice(0, 3), c];
      return [nums.slice(0, 3).concat(b.split(".").map(numOrString)), c];
    }
    function test(v, t, c) {
      if (!ok("=", v[0], t[0])) return ok(c, v[0], t[0]);
      if (!ok("=", v[1], t[1])) return ok(c, v[1], t[1]);
      if (!ok("=", v[2], t[2])) return ok(c, v[2], t[2]);
      if (v.length === 3 && t.length === 3) return ok(c, v[2], t[2]);
      if (c[0] === "<" && (t.length === 3 || v.length === 3)) return false;
      if (c[0] === ">") {
        if (v.length === 3) return true;
        if (t.length === 3) return false;
      }
      for (let i = 3; i < Math.max(v.length, t.length); i++) {
        if (ok(c, v[i] || "", t[i] || "")) return true;
      }
      return false;
    }
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/percent.js
var require_percent = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/percent.js"(exports2, module2) {
    "use strict";
    module2.exports = function percent(covered, total) {
      let tmp;
      if (total > 0) {
        tmp = 1e3 * 100 * covered / total;
        return Math.floor(tmp / 10) / 100;
      } else {
        return 100;
      }
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/data-properties.js
var require_data_properties = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/data-properties.js"(exports2, module2) {
    "use strict";
    module2.exports = function dataProperties(klass, properties) {
      properties.forEach((p) => {
        Object.defineProperty(klass.prototype, p, {
          enumerable: true,
          get() {
            return this.data[p];
          }
        });
      });
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/coverage-summary.js
var require_coverage_summary = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/coverage-summary.js"(exports2, module2) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    function blankSummary() {
      const empty = () => ({
        total: 0,
        covered: 0,
        skipped: 0,
        pct: "Unknown"
      });
      return {
        lines: empty(),
        statements: empty(),
        functions: empty(),
        branches: empty(),
        branchesTrue: empty()
      };
    }
    function assertValidSummary(obj) {
      const valid = obj && obj.lines && obj.statements && obj.functions && obj.branches;
      if (!valid) {
        throw new Error(
          "Invalid summary coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    var CoverageSummary = class _CoverageSummary {
      /**
       * @constructor
       * @param {Object|CoverageSummary} [obj=undefined] an optional data object or
       * another coverage summary to initialize this object with.
       */
      constructor(obj) {
        if (!obj) {
          this.data = blankSummary();
        } else if (obj instanceof _CoverageSummary) {
          this.data = obj.data;
        } else {
          this.data = obj;
        }
        assertValidSummary(this.data);
      }
      /**
       * merges a second summary coverage object into this one
       * @param {CoverageSummary} obj - another coverage summary object
       */
      merge(obj) {
        const keys = [
          "lines",
          "statements",
          "branches",
          "functions",
          "branchesTrue"
        ];
        keys.forEach((key) => {
          if (obj[key]) {
            this[key].total += obj[key].total;
            this[key].covered += obj[key].covered;
            this[key].skipped += obj[key].skipped;
            this[key].pct = percent(this[key].covered, this[key].total);
          }
        });
        return this;
      }
      /**
       * returns a POJO that is JSON serializable. May be used to get the raw
       * summary object.
       */
      toJSON() {
        return this.data;
      }
      /**
       * return true if summary has no lines of code
       */
      isEmpty() {
        return this.lines.total === 0;
      }
    };
    dataProperties(CoverageSummary, [
      "lines",
      "statements",
      "functions",
      "branches",
      "branchesTrue"
    ]);
    module2.exports = {
      CoverageSummary
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/file-coverage.js
var require_file_coverage = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/file-coverage.js"(exports2, module2) {
    "use strict";
    var percent = require_percent();
    var dataProperties = require_data_properties();
    var { CoverageSummary } = require_coverage_summary();
    function emptyCoverage(filePath, reportLogic) {
      const cov = {
        path: filePath,
        statementMap: {},
        fnMap: {},
        branchMap: {},
        s: {},
        f: {},
        b: {}
      };
      if (reportLogic) cov.bT = {};
      return cov;
    }
    function assertValidObject(obj) {
      const valid = obj && obj.path && obj.statementMap && obj.fnMap && obj.branchMap && obj.s && obj.f && obj.b;
      if (!valid) {
        throw new Error(
          "Invalid file coverage object, missing keys, found:" + Object.keys(obj).join(",")
        );
      }
    }
    var keyFromLoc = ({ start, end }) => `${start.line}|${start.column}|${end.line}|${end.column}`;
    var isObj = (o) => !!o && typeof o === "object";
    var isLineCol = (o) => isObj(o) && typeof o.line === "number" && typeof o.column === "number";
    var isLoc = (o) => isObj(o) && isLineCol(o.start) && isLineCol(o.end);
    var getLoc = (o) => isLoc(o) ? o : isLoc(o.loc) ? o.loc : null;
    var findNearestContainer = (item, map) => {
      const itemLoc = getLoc(item);
      if (!itemLoc) return null;
      let nearestContainingItem = null;
      let containerDistance = null;
      let containerKey = null;
      for (const [i, mapItem] of Object.entries(map)) {
        const mapLoc = getLoc(mapItem);
        if (!mapLoc) continue;
        const distance = [
          itemLoc.start.line - mapLoc.start.line,
          itemLoc.start.column - mapLoc.start.column,
          mapLoc.end.line - itemLoc.end.line,
          mapLoc.end.column - itemLoc.end.column
        ];
        if (distance[0] < 0 || distance[2] < 0 || distance[0] === 0 && distance[1] < 0 || distance[2] === 0 && distance[3] < 0) {
          continue;
        }
        if (nearestContainingItem === null) {
          containerDistance = distance;
          nearestContainingItem = mapItem;
          containerKey = i;
          continue;
        }
        const closerBefore = distance[0] < containerDistance[0] || distance[0] === 0 && distance[1] < containerDistance[1];
        const closerAfter = distance[2] < containerDistance[2] || distance[2] === 0 && distance[3] < containerDistance[3];
        if (closerBefore || closerAfter) {
          containerDistance = distance;
          nearestContainingItem = mapItem;
          containerKey = i;
        }
      }
      return containerKey;
    };
    var addHits = (aHits, bHits) => {
      if (typeof aHits === "number" && typeof bHits === "number") {
        return aHits + bHits;
      } else if (Array.isArray(aHits) && Array.isArray(bHits)) {
        return aHits.map((a, i) => (a || 0) + (bHits[i] || 0));
      }
      return null;
    };
    var addNearestContainerHits = (item, itemHits, map, mapHits) => {
      const container = findNearestContainer(item, map);
      if (container) {
        return addHits(itemHits, mapHits[container]);
      } else {
        return itemHits;
      }
    };
    var mergeProp = (aHits, aMap, bHits, bMap, itemKey = keyFromLoc) => {
      const aItems = {};
      for (const [key, itemHits] of Object.entries(aHits)) {
        const item = aMap[key];
        aItems[itemKey(item)] = [itemHits, item];
      }
      const bItems = {};
      for (const [key, itemHits] of Object.entries(bHits)) {
        const item = bMap[key];
        bItems[itemKey(item)] = [itemHits, item];
      }
      const mergedItems = {};
      for (const [key, aValue] of Object.entries(aItems)) {
        let aItemHits = aValue[0];
        const aItem = aValue[1];
        const bValue = bItems[key];
        if (!bValue) {
          aItemHits = addNearestContainerHits(aItem, aItemHits, bMap, bHits);
        } else {
          aItemHits = addHits(aItemHits, bValue[0]);
        }
        mergedItems[key] = [aItemHits, aItem];
      }
      for (const [key, bValue] of Object.entries(bItems)) {
        let bItemHits = bValue[0];
        const bItem = bValue[1];
        if (mergedItems[key]) continue;
        bItemHits = addNearestContainerHits(bItem, bItemHits, aMap, aHits);
        mergedItems[key] = [bItemHits, bItem];
      }
      const hits = {};
      const map = {};
      Object.values(mergedItems).forEach(([itemHits, item], i) => {
        hits[i] = itemHits;
        map[i] = item;
      });
      return [hits, map];
    };
    var FileCoverage = class _FileCoverage {
      /**
       * @constructor
       * @param {Object|FileCoverage|String} pathOrObj is a string that initializes
       * and empty coverage object with the specified file path or a data object that
       * has all the required properties for a file coverage object.
       */
      constructor(pathOrObj, reportLogic = false) {
        if (!pathOrObj) {
          throw new Error(
            "Coverage must be initialized with a path or an object"
          );
        }
        if (typeof pathOrObj === "string") {
          this.data = emptyCoverage(pathOrObj, reportLogic);
        } else if (pathOrObj instanceof _FileCoverage) {
          this.data = pathOrObj.data;
        } else if (typeof pathOrObj === "object") {
          this.data = pathOrObj;
        } else {
          throw new Error("Invalid argument to coverage constructor");
        }
        assertValidObject(this.data);
      }
      /**
       * returns computed line coverage from statement coverage.
       * This is a map of hits keyed by line number in the source.
       */
      getLineCoverage() {
        const statementMap = this.data.statementMap;
        const statements = this.data.s;
        const lineMap = /* @__PURE__ */ Object.create(null);
        Object.entries(statements).forEach(([st, count]) => {
          if (!statementMap[st]) {
            return;
          }
          const { line } = statementMap[st].start;
          const prevVal = lineMap[line];
          if (prevVal === void 0 || prevVal < count) {
            lineMap[line] = count;
          }
        });
        return lineMap;
      }
      /**
       * returns an array of uncovered line numbers.
       * @returns {Array} an array of line numbers for which no hits have been
       *  collected.
       */
      getUncoveredLines() {
        const lc = this.getLineCoverage();
        const ret = [];
        Object.entries(lc).forEach(([l, hits]) => {
          if (hits === 0) {
            ret.push(l);
          }
        });
        return ret;
      }
      /**
       * returns a map of branch coverage by source line number.
       * @returns {Object} an object keyed by line number. Each object
       * has a `covered`, `total` and `coverage` (percentage) property.
       */
      getBranchCoverageByLine() {
        const branchMap = this.branchMap;
        const branches = this.b;
        const ret = {};
        Object.entries(branchMap).forEach(([k, map]) => {
          const line = map.line || map.loc.start.line;
          const branchData = branches[k];
          ret[line] = ret[line] || [];
          ret[line].push(...branchData);
        });
        Object.entries(ret).forEach(([k, dataArray]) => {
          const covered = dataArray.filter((item) => item > 0);
          const coverage = covered.length / dataArray.length * 100;
          ret[k] = {
            covered: covered.length,
            total: dataArray.length,
            coverage
          };
        });
        return ret;
      }
      /**
       * return a JSON-serializable POJO for this file coverage object
       */
      toJSON() {
        return this.data;
      }
      /**
       * merges a second coverage object into this one, updating hit counts
       * @param {FileCoverage} other - the coverage object to be merged into this one.
       *  Note that the other object should have the same structure as this one (same file).
       */
      merge(other) {
        if (other.all === true) {
          return;
        }
        if (this.all === true) {
          this.data = other.data;
          return;
        }
        let [hits, map] = mergeProp(
          this.s,
          this.statementMap,
          other.s,
          other.statementMap
        );
        this.data.s = hits;
        this.data.statementMap = map;
        const keyFromLocProp = (x) => keyFromLoc(x.loc);
        const keyFromLocationsProp = (x) => keyFromLoc(x.locations[0]);
        [hits, map] = mergeProp(
          this.f,
          this.fnMap,
          other.f,
          other.fnMap,
          keyFromLocProp
        );
        this.data.f = hits;
        this.data.fnMap = map;
        [hits, map] = mergeProp(
          this.b,
          this.branchMap,
          other.b,
          other.branchMap,
          keyFromLocationsProp
        );
        this.data.b = hits;
        this.data.branchMap = map;
        if (this.bT && other.bT) {
          [hits, map] = mergeProp(
            this.bT,
            this.branchMap,
            other.bT,
            other.branchMap,
            keyFromLocationsProp
          );
          this.data.bT = hits;
        }
      }
      computeSimpleTotals(property) {
        let stats = this[property];
        if (typeof stats === "function") {
          stats = stats.call(this);
        }
        const ret = {
          total: Object.keys(stats).length,
          covered: Object.values(stats).filter((v) => !!v).length,
          skipped: 0
        };
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      computeBranchTotals(property) {
        const stats = this[property];
        const ret = { total: 0, covered: 0, skipped: 0 };
        Object.values(stats).forEach((branches) => {
          ret.covered += branches.filter((hits) => hits > 0).length;
          ret.total += branches.length;
        });
        ret.pct = percent(ret.covered, ret.total);
        return ret;
      }
      /**
       * resets hit counts for all statements, functions and branches
       * in this coverage object resulting in zero coverage.
       */
      resetHits() {
        const statements = this.s;
        const functions = this.f;
        const branches = this.b;
        const branchesTrue = this.bT;
        Object.keys(statements).forEach((s) => {
          statements[s] = 0;
        });
        Object.keys(functions).forEach((f) => {
          functions[f] = 0;
        });
        Object.keys(branches).forEach((b) => {
          branches[b].fill(0);
        });
        if (branchesTrue) {
          Object.keys(branchesTrue).forEach((bT) => {
            branchesTrue[bT].fill(0);
          });
        }
      }
      /**
       * returns a CoverageSummary for this file coverage object
       * @returns {CoverageSummary}
       */
      toSummary() {
        const ret = {};
        ret.lines = this.computeSimpleTotals("getLineCoverage");
        ret.functions = this.computeSimpleTotals("f", "fnMap");
        ret.statements = this.computeSimpleTotals("s", "statementMap");
        ret.branches = this.computeBranchTotals("b");
        if (this.bT) {
          ret.branchesTrue = this.computeBranchTotals("bT");
        }
        return new CoverageSummary(ret);
      }
    };
    dataProperties(FileCoverage, [
      "path",
      "statementMap",
      "fnMap",
      "branchMap",
      "s",
      "f",
      "b",
      "bT",
      "all"
    ]);
    module2.exports = {
      FileCoverage,
      // exported for testing
      findNearestContainer,
      addHits,
      addNearestContainerHits
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/lib/coverage-map.js
var require_coverage_map = __commonJS({
  "../../node_modules/istanbul-lib-coverage/lib/coverage-map.js"(exports2, module2) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageSummary } = require_coverage_summary();
    function maybeConstruct(obj, klass) {
      if (obj instanceof klass) {
        return obj;
      }
      return new klass(obj);
    }
    function loadMap(source) {
      const data = /* @__PURE__ */ Object.create(null);
      if (!source) {
        return data;
      }
      Object.entries(source).forEach(([k, cov]) => {
        data[k] = maybeConstruct(cov, FileCoverage);
      });
      return data;
    }
    var CoverageMap = class _CoverageMap {
      /**
       * @constructor
       * @param {Object} [obj=undefined] obj A coverage map from which to initialize this
       * map's contents. This can be the raw global coverage object.
       */
      constructor(obj) {
        if (obj instanceof _CoverageMap) {
          this.data = obj.data;
        } else {
          this.data = loadMap(obj);
        }
      }
      /**
       * merges a second coverage map into this one
       * @param {CoverageMap} obj - a CoverageMap or its raw data. Coverage is merged
       *  correctly for the same files and additional file coverage keys are created
       *  as needed.
       */
      merge(obj) {
        const other = maybeConstruct(obj, _CoverageMap);
        Object.values(other.data).forEach((fc) => {
          this.addFileCoverage(fc);
        });
      }
      /**
       * filter the coveragemap based on the callback provided
       * @param {Function (filename)} callback - Returns true if the path
       *  should be included in the coveragemap. False if it should be
       *  removed.
       */
      filter(callback) {
        Object.keys(this.data).forEach((k) => {
          if (!callback(k)) {
            delete this.data[k];
          }
        });
      }
      /**
       * returns a JSON-serializable POJO for this coverage map
       * @returns {Object}
       */
      toJSON() {
        return this.data;
      }
      /**
       * returns an array for file paths for which this map has coverage
       * @returns {Array{string}} - array of files
       */
      files() {
        return Object.keys(this.data);
      }
      /**
       * returns the file coverage for the specified file.
       * @param {String} file
       * @returns {FileCoverage}
       */
      fileCoverageFor(file) {
        const fc = this.data[file];
        if (!fc) {
          throw new Error(`No file coverage available for: ${file}`);
        }
        return fc;
      }
      /**
       * adds a file coverage object to this map. If the path for the object,
       * already exists in the map, it is merged with the existing coverage
       * otherwise a new key is added to the map.
       * @param {FileCoverage} fc the file coverage to add
       */
      addFileCoverage(fc) {
        const cov = new FileCoverage(fc);
        const { path } = cov;
        if (this.data[path]) {
          this.data[path].merge(cov);
        } else {
          this.data[path] = cov;
        }
      }
      /**
       * returns the coverage summary for all the file coverage objects in this map.
       * @returns {CoverageSummary}
       */
      getCoverageSummary() {
        const ret = new CoverageSummary();
        Object.values(this.data).forEach((fc) => {
          ret.merge(fc.toSummary());
        });
        return ret;
      }
    };
    module2.exports = {
      CoverageMap
    };
  }
});

// ../../node_modules/istanbul-lib-coverage/index.js
var require_istanbul_lib_coverage = __commonJS({
  "../../node_modules/istanbul-lib-coverage/index.js"(exports2, module2) {
    "use strict";
    var { FileCoverage } = require_file_coverage();
    var { CoverageMap } = require_coverage_map();
    var { CoverageSummary } = require_coverage_summary();
    module2.exports = {
      /**
       * creates a coverage summary object
       * @param {Object} obj an argument with the same semantics
       *  as the one passed to the `CoverageSummary` constructor
       * @returns {CoverageSummary}
       */
      createCoverageSummary(obj) {
        if (obj && obj instanceof CoverageSummary) {
          return obj;
        }
        return new CoverageSummary(obj);
      },
      /**
       * creates a CoverageMap object
       * @param {Object} obj optional - an argument with the same semantics
       *  as the one passed to the CoverageMap constructor.
       * @returns {CoverageMap}
       */
      createCoverageMap(obj) {
        if (obj && obj instanceof CoverageMap) {
          return obj;
        }
        return new CoverageMap(obj);
      },
      /**
       * creates a FileCoverage object
       * @param {Object} obj optional - an argument with the same semantics
       *  as the one passed to the FileCoverage constructor.
       * @returns {FileCoverage}
       */
      createFileCoverage(obj) {
        if (obj && obj instanceof FileCoverage) {
          return obj;
        }
        return new FileCoverage(obj);
      }
    };
    module2.exports.classes = {
      /**
       * the file coverage constructor
       */
      FileCoverage
    };
  }
});

// ../../node_modules/ignore/index.js
var require_ignore = __commonJS({
  "../../node_modules/ignore/index.js"(exports2, module2) {
    function makeArray(subject) {
      return Array.isArray(subject) ? subject : [subject];
    }
    var UNDEFINED = void 0;
    var EMPTY = "";
    var SPACE = " ";
    var ESCAPE = "\\";
    var REGEX_TEST_BLANK_LINE = /^\s+$/;
    var REGEX_INVALID_TRAILING_BACKSLASH = /(?:[^\\]|^)\\$/;
    var REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
    var REGEX_REPLACE_LEADING_EXCAPED_HASH = /^\\#/;
    var REGEX_SPLITALL_CRLF = /\r?\n/g;
    var REGEX_TEST_INVALID_PATH = /^\.{0,2}\/|^\.{1,2}$/;
    var REGEX_TEST_TRAILING_SLASH = /\/$/;
    var SLASH = "/";
    var TMP_KEY_IGNORE = "node-ignore";
    if (typeof Symbol !== "undefined") {
      TMP_KEY_IGNORE = Symbol.for("node-ignore");
    }
    var KEY_IGNORE = TMP_KEY_IGNORE;
    var define2 = (object, key, value) => {
      Object.defineProperty(object, key, { value });
      return value;
    };
    var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
    var RETURN_FALSE = () => false;
    var sanitizeRange = (range) => range.replace(
      REGEX_REGEXP_RANGE,
      (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : EMPTY
    );
    var cleanRangeBackSlash = (slashes) => {
      const { length } = slashes;
      return slashes.slice(0, length - length % 2);
    };
    var REPLACERS = [
      [
        // Remove BOM
        // TODO:
        // Other similar zero-width characters?
        /^\uFEFF/,
        () => EMPTY
      ],
      // > Trailing spaces are ignored unless they are quoted with backslash ("\")
      [
        // (a\ ) -> (a )
        // (a  ) -> (a)
        // (a ) -> (a)
        // (a \ ) -> (a  )
        /((?:\\\\)*?)(\\?\s+)$/,
        (_2, m1, m2) => m1 + (m2.indexOf("\\") === 0 ? SPACE : EMPTY)
      ],
      // Replace (\ ) with ' '
      // (\ ) -> ' '
      // (\\ ) -> '\\ '
      // (\\\ ) -> '\\ '
      [
        /(\\+?)\s/g,
        (_2, m1) => {
          const { length } = m1;
          return m1.slice(0, length - length % 2) + SPACE;
        }
      ],
      // Escape metacharacters
      // which is written down by users but means special for regular expressions.
      // > There are 12 characters with special meanings:
      // > - the backslash \,
      // > - the caret ^,
      // > - the dollar sign $,
      // > - the period or dot .,
      // > - the vertical bar or pipe symbol |,
      // > - the question mark ?,
      // > - the asterisk or star *,
      // > - the plus sign +,
      // > - the opening parenthesis (,
      // > - the closing parenthesis ),
      // > - and the opening square bracket [,
      // > - the opening curly brace {,
      // > These special characters are often called "metacharacters".
      [
        /[\\$.|*+(){^]/g,
        (match) => `\\${match}`
      ],
      [
        // > a question mark (?) matches a single character
        /(?!\\)\?/g,
        () => "[^/]"
      ],
      // leading slash
      [
        // > A leading slash matches the beginning of the pathname.
        // > For example, "/*.c" matches "cat-file.c" but not "mozilla-sha1/sha1.c".
        // A leading slash matches the beginning of the pathname
        /^\//,
        () => "^"
      ],
      // replace special metacharacter slash after the leading slash
      [
        /\//g,
        () => "\\/"
      ],
      [
        // > A leading "**" followed by a slash means match in all directories.
        // > For example, "**/foo" matches file or directory "foo" anywhere,
        // > the same as pattern "foo".
        // > "**/foo/bar" matches file or directory "bar" anywhere that is directly
        // >   under directory "foo".
        // Notice that the '*'s have been replaced as '\\*'
        /^\^*\\\*\\\*\\\//,
        // '**/foo' <-> 'foo'
        () => "^(?:.*\\/)?"
      ],
      // starting
      [
        // there will be no leading '/'
        //   (which has been replaced by section "leading slash")
        // If starts with '**', adding a '^' to the regular expression also works
        /^(?=[^^])/,
        function startingReplacer() {
          return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
        }
      ],
      // two globstars
      [
        // Use lookahead assertions so that we could match more than one `'/**'`
        /\\\/\\\*\\\*(?=\\\/|$)/g,
        // Zero, one or several directories
        // should not use '*', or it will be replaced by the next replacer
        // Check if it is not the last `'/**'`
        (_2, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
      ],
      // normal intermediate wildcards
      [
        // Never replace escaped '*'
        // ignore rule '\*' will match the path '*'
        // 'abc.*/' -> go
        // 'abc.*'  -> skip this rule,
        //    coz trailing single wildcard will be handed by [trailing wildcard]
        /(^|[^\\]+)(\\\*)+(?=.+)/g,
        // '*.js' matches '.js'
        // '*.js' doesn't match 'abc'
        (_2, p1, p2) => {
          const unescaped = p2.replace(/\\\*/g, "[^\\/]*");
          return p1 + unescaped;
        }
      ],
      [
        // unescape, revert step 3 except for back slash
        // For example, if a user escape a '\\*',
        // after step 3, the result will be '\\\\\\*'
        /\\\\\\(?=[$.|*+(){^])/g,
        () => ESCAPE
      ],
      [
        // '\\\\' -> '\\'
        /\\\\/g,
        () => ESCAPE
      ],
      [
        // > The range notation, e.g. [a-zA-Z],
        // > can be used to match one of the characters in a range.
        // `\` is escaped by step 3
        /(\\)?\[([^\]/]*?)(\\*)($|\])/g,
        (match, leadEscape, range, endEscape, close) => leadEscape === ESCAPE ? `\\[${range}${cleanRangeBackSlash(endEscape)}${close}` : close === "]" ? endEscape.length % 2 === 0 ? `[${sanitizeRange(range)}${endEscape}]` : "[]" : "[]"
      ],
      // ending
      [
        // 'js' will not match 'js.'
        // 'ab' will not match 'abc'
        /(?:[^*])$/,
        // WTF!
        // https://git-scm.com/docs/gitignore
        // changes in [2.22.1](https://git-scm.com/docs/gitignore/2.22.1)
        // which re-fixes #24, #38
        // > If there is a separator at the end of the pattern then the pattern
        // > will only match directories, otherwise the pattern can match both
        // > files and directories.
        // 'js*' will not match 'a.js'
        // 'js/' will not match 'a.js'
        // 'js' will match 'a.js' and 'a.js/'
        (match) => /\/$/.test(match) ? `${match}$` : `${match}(?=$|\\/$)`
      ]
    ];
    var REGEX_REPLACE_TRAILING_WILDCARD = /(^|\\\/)?\\\*$/;
    var MODE_IGNORE = "regex";
    var MODE_CHECK_IGNORE = "checkRegex";
    var UNDERSCORE = "_";
    var TRAILING_WILD_CARD_REPLACERS = {
      [MODE_IGNORE](_2, p1) {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      },
      [MODE_CHECK_IGNORE](_2, p1) {
        const prefix = p1 ? `${p1}[^/]*` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    };
    var makeRegexPrefix = (pattern) => REPLACERS.reduce(
      (prev, [matcher, replacer]) => prev.replace(matcher, replacer.bind(pattern)),
      pattern
    );
    var isString = (subject) => typeof subject === "string";
    var checkPattern = (pattern) => pattern && isString(pattern) && !REGEX_TEST_BLANK_LINE.test(pattern) && !REGEX_INVALID_TRAILING_BACKSLASH.test(pattern) && pattern.indexOf("#") !== 0;
    var splitPattern = (pattern) => pattern.split(REGEX_SPLITALL_CRLF).filter(Boolean);
    var IgnoreRule = class {
      constructor(pattern, mark, body, ignoreCase, negative, prefix) {
        this.pattern = pattern;
        this.mark = mark;
        this.negative = negative;
        define2(this, "body", body);
        define2(this, "ignoreCase", ignoreCase);
        define2(this, "regexPrefix", prefix);
      }
      get regex() {
        const key = UNDERSCORE + MODE_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_IGNORE, key);
      }
      get checkRegex() {
        const key = UNDERSCORE + MODE_CHECK_IGNORE;
        if (this[key]) {
          return this[key];
        }
        return this._make(MODE_CHECK_IGNORE, key);
      }
      _make(mode, key) {
        const str = this.regexPrefix.replace(
          REGEX_REPLACE_TRAILING_WILDCARD,
          // It does not need to bind pattern
          TRAILING_WILD_CARD_REPLACERS[mode]
        );
        const regex = this.ignoreCase ? new RegExp(str, "i") : new RegExp(str);
        return define2(this, key, regex);
      }
    };
    var createRule = ({
      pattern,
      mark
    }, ignoreCase) => {
      let negative = false;
      let body = pattern;
      if (body.indexOf("!") === 0) {
        negative = true;
        body = body.substr(1);
      }
      body = body.replace(REGEX_REPLACE_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_REPLACE_LEADING_EXCAPED_HASH, "#");
      const regexPrefix = makeRegexPrefix(body);
      return new IgnoreRule(
        pattern,
        mark,
        body,
        ignoreCase,
        negative,
        regexPrefix
      );
    };
    var RuleManager = class {
      constructor(ignoreCase) {
        this._ignoreCase = ignoreCase;
        this._rules = [];
      }
      _add(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules._rules);
          this._added = true;
          return;
        }
        if (isString(pattern)) {
          pattern = {
            pattern
          };
        }
        if (checkPattern(pattern.pattern)) {
          const rule = createRule(pattern, this._ignoreCase);
          this._added = true;
          this._rules.push(rule);
        }
      }
      // @param {Array<string> | string | Ignore} pattern
      add(pattern) {
        this._added = false;
        makeArray(
          isString(pattern) ? splitPattern(pattern) : pattern
        ).forEach(this._add, this);
        return this._added;
      }
      // Test one single path without recursively checking parent directories
      //
      // - checkUnignored `boolean` whether should check if the path is unignored,
      //   setting `checkUnignored` to `false` could reduce additional
      //   path matching.
      // - check `string` either `MODE_IGNORE` or `MODE_CHECK_IGNORE`
      // @returns {TestResult} true if a file is ignored
      test(path, checkUnignored, mode) {
        let ignored = false;
        let unignored = false;
        let matchedRule;
        this._rules.forEach((rule) => {
          const { negative } = rule;
          if (unignored === negative && ignored !== unignored || negative && !ignored && !unignored && !checkUnignored) {
            return;
          }
          const matched = rule[mode].test(path);
          if (!matched) {
            return;
          }
          ignored = !negative;
          unignored = negative;
          matchedRule = negative ? UNDEFINED : rule;
        });
        const ret = {
          ignored,
          unignored
        };
        if (matchedRule) {
          ret.rule = matchedRule;
        }
        return ret;
      }
    };
    var throwError = (message, Ctor) => {
      throw new Ctor(message);
    };
    var checkPath = (path, originalPath, doThrow) => {
      if (!isString(path)) {
        return doThrow(
          `path must be a string, but got \`${originalPath}\``,
          TypeError
        );
      }
      if (!path) {
        return doThrow(`path must not be empty`, TypeError);
      }
      if (checkPath.isNotRelative(path)) {
        const r = "`path.relative()`d";
        return doThrow(
          `path should be a ${r} string, but got "${originalPath}"`,
          RangeError
        );
      }
      return true;
    };
    var isNotRelative = (path) => REGEX_TEST_INVALID_PATH.test(path);
    checkPath.isNotRelative = isNotRelative;
    checkPath.convert = (p) => p;
    var Ignore = class {
      constructor({
        ignorecase = true,
        ignoreCase = ignorecase,
        allowRelativePaths = false
      } = {}) {
        define2(this, KEY_IGNORE, true);
        this._rules = new RuleManager(ignoreCase);
        this._strictPathCheck = !allowRelativePaths;
        this._initCache();
      }
      _initCache() {
        this._ignoreCache = /* @__PURE__ */ Object.create(null);
        this._testCache = /* @__PURE__ */ Object.create(null);
      }
      add(pattern) {
        if (this._rules.add(pattern)) {
          this._initCache();
        }
        return this;
      }
      // legacy
      addPattern(pattern) {
        return this.add(pattern);
      }
      // @returns {TestResult}
      _test(originalPath, cache, checkUnignored, slices) {
        const path = originalPath && checkPath.convert(originalPath);
        checkPath(
          path,
          originalPath,
          this._strictPathCheck ? throwError : RETURN_FALSE
        );
        return this._t(path, cache, checkUnignored, slices);
      }
      checkIgnore(path) {
        if (!REGEX_TEST_TRAILING_SLASH.test(path)) {
          return this.test(path);
        }
        const slices = path.split(SLASH).filter(Boolean);
        slices.pop();
        if (slices.length) {
          const parent = this._t(
            slices.join(SLASH) + SLASH,
            this._testCache,
            true,
            slices
          );
          if (parent.ignored) {
            return parent;
          }
        }
        return this._rules.test(path, false, MODE_CHECK_IGNORE);
      }
      _t(path, cache, checkUnignored, slices) {
        if (path in cache) {
          return cache[path];
        }
        if (!slices) {
          slices = path.split(SLASH).filter(Boolean);
        }
        slices.pop();
        if (!slices.length) {
          return cache[path] = this._rules.test(path, checkUnignored, MODE_IGNORE);
        }
        const parent = this._t(
          slices.join(SLASH) + SLASH,
          cache,
          checkUnignored,
          slices
        );
        return cache[path] = parent.ignored ? parent : this._rules.test(path, checkUnignored, MODE_IGNORE);
      }
      ignores(path) {
        return this._test(path, this._ignoreCache, false).ignored;
      }
      createFilter() {
        return (path) => !this.ignores(path);
      }
      filter(paths) {
        return makeArray(paths).filter(this.createFilter());
      }
      // @returns {TestResult}
      test(path) {
        return this._test(path, this._testCache, true);
      }
    };
    var factory = (options) => new Ignore(options);
    var isPathValid = (path) => checkPath(path && checkPath.convert(path), path, RETURN_FALSE);
    var setupWindows = () => {
      const makePosix = (str) => /^\\\\\?\\/.test(str) || /["<>|\u0000-\u001F]+/u.test(str) ? str : str.replace(/\\/g, "/");
      checkPath.convert = makePosix;
      const REGEX_TEST_WINDOWS_PATH_ABSOLUTE = /^[a-z]:\//i;
      checkPath.isNotRelative = (path) => REGEX_TEST_WINDOWS_PATH_ABSOLUTE.test(path) || isNotRelative(path);
    };
    if (
      // Detect `process` so that it can run in browsers.
      typeof process !== "undefined" && process.platform === "win32"
    ) {
      setupWindows();
    }
    module2.exports = factory;
    factory.default = factory;
    module2.exports.isPathValid = isPathValid;
    define2(module2.exports, Symbol.for("setupWindows"), setupWindows);
  }
});

// ../../packages/dd-trace/src/plugins/util/tags.js
var require_tags2 = __commonJS({
  "../../packages/dd-trace/src/plugins/util/tags.js"(exports2, module2) {
    "use strict";
    var GIT_COMMIT_SHA = "git.commit.sha";
    var GIT_BRANCH = "git.branch";
    var GIT_REPOSITORY_URL = "git.repository_url";
    var GIT_TAG = "git.tag";
    var GIT_COMMIT_MESSAGE = "git.commit.message";
    var GIT_COMMIT_COMMITTER_DATE = "git.commit.committer.date";
    var GIT_COMMIT_COMMITTER_EMAIL = "git.commit.committer.email";
    var GIT_COMMIT_COMMITTER_NAME = "git.commit.committer.name";
    var GIT_COMMIT_AUTHOR_DATE = "git.commit.author.date";
    var GIT_COMMIT_AUTHOR_EMAIL = "git.commit.author.email";
    var GIT_COMMIT_AUTHOR_NAME = "git.commit.author.name";
    var GIT_COMMIT_HEAD_SHA = "git.commit.head.sha";
    var GIT_COMMIT_HEAD_MESSAGE = "git.commit.head.message";
    var GIT_COMMIT_HEAD_AUTHOR_DATE = "git.commit.head.author.date";
    var GIT_COMMIT_HEAD_AUTHOR_EMAIL = "git.commit.head.author.email";
    var GIT_COMMIT_HEAD_AUTHOR_NAME = "git.commit.head.author.name";
    var GIT_COMMIT_HEAD_COMMITTER_DATE = "git.commit.head.committer.date";
    var GIT_COMMIT_HEAD_COMMITTER_EMAIL = "git.commit.head.committer.email";
    var GIT_COMMIT_HEAD_COMMITTER_NAME = "git.commit.head.committer.name";
    var GIT_PULL_REQUEST_BASE_BRANCH_SHA = "git.pull_request.base_branch_sha";
    var GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA = "git.pull_request.base_branch_head_sha";
    var GIT_PULL_REQUEST_BASE_BRANCH = "git.pull_request.base_branch";
    var CI_PIPELINE_ID = "ci.pipeline.id";
    var CI_PIPELINE_NAME = "ci.pipeline.name";
    var CI_PIPELINE_NUMBER = "ci.pipeline.number";
    var CI_PIPELINE_URL = "ci.pipeline.url";
    var CI_PROVIDER_NAME = "ci.provider.name";
    var CI_WORKSPACE_PATH = "ci.workspace_path";
    var CI_JOB_URL = "ci.job.url";
    var CI_JOB_NAME = "ci.job.name";
    var CI_JOB_ID = "ci.job.id";
    var CI_STAGE_NAME = "ci.stage.name";
    var CI_NODE_NAME = "ci.node.name";
    var CI_NODE_LABELS = "ci.node.labels";
    var CI_ENV_VARS = "_dd.ci.env_vars";
    var PR_NUMBER = "pr.number";
    module2.exports = {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_HEAD_SHA,
      GIT_COMMIT_HEAD_MESSAGE,
      GIT_COMMIT_HEAD_AUTHOR_DATE,
      GIT_COMMIT_HEAD_AUTHOR_EMAIL,
      GIT_COMMIT_HEAD_AUTHOR_NAME,
      GIT_COMMIT_HEAD_COMMITTER_DATE,
      GIT_COMMIT_HEAD_COMMITTER_EMAIL,
      GIT_COMMIT_HEAD_COMMITTER_NAME,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_JOB_ID,
      CI_STAGE_NAME,
      CI_ENV_VARS,
      CI_NODE_NAME,
      CI_NODE_LABELS,
      PR_NUMBER
    };
  }
});

// ../../packages/dd-trace/src/ci-visibility/telemetry.js
var require_telemetry = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/telemetry.js"(exports2, module2) {
    "use strict";
    var telemetryMetrics = require_metrics();
    var ciVisibilityMetrics = telemetryMetrics.manager.namespace("civisibility");
    var formattedTags = {
      testLevel: "event_type",
      testFramework: "test_framework",
      errorType: "error_type",
      exitCode: "exit_code",
      isCodeCoverageEnabled: "coverage_enabled",
      isSuitesSkippingEnabled: "itrskip_enabled",
      hasCodeOwners: "has_code_owners",
      isUnsupportedCIProvider: "is_unsupported_ci",
      isNew: "is_new",
      isRum: "is_rum",
      browserDriver: "browser_driver",
      autoInjected: "auto_injected"
    };
    function formatMetricTags(tagsDictionary) {
      return Object.keys(tagsDictionary).reduce((acc, tagKey) => {
        if (tagKey === "statusCode") {
          const statusCode = tagsDictionary[tagKey];
          if (isStatusCode400(statusCode)) {
            acc.push(`status_code:${statusCode}`);
          }
          acc.push(`error_type:${getErrorTypeFromStatusCode(statusCode)}`);
          return acc;
        }
        const formattedTagKey = formattedTags[tagKey] || tagKey;
        if (tagsDictionary[tagKey] === true) {
          acc.push(formattedTagKey);
        } else if (tagsDictionary[tagKey] !== void 0 && tagsDictionary[tagKey] !== null) {
          acc.push(`${formattedTagKey}:${tagsDictionary[tagKey]}`);
        }
        return acc;
      }, []);
    }
    function incrementCountMetric(name, tags = {}, value = 1) {
      ciVisibilityMetrics.count(name, formatMetricTags(tags)).inc(value);
    }
    function distributionMetric(name, tags, measure) {
      ciVisibilityMetrics.distribution(name, formatMetricTags(tags)).track(measure);
    }
    var TELEMETRY_TEST_SESSION = "test_session";
    var TELEMETRY_EVENT_CREATED = "event_created";
    var TELEMETRY_EVENT_FINISHED = "event_finished";
    var TELEMETRY_CODE_COVERAGE_STARTED = "code_coverage_started";
    var TELEMETRY_CODE_COVERAGE_FINISHED = "code_coverage_finished";
    var TELEMETRY_ITR_SKIPPED = "itr_skipped";
    var TELEMETRY_ITR_UNSKIPPABLE = "itr_unskippable";
    var TELEMETRY_ITR_FORCED_TO_RUN = "itr_forced_run";
    var TELEMETRY_CODE_COVERAGE_EMPTY = "code_coverage.is_empty";
    var TELEMETRY_CODE_COVERAGE_NUM_FILES = "code_coverage.files";
    var TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION = "events_enqueued_for_serialization";
    var TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS = "endpoint_payload.events_serialization_ms";
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS = "endpoint_payload.requests";
    var TELEMETRY_ENDPOINT_PAYLOAD_BYTES = "endpoint_payload.bytes";
    var TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT = "endpoint_payload.events_count";
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS = "endpoint_payload.requests_ms";
    var TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS = "endpoint_payload.requests_errors";
    var TELEMETRY_ENDPOINT_PAYLOAD_DROPPED = "endpoint_payload.dropped";
    var TELEMETRY_GIT_COMMAND = "git.command";
    var TELEMETRY_GIT_COMMAND_MS = "git.command_ms";
    var TELEMETRY_GIT_COMMAND_ERRORS = "git.command_errors";
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS = "git_requests.search_commits";
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS = "git_requests.search_commits_ms";
    var TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS = "git_requests.search_commits_errors";
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES = "git_requests.objects_pack";
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS = "git_requests.objects_pack_ms";
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS = "git_requests.objects_pack_errors";
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM = "git_requests.objects_pack_files";
    var TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES = "git_requests.objects_pack_bytes";
    var TELEMETRY_GIT_REQUESTS_SETTINGS = "git_requests.settings";
    var TELEMETRY_GIT_REQUESTS_SETTINGS_MS = "git_requests.settings_ms";
    var TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS = "git_requests.settings_errors";
    var TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE = "git_requests.settings_response";
    var TELEMETRY_GIT_SHA_MATCH = "git.commit_sha_match";
    var TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY = "git.commit_sha_discrepancy";
    var TELEMETRY_ITR_SKIPPABLE_TESTS = "itr_skippable_tests.request";
    var TELEMETRY_ITR_SKIPPABLE_TESTS_MS = "itr_skippable_tests.request_ms";
    var TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS = "itr_skippable_tests.request_errors";
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES = "itr_skippable_tests.response_suites";
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS = "itr_skippable_tests.response_tests";
    var TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES = "itr_skippable_tests.response_bytes";
    var TELEMETRY_KNOWN_TESTS = "early_flake_detection.request";
    var TELEMETRY_KNOWN_TESTS_MS = "early_flake_detection.request_ms";
    var TELEMETRY_KNOWN_TESTS_ERRORS = "early_flake_detection.request_errors";
    var TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS = "early_flake_detection.response_tests";
    var TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES = "early_flake_detection.response_bytes";
    function isStatusCode400(statusCode) {
      return statusCode >= 400 && statusCode < 500;
    }
    function getErrorTypeFromStatusCode(statusCode) {
      if (statusCode >= 400 && statusCode < 500) {
        return "status_code_4xx_response";
      }
      if (statusCode >= 500) {
        return "status_code_5xx_response";
      }
      return "network";
    }
    module2.exports = {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_TEST_SESSION,
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_SKIPPED,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION,
      TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
      TELEMETRY_GIT_COMMAND,
      TELEMETRY_GIT_COMMAND_MS,
      TELEMETRY_GIT_COMMAND_ERRORS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_MS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE,
      TELEMETRY_GIT_SHA_MATCH,
      TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY,
      TELEMETRY_ITR_SKIPPABLE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_MS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES,
      TELEMETRY_KNOWN_TESTS,
      TELEMETRY_KNOWN_TESTS_MS,
      TELEMETRY_KNOWN_TESTS_ERRORS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/url.js
var require_url2 = __commonJS({
  "../../packages/dd-trace/src/plugins/util/url.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = __require("url");
    function filterSensitiveInfoFromRepository(repositoryUrl) {
      if (!repositoryUrl) {
        return "";
      }
      if (repositoryUrl.startsWith("git@")) {
        return repositoryUrl;
      }
      if (repositoryUrl.startsWith("ssh://")) {
        const sshRegex = /^(ssh:\/\/)[^@/]*@/;
        return repositoryUrl.replace(sshRegex, "$1");
      }
      try {
        const { protocol, host, pathname } = new URL2(repositoryUrl);
        return `${protocol}//${host}${pathname === "/" ? "" : pathname}`;
      } catch {
        return "";
      }
    }
    module2.exports = { filterSensitiveInfoFromRepository };
  }
});

// ../../packages/dd-trace/src/plugins/util/git-cache.js
var require_git_cache = __commonJS({
  "../../packages/dd-trace/src/plugins/util/git-cache.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var path = __require("path");
    var fs = __require("fs");
    var crypto = __require("crypto");
    var cp = __require("child_process");
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var { isTrue } = require_util();
    var isGitEnabled = isTrue(getEnvironmentVariable("DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_ENABLED"));
    var GIT_CACHE_DIR = getEnvironmentVariable("DD_EXPERIMENTAL_TEST_OPT_GIT_CACHE_DIR") || path.join(os.tmpdir(), "dd-trace-git-cache");
    function ensureCacheDir() {
      if (!isGitEnabled) return false;
      try {
        if (fs.existsSync(GIT_CACHE_DIR)) {
          const stats = fs.statSync(GIT_CACHE_DIR);
          if (!stats.isDirectory()) {
            throw new Error(`Cache directory path exists but is not a directory: ${GIT_CACHE_DIR}`);
          }
        } else {
          fs.mkdirSync(GIT_CACHE_DIR, { recursive: true });
        }
        return true;
      } catch (err) {
        log.error("Failed to create git cache directory, disabling cache", err);
        isGitEnabled = false;
        return false;
      }
    }
    ensureCacheDir();
    function getCacheKey(cmd, flags) {
      const commandString = `${cmd} ${flags.join(" ")}`;
      return crypto.createHash("sha256").update(commandString).digest("hex");
    }
    function getCacheFilePath(cacheKey) {
      return path.join(GIT_CACHE_DIR, `${cacheKey}.cache`);
    }
    function getCache(cacheKey) {
      if (!isGitEnabled) return null;
      try {
        const cacheFilePath = getCacheFilePath(cacheKey);
        if (!fs.existsSync(cacheFilePath)) {
          return null;
        }
        const content = fs.readFileSync(cacheFilePath, "utf8");
        return content;
      } catch (err) {
        log.error("Failed to read git cache", err);
        return null;
      }
    }
    function setCache(cacheKey, result) {
      if (!isGitEnabled) return;
      if (!ensureCacheDir()) return;
      try {
        const cacheFilePath = getCacheFilePath(cacheKey);
        fs.writeFileSync(cacheFilePath, result, "utf8");
      } catch (err) {
        log.error("Failed to write git cache", err);
      }
    }
    function cachedExec(cmd, flags, options) {
      if (options === void 0) {
        options = { stdio: "pipe" };
      }
      if (!isGitEnabled) {
        return cp.execFileSync(cmd, flags, options);
      }
      const cacheKey = getCacheKey(cmd, flags);
      const cachedResult = getCache(cacheKey);
      if (cachedResult !== null) {
        if (cachedResult.startsWith("__GIT_COMMAND_FAILED__")) {
          let error;
          try {
            const errorData = cachedResult.replace("__GIT_COMMAND_FAILED__", "");
            const { message, code, status, errno } = JSON.parse(errorData);
            error = new Error(message);
            error.code = code;
            error.status = status;
            error.errno = errno;
          } catch {
            throw new Error("Git command failed");
          }
          throw error;
        }
        return cachedResult;
      }
      try {
        const result = cp.execFileSync(cmd, flags, options);
        setCache(cacheKey, result);
        return result;
      } catch (err) {
        const cacheValue = "__GIT_COMMAND_FAILED__" + JSON.stringify({
          code: err.code,
          status: err.status,
          errno: err.errno,
          message: err.message
        });
        setCache(cacheKey, cacheValue);
        throw err;
      }
    }
    module2.exports = {
      getCacheKey,
      getCacheFilePath,
      cachedExec
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/git.js
var require_git = __commonJS({
  "../../packages/dd-trace/src/plugins/util/git.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var path = __require("path");
    var fs = __require("fs");
    var log = require_log2();
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      CI_WORKSPACE_PATH,
      GIT_COMMIT_HEAD_AUTHOR_DATE,
      GIT_COMMIT_HEAD_AUTHOR_EMAIL,
      GIT_COMMIT_HEAD_AUTHOR_NAME,
      GIT_COMMIT_HEAD_COMMITTER_DATE,
      GIT_COMMIT_HEAD_COMMITTER_EMAIL,
      GIT_COMMIT_HEAD_COMMITTER_NAME,
      GIT_COMMIT_HEAD_MESSAGE
    } = require_tags2();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_COMMAND,
      TELEMETRY_GIT_COMMAND_MS,
      TELEMETRY_GIT_COMMAND_ERRORS
    } = require_telemetry();
    var { filterSensitiveInfoFromRepository } = require_url2();
    var { storage } = require_datadog_core();
    var { cachedExec } = require_git_cache();
    var GIT_REV_LIST_MAX_BUFFER = 12 * 1024 * 1024;
    function sanitizedExec(cmd, flags, operationMetric, durationMetric, errorMetric, shouldTrim = true) {
      const store = storage("legacy").getStore();
      storage("legacy").enterWith({ noop: true });
      let startTime;
      if (operationMetric) {
        incrementCountMetric(operationMetric.name, operationMetric.tags);
      }
      if (durationMetric) {
        startTime = Date.now();
      }
      try {
        let result = cachedExec(cmd, flags, { stdio: "pipe" }).toString();
        if (shouldTrim) {
          result = result.replaceAll(/(\r\n|\n|\r)/gm, "");
        }
        if (durationMetric) {
          distributionMetric(durationMetric.name, durationMetric.tags, Date.now() - startTime);
        }
        return result;
      } catch (err) {
        if (errorMetric) {
          incrementCountMetric(errorMetric.name, {
            ...errorMetric.tags,
            errorType: err.code,
            exitCode: err.status || err.errno
          });
        }
        log.error("Git plugin error executing command", err);
        return "";
      } finally {
        storage("legacy").enterWith(store);
      }
    }
    function isDirectory(path2) {
      try {
        const stats = fs.statSync(path2);
        return stats.isDirectory();
      } catch {
        return false;
      }
    }
    function isGitAvailable() {
      const isWindows = os.platform() === "win32";
      const command = isWindows ? "where" : "which";
      try {
        cachedExec(command, ["git"]);
        return true;
      } catch {
        incrementCountMetric(TELEMETRY_GIT_COMMAND_ERRORS, { command: "check_git", exitCode: "missing" });
        return false;
      }
    }
    function isShallowRepository() {
      return sanitizedExec(
        "git",
        ["rev-parse", "--is-shallow-repository"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "check_shallow" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "check_shallow" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "check_shallow" } }
      ) === "true";
    }
    function getGitVersion() {
      const gitVersionString = sanitizedExec("git", ["version"]);
      const gitVersionMatches = (
        /** @type {RegExpMatchArray} */
        gitVersionString.match(/git version (\d+)\.(\d+)\.(\d+)/)
      );
      try {
        return {
          major: Number.parseInt(gitVersionMatches[1]),
          minor: Number.parseInt(gitVersionMatches[2]),
          patch: Number.parseInt(gitVersionMatches[3])
        };
      } catch {
        return null;
      }
    }
    function unshallowRepository(parentOnly = false) {
      const gitVersion = getGitVersion();
      if (!gitVersion) {
        log.warn("Git version could not be extracted, so git unshallow will not proceed");
        return;
      }
      if (gitVersion.major < 2 || gitVersion.major === 2 && gitVersion.minor < 27) {
        log.warn("Git version is <2.27, so git unshallow will not proceed");
        return;
      }
      const defaultRemoteName = sanitizedExec("git", ["config", "--default", "origin", "--get", "clone.defaultRemoteName"]);
      const revParseHead = sanitizedExec("git", ["rev-parse", "HEAD"]);
      const baseGitOptions = [
        "fetch",
        parentOnly ? "--deepen=1" : '--shallow-since="1 month ago"',
        "--update-shallow",
        "--filter=blob:none",
        "--recurse-submodules=no",
        defaultRemoteName
      ];
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: "unshallow" });
      const start = Date.now();
      let flags = [
        ...baseGitOptions,
        revParseHead
      ];
      try {
        cachedExec("git", flags);
      } catch (err) {
        log.warn(`Git unshallow failed: ${flags.join(" ")}`);
        incrementCountMetric(
          TELEMETRY_GIT_COMMAND_ERRORS,
          { command: "unshallow", errorType: err.code, exitCode: err.status || err.errno }
        );
        const upstreamRemote = sanitizedExec(
          "git",
          ["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"]
        );
        flags = [
          ...baseGitOptions,
          upstreamRemote
        ];
        try {
          cachedExec("git", flags);
        } catch (err2) {
          log.warn(`Git unshallow failed again: ${flags.join(" ")}`);
          incrementCountMetric(
            TELEMETRY_GIT_COMMAND_ERRORS,
            { command: "unshallow", errorType: err2.code, exitCode: err2.status || err2.errno }
          );
          sanitizedExec(
            "git",
            baseGitOptions,
            null,
            null,
            { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "unshallow" } }
            // we log the error in sanitizedExec
          );
        }
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: "unshallow" }, Date.now() - start);
    }
    function getRepositoryUrl() {
      return sanitizedExec(
        "git",
        ["config", "--get", "remote.origin.url"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_repository" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_repository" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_repository" } }
      );
    }
    function getLatestCommits() {
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: "get_local_commits" });
      const startTime = Date.now();
      try {
        const result = cachedExec("git", ["log", "--format=%H", "-n 1000", '--since="1 month ago"']).toString().split("\n").filter(Boolean);
        distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: "get_local_commits" }, Date.now() - startTime);
        return result;
      } catch (err) {
        log.error("Get latest commits failed: %s", err.message);
        incrementCountMetric(
          TELEMETRY_GIT_COMMAND_ERRORS,
          { command: "get_local_commits", errorType: err.status }
        );
        return [];
      }
    }
    function getGitDiff(baseCommit, targetCommit) {
      const flags = ["diff", "-U0", "--word-diff=porcelain", baseCommit];
      if (targetCommit) {
        flags.push(targetCommit);
      }
      return sanitizedExec(
        "git",
        flags,
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "diff" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "diff" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "diff" } },
        false
        // important not to trim or we'll lose the line breaks which we need to detect impacted tests
      );
    }
    function getGitRemoteName() {
      const upstreamRemote = sanitizedExec(
        "git",
        ["rev-parse", "--abbrev-ref", "--symbolic-full-name", "@{upstream}"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_remote_name" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_remote_name" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_remote_name" } }
      );
      if (upstreamRemote) {
        return upstreamRemote.split("/")[0];
      }
      const remotes = sanitizedExec(
        "git",
        ["remote"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_remote_name" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_remote_name" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_remote_name" } },
        false
      );
      return remotes.split("\n")[0] || "origin";
    }
    function getSourceBranch() {
      return sanitizedExec(
        "git",
        ["rev-parse", "--abbrev-ref", "HEAD"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_source_branch" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_source_branch" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_source_branch" } }
      );
    }
    function checkAndFetchBranch(branch, remoteName) {
      try {
        cachedExec(
          "git",
          ["show-ref", "--verify", "--quiet", `refs/remotes/${remoteName}/${branch}`]
        );
      } catch {
        try {
          const remoteHeads = cachedExec(
            "git",
            ["ls-remote", "--heads", remoteName, branch],
            { stdio: "pipe", timeout: 2e3 }
          );
          if (remoteHeads) {
            cachedExec(
              "git",
              ["fetch", "--depth", "1", remoteName, branch],
              { stdio: "pipe", timeout: 5e3 }
            );
          }
        } catch (err) {
          log.debug("Git plugin error checking and fetching branch", err);
        }
      }
    }
    function getLocalBranches(remoteName) {
      const localBranches = sanitizedExec(
        "git",
        ["for-each-ref", "--format=%(refname:short)", `refs/remotes/${remoteName}`],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_local_branches" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_local_branches" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_local_branches" } },
        false
      );
      try {
        return localBranches.split("\n").filter(Boolean);
      } catch {
        return [];
      }
    }
    function getMergeBase(baseBranch, sourceBranch) {
      return sanitizedExec(
        "git",
        ["merge-base", baseBranch, sourceBranch],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_merge_base" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_merge_base" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_merge_base" } }
      );
    }
    function getCounts(sourceBranch, candidateBranch) {
      const counts = sanitizedExec(
        "git",
        ["rev-list", "--left-right", "--count", `${candidateBranch}...${sourceBranch}`],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_counts" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_counts" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_counts" } }
      );
      try {
        if (!counts) {
          return { behind: null, ahead: null };
        }
        const [behind, ahead] = counts.split(/\s+/).map(Number);
        return { behind, ahead };
      } catch {
        return { behind: null, ahead: null };
      }
    }
    function getCommitsRevList(commitsToExclude, commitsToInclude) {
      let result = null;
      const commitsToExcludeString = commitsToExclude.map((commit) => `^${commit}`);
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: "get_objects" });
      const startTime = Date.now();
      try {
        result = cachedExec(
          "git",
          [
            "rev-list",
            "--objects",
            "--no-object-names",
            "--filter=blob:none",
            '--since="1 month ago"',
            ...commitsToExcludeString,
            ...commitsToInclude
          ],
          { stdio: "pipe", maxBuffer: GIT_REV_LIST_MAX_BUFFER }
        ).toString().split("\n").filter(Boolean);
      } catch (err) {
        log.error("Get commits to upload failed: %s", err.message);
        incrementCountMetric(
          TELEMETRY_GIT_COMMAND_ERRORS,
          { command: "get_objects", errorType: err.code, exitCode: err.status || err.errno }
          // err.status might be null
        );
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: "get_objects" }, Date.now() - startTime);
      return result;
    }
    function generatePackFilesForCommits(commitsToUpload) {
      let result = [];
      const tmpFolder = os.tmpdir();
      if (!isDirectory(tmpFolder)) {
        log.error(new Error("Provided path to generate packfiles is not a directory"));
        return [];
      }
      const randomPrefix = String(Math.floor(Math.random() * 1e4));
      const temporaryPath = path.join(tmpFolder, randomPrefix);
      const cwdPath = path.join(process.cwd(), randomPrefix);
      incrementCountMetric(TELEMETRY_GIT_COMMAND, { command: "pack_objects" });
      const startTime = Date.now();
      function execGitPackObjects(targetPath) {
        return cachedExec(
          "git",
          [
            "pack-objects",
            "--compression=9",
            "--max-pack-size=3m",
            targetPath
          ],
          { stdio: "pipe", input: commitsToUpload.join("\n") }
        ).toString().split("\n").filter(Boolean).map((commit) => `${targetPath}-${commit}.pack`);
      }
      try {
        result = execGitPackObjects(temporaryPath);
      } catch (err) {
        log.error("Git plugin error executing git pack-objects command", err);
        incrementCountMetric(
          TELEMETRY_GIT_COMMAND_ERRORS,
          { command: "pack_objects", exitCode: err.status || err.errno, errorType: err.code }
        );
        try {
          result = execGitPackObjects(cwdPath);
        } catch (err2) {
          log.error("Git plugin error executing fallback git pack-objects command", err2);
          incrementCountMetric(
            TELEMETRY_GIT_COMMAND_ERRORS,
            { command: "pack_objects", exitCode: err2.status || err2.errno, errorType: err2.code }
          );
        }
      }
      distributionMetric(TELEMETRY_GIT_COMMAND_MS, { command: "pack_objects" }, Date.now() - startTime);
      return result;
    }
    function getRepositoryRoot() {
      return sanitizedExec(
        "git",
        ["rev-parse", "--show-toplevel"]
      );
    }
    function getGitMetadata(ciMetadata) {
      const {
        commitSHA,
        branch,
        repositoryUrl,
        tag,
        commitMessage,
        authorName: ciAuthorName,
        authorEmail: ciAuthorEmail,
        ciWorkspacePath,
        headCommitSha
      } = ciMetadata;
      const [
        authorName,
        authorEmail,
        authorDate,
        committerName,
        committerEmail,
        committerDate
      ] = sanitizedExec("git", ["show", "-s", "--format=%an,%ae,%aI,%cn,%ce,%cI"]).split(",");
      const tags = {
        [GIT_COMMIT_MESSAGE]: commitMessage || sanitizedExec("git", ["show", "-s", "--format=%B"], null, null, null, false),
        [GIT_BRANCH]: branch || sanitizedExec("git", ["rev-parse", "--abbrev-ref", "HEAD"]),
        [GIT_COMMIT_SHA]: commitSHA || sanitizedExec("git", ["rev-parse", "HEAD"]),
        [CI_WORKSPACE_PATH]: ciWorkspacePath || getRepositoryRoot()
      };
      if (headCommitSha) {
        if (isShallowRepository()) {
          fetchHeadCommitSha(headCommitSha);
        }
        const [
          gitHeadCommitSha,
          headAuthorDate,
          headAuthorName,
          headAuthorEmail,
          headCommitterDate,
          headCommitterName,
          headCommitterEmail,
          headCommitMessage
        ] = sanitizedExec(
          "git",
          [
            "show",
            "-s",
            `--format='%H","%aI","%an","%ae","%cI","%cn","%ce","%B'`,
            headCommitSha
          ],
          null,
          null,
          null,
          false
        ).split('","');
        if (gitHeadCommitSha) {
          tags[GIT_COMMIT_HEAD_AUTHOR_DATE] = headAuthorDate;
          tags[GIT_COMMIT_HEAD_AUTHOR_EMAIL] = headAuthorEmail;
          tags[GIT_COMMIT_HEAD_AUTHOR_NAME] = headAuthorName;
          tags[GIT_COMMIT_HEAD_COMMITTER_DATE] = headCommitterDate;
          tags[GIT_COMMIT_HEAD_COMMITTER_EMAIL] = headCommitterEmail;
          tags[GIT_COMMIT_HEAD_COMMITTER_NAME] = headCommitterName;
          tags[GIT_COMMIT_HEAD_MESSAGE] = headCommitMessage;
        }
      }
      const entries = [
        GIT_REPOSITORY_URL,
        filterSensitiveInfoFromRepository(repositoryUrl || sanitizedExec("git", ["ls-remote", "--get-url"])),
        GIT_COMMIT_AUTHOR_DATE,
        authorDate,
        GIT_COMMIT_AUTHOR_NAME,
        ciAuthorName || authorName,
        GIT_COMMIT_AUTHOR_EMAIL,
        ciAuthorEmail || authorEmail,
        GIT_COMMIT_COMMITTER_DATE,
        committerDate,
        GIT_COMMIT_COMMITTER_NAME,
        committerName,
        GIT_COMMIT_COMMITTER_EMAIL,
        committerEmail,
        GIT_TAG,
        tag
      ];
      for (let i = 0; i < entries.length; i += 2) {
        const value = entries[i + 1];
        if (value) {
          tags[entries[i]] = value;
        }
      }
      return tags;
    }
    function getGitInformationDiscrepancy() {
      const gitRepositoryUrl = getRepositoryUrl();
      const gitCommitSHA = sanitizedExec(
        "git",
        ["rev-parse", "HEAD"],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "get_commit_sha" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "get_commit_sha" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "get_commit_sha" } }
      );
      return { gitRepositoryUrl, gitCommitSHA };
    }
    function fetchHeadCommitSha(headSha) {
      const remoteName = getGitRemoteName();
      sanitizedExec(
        "git",
        [
          "fetch",
          "--update-shallow",
          "--filter=blob:none",
          "--recurse-submodules=no",
          "--no-write-fetch-head",
          remoteName,
          headSha
        ],
        { name: TELEMETRY_GIT_COMMAND, tags: { command: "fetch_head_commit_sha" } },
        { name: TELEMETRY_GIT_COMMAND_MS, tags: { command: "fetch_head_commit_sha" } },
        { name: TELEMETRY_GIT_COMMAND_ERRORS, tags: { command: "fetch_head_commit_sha" } }
      );
    }
    module2.exports = {
      getGitMetadata,
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsRevList,
      GIT_REV_LIST_MAX_BUFFER,
      isShallowRepository,
      unshallowRepository,
      isGitAvailable,
      getGitInformationDiscrepancy,
      getGitDiff,
      getGitRemoteName,
      getSourceBranch,
      checkAndFetchBranch,
      getLocalBranches,
      getMergeBase,
      getCounts,
      fetchHeadCommitSha,
      getRepositoryRoot
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/ci.js
var require_ci = __commonJS({
  "../../packages/dd-trace/src/plugins/util/ci.js"(exports2, module2) {
    "use strict";
    var { readFileSync } = __require("fs");
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_REPOSITORY_URL,
      CI_PIPELINE_ID,
      CI_PIPELINE_NAME,
      CI_PIPELINE_NUMBER,
      CI_PIPELINE_URL,
      CI_PROVIDER_NAME,
      CI_WORKSPACE_PATH,
      CI_JOB_URL,
      CI_JOB_NAME,
      CI_STAGE_NAME,
      CI_ENV_VARS,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_COMMITTER_EMAIL,
      CI_NODE_LABELS,
      CI_NODE_NAME,
      PR_NUMBER,
      CI_JOB_ID,
      GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA
    } = require_tags2();
    var { filterSensitiveInfoFromRepository } = require_url2();
    var { getEnvironmentVariable, getEnvironmentVariables } = require_config_helper();
    function parseEmailAndName(emailAndName) {
      if (!emailAndName) {
        return { name: "", email: "" };
      }
      let name = "";
      let email = "";
      const matchNameAndEmail = emailAndName.match(/(?:"?([^"]*)"?\s)?(?:<?(.+@[^>]+)>?)/);
      if (matchNameAndEmail) {
        name = matchNameAndEmail[1];
        email = matchNameAndEmail[2];
      }
      return { name, email };
    }
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags;
        }
        return {
          ...filteredTags,
          [tag]: tags[tag]
        };
      }, {});
    }
    function normalizeTag(targetTags, tagKey, normalize) {
      if (targetTags[tagKey]) {
        targetTags[tagKey] = normalize(targetTags[tagKey]);
      }
    }
    function normalizeRef(ref) {
      if (!ref) {
        return ref;
      }
      return ref.replaceAll(/origin\/|refs\/heads\/|tags\//gm, "");
    }
    function resolveTilde(filePath) {
      if (!filePath || typeof filePath !== "string") {
        return "";
      }
      if (filePath[0] === "~" && (filePath[1] === "/" || filePath.length === 1)) {
        return filePath.replace("~", getEnvironmentVariable("HOME"));
      }
      return filePath;
    }
    function normalizeNumber(number) {
      if (typeof number !== "number") {
        return number;
      }
      return number.toString();
    }
    function getGitHubEventPayload() {
      const path = getEnvironmentVariable("GITHUB_EVENT_PATH");
      if (!path) {
        return;
      }
      return JSON.parse(readFileSync(path, "utf8"));
    }
    module2.exports = {
      normalizeRef,
      getCIMetadata() {
        const env = getEnvironmentVariables();
        let tags = {};
        if (env.JENKINS_URL) {
          const {
            WORKSPACE,
            BUILD_TAG,
            JOB_NAME,
            BUILD_NUMBER,
            BUILD_URL,
            GIT_BRANCH: JENKINS_GIT_BRANCH,
            GIT_COMMIT: JENKINS_GIT_COMMIT,
            GIT_URL: JENKINS_GIT_REPOSITORY_URL,
            GIT_URL_1: JENKINS_GIT_REPOSITORY_URL_1,
            DD_CUSTOM_TRACE_ID,
            NODE_NAME,
            NODE_LABELS,
            CHANGE_ID,
            CHANGE_TARGET
          } = env;
          tags = {
            [CI_PIPELINE_ID]: BUILD_TAG,
            [CI_PIPELINE_NUMBER]: BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILD_URL,
            [CI_PROVIDER_NAME]: "jenkins",
            [GIT_COMMIT_SHA]: JENKINS_GIT_COMMIT,
            [GIT_REPOSITORY_URL]: JENKINS_GIT_REPOSITORY_URL || JENKINS_GIT_REPOSITORY_URL_1,
            [CI_WORKSPACE_PATH]: WORKSPACE,
            [CI_ENV_VARS]: JSON.stringify({ DD_CUSTOM_TRACE_ID }),
            [CI_NODE_NAME]: NODE_NAME,
            [PR_NUMBER]: CHANGE_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CHANGE_TARGET
          };
          if (NODE_LABELS) {
            let nodeLabels;
            try {
              nodeLabels = JSON.stringify(NODE_LABELS.split(" "));
              tags[CI_NODE_LABELS] = nodeLabels;
            } catch {
            }
          }
          const isTag = JENKINS_GIT_BRANCH && JENKINS_GIT_BRANCH.includes("tags/");
          const refKey = isTag ? GIT_TAG : GIT_BRANCH;
          const ref = normalizeRef(JENKINS_GIT_BRANCH);
          tags[refKey] = ref;
          if (JOB_NAME) {
            const jobNameAndParams = JOB_NAME.split("/");
            const finalPipelineName = jobNameAndParams.length > 1 && jobNameAndParams[1].includes("=") ? jobNameAndParams[0] : JOB_NAME.replace(`/${ref}`, "");
            tags[CI_PIPELINE_NAME] = finalPipelineName;
          }
        }
        if (env.GITLAB_CI) {
          const {
            CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
            CI_PROJECT_PATH,
            CI_PIPELINE_IID,
            CI_PIPELINE_URL: GITLAB_PIPELINE_URL,
            CI_PROJECT_DIR,
            CI_COMMIT_REF_NAME,
            CI_COMMIT_TAG,
            CI_COMMIT_SHA,
            CI_REPOSITORY_URL,
            CI_JOB_URL: GITLAB_CI_JOB_URL,
            CI_JOB_STAGE,
            CI_JOB_NAME: GITLAB_CI_JOB_NAME,
            CI_COMMIT_MESSAGE,
            CI_COMMIT_TIMESTAMP,
            CI_COMMIT_AUTHOR,
            CI_PROJECT_URL: GITLAB_PROJECT_URL,
            CI_JOB_ID: GITLAB_CI_JOB_ID,
            CI_RUNNER_ID,
            CI_RUNNER_TAGS,
            CI_MERGE_REQUEST_TARGET_BRANCH_NAME,
            CI_MERGE_REQUEST_IID,
            CI_MERGE_REQUEST_TARGET_BRANCH_SHA,
            CI_MERGE_REQUEST_DIFF_BASE_SHA
          } = env;
          const { name, email } = parseEmailAndName(CI_COMMIT_AUTHOR);
          tags = {
            [CI_PIPELINE_ID]: GITLAB_PIPELINE_ID,
            [CI_PIPELINE_NAME]: CI_PROJECT_PATH,
            [CI_PIPELINE_NUMBER]: CI_PIPELINE_IID,
            [CI_PROVIDER_NAME]: "gitlab",
            [GIT_COMMIT_SHA]: CI_COMMIT_SHA,
            [GIT_REPOSITORY_URL]: CI_REPOSITORY_URL,
            [CI_JOB_URL]: GITLAB_CI_JOB_URL,
            [GIT_TAG]: CI_COMMIT_TAG,
            [GIT_BRANCH]: CI_COMMIT_REF_NAME,
            [CI_WORKSPACE_PATH]: CI_PROJECT_DIR,
            [CI_PIPELINE_URL]: GITLAB_PIPELINE_URL,
            [CI_STAGE_NAME]: CI_JOB_STAGE,
            [CI_JOB_NAME]: GITLAB_CI_JOB_NAME,
            [GIT_COMMIT_MESSAGE]: CI_COMMIT_MESSAGE,
            [GIT_COMMIT_AUTHOR_NAME]: name,
            [GIT_COMMIT_AUTHOR_EMAIL]: email,
            [GIT_COMMIT_AUTHOR_DATE]: CI_COMMIT_TIMESTAMP,
            [CI_ENV_VARS]: JSON.stringify({
              CI_PROJECT_URL: GITLAB_PROJECT_URL,
              CI_PIPELINE_ID: GITLAB_PIPELINE_ID,
              CI_JOB_ID: GITLAB_CI_JOB_ID
            }),
            [CI_NODE_LABELS]: CI_RUNNER_TAGS,
            [CI_NODE_NAME]: CI_RUNNER_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CI_MERGE_REQUEST_TARGET_BRANCH_NAME,
            [PR_NUMBER]: CI_MERGE_REQUEST_IID,
            [CI_JOB_ID]: GITLAB_CI_JOB_ID,
            [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: CI_MERGE_REQUEST_DIFF_BASE_SHA,
            [GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA]: CI_MERGE_REQUEST_TARGET_BRANCH_SHA
          };
        }
        if (env.CIRCLECI) {
          const {
            CIRCLE_WORKFLOW_ID,
            CIRCLE_PROJECT_REPONAME,
            CIRCLE_BUILD_URL,
            CIRCLE_WORKING_DIRECTORY,
            CIRCLE_BRANCH,
            CIRCLE_TAG,
            CIRCLE_SHA1,
            CIRCLE_REPOSITORY_URL,
            CIRCLE_JOB,
            CIRCLE_BUILD_NUM,
            CIRCLE_PR_NUMBER
          } = env;
          const pipelineUrl = `https://app.circleci.com/pipelines/workflows/${CIRCLE_WORKFLOW_ID}`;
          tags = {
            [CI_PIPELINE_ID]: CIRCLE_WORKFLOW_ID,
            [CI_PIPELINE_NAME]: CIRCLE_PROJECT_REPONAME,
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_JOB_NAME]: CIRCLE_JOB,
            [CI_PROVIDER_NAME]: "circleci",
            [GIT_COMMIT_SHA]: CIRCLE_SHA1,
            [GIT_REPOSITORY_URL]: CIRCLE_REPOSITORY_URL,
            [CI_JOB_URL]: CIRCLE_BUILD_URL,
            [CI_WORKSPACE_PATH]: CIRCLE_WORKING_DIRECTORY,
            [GIT_TAG]: CIRCLE_TAG,
            [GIT_BRANCH]: CIRCLE_BRANCH,
            [CI_ENV_VARS]: JSON.stringify({
              CIRCLE_WORKFLOW_ID,
              CIRCLE_BUILD_NUM
            }),
            [PR_NUMBER]: CIRCLE_PR_NUMBER,
            [CI_JOB_ID]: CIRCLE_BUILD_NUM
          };
        }
        if (env.GITHUB_ACTIONS || env.GITHUB_ACTION) {
          const {
            GITHUB_RUN_ID,
            GITHUB_WORKFLOW,
            GITHUB_RUN_NUMBER,
            GITHUB_WORKSPACE,
            GITHUB_HEAD_REF,
            GITHUB_REF,
            GITHUB_SHA,
            GITHUB_REPOSITORY,
            GITHUB_SERVER_URL,
            GITHUB_RUN_ATTEMPT,
            GITHUB_JOB,
            GITHUB_BASE_REF
          } = env;
          const repositoryURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}.git`;
          let pipelineURL = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}`;
          if (GITHUB_RUN_ATTEMPT) {
            pipelineURL = `${pipelineURL}/attempts/${GITHUB_RUN_ATTEMPT}`;
          }
          const jobUrl = `${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}/checks`;
          const ref = GITHUB_HEAD_REF || GITHUB_REF || "";
          const refKey = ref.includes("tags/") ? GIT_TAG : GIT_BRANCH;
          tags = {
            [CI_PIPELINE_ID]: GITHUB_RUN_ID,
            [CI_PIPELINE_NAME]: GITHUB_WORKFLOW,
            [CI_PIPELINE_NUMBER]: GITHUB_RUN_NUMBER,
            [CI_PIPELINE_URL]: filterSensitiveInfoFromRepository(pipelineURL),
            [CI_PROVIDER_NAME]: "github",
            [GIT_COMMIT_SHA]: GITHUB_SHA,
            [GIT_REPOSITORY_URL]: repositoryURL,
            [CI_JOB_URL]: filterSensitiveInfoFromRepository(jobUrl),
            [CI_JOB_NAME]: GITHUB_JOB,
            [CI_WORKSPACE_PATH]: GITHUB_WORKSPACE,
            [refKey]: ref,
            [CI_ENV_VARS]: JSON.stringify({
              GITHUB_SERVER_URL: filterSensitiveInfoFromRepository(GITHUB_SERVER_URL),
              GITHUB_REPOSITORY,
              GITHUB_RUN_ID,
              GITHUB_RUN_ATTEMPT
            }),
            [CI_JOB_ID]: GITHUB_JOB
          };
          if (GITHUB_BASE_REF) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = GITHUB_BASE_REF;
            try {
              const eventContent = getGitHubEventPayload();
              tags[GIT_PULL_REQUEST_BASE_BRANCH_HEAD_SHA] = eventContent.pull_request.base.sha;
              tags[GIT_COMMIT_HEAD_SHA] = eventContent.pull_request.head.sha;
            } catch {
            }
          }
        }
        if (env.APPVEYOR) {
          const {
            APPVEYOR_REPO_NAME,
            APPVEYOR_REPO_PROVIDER,
            APPVEYOR_BUILD_FOLDER,
            APPVEYOR_BUILD_ID,
            APPVEYOR_BUILD_NUMBER,
            APPVEYOR_REPO_COMMIT,
            APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH,
            APPVEYOR_REPO_BRANCH,
            APPVEYOR_REPO_TAG_NAME,
            APPVEYOR_REPO_COMMIT_AUTHOR,
            APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            APPVEYOR_REPO_COMMIT_MESSAGE,
            APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED,
            APPVEYOR_PULL_REQUEST_HEAD_COMMIT,
            APPVEYOR_PULL_REQUEST_NUMBER
          } = env;
          const pipelineUrl = `https://ci.appveyor.com/project/${APPVEYOR_REPO_NAME}/builds/${APPVEYOR_BUILD_ID}`;
          tags = {
            [CI_PROVIDER_NAME]: "appveyor",
            [CI_PIPELINE_URL]: pipelineUrl,
            [CI_PIPELINE_ID]: APPVEYOR_BUILD_ID,
            [CI_PIPELINE_NAME]: APPVEYOR_REPO_NAME,
            [CI_PIPELINE_NUMBER]: APPVEYOR_BUILD_NUMBER,
            [CI_JOB_URL]: pipelineUrl,
            [CI_WORKSPACE_PATH]: APPVEYOR_BUILD_FOLDER,
            [GIT_COMMIT_AUTHOR_NAME]: APPVEYOR_REPO_COMMIT_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: APPVEYOR_REPO_COMMIT_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: APPVEYOR_REPO_COMMIT_MESSAGE + "\n" + APPVEYOR_REPO_COMMIT_MESSAGE_EXTENDED,
            [GIT_COMMIT_HEAD_SHA]: APPVEYOR_PULL_REQUEST_HEAD_COMMIT,
            [PR_NUMBER]: APPVEYOR_PULL_REQUEST_NUMBER
          };
          if (APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = APPVEYOR_REPO_BRANCH;
          }
          if (APPVEYOR_REPO_PROVIDER === "github") {
            tags = {
              ...tags,
              [GIT_REPOSITORY_URL]: `https://github.com/${APPVEYOR_REPO_NAME}.git`,
              [GIT_COMMIT_SHA]: APPVEYOR_REPO_COMMIT,
              [GIT_TAG]: APPVEYOR_REPO_TAG_NAME,
              [GIT_BRANCH]: APPVEYOR_PULL_REQUEST_HEAD_REPO_BRANCH || APPVEYOR_REPO_BRANCH
            };
          }
        }
        if (env.TF_BUILD) {
          const {
            BUILD_SOURCESDIRECTORY,
            BUILD_BUILDID,
            BUILD_DEFINITIONNAME,
            SYSTEM_TEAMFOUNDATIONSERVERURI,
            SYSTEM_TEAMPROJECTID,
            SYSTEM_JOBID,
            SYSTEM_TASKINSTANCEID,
            SYSTEM_PULLREQUEST_SOURCEBRANCH,
            BUILD_SOURCEBRANCH,
            BUILD_SOURCEBRANCHNAME,
            SYSTEM_PULLREQUEST_SOURCECOMMITID,
            SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI,
            BUILD_REPOSITORY_URI,
            BUILD_SOURCEVERSION,
            BUILD_REQUESTEDFORID,
            BUILD_REQUESTEDFOREMAIL,
            BUILD_SOURCEVERSIONMESSAGE,
            SYSTEM_STAGEDISPLAYNAME,
            SYSTEM_JOBDISPLAYNAME,
            SYSTEM_PULLREQUEST_PULLREQUESTNUMBER,
            SYSTEM_PULLREQUEST_TARGETBRANCH
          } = env;
          const ref = SYSTEM_PULLREQUEST_SOURCEBRANCH || BUILD_SOURCEBRANCH || BUILD_SOURCEBRANCHNAME;
          const refKey = (ref || "").includes("tags/") ? GIT_TAG : GIT_BRANCH;
          tags = {
            [CI_PROVIDER_NAME]: "azurepipelines",
            [CI_PIPELINE_ID]: BUILD_BUILDID,
            [CI_PIPELINE_NAME]: BUILD_DEFINITIONNAME,
            [CI_PIPELINE_NUMBER]: BUILD_BUILDID,
            [GIT_COMMIT_SHA]: SYSTEM_PULLREQUEST_SOURCECOMMITID || BUILD_SOURCEVERSION,
            [CI_WORKSPACE_PATH]: BUILD_SOURCESDIRECTORY,
            [GIT_REPOSITORY_URL]: SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI || BUILD_REPOSITORY_URI,
            [refKey]: ref,
            [GIT_COMMIT_AUTHOR_NAME]: BUILD_REQUESTEDFORID,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILD_REQUESTEDFOREMAIL,
            [GIT_COMMIT_MESSAGE]: BUILD_SOURCEVERSIONMESSAGE,
            [CI_STAGE_NAME]: SYSTEM_STAGEDISPLAYNAME,
            [CI_JOB_NAME]: SYSTEM_JOBDISPLAYNAME,
            [CI_ENV_VARS]: JSON.stringify({ SYSTEM_TEAMPROJECTID, BUILD_BUILDID, SYSTEM_JOBID }),
            [PR_NUMBER]: SYSTEM_PULLREQUEST_PULLREQUESTNUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: SYSTEM_PULLREQUEST_TARGETBRANCH,
            [CI_JOB_ID]: SYSTEM_JOBID
          };
          if (SYSTEM_TEAMFOUNDATIONSERVERURI && SYSTEM_TEAMPROJECTID && BUILD_BUILDID) {
            const baseUrl = `${SYSTEM_TEAMFOUNDATIONSERVERURI}${SYSTEM_TEAMPROJECTID}/_build/results?buildId=${BUILD_BUILDID}`;
            const pipelineUrl = baseUrl;
            const jobUrl = `${baseUrl}&view=logs&j=${SYSTEM_JOBID}&t=${SYSTEM_TASKINSTANCEID}`;
            tags = {
              ...tags,
              [CI_PIPELINE_URL]: pipelineUrl,
              [CI_JOB_URL]: jobUrl
            };
          }
        }
        if (env.BITBUCKET_COMMIT) {
          const {
            BITBUCKET_REPO_FULL_NAME,
            BITBUCKET_BUILD_NUMBER,
            BITBUCKET_BRANCH,
            BITBUCKET_COMMIT,
            BITBUCKET_GIT_SSH_ORIGIN,
            BITBUCKET_GIT_HTTP_ORIGIN,
            BITBUCKET_TAG,
            BITBUCKET_PIPELINE_UUID,
            BITBUCKET_CLONE_DIR,
            BITBUCKET_PR_DESTINATION_BRANCH,
            BITBUCKET_PR_ID
          } = env;
          const url = `https://bitbucket.org/${BITBUCKET_REPO_FULL_NAME}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER}`;
          tags = {
            [CI_PROVIDER_NAME]: "bitbucket",
            [GIT_COMMIT_SHA]: BITBUCKET_COMMIT,
            [CI_PIPELINE_NUMBER]: BITBUCKET_BUILD_NUMBER,
            [CI_PIPELINE_NAME]: BITBUCKET_REPO_FULL_NAME,
            [CI_JOB_URL]: url,
            [CI_PIPELINE_URL]: url,
            [GIT_BRANCH]: BITBUCKET_BRANCH,
            [GIT_TAG]: BITBUCKET_TAG,
            [GIT_REPOSITORY_URL]: BITBUCKET_GIT_SSH_ORIGIN || BITBUCKET_GIT_HTTP_ORIGIN,
            [CI_WORKSPACE_PATH]: BITBUCKET_CLONE_DIR,
            [CI_PIPELINE_ID]: BITBUCKET_PIPELINE_UUID && BITBUCKET_PIPELINE_UUID.replaceAll(/{|}/gm, ""),
            [GIT_PULL_REQUEST_BASE_BRANCH]: BITBUCKET_PR_DESTINATION_BRANCH,
            [PR_NUMBER]: BITBUCKET_PR_ID
          };
        }
        if (env.BITRISE_BUILD_SLUG) {
          const {
            BITRISE_GIT_COMMIT,
            GIT_CLONE_COMMIT_HASH,
            BITRISEIO_GIT_BRANCH_DEST,
            BITRISE_GIT_BRANCH,
            BITRISE_BUILD_SLUG,
            BITRISE_TRIGGERED_WORKFLOW_ID,
            BITRISE_BUILD_NUMBER,
            BITRISE_BUILD_URL,
            BITRISE_SOURCE_DIR,
            GIT_REPOSITORY_URL: BITRISE_GIT_REPOSITORY_URL,
            BITRISE_GIT_TAG,
            BITRISE_GIT_MESSAGE,
            BITRISE_PULL_REQUEST
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "bitrise",
            [CI_PIPELINE_ID]: BITRISE_BUILD_SLUG,
            [CI_PIPELINE_NAME]: BITRISE_TRIGGERED_WORKFLOW_ID,
            [CI_PIPELINE_NUMBER]: BITRISE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BITRISE_BUILD_URL,
            [GIT_COMMIT_SHA]: BITRISE_GIT_COMMIT || GIT_CLONE_COMMIT_HASH,
            [GIT_REPOSITORY_URL]: BITRISE_GIT_REPOSITORY_URL,
            [CI_WORKSPACE_PATH]: BITRISE_SOURCE_DIR,
            [GIT_TAG]: BITRISE_GIT_TAG,
            [GIT_BRANCH]: BITRISEIO_GIT_BRANCH_DEST || BITRISE_GIT_BRANCH,
            [GIT_COMMIT_MESSAGE]: BITRISE_GIT_MESSAGE,
            [GIT_PULL_REQUEST_BASE_BRANCH]: BITRISEIO_GIT_BRANCH_DEST,
            [PR_NUMBER]: BITRISE_PULL_REQUEST
          };
        }
        if (env.BUILDKITE) {
          const {
            BUILDKITE_BRANCH,
            BUILDKITE_COMMIT,
            BUILDKITE_REPO,
            BUILDKITE_TAG,
            BUILDKITE_BUILD_ID,
            BUILDKITE_PIPELINE_SLUG,
            BUILDKITE_BUILD_NUMBER,
            BUILDKITE_BUILD_URL,
            BUILDKITE_JOB_ID,
            BUILDKITE_BUILD_CHECKOUT_PATH,
            BUILDKITE_BUILD_AUTHOR,
            BUILDKITE_BUILD_AUTHOR_EMAIL,
            BUILDKITE_MESSAGE,
            BUILDKITE_AGENT_ID,
            BUILDKITE_PULL_REQUEST,
            BUILDKITE_PULL_REQUEST_BASE_BRANCH
          } = env;
          const extraTags = Object.keys(env).filter(
            (envVar) => envVar.startsWith("BUILDKITE_AGENT_META_DATA_")
          ).map((metadataKey) => {
            const key = metadataKey.replace("BUILDKITE_AGENT_META_DATA_", "").toLowerCase();
            return `${key}:${env[metadataKey]}`;
          });
          tags = {
            [CI_PROVIDER_NAME]: "buildkite",
            [CI_PIPELINE_ID]: BUILDKITE_BUILD_ID,
            [CI_PIPELINE_NAME]: BUILDKITE_PIPELINE_SLUG,
            [CI_PIPELINE_NUMBER]: BUILDKITE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: BUILDKITE_BUILD_URL,
            [CI_JOB_URL]: `${BUILDKITE_BUILD_URL}#${BUILDKITE_JOB_ID}`,
            [GIT_COMMIT_SHA]: BUILDKITE_COMMIT,
            [CI_WORKSPACE_PATH]: BUILDKITE_BUILD_CHECKOUT_PATH,
            [GIT_REPOSITORY_URL]: BUILDKITE_REPO,
            [GIT_TAG]: BUILDKITE_TAG,
            [GIT_BRANCH]: BUILDKITE_BRANCH,
            [GIT_COMMIT_AUTHOR_NAME]: BUILDKITE_BUILD_AUTHOR,
            [GIT_COMMIT_AUTHOR_EMAIL]: BUILDKITE_BUILD_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: BUILDKITE_MESSAGE,
            [CI_ENV_VARS]: JSON.stringify({
              BUILDKITE_BUILD_ID,
              BUILDKITE_JOB_ID
            }),
            [CI_NODE_NAME]: BUILDKITE_AGENT_ID,
            [CI_NODE_LABELS]: JSON.stringify(extraTags),
            [PR_NUMBER]: BUILDKITE_PULL_REQUEST,
            [CI_JOB_ID]: BUILDKITE_JOB_ID
          };
          if (BUILDKITE_PULL_REQUEST) {
            tags[GIT_PULL_REQUEST_BASE_BRANCH] = BUILDKITE_PULL_REQUEST_BASE_BRANCH;
          }
        }
        if (env.TRAVIS) {
          const {
            TRAVIS_PULL_REQUEST_BRANCH,
            TRAVIS_BRANCH,
            TRAVIS_COMMIT,
            TRAVIS_REPO_SLUG,
            TRAVIS_TAG,
            TRAVIS_JOB_WEB_URL,
            TRAVIS_BUILD_ID,
            TRAVIS_BUILD_NUMBER,
            TRAVIS_BUILD_WEB_URL,
            TRAVIS_BUILD_DIR,
            TRAVIS_COMMIT_MESSAGE,
            TRAVIS_PULL_REQUEST,
            TRAVIS_PULL_REQUEST_SHA
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "travisci",
            [CI_JOB_URL]: TRAVIS_JOB_WEB_URL,
            [CI_PIPELINE_ID]: TRAVIS_BUILD_ID,
            [CI_PIPELINE_NAME]: TRAVIS_REPO_SLUG,
            [CI_PIPELINE_NUMBER]: TRAVIS_BUILD_NUMBER,
            [CI_PIPELINE_URL]: TRAVIS_BUILD_WEB_URL,
            [GIT_COMMIT_SHA]: TRAVIS_COMMIT,
            [GIT_REPOSITORY_URL]: `https://github.com/${TRAVIS_REPO_SLUG}.git`,
            [CI_WORKSPACE_PATH]: TRAVIS_BUILD_DIR,
            [GIT_TAG]: TRAVIS_TAG,
            [GIT_BRANCH]: TRAVIS_PULL_REQUEST_BRANCH || TRAVIS_BRANCH,
            [GIT_COMMIT_MESSAGE]: TRAVIS_COMMIT_MESSAGE,
            [GIT_COMMIT_HEAD_SHA]: TRAVIS_PULL_REQUEST_SHA,
            [GIT_PULL_REQUEST_BASE_BRANCH]: TRAVIS_BRANCH,
            [PR_NUMBER]: TRAVIS_PULL_REQUEST
          };
        }
        if (env.BUDDY) {
          const {
            BUDDY_EXECUTION_BRANCH,
            BUDDY_EXECUTION_ID,
            BUDDY_EXECUTION_REVISION,
            BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            BUDDY_EXECUTION_REVISION_MESSAGE,
            BUDDY_EXECUTION_TAG,
            BUDDY_EXECUTION_URL,
            BUDDY_PIPELINE_ID,
            BUDDY_PIPELINE_NAME,
            BUDDY_SCM_URL,
            BUDDY_RUN_PR_BASE_BRANCH,
            BUDDY_RUN_PR_NO
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "buddy",
            [CI_PIPELINE_ID]: `${BUDDY_PIPELINE_ID}/${BUDDY_EXECUTION_ID}`,
            [CI_PIPELINE_NAME]: BUDDY_PIPELINE_NAME,
            [CI_PIPELINE_NUMBER]: BUDDY_EXECUTION_ID,
            [CI_PIPELINE_URL]: BUDDY_EXECUTION_URL,
            [GIT_COMMIT_SHA]: BUDDY_EXECUTION_REVISION,
            [GIT_REPOSITORY_URL]: BUDDY_SCM_URL,
            [GIT_BRANCH]: BUDDY_EXECUTION_BRANCH,
            [GIT_TAG]: BUDDY_EXECUTION_TAG,
            [GIT_COMMIT_MESSAGE]: BUDDY_EXECUTION_REVISION_MESSAGE,
            [GIT_COMMIT_COMMITTER_NAME]: BUDDY_EXECUTION_REVISION_COMMITTER_NAME,
            [GIT_COMMIT_COMMITTER_EMAIL]: BUDDY_EXECUTION_REVISION_COMMITTER_EMAIL,
            [GIT_PULL_REQUEST_BASE_BRANCH]: BUDDY_RUN_PR_BASE_BRANCH,
            [PR_NUMBER]: BUDDY_RUN_PR_NO
          };
        }
        if (env.TEAMCITY_VERSION) {
          const {
            BUILD_URL,
            TEAMCITY_BUILDCONF_NAME,
            DATADOG_BUILD_ID,
            TEAMCITY_PULLREQUEST_NUMBER,
            TEAMCITY_PULLREQUEST_TARGET_BRANCH
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "teamcity",
            [CI_JOB_URL]: BUILD_URL,
            [CI_JOB_NAME]: TEAMCITY_BUILDCONF_NAME,
            [CI_ENV_VARS]: JSON.stringify({
              DATADOG_BUILD_ID
            }),
            [PR_NUMBER]: TEAMCITY_PULLREQUEST_NUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: TEAMCITY_PULLREQUEST_TARGET_BRANCH
          };
        }
        if (env.CF_BUILD_ID) {
          const {
            CF_BUILD_ID,
            CF_PIPELINE_NAME,
            CF_BUILD_URL,
            CF_STEP_NAME,
            CF_BRANCH,
            CF_PULL_REQUEST_NUMBER,
            CF_PULL_REQUEST_TARGET
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "codefresh",
            [CI_PIPELINE_ID]: CF_BUILD_ID,
            [CI_PIPELINE_NAME]: CF_PIPELINE_NAME,
            [CI_PIPELINE_URL]: CF_BUILD_URL,
            [CI_JOB_NAME]: CF_STEP_NAME,
            [CI_ENV_VARS]: JSON.stringify({
              CF_BUILD_ID
            }),
            [PR_NUMBER]: CF_PULL_REQUEST_NUMBER,
            [GIT_PULL_REQUEST_BASE_BRANCH]: CF_PULL_REQUEST_TARGET
          };
          const isTag = CF_BRANCH && CF_BRANCH.includes("tags/");
          const refKey = isTag ? GIT_TAG : GIT_BRANCH;
          const ref = normalizeRef(CF_BRANCH);
          tags[refKey] = ref;
        }
        if (env.CODEBUILD_INITIATOR?.startsWith("codepipeline/")) {
          const {
            CODEBUILD_BUILD_ARN,
            DD_ACTION_EXECUTION_ID,
            DD_PIPELINE_EXECUTION_ID
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "awscodepipeline",
            [CI_PIPELINE_ID]: DD_PIPELINE_EXECUTION_ID,
            [CI_ENV_VARS]: JSON.stringify({
              CODEBUILD_BUILD_ARN,
              DD_PIPELINE_EXECUTION_ID,
              DD_ACTION_EXECUTION_ID
            }),
            [CI_JOB_ID]: DD_ACTION_EXECUTION_ID
          };
        }
        if (env.DRONE && env.CI) {
          const {
            DRONE_BUILD_NUMBER,
            DRONE_BUILD_LINK,
            DRONE_STEP_NAME,
            DRONE_STAGE_NAME,
            DRONE_WORKSPACE,
            DRONE_GIT_HTTP_URL,
            DRONE_COMMIT_SHA,
            DRONE_BRANCH,
            DRONE_TAG,
            DRONE_COMMIT_AUTHOR_NAME,
            DRONE_COMMIT_AUTHOR_EMAIL,
            DRONE_COMMIT_MESSAGE,
            DRONE_PULL_REQUEST,
            DRONE_TARGET_BRANCH
          } = env;
          tags = {
            [CI_PROVIDER_NAME]: "drone",
            [CI_PIPELINE_NUMBER]: DRONE_BUILD_NUMBER,
            [CI_PIPELINE_URL]: DRONE_BUILD_LINK,
            [CI_JOB_NAME]: DRONE_STEP_NAME,
            [CI_STAGE_NAME]: DRONE_STAGE_NAME,
            [CI_WORKSPACE_PATH]: DRONE_WORKSPACE,
            [GIT_REPOSITORY_URL]: DRONE_GIT_HTTP_URL,
            [GIT_COMMIT_SHA]: DRONE_COMMIT_SHA,
            [GIT_BRANCH]: DRONE_BRANCH,
            [GIT_TAG]: DRONE_TAG,
            [GIT_COMMIT_AUTHOR_NAME]: DRONE_COMMIT_AUTHOR_NAME,
            [GIT_COMMIT_AUTHOR_EMAIL]: DRONE_COMMIT_AUTHOR_EMAIL,
            [GIT_COMMIT_MESSAGE]: DRONE_COMMIT_MESSAGE,
            [PR_NUMBER]: DRONE_PULL_REQUEST,
            [GIT_PULL_REQUEST_BASE_BRANCH]: DRONE_TARGET_BRANCH
          };
        }
        normalizeTag(tags, CI_WORKSPACE_PATH, resolveTilde);
        normalizeTag(tags, GIT_REPOSITORY_URL, filterSensitiveInfoFromRepository);
        normalizeTag(tags, GIT_BRANCH, normalizeRef);
        normalizeTag(tags, GIT_TAG, normalizeRef);
        normalizeTag(tags, GIT_PULL_REQUEST_BASE_BRANCH, normalizeRef);
        normalizeTag(tags, PR_NUMBER, normalizeNumber);
        return removeEmptyValues(tags);
      }
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/user-provided-git.js
var require_user_provided_git = __commonJS({
  "../../packages/dd-trace/src/plugins/util/user-provided-git.js"(exports2, module2) {
    "use strict";
    var {
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_MESSAGE,
      GIT_COMMIT_COMMITTER_DATE,
      GIT_COMMIT_COMMITTER_EMAIL,
      GIT_COMMIT_COMMITTER_NAME,
      GIT_COMMIT_AUTHOR_DATE,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_COMMIT_HEAD_SHA
    } = require_tags2();
    var { normalizeRef } = require_ci();
    var { filterSensitiveInfoFromRepository } = require_url2();
    var { getEnvironmentVariables } = require_config_helper();
    function removeEmptyValues(tags) {
      return Object.keys(tags).reduce((filteredTags, tag) => {
        if (!tags[tag]) {
          return filteredTags;
        }
        return {
          ...filteredTags,
          [tag]: tags[tag]
        };
      }, {});
    }
    function validateGitRepositoryUrl(repoUrl) {
      return /(?:git|ssh|https?|git@[-\w.]+):(\/\/)?(.*?)(\/?|#[-\d\w._]+?)$/.test(repoUrl);
    }
    function validateGitCommitSha(gitCommitSha) {
      const isValidSha1 = /^[0-9a-f]{40}$/.test(gitCommitSha);
      const isValidSha256 = /^[0-9a-f]{64}$/.test(gitCommitSha);
      return isValidSha1 || isValidSha256;
    }
    function getUserProviderGitMetadata() {
      const {
        DD_GIT_COMMIT_SHA,
        DD_GIT_BRANCH,
        DD_GIT_REPOSITORY_URL,
        DD_GIT_TAG,
        DD_GIT_COMMIT_MESSAGE,
        DD_GIT_COMMIT_COMMITTER_NAME,
        DD_GIT_COMMIT_COMMITTER_EMAIL,
        DD_GIT_COMMIT_COMMITTER_DATE,
        DD_GIT_COMMIT_AUTHOR_NAME,
        DD_GIT_COMMIT_AUTHOR_EMAIL,
        DD_GIT_COMMIT_AUTHOR_DATE,
        DD_GIT_PULL_REQUEST_BASE_BRANCH,
        DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA,
        DD_GIT_COMMIT_HEAD_SHA
      } = getEnvironmentVariables();
      const branch = normalizeRef(DD_GIT_BRANCH);
      let tag = normalizeRef(DD_GIT_TAG);
      if ((DD_GIT_BRANCH || "").includes("origin/tags") || (DD_GIT_BRANCH || "").includes("refs/heads/tags")) {
        tag = normalizeRef(DD_GIT_BRANCH);
      }
      return removeEmptyValues({
        [GIT_COMMIT_SHA]: DD_GIT_COMMIT_SHA,
        [GIT_BRANCH]: branch,
        [GIT_REPOSITORY_URL]: filterSensitiveInfoFromRepository(DD_GIT_REPOSITORY_URL),
        [GIT_TAG]: tag,
        [GIT_COMMIT_MESSAGE]: DD_GIT_COMMIT_MESSAGE,
        [GIT_COMMIT_COMMITTER_NAME]: DD_GIT_COMMIT_COMMITTER_NAME,
        [GIT_COMMIT_COMMITTER_DATE]: DD_GIT_COMMIT_COMMITTER_DATE,
        [GIT_COMMIT_COMMITTER_EMAIL]: DD_GIT_COMMIT_COMMITTER_EMAIL,
        [GIT_COMMIT_AUTHOR_NAME]: DD_GIT_COMMIT_AUTHOR_NAME,
        [GIT_COMMIT_AUTHOR_EMAIL]: DD_GIT_COMMIT_AUTHOR_EMAIL,
        [GIT_COMMIT_AUTHOR_DATE]: DD_GIT_COMMIT_AUTHOR_DATE,
        [GIT_PULL_REQUEST_BASE_BRANCH]: DD_GIT_PULL_REQUEST_BASE_BRANCH,
        [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: DD_GIT_PULL_REQUEST_BASE_BRANCH_SHA,
        [GIT_COMMIT_HEAD_SHA]: DD_GIT_COMMIT_HEAD_SHA
      });
    }
    module2.exports = { getUserProviderGitMetadata, validateGitRepositoryUrl, validateGitCommitSha };
  }
});

// ../../packages/dd-trace/src/plugins/util/env.js
var require_env = __commonJS({
  "../../packages/dd-trace/src/plugins/util/env.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var OS_PLATFORM = "os.platform";
    var OS_VERSION = "os.version";
    var OS_ARCHITECTURE = "os.architecture";
    var RUNTIME_NAME = "runtime.name";
    var RUNTIME_VERSION = "runtime.version";
    var DD_HOST_CPU_COUNT = "_dd.host.vcpu_count";
    function getRuntimeAndOSMetadata() {
      return {
        [RUNTIME_VERSION]: process.version,
        [OS_ARCHITECTURE]: process.arch,
        [OS_PLATFORM]: process.platform,
        [RUNTIME_NAME]: "node",
        [OS_VERSION]: os.release(),
        [DD_HOST_CPU_COUNT]: os.cpus().length
      };
    }
    module2.exports = {
      getRuntimeAndOSMetadata,
      OS_PLATFORM,
      OS_VERSION,
      OS_ARCHITECTURE,
      RUNTIME_NAME,
      RUNTIME_VERSION,
      DD_HOST_CPU_COUNT
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/test.js
var require_test = __commonJS({
  "../../packages/dd-trace/src/plugins/util/test.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    var { URL: URL2 } = __require("url");
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var satisfies = require_semifies();
    var istanbul = require_istanbul_lib_coverage();
    var ignore = require_ignore();
    var {
      getGitMetadata,
      getGitInformationDiscrepancy,
      getGitDiff,
      getGitRemoteName,
      getSourceBranch,
      checkAndFetchBranch,
      getLocalBranches,
      getMergeBase,
      getCounts
    } = require_git();
    var { getUserProviderGitMetadata, validateGitRepositoryUrl, validateGitCommitSha } = require_user_provided_git();
    var { getCIMetadata } = require_ci();
    var { getRuntimeAndOSMetadata } = require_env();
    var {
      GIT_BRANCH,
      GIT_COMMIT_SHA,
      GIT_REPOSITORY_URL,
      GIT_TAG,
      GIT_COMMIT_AUTHOR_EMAIL,
      GIT_COMMIT_AUTHOR_NAME,
      GIT_COMMIT_MESSAGE,
      CI_WORKSPACE_PATH,
      CI_PIPELINE_URL,
      CI_JOB_NAME,
      GIT_COMMIT_HEAD_SHA
    } = require_tags2();
    var id = require_id();
    var {
      incrementCountMetric,
      TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY,
      TELEMETRY_GIT_SHA_MATCH
    } = require_telemetry();
    var { SPAN_TYPE, RESOURCE_NAME, SAMPLING_PRIORITY } = require_tags();
    var { SAMPLING_RULE_DECISION } = require_constants3();
    var { AUTO_KEEP } = require_priority();
    var { version: ddTraceVersion } = require_package();
    var TEST_SESSION_NAME = "test_session.name";
    var TEST_FRAMEWORK = "test.framework";
    var TEST_FRAMEWORK_VERSION = "test.framework_version";
    var TEST_TYPE = "test.type";
    var TEST_NAME = "test.name";
    var TEST_SUITE = "test.suite";
    var TEST_STATUS = "test.status";
    var TEST_PARAMETERS = "test.parameters";
    var TEST_SKIP_REASON = "test.skip_reason";
    var TEST_IS_RUM_ACTIVE = "test.is_rum_active";
    var TEST_CODE_OWNERS = "test.codeowners";
    var TEST_SOURCE_FILE = "test.source.file";
    var TEST_SOURCE_START = "test.source.start";
    var LIBRARY_VERSION = "library_version";
    var TEST_COMMAND = "test.command";
    var TEST_MODULE = "test.module";
    var TEST_SESSION_ID = "test_session_id";
    var TEST_MODULE_ID = "test_module_id";
    var TEST_SUITE_ID = "test_suite_id";
    var TEST_TOOLCHAIN = "test.toolchain";
    var TEST_SKIPPED_BY_ITR = "test.skipped_by_itr";
    var TEST_IS_NEW = "test.is_new";
    var TEST_IS_RETRY = "test.is_retry";
    var TEST_EARLY_FLAKE_ENABLED = "test.early_flake.enabled";
    var TEST_EARLY_FLAKE_ABORT_REASON = "test.early_flake.abort_reason";
    var TEST_RETRY_REASON = "test.retry_reason";
    var TEST_HAS_FAILED_ALL_RETRIES = "test.has_failed_all_retries";
    var TEST_IS_MODIFIED = "test.is_modified";
    var CI_APP_ORIGIN = "ciapp-test";
    var JEST_TEST_RUNNER = "test.jest.test_runner";
    var JEST_DISPLAY_NAME = "test.jest.display_name";
    var CUCUMBER_IS_PARALLEL = "test.cucumber.is_parallel";
    var MOCHA_IS_PARALLEL = "test.mocha.is_parallel";
    var TEST_ITR_TESTS_SKIPPED = "_dd.ci.itr.tests_skipped";
    var TEST_ITR_SKIPPING_ENABLED = "test.itr.tests_skipping.enabled";
    var TEST_ITR_SKIPPING_TYPE = "test.itr.tests_skipping.type";
    var TEST_ITR_SKIPPING_COUNT = "test.itr.tests_skipping.count";
    var TEST_CODE_COVERAGE_ENABLED = "test.code_coverage.enabled";
    var TEST_ITR_UNSKIPPABLE = "test.itr.unskippable";
    var TEST_ITR_FORCED_RUN = "test.itr.forced_run";
    var ITR_CORRELATION_ID = "itr_correlation_id";
    var TEST_CODE_COVERAGE_LINES_PCT = "test.code_coverage.lines_pct";
    var TEST_BROWSER_DRIVER = "test.browser.driver";
    var TEST_BROWSER_DRIVER_VERSION = "test.browser.driver_version";
    var TEST_BROWSER_NAME = "test.browser.name";
    var TEST_BROWSER_VERSION = "test.browser.version";
    var JEST_WORKER_TRACE_PAYLOAD_CODE = 60;
    var JEST_WORKER_COVERAGE_PAYLOAD_CODE = 61;
    var JEST_WORKER_LOGS_PAYLOAD_CODE = 62;
    var CUCUMBER_WORKER_TRACE_PAYLOAD_CODE = 70;
    var MOCHA_WORKER_TRACE_PAYLOAD_CODE = 80;
    var PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE = 90;
    var VITEST_WORKER_TRACE_PAYLOAD_CODE = 100;
    var VITEST_WORKER_LOGS_PAYLOAD_CODE = 102;
    var DD_CAPABILITIES_TEST_IMPACT_ANALYSIS = "_dd.library_capabilities.test_impact_analysis";
    var DD_CAPABILITIES_EARLY_FLAKE_DETECTION = "_dd.library_capabilities.early_flake_detection";
    var DD_CAPABILITIES_AUTO_TEST_RETRIES = "_dd.library_capabilities.auto_test_retries";
    var DD_CAPABILITIES_IMPACTED_TESTS = "_dd.library_capabilities.impacted_tests";
    var DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE = "_dd.library_capabilities.test_management.quarantine";
    var DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE = "_dd.library_capabilities.test_management.disable";
    var DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX = "_dd.library_capabilities.test_management.attempt_to_fix";
    var DD_CAPABILITIES_FAILED_TEST_REPLAY = "_dd.library_capabilities.failed_test_replay";
    var UNSUPPORTED_TIA_FRAMEWORKS = /* @__PURE__ */ new Set(["playwright", "vitest"]);
    var UNSUPPORTED_TIA_FRAMEWORKS_PARALLEL_MODE = /* @__PURE__ */ new Set(["cucumber", "mocha"]);
    var MINIMUM_FRAMEWORK_VERSION_FOR_EFD = {
      playwright: ">=1.38.0"
    };
    var MINIMUM_FRAMEWORK_VERSION_FOR_IMPACTED_TESTS = {
      playwright: ">=1.38.0"
    };
    var MINIMUM_FRAMEWORK_VERSION_FOR_QUARANTINE = {
      playwright: ">=1.38.0"
    };
    var MINIMUM_FRAMEWORK_VERSION_FOR_DISABLE = {
      playwright: ">=1.38.0"
    };
    var MINIMUM_FRAMEWORK_VERSION_FOR_ATTEMPT_TO_FIX = {
      playwright: ">=1.38.0"
    };
    var MINIMUM_FRAMEWORK_VERSION_FOR_FAILED_TEST_REPLAY = {
      playwright: ">=1.38.0"
    };
    var UNSUPPORTED_ATTEMPT_TO_FIX_FRAMEWORKS_PARALLEL_MODE = /* @__PURE__ */ new Set(["mocha"]);
    var NOT_SUPPORTED_GRANULARITY_IMPACTED_TESTS_FRAMEWORKS = /* @__PURE__ */ new Set(["mocha", "playwright", "vitest"]);
    var TEST_LEVEL_EVENT_TYPES = [
      "test",
      "test_suite_end",
      "test_module_end",
      "test_session_end"
    ];
    var TEST_RETRY_REASON_TYPES = {
      efd: "early_flake_detection",
      atr: "auto_test_retry",
      atf: "attempt_to_fix",
      ext: "external"
    };
    var DD_TEST_IS_USER_PROVIDED_SERVICE = "_dd.test.is_user_provided_service";
    var DI_ERROR_DEBUG_INFO_CAPTURED = "error.debug_info_captured";
    var DI_DEBUG_ERROR_PREFIX = "_dd.debug.error";
    var DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX = "snapshot_id";
    var DI_DEBUG_ERROR_FILE_SUFFIX = "file";
    var DI_DEBUG_ERROR_LINE_SUFFIX = "line";
    var TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX = "test.test_management.is_attempt_to_fix";
    var TEST_MANAGEMENT_IS_DISABLED = "test.test_management.is_test_disabled";
    var TEST_MANAGEMENT_IS_QUARANTINED = "test.test_management.is_quarantined";
    var TEST_MANAGEMENT_ENABLED = "test.test_management.enabled";
    var TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED = "test.test_management.attempt_to_fix_passed";
    var POSSIBLE_BASE_BRANCHES = ["main", "master", "preprod", "prod", "dev", "development", "trunk"];
    var BASE_LIKE_BRANCH_FILTER = /^(main|master|preprod|prod|dev|development|trunk|release\/.*|hotfix\/.*)$/;
    module2.exports = {
      TEST_CODE_OWNERS,
      TEST_SESSION_NAME,
      TEST_FRAMEWORK,
      TEST_FRAMEWORK_VERSION,
      JEST_TEST_RUNNER,
      JEST_DISPLAY_NAME,
      CUCUMBER_IS_PARALLEL,
      MOCHA_IS_PARALLEL,
      TEST_TYPE,
      TEST_NAME,
      TEST_SUITE,
      TEST_STATUS,
      TEST_PARAMETERS,
      TEST_SKIP_REASON,
      TEST_IS_RUM_ACTIVE,
      TEST_SOURCE_FILE,
      CI_APP_ORIGIN,
      LIBRARY_VERSION,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_LOGS_PAYLOAD_CODE,
      TEST_SOURCE_START,
      TEST_SKIPPED_BY_ITR,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_RETRY_REASON,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_IS_MODIFIED,
      getTestEnvironmentMetadata,
      getTestParametersString,
      finishAllTraceSpans,
      getTestParentSpan,
      getTestSuitePath,
      getCodeOwnersFileEntries,
      getCodeOwnersForFilename,
      getTestCommonTags,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      getTestSuiteCommonTags,
      TEST_COMMAND,
      TEST_TOOLCHAIN,
      TEST_SESSION_ID,
      TEST_MODULE_ID,
      TEST_SUITE_ID,
      TEST_ITR_TESTS_SKIPPED,
      TEST_MODULE,
      TEST_ITR_SKIPPING_ENABLED,
      TEST_ITR_SKIPPING_TYPE,
      TEST_ITR_SKIPPING_COUNT,
      TEST_CODE_COVERAGE_ENABLED,
      TEST_CODE_COVERAGE_LINES_PCT,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      ITR_CORRELATION_ID,
      addIntelligentTestRunnerSpanTags,
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      fromCoverageMapToCoverage,
      getTestLineStart,
      getTestEndLine,
      removeInvalidMetadata,
      parseAnnotations,
      getIsFaultyEarlyFlakeDetection,
      TEST_BROWSER_DRIVER,
      TEST_BROWSER_DRIVER_VERSION,
      TEST_BROWSER_NAME,
      TEST_BROWSER_VERSION,
      getTestSessionName,
      DD_CAPABILITIES_TEST_IMPACT_ANALYSIS,
      DD_CAPABILITIES_EARLY_FLAKE_DETECTION,
      DD_CAPABILITIES_AUTO_TEST_RETRIES,
      DD_CAPABILITIES_IMPACTED_TESTS,
      DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE,
      DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE,
      DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX,
      DD_CAPABILITIES_FAILED_TEST_REPLAY,
      TEST_LEVEL_EVENT_TYPES,
      TEST_RETRY_REASON_TYPES,
      getNumFromKnownTests,
      getFileAndLineNumberFromError,
      DI_ERROR_DEBUG_INFO_CAPTURED,
      DI_DEBUG_ERROR_PREFIX,
      DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX,
      DI_DEBUG_ERROR_FILE_SUFFIX,
      DI_DEBUG_ERROR_LINE_SUFFIX,
      getFormattedError,
      DD_TEST_IS_USER_PROVIDED_SERVICE,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      getLibraryCapabilitiesTags,
      checkShaDiscrepancies,
      getPullRequestDiff,
      getPullRequestBaseBranch,
      getModifiedFilesFromDiff,
      isModifiedTest,
      POSSIBLE_BASE_BRANCHES
    };
    function getPkgManager() {
      try {
        return getEnvironmentVariable("npm_config_user_agent").split(" ")[0].replace("/", "-");
      } catch {
        return "";
      }
    }
    function validateUrl(url) {
      try {
        const urlObject = new URL2(url);
        return urlObject.protocol === "https:" || urlObject.protocol === "http:";
      } catch {
        return false;
      }
    }
    function removeInvalidMetadata(metadata) {
      return Object.keys(metadata).reduce((filteredTags, tag) => {
        if (tag === GIT_REPOSITORY_URL && !validateGitRepositoryUrl(metadata[GIT_REPOSITORY_URL])) {
          log.error("Repository URL is not a valid repository URL: %s.", metadata[GIT_REPOSITORY_URL]);
          return filteredTags;
        }
        if (tag === GIT_COMMIT_SHA && !validateGitCommitSha(metadata[GIT_COMMIT_SHA])) {
          log.error("Git commit SHA must be a full-length git SHA: %s.", metadata[GIT_COMMIT_SHA]);
          return filteredTags;
        }
        if (tag === CI_PIPELINE_URL && !validateUrl(metadata[CI_PIPELINE_URL])) {
          return filteredTags;
        }
        filteredTags[tag] = metadata[tag];
        return filteredTags;
      }, {});
    }
    function checkShaDiscrepancies(ciMetadata, userProvidedGitMetadata) {
      const {
        [GIT_COMMIT_SHA]: ciCommitSHA,
        [GIT_REPOSITORY_URL]: ciRepositoryUrl
      } = ciMetadata;
      const {
        [GIT_COMMIT_SHA]: userProvidedCommitSHA,
        [GIT_REPOSITORY_URL]: userProvidedRepositoryUrl
      } = userProvidedGitMetadata;
      const { gitRepositoryUrl, gitCommitSHA } = getGitInformationDiscrepancy();
      const checkDiscrepancyAndSendMetrics = (valueExpected, valueDiscrepant, discrepancyType, expectedProvider, discrepantProvider) => {
        if (valueExpected && valueDiscrepant && valueExpected !== valueDiscrepant) {
          incrementCountMetric(
            TELEMETRY_GIT_COMMIT_SHA_DISCREPANCY,
            {
              type: discrepancyType,
              expected_provider: expectedProvider,
              discrepant_provider: discrepantProvider
            }
          );
          return true;
        }
        return false;
      };
      const checkConfigs = [
        // User provided vs Git metadata
        {
          v1: userProvidedRepositoryUrl,
          v2: gitRepositoryUrl,
          type: "repository_discrepancy",
          expected: "user_supplied",
          discrepant: "git_client"
        },
        {
          v1: userProvidedCommitSHA,
          v2: gitCommitSHA,
          type: "commit_discrepancy",
          expected: "user_supplied",
          discrepant: "git_client"
        },
        // User provided vs CI metadata
        {
          v1: userProvidedRepositoryUrl,
          v2: ciRepositoryUrl,
          type: "repository_discrepancy",
          expected: "user_supplied",
          discrepant: "ci_provider"
        },
        {
          v1: userProvidedCommitSHA,
          v2: ciCommitSHA,
          type: "commit_discrepancy",
          expected: "user_supplied",
          discrepant: "ci_provider"
        },
        // CI metadata vs Git metadata
        {
          v1: ciRepositoryUrl,
          v2: gitRepositoryUrl,
          type: "repository_discrepancy",
          expected: "ci_provider",
          discrepant: "git_client"
        },
        {
          v1: ciCommitSHA,
          v2: gitCommitSHA,
          type: "commit_discrepancy",
          expected: "ci_provider",
          discrepant: "git_client"
        }
      ];
      let gitCommitShaMatch = true;
      for (const checkConfig of checkConfigs) {
        const { v1, v2, type, expected, discrepant } = checkConfig;
        const discrepancy = checkDiscrepancyAndSendMetrics(v1, v2, type, expected, discrepant);
        if (discrepancy) {
          gitCommitShaMatch = false;
        }
      }
      incrementCountMetric(
        TELEMETRY_GIT_SHA_MATCH,
        { matched: gitCommitShaMatch }
      );
    }
    function getTestEnvironmentMetadata(testFramework, config, shouldSkipGitMetadataExtraction = false) {
      const ciMetadata = getCIMetadata();
      const userProvidedGitMetadata = getUserProviderGitMetadata();
      let gitMetadata = {};
      if (!shouldSkipGitMetadataExtraction) {
        checkShaDiscrepancies(ciMetadata, userProvidedGitMetadata);
        const {
          [GIT_COMMIT_SHA]: commitSHA,
          [GIT_BRANCH]: branch,
          [GIT_REPOSITORY_URL]: repositoryUrl,
          [GIT_TAG]: tag,
          [GIT_COMMIT_AUTHOR_NAME]: authorName,
          [GIT_COMMIT_AUTHOR_EMAIL]: authorEmail,
          [GIT_COMMIT_MESSAGE]: commitMessage,
          [CI_WORKSPACE_PATH]: ciWorkspacePath,
          [GIT_COMMIT_HEAD_SHA]: headCommitSha
        } = ciMetadata;
        gitMetadata = getGitMetadata({
          commitSHA,
          branch,
          repositoryUrl,
          tag,
          authorName,
          authorEmail,
          commitMessage,
          ciWorkspacePath,
          headCommitSha
        });
      }
      const runtimeAndOSMetadata = getRuntimeAndOSMetadata();
      const metadata = {
        [TEST_FRAMEWORK]: testFramework,
        [DD_TEST_IS_USER_PROVIDED_SERVICE]: config && config.isServiceUserProvided ? "true" : "false",
        ...gitMetadata,
        ...ciMetadata,
        ...userProvidedGitMetadata,
        ...runtimeAndOSMetadata
      };
      if (config && config.service) {
        metadata["service.name"] = config.service;
      }
      return removeInvalidMetadata(metadata);
    }
    function getTestParametersString(parametersByTestName, testName) {
      if (!parametersByTestName[testName]) {
        return "";
      }
      try {
        const testParameters = parametersByTestName[testName].shift();
        return JSON.stringify({ arguments: testParameters, metadata: {} });
      } catch {
        return "";
      }
    }
    function getTestTypeFromFramework(testFramework) {
      if (testFramework === "playwright" || testFramework === "cypress") {
        return "browser";
      }
      return "test";
    }
    function finishAllTraceSpans(span) {
      span.context()._trace.started.forEach((traceSpan) => {
        if (traceSpan !== span) {
          traceSpan.finish();
        }
      });
    }
    function getTestParentSpan(tracer2) {
      return tracer2.extract("text_map", {
        "x-datadog-trace-id": id().toString(10),
        "x-datadog-parent-id": "0000000000000000"
      });
    }
    function getTestCommonTags(name, suite, version, testFramework) {
      return {
        [SPAN_TYPE]: "test",
        [TEST_TYPE]: getTestTypeFromFramework(testFramework),
        [SAMPLING_RULE_DECISION]: 1,
        [SAMPLING_PRIORITY]: AUTO_KEEP,
        [TEST_NAME]: name,
        [TEST_SUITE]: suite,
        [RESOURCE_NAME]: `${suite}.${name}`,
        [TEST_FRAMEWORK_VERSION]: version,
        [LIBRARY_VERSION]: ddTraceVersion
      };
    }
    function getTestSuitePath(testSuiteAbsolutePath, sourceRoot) {
      if (!testSuiteAbsolutePath) {
        return sourceRoot;
      }
      const testSuitePath = testSuiteAbsolutePath === sourceRoot ? testSuiteAbsolutePath : path.relative(sourceRoot, testSuiteAbsolutePath);
      return testSuitePath.replace(path.sep, "/");
    }
    var POSSIBLE_CODEOWNERS_LOCATIONS = [
      "CODEOWNERS",
      ".github/CODEOWNERS",
      "docs/CODEOWNERS",
      ".gitlab/CODEOWNERS"
    ];
    function readCodeOwners(rootDir) {
      for (const location of POSSIBLE_CODEOWNERS_LOCATIONS) {
        try {
          return fs.readFileSync(path.join(rootDir, location)).toString();
        } catch {
        }
      }
      return "";
    }
    function getCodeOwnersFileEntries(rootDir) {
      let codeOwnersContent;
      let usedRootDir = rootDir;
      let isTriedCwd = false;
      const processCwd = process.cwd();
      if (!usedRootDir || usedRootDir === processCwd) {
        usedRootDir = processCwd;
        isTriedCwd = true;
      }
      codeOwnersContent = readCodeOwners(usedRootDir);
      if (!codeOwnersContent && !isTriedCwd) {
        codeOwnersContent = readCodeOwners(processCwd);
      }
      if (!codeOwnersContent) {
        return null;
      }
      const entries = [];
      const lines = codeOwnersContent.split("\n");
      for (const line of lines) {
        const [content] = line.split("#");
        const trimmed = content.trim();
        if (trimmed === "") continue;
        const [pattern, ...owners] = trimmed.split(/\s+/);
        entries.push({ pattern, owners });
      }
      return entries.reverse();
    }
    function getCodeOwnersForFilename(filename, entries) {
      if (!entries) {
        return null;
      }
      for (const entry of entries) {
        try {
          const isResponsible = ignore().add(entry.pattern).ignores(filename);
          if (isResponsible) {
            return JSON.stringify(entry.owners);
          }
        } catch {
          return null;
        }
      }
      return null;
    }
    function getTestLevelCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [TEST_FRAMEWORK_VERSION]: testFrameworkVersion,
        [LIBRARY_VERSION]: ddTraceVersion,
        [TEST_COMMAND]: command,
        [TEST_TYPE]: getTestTypeFromFramework(testFramework)
      };
    }
    function getTestSessionCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [SPAN_TYPE]: "test_session_end",
        [RESOURCE_NAME]: `test_session.${command}`,
        [TEST_MODULE]: testFramework,
        [TEST_TOOLCHAIN]: getPkgManager(),
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework)
      };
    }
    function getTestModuleCommonTags(command, testFrameworkVersion, testFramework) {
      return {
        [SPAN_TYPE]: "test_module_end",
        [RESOURCE_NAME]: `test_module.${command}`,
        [TEST_MODULE]: testFramework,
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework)
      };
    }
    function getTestSuiteCommonTags(command, testFrameworkVersion, testSuite, testFramework) {
      return {
        [SPAN_TYPE]: "test_suite_end",
        [RESOURCE_NAME]: `test_suite.${testSuite}`,
        [TEST_MODULE]: testFramework,
        [TEST_SUITE]: testSuite,
        ...getTestLevelCommonTags(command, testFrameworkVersion, testFramework)
      };
    }
    function addIntelligentTestRunnerSpanTags(testSessionSpan, testModuleSpan, {
      isSuitesSkipped,
      isSuitesSkippingEnabled,
      isCodeCoverageEnabled,
      testCodeCoverageLinesTotal,
      skippingCount,
      skippingType = "suite",
      hasUnskippableSuites,
      hasForcedToRunSuites
    }) {
      testSessionSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? "true" : "false");
      testSessionSpan.setTag(TEST_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? "true" : "false");
      testSessionSpan.setTag(TEST_ITR_SKIPPING_TYPE, skippingType);
      testSessionSpan.setTag(TEST_ITR_SKIPPING_COUNT, skippingCount);
      testSessionSpan.setTag(TEST_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? "true" : "false");
      testModuleSpan.setTag(TEST_ITR_TESTS_SKIPPED, isSuitesSkipped ? "true" : "false");
      testModuleSpan.setTag(TEST_ITR_SKIPPING_ENABLED, isSuitesSkippingEnabled ? "true" : "false");
      testModuleSpan.setTag(TEST_ITR_SKIPPING_TYPE, skippingType);
      testModuleSpan.setTag(TEST_ITR_SKIPPING_COUNT, skippingCount);
      testModuleSpan.setTag(TEST_CODE_COVERAGE_ENABLED, isCodeCoverageEnabled ? "true" : "false");
      if (hasUnskippableSuites) {
        testSessionSpan.setTag(TEST_ITR_UNSKIPPABLE, "true");
        testModuleSpan.setTag(TEST_ITR_UNSKIPPABLE, "true");
      }
      if (hasForcedToRunSuites) {
        testSessionSpan.setTag(TEST_ITR_FORCED_RUN, "true");
        testModuleSpan.setTag(TEST_ITR_FORCED_RUN, "true");
      }
      if (testCodeCoverageLinesTotal !== void 0) {
        testSessionSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal);
        testModuleSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal);
      }
    }
    function getCoveredFilenamesFromCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().filter((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        const lineCoverage = fileCoverage.getLineCoverage();
        const isAnyLineExecuted = Object.entries(lineCoverage).some(([, numExecutions]) => !!numExecutions);
        return isAnyLineExecuted;
      });
    }
    function resetCoverage(coverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        fileCoverage.resetHits();
      });
    }
    function mergeCoverage(coverage, targetCoverage) {
      const coverageMap = istanbul.createCoverageMap(coverage);
      return coverageMap.files().forEach((filename) => {
        const fileCoverage = coverageMap.fileCoverageFor(filename);
        if (!targetCoverage.data[filename]) {
          targetCoverage.addFileCoverage(istanbul.createFileCoverage(filename));
        }
        targetCoverage.addFileCoverage(fileCoverage);
        const targetFileCoverage = targetCoverage.fileCoverageFor(filename);
        Object.entries(targetFileCoverage.data.b).forEach(([key, value]) => {
          targetFileCoverage.data.b[key] = [...value];
        });
      });
    }
    function fromCoverageMapToCoverage(coverageMap) {
      return Object.entries(coverageMap.data).reduce((acc, [filename, fileCoverage]) => {
        acc[filename] = fileCoverage.data;
        return acc;
      }, {});
    }
    function getTestLineStart(err, testSuitePath) {
      if (!err.stack) {
        return null;
      }
      const testFileLine = err.stack.split("\n").find((line) => line.includes(testSuitePath));
      try {
        const testFileLineMatch = testFileLine.match(/at (?:(.+?)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        return Number.parseInt(testFileLineMatch[3], 10) || null;
      } catch {
        return null;
      }
    }
    function getTestEndLine(testFn, startLine = 0) {
      const source = testFn.toString();
      const lineCount = source.split("\n").length;
      return startLine + lineCount - 1;
    }
    function parseAnnotations(annotations) {
      return annotations.reduce((tags, annotation) => {
        if (!annotation?.type) {
          return tags;
        }
        const { type, description } = annotation;
        if (type.startsWith("DD_TAGS")) {
          const regex = /\[(.*?)\]/;
          const match = regex.exec(type);
          let tagValue = "";
          if (match) {
            tagValue = match[1];
          }
          if (tagValue) {
            tags[tagValue] = description;
          }
        }
        return tags;
      }, {});
    }
    function getIsFaultyEarlyFlakeDetection(projectSuites, testsBySuiteName, faultyThresholdPercentage) {
      let newSuites = 0;
      for (const suite of projectSuites) {
        if (!testsBySuiteName[suite]) {
          newSuites++;
        }
      }
      const newSuitesPercentage = newSuites / projectSuites.length * 100;
      return newSuites > faultyThresholdPercentage && newSuitesPercentage > faultyThresholdPercentage;
    }
    function getTestSessionName(config, trimmedCommand, envTags) {
      if (config.ciVisibilityTestSessionName) {
        return config.ciVisibilityTestSessionName;
      }
      if (envTags[CI_JOB_NAME]) {
        return `${envTags[CI_JOB_NAME]}-${trimmedCommand}`;
      }
      return trimmedCommand;
    }
    function getNumFromKnownTests(knownTests) {
      if (!knownTests) {
        return 0;
      }
      let totalNumTests = 0;
      for (const testModule of Object.values(knownTests)) {
        for (const testSuite of Object.values(testModule)) {
          totalNumTests += testSuite.length;
        }
      }
      return totalNumTests;
    }
    var DEPENDENCY_FOLDERS = [
      "node_modules",
      "node:",
      ".pnpm",
      ".yarn",
      ".pnp"
    ];
    function getFileAndLineNumberFromError(error, repositoryRoot) {
      const stackLines = error.stack.split("\n");
      const frames = stackLines.filter((line) => line.includes("at ") && line.includes(repositoryRoot));
      const topRelevantFrameIndex = frames.findIndex(
        (line) => line.includes(repositoryRoot) && !DEPENDENCY_FOLDERS.some((pattern) => line.includes(pattern))
      );
      if (topRelevantFrameIndex === -1) {
        return [];
      }
      const topFrame = frames[topRelevantFrameIndex];
      const regex = /\s*at\s+(?:.*\()?(.+):(\d+):(\d+)\)?/;
      const match = topFrame.match(regex);
      if (match) {
        const filePath = match[1];
        const lineNumber = Number(match[2]);
        return [filePath, lineNumber, topRelevantFrameIndex];
      }
      return [];
    }
    function getFormattedError(error, repositoryRoot) {
      const newError = new Error(error.message);
      if (error.stack) {
        newError.stack = error.stack.split("\n").filter((line) => line.includes(repositoryRoot)).join("\n");
      }
      newError.name = error.name;
      return newError;
    }
    function isTiaSupported(testFramework, isParallel) {
      return !(UNSUPPORTED_TIA_FRAMEWORKS.has(testFramework) || isParallel && UNSUPPORTED_TIA_FRAMEWORKS_PARALLEL_MODE.has(testFramework));
    }
    function isEarlyFlakeDetectionSupported(testFramework, frameworkVersion) {
      return testFramework === "playwright" ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_EFD[testFramework]) : true;
    }
    function isImpactedTestsSupported(testFramework, frameworkVersion) {
      return testFramework === "playwright" ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_IMPACTED_TESTS[testFramework]) : true;
    }
    function isQuarantineSupported(testFramework, frameworkVersion) {
      return testFramework === "playwright" ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_QUARANTINE[testFramework]) : true;
    }
    function isDisableSupported(testFramework, frameworkVersion) {
      return testFramework === "playwright" ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_DISABLE[testFramework]) : true;
    }
    function isAttemptToFixSupported(testFramework, isParallel, frameworkVersion) {
      if (testFramework === "playwright") {
        return satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_ATTEMPT_TO_FIX[testFramework]);
      }
      return !(isParallel && UNSUPPORTED_ATTEMPT_TO_FIX_FRAMEWORKS_PARALLEL_MODE.has(testFramework));
    }
    function isFailedTestReplaySupported(testFramework, frameworkVersion) {
      return testFramework === "playwright" ? satisfies(frameworkVersion, MINIMUM_FRAMEWORK_VERSION_FOR_FAILED_TEST_REPLAY[testFramework]) : true;
    }
    function getLibraryCapabilitiesTags(testFramework, isParallel, frameworkVersion) {
      return {
        [DD_CAPABILITIES_TEST_IMPACT_ANALYSIS]: isTiaSupported(testFramework, isParallel) ? "1" : void 0,
        [DD_CAPABILITIES_EARLY_FLAKE_DETECTION]: isEarlyFlakeDetectionSupported(testFramework, frameworkVersion) ? "1" : void 0,
        [DD_CAPABILITIES_AUTO_TEST_RETRIES]: "1",
        [DD_CAPABILITIES_IMPACTED_TESTS]: isImpactedTestsSupported(testFramework, frameworkVersion) ? "1" : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_QUARANTINE]: isQuarantineSupported(testFramework, frameworkVersion) ? "1" : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_DISABLE]: isDisableSupported(testFramework, frameworkVersion) ? "1" : void 0,
        [DD_CAPABILITIES_TEST_MANAGEMENT_ATTEMPT_TO_FIX]: isAttemptToFixSupported(testFramework, isParallel, frameworkVersion) ? "5" : void 0,
        [DD_CAPABILITIES_FAILED_TEST_REPLAY]: isFailedTestReplaySupported(testFramework, frameworkVersion) ? "1" : void 0
      };
    }
    function getPullRequestBaseBranch(pullRequestBaseBranch) {
      const remoteName = getGitRemoteName();
      const sourceBranch = getSourceBranch();
      const POSSIBLE_DEFAULT_BRANCHES = ["main", "master"];
      const candidateBranches = [];
      if (pullRequestBaseBranch) {
        checkAndFetchBranch(pullRequestBaseBranch, remoteName);
        candidateBranches.push(pullRequestBaseBranch);
      } else {
        for (const branch of POSSIBLE_BASE_BRANCHES) {
          checkAndFetchBranch(branch, remoteName);
        }
        const localBranches = getLocalBranches(remoteName);
        for (const branch of localBranches) {
          const shortBranchName = branch.replace(new RegExp(`^${remoteName}/`), "");
          if (branch !== sourceBranch && BASE_LIKE_BRANCH_FILTER.test(shortBranchName)) {
            candidateBranches.push(branch);
          }
        }
      }
      if (candidateBranches.length === 1) {
        return getMergeBase(candidateBranches[0], sourceBranch);
      }
      const metrics2 = {};
      for (const candidate of candidateBranches) {
        const baseSha = getMergeBase(candidate, sourceBranch);
        if (!baseSha) {
          continue;
        }
        const counts = getCounts(candidate, sourceBranch);
        if (!counts) {
          continue;
        }
        const behind = counts.behind;
        const ahead = counts.ahead;
        metrics2[candidate] = {
          behind,
          ahead,
          baseSha
        };
      }
      function isDefaultBranch(branch) {
        return POSSIBLE_DEFAULT_BRANCHES.some(
          (defaultBranch) => branch === defaultBranch || branch === `${remoteName}/${defaultBranch}`
        );
      }
      if (Object.keys(metrics2).length === 0) {
        return null;
      }
      let bestBranch = null;
      let bestScore = Infinity;
      for (const branch of Object.keys(metrics2)) {
        const score = metrics2[branch].ahead;
        if (score < bestScore) {
          bestScore = score;
          bestBranch = branch;
        } else if (score === bestScore && isDefaultBranch(branch)) {
          bestScore = score;
          bestBranch = branch;
        }
      }
      return bestBranch ? metrics2[bestBranch].baseSha : null;
    }
    function getPullRequestDiff(baseCommit, targetCommit) {
      if (!baseCommit) {
        return;
      }
      return getGitDiff(baseCommit, targetCommit);
    }
    function getModifiedFilesFromDiff(diff) {
      if (!diff) return null;
      const result = {};
      const filesRegex = /^diff --git a\/(?<file>.+) b\/(?<file2>.+)$/g;
      const linesRegex = /^@@ -\d+(,\d+)? \+(?<start>\d+)(,(?<count>\d+))? @@/g;
      let currentFile = null;
      const lines = diff.split("\n");
      for (const line of lines) {
        const fileMatch = filesRegex.exec(line);
        if (fileMatch && fileMatch.groups.file) {
          currentFile = fileMatch.groups.file;
          result[currentFile] = [];
          continue;
        }
        const lineMatch = linesRegex.exec(line);
        if (lineMatch && currentFile) {
          const start = Number(lineMatch.groups.start);
          const count = lineMatch.groups.count ? Number(lineMatch.groups.count) : 1;
          for (let j = 0; j < count; j++) {
            result[currentFile].push(start + j);
          }
        }
        filesRegex.lastIndex = 0;
        linesRegex.lastIndex = 0;
      }
      if (Object.keys(result).length === 0) {
        return null;
      }
      return result;
    }
    function isModifiedTest(testPath, testStartLine, testEndLine, modifiedFiles, testFramework) {
      if (modifiedFiles === void 0) {
        return false;
      }
      const lines = modifiedFiles[testPath];
      if (!lines) {
        return false;
      }
      if (NOT_SUPPORTED_GRANULARITY_IMPACTED_TESTS_FRAMEWORKS.has(testFramework)) {
        return lines.length > 0;
      }
      return lines.some((line) => line >= testStartLine && line <= testEndLine);
    }
  }
});

// ../../packages/dd-trace/src/encode/agentless-ci-visibility.js
var require_agentless_ci_visibility = __commonJS({
  "../../packages/dd-trace/src/encode/agentless-ci-visibility.js"(exports2, module2) {
    "use strict";
    var { truncateSpan, normalizeSpan } = require_tags_processors();
    var { AgentEncoder } = require__();
    var { version: ddTraceVersion } = require_package();
    var { ITR_CORRELATION_ID } = require_test();
    var id = require_id();
    var {
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT
    } = require_telemetry();
    var ENCODING_VERSION = 1;
    var ALLOWED_CONTENT_TYPES = /* @__PURE__ */ new Set(["test_session_end", "test_module_end", "test_suite_end", "test"]);
    var TEST_SUITE_KEYS_LENGTH = 12;
    var TEST_MODULE_KEYS_LENGTH = 11;
    var TEST_SESSION_KEYS_LENGTH = 10;
    var TEST_AND_SPAN_KEYS_LENGTH = 11;
    var INTAKE_SOFT_LIMIT = 2 * 1024 * 1024;
    function formatSpan(span) {
      let encodingVersion = ENCODING_VERSION;
      if (span.type === "test" && span.meta && span.meta.test_session_id) {
        encodingVersion = 2;
      }
      return {
        type: ALLOWED_CONTENT_TYPES.has(span.type) ? span.type : "span",
        version: encodingVersion,
        content: normalizeSpan(truncateSpan(span))
      };
    }
    var AgentlessCiVisibilityEncoder = class extends AgentEncoder {
      constructor(writer, { runtimeId, service, env }) {
        super(writer, INTAKE_SOFT_LIMIT);
        this.runtimeId = runtimeId;
        this.service = service;
        this.env = env;
        this._eventCount = 0;
        this.metadataTags = {};
        this.reset();
      }
      addMetadataTags(tags) {
        ALLOWED_CONTENT_TYPES.forEach((type) => {
          if (tags[type]) {
            this.metadataTags[type] = {
              ...this.metadataTags[type],
              ...tags[type]
            };
          }
        });
      }
      _encodeTestSuite(bytes, content) {
        let keysLength = TEST_SUITE_KEYS_LENGTH;
        const itrCorrelationId = content.meta[ITR_CORRELATION_ID];
        if (itrCorrelationId) {
          keysLength++;
        }
        this._encodeMapPrefix(bytes, keysLength);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "test_module_id");
        this._encodeId(bytes, content.parent_id);
        this._encodeString(bytes, "test_suite_id");
        this._encodeId(bytes, content.span_id);
        if (itrCorrelationId) {
          this._encodeString(bytes, ITR_CORRELATION_ID);
          this._encodeString(bytes, itrCorrelationId);
          delete content.meta[ITR_CORRELATION_ID];
        }
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeTestModule(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_MODULE_KEYS_LENGTH);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "test_module_id");
        this._encodeId(bytes, content.span_id);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeTestSession(bytes, content) {
        this._encodeMapPrefix(bytes, TEST_SESSION_KEYS_LENGTH);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, content.type);
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeEventContent(bytes, content) {
        let totalKeysLength = TEST_AND_SPAN_KEYS_LENGTH;
        if (content.meta.test_session_id) {
          totalKeysLength += 1;
        }
        if (content.meta.test_module_id) {
          totalKeysLength += 1;
        }
        if (content.meta.test_suite_id) {
          totalKeysLength += 1;
        }
        const itrCorrelationId = content.meta[ITR_CORRELATION_ID];
        if (itrCorrelationId) {
          totalKeysLength += 1;
        }
        if (content.type) {
          totalKeysLength += 1;
        }
        this._encodeMapPrefix(bytes, totalKeysLength);
        if (content.type) {
          this._encodeString(bytes, "type");
          this._encodeString(bytes, content.type);
        }
        this._encodeString(bytes, "trace_id");
        this._encodeId(bytes, content.trace_id);
        this._encodeString(bytes, "span_id");
        this._encodeId(bytes, content.span_id);
        this._encodeString(bytes, "parent_id");
        this._encodeId(bytes, content.parent_id);
        this._encodeString(bytes, "name");
        this._encodeString(bytes, content.name);
        this._encodeString(bytes, "resource");
        this._encodeString(bytes, content.resource);
        this._encodeString(bytes, "service");
        this._encodeString(bytes, content.service);
        this._encodeString(bytes, "error");
        this._encodeNumber(bytes, content.error);
        this._encodeString(bytes, "start");
        this._encodeNumber(bytes, content.start);
        this._encodeString(bytes, "duration");
        this._encodeNumber(bytes, content.duration);
        if (content.meta.test_session_id) {
          this._encodeString(bytes, "test_session_id");
          this._encodeId(bytes, id(content.meta.test_session_id, 10));
          delete content.meta.test_session_id;
        }
        if (content.meta.test_module_id) {
          this._encodeString(bytes, "test_module_id");
          this._encodeId(bytes, id(content.meta.test_module_id, 10));
          delete content.meta.test_module_id;
        }
        if (content.meta.test_suite_id) {
          this._encodeString(bytes, "test_suite_id");
          this._encodeId(bytes, id(content.meta.test_suite_id, 10));
          delete content.meta.test_suite_id;
        }
        if (itrCorrelationId) {
          this._encodeString(bytes, ITR_CORRELATION_ID);
          this._encodeString(bytes, itrCorrelationId);
          delete content.meta[ITR_CORRELATION_ID];
        }
        this._encodeString(bytes, "meta");
        this._encodeMap(bytes, content.meta);
        this._encodeString(bytes, "metrics");
        this._encodeMap(bytes, content.metrics);
      }
      _encodeEvent(bytes, event) {
        this._encodeMapPrefix(bytes, Object.keys(event).length);
        this._encodeString(bytes, "type");
        this._encodeString(bytes, event.type);
        this._encodeString(bytes, "version");
        this._encodeNumber(bytes, event.version);
        this._encodeString(bytes, "content");
        if (event.type === "span" || event.type === "test") {
          this._encodeEventContent(bytes, event.content);
        } else if (event.type === "test_suite_end") {
          this._encodeTestSuite(bytes, event.content);
        } else if (event.type === "test_module_end") {
          this._encodeTestModule(bytes, event.content);
        } else if (event.type === "test_session_end") {
          this._encodeTestSession(bytes, event.content);
        }
      }
      _encode(bytes, trace2) {
        if (this._isReset) {
          this._encodePayloadStart(bytes);
          this._isReset = false;
        }
        const startTime = Date.now();
        const rawEvents = trace2.map(formatSpan);
        const testSessionEvents = rawEvents.filter(
          (event) => event.type === "test_session_end" || event.type === "test_suite_end" || event.type === "test_module_end"
        );
        const isTestSessionTrace = !!testSessionEvents.length;
        const events = isTestSessionTrace ? testSessionEvents : rawEvents;
        this._eventCount += events.length;
        for (const event of events) {
          this._encodeEvent(bytes, event);
        }
        distributionMetric(
          TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
          { endpoint: "test_cycle" },
          Date.now() - startTime
        );
      }
      makePayload() {
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT, { endpoint: "test_cycle" }, this._eventCount);
        const bytes = this._traceBytes;
        const eventsOffset = this._eventsOffset;
        const eventsCount = this._eventCount;
        bytes.buffer[eventsOffset] = 221;
        bytes.buffer[eventsOffset + 1] = eventsCount >> 24;
        bytes.buffer[eventsOffset + 2] = eventsCount >> 16;
        bytes.buffer[eventsOffset + 3] = eventsCount >> 8;
        bytes.buffer[eventsOffset + 4] = eventsCount;
        const traceSize = bytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        bytes.buffer.copy(buffer, 0, 0, traceSize);
        this.reset();
        return buffer;
      }
      _encodePayloadStart(bytes) {
        const payload = {
          version: ENCODING_VERSION,
          metadata: {
            "*": {
              language: "javascript",
              library_version: ddTraceVersion
            },
            ...this.metadataTags
          },
          events: []
        };
        if (this.env) {
          payload.metadata["*"].env = this.env;
        }
        if (this.runtimeId) {
          payload.metadata["*"]["runtime-id"] = this.runtimeId;
        }
        this._encodeMapPrefix(bytes, Object.keys(payload).length);
        this._encodeString(bytes, "version");
        this._encodeNumber(bytes, payload.version);
        this._encodeString(bytes, "metadata");
        this._encodeMapPrefix(bytes, Object.keys(payload.metadata).length);
        this._encodeString(bytes, "*");
        this._encodeMap(bytes, payload.metadata["*"]);
        if (payload.metadata.test) {
          this._encodeString(bytes, "test");
          this._encodeMap(bytes, payload.metadata.test);
        }
        if (payload.metadata.test_suite_end) {
          this._encodeString(bytes, "test_suite_end");
          this._encodeMap(bytes, payload.metadata.test_suite_end);
        }
        if (payload.metadata.test_module_end) {
          this._encodeString(bytes, "test_module_end");
          this._encodeMap(bytes, payload.metadata.test_module_end);
        }
        if (payload.metadata.test_session_end) {
          this._encodeString(bytes, "test_session_end");
          this._encodeMap(bytes, payload.metadata.test_session_end);
        }
        this._encodeString(bytes, "events");
        this._eventsOffset = bytes.length;
        bytes.reserve(5);
      }
      reset() {
        this._reset();
        this._eventCount = 0;
        this._isReset = true;
      }
    };
    module2.exports = { AgentlessCiVisibilityEncoder };
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js
var require_writer7 = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/agentless/writer.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var { safeJSONStringify } = require_util3();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var { AgentlessCiVisibilityEncoder } = require_agentless_ci_visibility();
    var BaseWriter = require_writer3();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED
    } = require_telemetry();
    var Writer = class extends BaseWriter {
      constructor({ url, tags, evpProxyPrefix = "" }) {
        super(...arguments);
        const { "runtime-id": runtimeId, env, service } = tags;
        this._url = url;
        this._encoder = new AgentlessCiVisibilityEncoder(this, { runtimeId, env, service });
        this._evpProxyPrefix = evpProxyPrefix;
      }
      _sendPayload(data, _2, done) {
        const options = {
          path: "/api/v2/citestcycle",
          method: "POST",
          headers: {
            "dd-api-key": getEnvironmentVariable("DD_API_KEY"),
            "Content-Type": "application/msgpack"
          },
          timeout: 15e3,
          url: this._url
        };
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcycle`;
          delete options.headers["dd-api-key"];
          options.headers["X-Datadog-EVP-Subdomain"] = "citestcycle-intake";
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`);
        const startRequestTime = Date.now();
        incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS, { endpoint: "test_cycle" });
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_BYTES, { endpoint: "test_cycle" }, Buffer.byteLength(data));
        request2(data, options, (err, res, statusCode) => {
          distributionMetric(
            TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
            { endpoint: "test_cycle" },
            Date.now() - startRequestTime
          );
          if (err) {
            incrementCountMetric(
              TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
              { endpoint: "test_cycle", statusCode }
            );
            incrementCountMetric(
              TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
              { endpoint: "test_cycle" }
            );
            log.error("Error sending CI agentless payload", err);
            done();
            return;
          }
          log.debug("Response from the intake:", res);
          done();
        });
      }
      addMetadataTags(tags) {
        this._encoder.addMetadataTags(tags);
      }
    };
    module2.exports = Writer;
  }
});

// ../../packages/dd-trace/src/exporters/common/form-data.js
var require_form_data = __commonJS({
  "../../packages/dd-trace/src/exporters/common/form-data.js"(exports2, module2) {
    "use strict";
    var { Readable } = __require("stream");
    var id = require_id();
    var FormData = class extends Readable {
      constructor() {
        super();
        this._boundary = id().toString();
        this._data = [];
      }
      append(key, value, options = {}) {
        this._appendBoundary();
        if (options.filename) {
          this._appendFile(key, value, options);
        } else {
          this._appendMetadata(key, value, options);
        }
      }
      size() {
        return this._data.reduce((size, chunk) => size + chunk.length, 0);
      }
      getHeaders() {
        return { "Content-Type": "multipart/form-data; boundary=" + this._boundary };
      }
      _appendBoundary() {
        this._data.push(`--${this._boundary}\r
`);
      }
      _appendMetadata(key, value) {
        this._data.push(`Content-Disposition: form-data; name="${key}"\r
\r
${value}\r
`);
      }
      _appendFile(key, value, { filename, contentType = "application/octet-stream" }) {
        this._data.push(
          `Content-Disposition: form-data; name="${key}"; filename="${filename}"\r
`,
          `Content-Type: ${contentType}\r
\r
`,
          value,
          "\r\n"
        );
      }
      _read() {
        this.push(this._data.shift());
        if (this._data.length === 0) {
          this.push(`--${this._boundary}--\r
`);
          this.push(null);
        }
      }
    };
    module2.exports = FormData;
  }
});

// ../../packages/dd-trace/src/encode/coverage-ci-visibility.js
var require_coverage_ci_visibility = __commonJS({
  "../../packages/dd-trace/src/encode/coverage-ci-visibility.js"(exports2, module2) {
    "use strict";
    var { AgentEncoder } = require__();
    var { Chunk } = require_msgpack();
    var {
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT
    } = require_telemetry();
    var FormData = require_form_data();
    var COVERAGE_PAYLOAD_VERSION = 2;
    var COVERAGE_KEYS_LENGTH = 2;
    var CoverageCIVisibilityEncoder = class extends AgentEncoder {
      constructor() {
        super(...arguments);
        this._coverageBytes = new Chunk();
        this.form = new FormData();
        this._coveragesCount = 0;
        this.reset();
      }
      count() {
        return this._coveragesCount;
      }
      encode(coverage) {
        const startTime = Date.now();
        this._coveragesCount++;
        this.encodeCodeCoverage(this._coverageBytes, coverage);
        distributionMetric(
          TELEMETRY_ENDPOINT_PAYLOAD_SERIALIZATION_MS,
          { endpoint: "code_coverage" },
          Date.now() - startTime
        );
      }
      encodeCodeCoverage(bytes, coverage) {
        if (coverage.testId) {
          this._encodeMapPrefix(bytes, 4);
        } else {
          this._encodeMapPrefix(bytes, 3);
        }
        this._encodeString(bytes, "test_session_id");
        this._encodeId(bytes, coverage.sessionId);
        this._encodeString(bytes, "test_suite_id");
        this._encodeId(bytes, coverage.suiteId);
        if (coverage.testId) {
          this._encodeString(bytes, "span_id");
          this._encodeId(bytes, coverage.testId);
        }
        this._encodeString(bytes, "files");
        this._encodeArrayPrefix(bytes, coverage.files);
        for (const filename of coverage.files) {
          this._encodeMapPrefix(bytes, 1);
          this._encodeString(bytes, "filename");
          this._encodeString(bytes, filename);
        }
      }
      reset() {
        this._reset();
        if (this._coverageBytes) {
          this._coverageBytes.length = 0;
        }
        this._coveragesCount = 0;
        this._encodePayloadStart(this._coverageBytes);
      }
      _encodePayloadStart(bytes) {
        const payload = {
          version: COVERAGE_PAYLOAD_VERSION,
          coverages: []
        };
        this._encodeMapPrefix(bytes, COVERAGE_KEYS_LENGTH);
        this._encodeString(bytes, "version");
        this._encodeInteger(bytes, payload.version);
        this._encodeString(bytes, "coverages");
        this._coveragesOffset = bytes.length;
        bytes.reserve(5);
      }
      makePayload() {
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_EVENTS_COUNT, { endpoint: "code_coverage" }, this._coveragesCount);
        const bytes = this._coverageBytes;
        const coveragesOffset = this._coveragesOffset;
        const coveragesCount = this._coveragesCount;
        bytes.buffer[coveragesOffset] = 221;
        bytes.buffer[coveragesOffset + 1] = coveragesCount >> 24;
        bytes.buffer[coveragesOffset + 2] = coveragesCount >> 16;
        bytes.buffer[coveragesOffset + 3] = coveragesCount >> 8;
        bytes.buffer[coveragesOffset + 4] = coveragesCount;
        const traceSize = bytes.length;
        const buffer = Buffer.allocUnsafe(traceSize);
        bytes.buffer.copy(buffer, 0, 0, bytes.length);
        this.form.append(
          "coverage1",
          buffer,
          {
            filename: "coverage1.msgpack",
            contentType: "application/msgpack"
          }
        );
        this.form.append(
          "event",
          // The intake requires a populated dictionary here. Simply having {} is not valid.
          // We use dummy: true but any other key/value pair would be valid.
          JSON.stringify({ dummy: true }),
          { filename: "event.json", contentType: "application/json" }
        );
        const form = this.form;
        this.form = new FormData();
        this.reset();
        return form;
      }
    };
    module2.exports = { CoverageCIVisibilityEncoder };
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js
var require_coverage_writer = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/agentless/coverage-writer.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var log = require_log2();
    var { safeJSONStringify } = require_util3();
    var { getEnvironmentVariable } = require_config_helper();
    var { CoverageCIVisibilityEncoder } = require_coverage_ci_visibility();
    var BaseWriter = require_writer3();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS,
      TELEMETRY_ENDPOINT_PAYLOAD_BYTES,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
      TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
      TELEMETRY_ENDPOINT_PAYLOAD_DROPPED
    } = require_telemetry();
    var Writer = class extends BaseWriter {
      constructor({ url, evpProxyPrefix = "" }) {
        super(...arguments);
        this._url = url;
        this._encoder = new CoverageCIVisibilityEncoder(this);
        this._evpProxyPrefix = evpProxyPrefix;
      }
      _sendPayload(form, _2, done) {
        const options = {
          path: "/api/v2/citestcov",
          method: "POST",
          headers: {
            "dd-api-key": getEnvironmentVariable("DD_API_KEY"),
            ...form.getHeaders()
          },
          timeout: 15e3,
          url: this._url
        };
        if (this._evpProxyPrefix) {
          options.path = `${this._evpProxyPrefix}/api/v2/citestcov`;
          delete options.headers["dd-api-key"];
          options.headers["X-Datadog-EVP-Subdomain"] = "citestcov-intake";
        }
        log.debug(() => `Request to the intake: ${safeJSONStringify(options)}`);
        const startRequestTime = Date.now();
        incrementCountMetric(TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS, { endpoint: "code_coverage" });
        distributionMetric(TELEMETRY_ENDPOINT_PAYLOAD_BYTES, { endpoint: "code_coverage" }, form.size());
        request2(form, options, (err, res, statusCode) => {
          distributionMetric(
            TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_MS,
            { endpoint: "code_coverage" },
            Date.now() - startRequestTime
          );
          if (err) {
            incrementCountMetric(
              TELEMETRY_ENDPOINT_PAYLOAD_REQUESTS_ERRORS,
              { endpoint: "code_coverage", statusCode }
            );
            incrementCountMetric(
              TELEMETRY_ENDPOINT_PAYLOAD_DROPPED,
              { endpoint: "code_coverage" }
            );
            log.error("Error sending CI coverage payload", err);
            done();
            return;
          }
          log.debug("Response from the intake:", res);
          done();
        });
      }
    };
    module2.exports = Writer;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js
var require_git_metadata = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/git/git_metadata.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var FormData = require_form_data();
    var request2 = require_request();
    var { getEnvironmentVariable } = require_config_helper();
    var log = require_log2();
    var { isFalse } = require_util();
    var {
      getLatestCommits,
      getRepositoryUrl,
      generatePackFilesForCommits,
      getCommitsRevList,
      isShallowRepository,
      unshallowRepository,
      isGitAvailable
    } = require_git();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS,
      TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS,
      TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES
    } = require_telemetry();
    var isValidSha1 = (sha) => /^[0-9a-f]{40}$/.test(sha);
    var isValidSha256 = (sha) => /^[0-9a-f]{64}$/.test(sha);
    function validateCommits(commits) {
      return commits.map(({ id: commitSha, type }) => {
        if (type !== "commit") {
          throw new Error("Invalid commit type response");
        }
        if (isValidSha1(commitSha) || isValidSha256(commitSha)) {
          return commitSha.replaceAll(/[^0-9a-f]+/g, "");
        }
        throw new Error("Invalid commit format");
      });
    }
    function getCommonRequestOptions(url) {
      return {
        method: "POST",
        headers: {
          "dd-api-key": getEnvironmentVariable("DD_API_KEY")
        },
        timeout: 15e3,
        url
      };
    }
    function getCommitsToUpload({ url, repositoryUrl, latestCommits, isEvpProxy, evpProxyPrefix }, callback) {
      const commonOptions = getCommonRequestOptions(url);
      const options = {
        ...commonOptions,
        headers: {
          ...commonOptions.headers,
          "Content-Type": "application/json"
        },
        path: "/api/v2/git/repository/search_commits"
      };
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/git/repository/search_commits`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        delete options.headers["dd-api-key"];
      }
      const localCommitData = JSON.stringify({
        meta: {
          repository_url: repositoryUrl
        },
        data: latestCommits.map((commit) => ({
          id: commit,
          type: "commit"
        }))
      });
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS);
      const startTime = Date.now();
      request2(localCommitData, options, (err, response, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_MS, {}, Date.now() - startTime);
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS, { statusCode });
          const error = new Error(`Error fetching commits to exclude: ${err.message}`);
          return callback(error);
        }
        let alreadySeenCommits;
        try {
          alreadySeenCommits = validateCommits(JSON.parse(response).data);
        } catch (e) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SEARCH_COMMITS_ERRORS, { errorType: "network" });
          return callback(new Error(`Can't parse commits to exclude response: ${e.message}`));
        }
        log.debug("There are %s commits to exclude.", alreadySeenCommits.length);
        const commitsToInclude = latestCommits.filter((commit) => !alreadySeenCommits.includes(commit));
        log.debug("There are %s commits to include.", commitsToInclude.length);
        if (!commitsToInclude.length) {
          return callback(null, []);
        }
        const commitsToUpload = getCommitsRevList(alreadySeenCommits, commitsToInclude);
        if (commitsToUpload === null) {
          return callback(new Error("git rev-list failed"));
        }
        callback(null, commitsToUpload);
      });
    }
    function uploadPackFile({ url, isEvpProxy, evpProxyPrefix, packFileToUpload, repositoryUrl, headCommit }, callback) {
      const form = new FormData();
      const pushedSha = JSON.stringify({
        data: {
          id: headCommit,
          type: "commit"
        },
        meta: {
          repository_url: repositoryUrl
        }
      });
      form.append("pushedSha", pushedSha, { contentType: "application/json" });
      try {
        const packFileContent = fs.readFileSync(packFileToUpload);
        const [, filename] = path.basename(packFileToUpload).split("-");
        form.append("packfile", packFileContent, {
          filename,
          contentType: "application/octet-stream"
        });
      } catch {
        callback(new Error(`Could not read "${packFileToUpload}"`));
        return;
      }
      const commonOptions = getCommonRequestOptions(url);
      const options = {
        ...commonOptions,
        path: "/api/v2/git/repository/packfile",
        headers: {
          ...commonOptions.headers,
          ...form.getHeaders()
        }
      };
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/git/repository/packfile`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
        delete options.headers["dd-api-key"];
      }
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES);
      const uploadSize = form.size();
      const startTime = Date.now();
      request2(form, options, (err, _2, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_MS, {}, Date.now() - startTime);
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_ERRORS, { statusCode });
          const error = new Error(`Could not upload packfiles: status code ${statusCode}: ${err.message}`);
          return callback(error, uploadSize);
        }
        callback(null, uploadSize);
      });
    }
    function generateAndUploadPackFiles({
      url,
      isEvpProxy,
      evpProxyPrefix,
      commitsToUpload,
      repositoryUrl,
      headCommit
    }, callback) {
      log.debug("There are %s commits to upload", commitsToUpload.length);
      const packFilesToUpload = generatePackFilesForCommits(commitsToUpload);
      log.debug("Uploading %s packfiles.", packFilesToUpload.length);
      if (!packFilesToUpload.length) {
        return callback(new Error("Failed to generate packfiles"));
      }
      distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_NUM, {}, packFilesToUpload.length);
      let packFileIndex = 0;
      let totalUploadedBytes = 0;
      const uploadPackFileCallback = (err, byteLength) => {
        totalUploadedBytes += byteLength;
        if (err || packFileIndex === packFilesToUpload.length) {
          distributionMetric(TELEMETRY_GIT_REQUESTS_OBJECT_PACKFILES_BYTES, {}, totalUploadedBytes);
          return callback(err);
        }
        return uploadPackFile(
          {
            packFileToUpload: packFilesToUpload[packFileIndex++],
            url,
            isEvpProxy,
            evpProxyPrefix,
            repositoryUrl,
            headCommit
          },
          uploadPackFileCallback
        );
      };
      uploadPackFile(
        {
          packFileToUpload: packFilesToUpload[packFileIndex++],
          url,
          isEvpProxy,
          evpProxyPrefix,
          repositoryUrl,
          headCommit
        },
        uploadPackFileCallback
      );
    }
    function sendGitMetadata(url, { isEvpProxy, evpProxyPrefix }, configRepositoryUrl, callback) {
      if (!isGitAvailable()) {
        return callback(new Error("Git is not available"));
      }
      let repositoryUrl = configRepositoryUrl;
      if (!repositoryUrl) {
        repositoryUrl = getRepositoryUrl();
      }
      log.debug("Uploading git history for repository", repositoryUrl);
      if (!repositoryUrl) {
        return callback(new Error("Repository URL is empty"));
      }
      let latestCommits = getLatestCommits();
      log.debug("There were %s commits since last month.", latestCommits.length);
      const getOnFinishGetCommitsToUpload = (hasCheckedShallow) => (err, commitsToUpload) => {
        if (err) {
          return callback(err);
        }
        if (!commitsToUpload.length) {
          log.debug("No commits to upload");
          return callback(null);
        }
        if (hasCheckedShallow || !isShallowRepository()) {
          const [headCommit] = latestCommits;
          return generateAndUploadPackFiles({
            url,
            isEvpProxy,
            evpProxyPrefix,
            commitsToUpload,
            repositoryUrl,
            headCommit
          }, callback);
        }
        log.debug("It is shallow clone, unshallowing...");
        if (!isFalse(getEnvironmentVariable("DD_CIVISIBILITY_GIT_UNSHALLOW_ENABLED"))) {
          unshallowRepository(false);
        }
        latestCommits = getLatestCommits();
        getCommitsToUpload({
          url,
          repositoryUrl,
          latestCommits,
          isEvpProxy,
          evpProxyPrefix
        }, getOnFinishGetCommitsToUpload(true));
      };
      getCommitsToUpload({
        url,
        repositoryUrl,
        latestCommits,
        isEvpProxy,
        evpProxyPrefix
      }, getOnFinishGetCommitsToUpload(false));
    }
    module2.exports = {
      sendGitMetadata
    };
  }
});

// ../../packages/dd-trace/src/ci-visibility/requests/get-library-configuration.js
var require_get_library_configuration = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/requests/get-library-configuration.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var id = require_id();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_GIT_REQUESTS_SETTINGS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_MS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS,
      TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE
    } = require_telemetry();
    var DEFAULT_EARLY_FLAKE_DETECTION_NUM_RETRIES = 2;
    var DEFAULT_EARLY_FLAKE_DETECTION_ERROR_THRESHOLD = 30;
    function getLibraryConfiguration({
      url,
      isEvpProxy,
      evpProxyPrefix,
      env,
      service,
      repositoryUrl,
      sha,
      osVersion,
      osPlatform,
      osArchitecture,
      runtimeName,
      runtimeVersion,
      branch,
      testLevel = "suite",
      custom,
      tag
    }, done) {
      const options = {
        path: "/api/v2/libraries/tests/services/setting",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        url,
        timeout: 2e4
      };
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/libraries/tests/services/setting`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
      } else {
        const apiKey = getEnvironmentVariable("DD_API_KEY");
        if (!apiKey) {
          return done(new Error("Request to settings endpoint was not done because Datadog API key is not defined."));
        }
        options.headers["dd-api-key"] = apiKey;
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: "ci_app_test_service_libraries_settings",
          attributes: {
            test_level: testLevel,
            configurations: {
              "os.platform": osPlatform,
              "os.version": osVersion,
              "os.architecture": osArchitecture,
              "runtime.name": runtimeName,
              "runtime.version": runtimeVersion,
              custom
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha,
            branch: branch || tag
          }
        }
      });
      incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS);
      const startTime = Date.now();
      request2(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_MS, {}, Date.now() - startTime);
        if (err) {
          incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_ERRORS, { statusCode });
          done(err);
        } else {
          try {
            const {
              data: {
                attributes: {
                  code_coverage: isCodeCoverageEnabled,
                  tests_skipping: isSuitesSkippingEnabled,
                  itr_enabled: isItrEnabled,
                  require_git: requireGit,
                  early_flake_detection: earlyFlakeDetectionConfig,
                  flaky_test_retries_enabled: isFlakyTestRetriesEnabled,
                  di_enabled: isDiEnabled,
                  known_tests_enabled: isKnownTestsEnabled,
                  test_management: testManagementConfig,
                  impacted_tests_enabled: isImpactedTestsEnabled
                }
              }
            } = JSON.parse(res);
            const settings = {
              isCodeCoverageEnabled,
              isSuitesSkippingEnabled,
              isItrEnabled,
              requireGit,
              isEarlyFlakeDetectionEnabled: isKnownTestsEnabled && (earlyFlakeDetectionConfig?.enabled ?? false),
              earlyFlakeDetectionNumRetries: earlyFlakeDetectionConfig?.slow_test_retries?.["5s"] || DEFAULT_EARLY_FLAKE_DETECTION_NUM_RETRIES,
              earlyFlakeDetectionFaultyThreshold: earlyFlakeDetectionConfig?.faulty_session_threshold ?? DEFAULT_EARLY_FLAKE_DETECTION_ERROR_THRESHOLD,
              isFlakyTestRetriesEnabled,
              isDiEnabled: isDiEnabled && isFlakyTestRetriesEnabled,
              isKnownTestsEnabled,
              isTestManagementEnabled: testManagementConfig?.enabled ?? false,
              testManagementAttemptToFixRetries: testManagementConfig?.attempt_to_fix_retries,
              isImpactedTestsEnabled
            };
            log.debug("Remote settings: %j", settings);
            if (getEnvironmentVariable("DD_CIVISIBILITY_DANGEROUSLY_FORCE_COVERAGE")) {
              settings.isCodeCoverageEnabled = true;
              log.debug("Dangerously set code coverage to true");
            }
            if (getEnvironmentVariable("DD_CIVISIBILITY_DANGEROUSLY_FORCE_TEST_SKIPPING")) {
              settings.isSuitesSkippingEnabled = true;
              log.debug("Dangerously set test skipping to true");
            }
            incrementCountMetric(TELEMETRY_GIT_REQUESTS_SETTINGS_RESPONSE, settings);
            done(null, settings);
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    module2.exports = { getLibraryConfiguration };
  }
});

// ../../packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js
var require_get_skippable_suites = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/intelligent-test-runner/get-skippable-suites.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_ITR_SKIPPABLE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_MS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS,
      TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES
    } = require_telemetry();
    function getSkippableSuites({
      url,
      isEvpProxy,
      evpProxyPrefix,
      isGzipCompatible,
      env,
      service,
      repositoryUrl,
      sha,
      osVersion,
      osPlatform,
      osArchitecture,
      runtimeName,
      runtimeVersion,
      custom,
      testLevel = "suite"
    }, done) {
      const options = {
        path: "/api/v2/ci/tests/skippable",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        timeout: 2e4,
        url
      };
      if (isGzipCompatible) {
        options.headers["accept-encoding"] = "gzip";
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/ci/tests/skippable`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
      } else {
        const apiKey = getEnvironmentVariable("DD_API_KEY");
        if (!apiKey) {
          return done(new Error("Skippable suites were not fetched because Datadog API key is not defined."));
        }
        options.headers["dd-api-key"] = apiKey;
      }
      const data = JSON.stringify({
        data: {
          type: "test_params",
          attributes: {
            test_level: testLevel,
            configurations: {
              "os.platform": osPlatform,
              "os.version": osVersion,
              "os.architecture": osArchitecture,
              "runtime.name": runtimeName,
              "runtime.version": runtimeVersion,
              custom
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha
          }
        }
      });
      incrementCountMetric(TELEMETRY_ITR_SKIPPABLE_TESTS);
      const startTime = Date.now();
      request2(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_MS, {}, Date.now() - startTime);
        if (err) {
          incrementCountMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_ERRORS, { statusCode });
          done(err);
        } else {
          try {
            const parsedResponse = JSON.parse(res);
            const skippableSuites = parsedResponse.data.filter(({ type }) => type === testLevel).map(({ attributes: { suite, name } }) => {
              if (testLevel === "suite") {
                return suite;
              }
              return { suite, name };
            });
            const { meta: { correlation_id: correlationId } } = parsedResponse;
            incrementCountMetric(
              testLevel === "test" ? TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_TESTS : TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_SUITES,
              {},
              skippableSuites.length
            );
            distributionMetric(TELEMETRY_ITR_SKIPPABLE_TESTS_RESPONSE_BYTES, {}, res.length);
            log.debug("Number of received skippable %ss:", testLevel, skippableSuites.length);
            done(null, skippableSuites, correlationId);
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    module2.exports = { getSkippableSuites };
  }
});

// ../../packages/dd-trace/src/ci-visibility/early-flake-detection/get-known-tests.js
var require_get_known_tests = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/early-flake-detection/get-known-tests.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var id = require_id();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_KNOWN_TESTS,
      TELEMETRY_KNOWN_TESTS_MS,
      TELEMETRY_KNOWN_TESTS_ERRORS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS,
      TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES
    } = require_telemetry();
    var { getNumFromKnownTests } = require_test();
    function getKnownTests({
      url,
      isEvpProxy,
      evpProxyPrefix,
      isGzipCompatible,
      env,
      service,
      repositoryUrl,
      sha,
      osVersion,
      osPlatform,
      osArchitecture,
      runtimeName,
      runtimeVersion,
      custom
    }, done) {
      const options = {
        path: "/api/v2/ci/libraries/tests",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        timeout: 2e4,
        url
      };
      if (isGzipCompatible) {
        options.headers["accept-encoding"] = "gzip";
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/ci/libraries/tests`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
      } else {
        const apiKey = getEnvironmentVariable("DD_API_KEY");
        if (!apiKey) {
          return done(new Error("Known tests were not fetched because Datadog API key is not defined."));
        }
        options.headers["dd-api-key"] = apiKey;
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: "ci_app_libraries_tests_request",
          attributes: {
            configurations: {
              "os.platform": osPlatform,
              "os.version": osVersion,
              "os.architecture": osArchitecture,
              "runtime.name": runtimeName,
              "runtime.version": runtimeVersion,
              custom
            },
            service,
            env,
            repository_url: repositoryUrl,
            sha
          }
        }
      });
      incrementCountMetric(TELEMETRY_KNOWN_TESTS);
      const startTime = Date.now();
      request2(data, options, (err, res, statusCode) => {
        distributionMetric(TELEMETRY_KNOWN_TESTS_MS, {}, Date.now() - startTime);
        if (err) {
          incrementCountMetric(TELEMETRY_KNOWN_TESTS_ERRORS, { statusCode });
          done(err);
        } else {
          try {
            const { data: { attributes: { tests: knownTests } } } = JSON.parse(res);
            const numTests = getNumFromKnownTests(knownTests);
            incrementCountMetric(TELEMETRY_KNOWN_TESTS_RESPONSE_TESTS, {}, numTests);
            distributionMetric(TELEMETRY_KNOWN_TESTS_RESPONSE_BYTES, {}, res.length);
            log.debug("Number of received known tests:", numTests);
            done(null, knownTests);
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    module2.exports = { getKnownTests };
  }
});

// ../../packages/dd-trace/src/ci-visibility/test-management/get-test-management-tests.js
var require_get_test_management_tests = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/test-management/get-test-management-tests.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var id = require_id();
    var { getEnvironmentVariable } = require_config_helper();
    var log = require_log2();
    function getTestManagementTests({
      url,
      isEvpProxy,
      evpProxyPrefix,
      isGzipCompatible,
      repositoryUrl,
      commitMessage,
      sha,
      commitHeadSha,
      commitHeadMessage
    }, done) {
      const options = {
        path: "/api/v2/test/libraries/test-management/tests",
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        timeout: 2e4,
        url
      };
      if (isGzipCompatible) {
        options.headers["accept-encoding"] = "gzip";
      }
      if (isEvpProxy) {
        options.path = `${evpProxyPrefix}/api/v2/test/libraries/test-management/tests`;
        options.headers["X-Datadog-EVP-Subdomain"] = "api";
      } else {
        const apiKey = getEnvironmentVariable("DD_API_KEY");
        if (!apiKey) {
          return done(new Error("Test management tests were not fetched because Datadog API key is not defined."));
        }
        options.headers["dd-api-key"] = apiKey;
      }
      const data = JSON.stringify({
        data: {
          id: id().toString(10),
          type: "ci_app_libraries_tests_request",
          attributes: {
            repository_url: repositoryUrl,
            commit_message: commitHeadMessage || commitMessage,
            sha: commitHeadSha || sha
          }
        }
      });
      log.debug("Requesting test management tests: %s", data);
      request2(data, options, (err, res) => {
        if (err) {
          done(err);
        } else {
          try {
            const { data: { attributes: { modules: testManagementTests } } } = JSON.parse(res);
            log.debug("Test management tests received: %j", testManagementTests);
            done(null, testManagementTests);
          } catch (err2) {
            done(err2);
          }
        }
      });
    }
    module2.exports = { getTestManagementTests };
  }
});

// ../../packages/dd-trace/src/exporters/common/agent-info-exporter.js
var require_agent_info_exporter = __commonJS({
  "../../packages/dd-trace/src/exporters/common/agent-info-exporter.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var request2 = require_request();
    var defaults = require_config_defaults();
    var { incrementCountMetric, TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION } = require_telemetry();
    function fetchAgentInfo(url, callback) {
      request2("", {
        path: "/info",
        url
      }, (err, res) => {
        if (err) {
          return callback(err);
        }
        try {
          const response = JSON.parse(res);
          return callback(null, response);
        } catch (e) {
          return callback(e);
        }
      });
    }
    var AgentInfoExporter = class {
      constructor(tracerConfig) {
        this._config = tracerConfig;
        const { url, hostname = defaults.hostname, port } = this._config;
        this._url = url || new URL2(format({
          protocol: "http:",
          hostname,
          port
        }));
        this._traceBuffer = [];
        this._isInitialized = false;
      }
      getAgentInfo(onReceivedInfo) {
        fetchAgentInfo(this._url, onReceivedInfo);
      }
      export(trace2) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace2);
          return;
        }
        this._export(trace2);
      }
      _export(payload, writer = this._writer, timerKey = "_timer") {
        if (this._config.isCiVisibility) {
          incrementCountMetric(TELEMETRY_EVENTS_ENQUEUED_FOR_SERIALIZATION, {}, payload.length);
        }
        writer.append(payload);
        const { flushInterval } = this._config;
        if (flushInterval === 0) {
          writer.flush();
        } else if (this[timerKey] === void 0) {
          this[timerKey] = setTimeout(() => {
            writer.flush();
            this[timerKey] = void 0;
          }, flushInterval).unref();
        }
      }
      getUncodedTraces() {
        return this._traceBuffer;
      }
      exportUncodedTraces() {
        this.getUncodedTraces().forEach((uncodedTrace) => {
          this.export(uncodedTrace);
        });
        this.resetUncodedTraces();
      }
      resetUncodedTraces() {
        this._traceBuffer = [];
      }
    };
    module2.exports = AgentInfoExporter;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js
var require_ci_visibility_exporter = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/ci-visibility-exporter.js"(exports2, module2) {
    "use strict";
    var URL2 = __require("url").URL;
    var { sendGitMetadata: sendGitMetadataRequest } = require_git_metadata();
    var { getLibraryConfiguration: getLibraryConfigurationRequest } = require_get_library_configuration();
    var { getSkippableSuites: getSkippableSuitesRequest } = require_get_skippable_suites();
    var { getKnownTests: getKnownTestsRequest } = require_get_known_tests();
    var { getTestManagementTests: getTestManagementTestsRequest } = require_get_test_management_tests();
    var log = require_log2();
    var AgentInfoExporter = require_agent_info_exporter();
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2();
    function getTestConfigurationTags(tags) {
      if (!tags) {
        return {};
      }
      return Object.keys(tags).reduce((acc, key) => {
        if (key.startsWith("test.configuration.")) {
          const [, configKey] = key.split("test.configuration.");
          acc[configKey] = tags[key];
        }
        return acc;
      }, {});
    }
    function getIsTestSessionTrace(trace2) {
      return trace2.some(
        (span) => span.type === "test_session_end" || span.type === "test_suite_end" || span.type === "test_module_end"
      );
    }
    var GIT_UPLOAD_TIMEOUT = 6e4;
    var CAN_USE_CI_VIS_PROTOCOL_TIMEOUT = GIT_UPLOAD_TIMEOUT;
    var CiVisibilityExporter = class extends AgentInfoExporter {
      constructor(config) {
        super(config);
        this._timer = void 0;
        this._coverageTimer = void 0;
        this._logsTimer = void 0;
        this._coverageBuffer = [];
        this._canUseCiVisProtocol = false;
        const gitUploadTimeoutId = setTimeout(() => {
          this._resolveGit(new Error("Timeout while uploading git metadata"));
        }, GIT_UPLOAD_TIMEOUT).unref();
        const canUseCiVisProtocolTimeoutId = setTimeout(() => {
          this._resolveCanUseCiVisProtocol(false);
        }, CAN_USE_CI_VIS_PROTOCOL_TIMEOUT).unref();
        this._gitUploadPromise = new Promise((resolve) => {
          this._resolveGit = (err) => {
            clearTimeout(gitUploadTimeoutId);
            resolve(err);
          };
        });
        this._canUseCiVisProtocolPromise = new Promise((resolve) => {
          this._resolveCanUseCiVisProtocol = (canUseCiVisProtocol) => {
            clearTimeout(canUseCiVisProtocolTimeoutId);
            this._canUseCiVisProtocol = canUseCiVisProtocol;
            resolve(canUseCiVisProtocol);
          };
        });
        process.once("beforeExit", () => {
          if (this._writer) {
            this._writer.flush();
          }
          if (this._coverageWriter) {
            this._coverageWriter.flush();
          }
          if (this._logsWriter) {
            this._logsWriter.flush();
          }
        });
      }
      shouldRequestSkippableSuites() {
        return !!(this._config.isIntelligentTestRunnerEnabled && this._canUseCiVisProtocol && this._libraryConfig?.isSuitesSkippingEnabled);
      }
      shouldRequestKnownTests() {
        return !!(this._canUseCiVisProtocol && this._libraryConfig?.isKnownTestsEnabled);
      }
      shouldRequestTestManagementTests() {
        return !!(this._canUseCiVisProtocol && this._config.isTestManagementEnabled && this._libraryConfig?.isTestManagementEnabled);
      }
      shouldRequestLibraryConfiguration() {
        return this._config.isIntelligentTestRunnerEnabled;
      }
      canReportSessionTraces() {
        return this._canUseCiVisProtocol;
      }
      canReportCodeCoverage() {
        return this._canUseCiVisProtocol;
      }
      getRequestConfiguration(testConfiguration) {
        return {
          url: this._getApiUrl(),
          env: this._config.env,
          service: this._config.service,
          isEvpProxy: !!this._isUsingEvpProxy,
          isGzipCompatible: this._isGzipCompatible,
          evpProxyPrefix: this.evpProxyPrefix,
          custom: getTestConfigurationTags(this._config.tags),
          ...testConfiguration
        };
      }
      // We can't call the skippable endpoint until git upload has finished,
      // hence the this._gitUploadPromise.then
      getSkippableSuites(testConfiguration, callback) {
        if (!this.shouldRequestSkippableSuites()) {
          return callback(null, []);
        }
        this._gitUploadPromise.then((gitUploadError) => {
          if (gitUploadError) {
            return callback(gitUploadError, []);
          }
          getSkippableSuitesRequest(this.getRequestConfiguration(testConfiguration), callback);
        });
      }
      getKnownTests(testConfiguration, callback) {
        if (!this.shouldRequestKnownTests()) {
          return callback(null);
        }
        getKnownTestsRequest(this.getRequestConfiguration(testConfiguration), callback);
      }
      getTestManagementTests(testConfiguration, callback) {
        if (!this.shouldRequestTestManagementTests()) {
          return callback(null);
        }
        getTestManagementTestsRequest(this.getRequestConfiguration(testConfiguration), callback);
      }
      /**
       * We can't request library configuration until we know whether we can use the
       * CI Visibility Protocol, hence the this._canUseCiVisProtocol promise.
       */
      getLibraryConfiguration(testConfiguration, callback) {
        const { repositoryUrl } = testConfiguration;
        this.sendGitMetadata(repositoryUrl);
        if (!this.shouldRequestLibraryConfiguration()) {
          return callback(null, {});
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return callback(null, {});
          }
          const configuration = this.getRequestConfiguration(testConfiguration);
          getLibraryConfigurationRequest(configuration, (err, libraryConfig) => {
            this._libraryConfig = this.filterConfiguration(libraryConfig);
            if (err) {
              callback(err, {});
            } else if (libraryConfig?.requireGit) {
              this._gitUploadPromise.then((gitUploadError) => {
                if (gitUploadError) {
                  return callback(gitUploadError, {});
                }
                getLibraryConfigurationRequest(configuration, (err2, finalLibraryConfig) => {
                  this._libraryConfig = this.filterConfiguration(finalLibraryConfig);
                  callback(err2, this._libraryConfig);
                });
              });
            } else {
              callback(null, this._libraryConfig);
            }
          });
        });
      }
      // Takes into account potential kill switches
      filterConfiguration(remoteConfiguration) {
        if (!remoteConfiguration) {
          return {};
        }
        const {
          isCodeCoverageEnabled,
          isSuitesSkippingEnabled,
          isItrEnabled,
          requireGit,
          isEarlyFlakeDetectionEnabled,
          earlyFlakeDetectionNumRetries,
          earlyFlakeDetectionFaultyThreshold,
          isFlakyTestRetriesEnabled,
          isDiEnabled,
          isKnownTestsEnabled,
          isTestManagementEnabled,
          testManagementAttemptToFixRetries,
          isImpactedTestsEnabled
        } = remoteConfiguration;
        return {
          isCodeCoverageEnabled,
          isSuitesSkippingEnabled,
          isItrEnabled,
          requireGit,
          isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled && this._config.isEarlyFlakeDetectionEnabled,
          earlyFlakeDetectionNumRetries,
          earlyFlakeDetectionFaultyThreshold,
          isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled && this._config.isFlakyTestRetriesEnabled,
          flakyTestRetriesCount: this._config.flakyTestRetriesCount,
          isDiEnabled: isDiEnabled && this._config.isTestDynamicInstrumentationEnabled,
          isKnownTestsEnabled,
          isTestManagementEnabled: isTestManagementEnabled && this._config.isTestManagementEnabled,
          testManagementAttemptToFixRetries: testManagementAttemptToFixRetries ?? this._config.testManagementAttemptToFixRetries,
          isImpactedTestsEnabled: isImpactedTestsEnabled && this._config.isImpactedTestsEnabled
        };
      }
      sendGitMetadata(repositoryUrl) {
        if (!this._config.isGitUploadEnabled) {
          return;
        }
        this._canUseCiVisProtocolPromise.then((canUseCiVisProtocol) => {
          if (!canUseCiVisProtocol) {
            return;
          }
          sendGitMetadataRequest(
            this._getApiUrl(),
            { isEvpProxy: !!this._isUsingEvpProxy, evpProxyPrefix: this.evpProxyPrefix },
            repositoryUrl,
            (err) => {
              if (err) {
                log.error("Error uploading git metadata: %s", err.message);
              } else {
                log.debug("Successfully uploaded git metadata");
              }
              this._resolveGit(err);
            }
          );
        });
      }
      export(trace2) {
        if (!this._isInitialized) {
          this._traceBuffer.push(trace2);
          return;
        }
        if (!this.canReportSessionTraces() && getIsTestSessionTrace(trace2)) {
          return;
        }
        this._export(trace2);
      }
      exportCoverage(formattedCoverage) {
        if (!this._isInitialized) {
          this._coverageBuffer.push(formattedCoverage);
          return;
        }
        if (!this.canReportCodeCoverage()) {
          return;
        }
        this._export(formattedCoverage, this._coverageWriter, "_coverageTimer");
      }
      formatLogMessage(testEnvironmentMetadata, logMessage) {
        const {
          [GIT_REPOSITORY_URL]: gitRepositoryUrl,
          [GIT_COMMIT_SHA]: gitCommitSha
        } = testEnvironmentMetadata;
        const { service, env, version } = this._config;
        return {
          ddtags: [
            ...logMessage.ddtags || [],
            `${GIT_REPOSITORY_URL}:${gitRepositoryUrl}`,
            `${GIT_COMMIT_SHA}:${gitCommitSha}`
          ].join(","),
          level: "error",
          service,
          dd: {
            ...logMessage.dd || [],
            service,
            env,
            version
          },
          ddsource: "dd_debugger",
          ...logMessage
        };
      }
      // DI logs
      exportDiLogs(testEnvironmentMetadata, logMessage) {
        if (!this._config.isTestDynamicInstrumentationEnabled || !this._isInitialized || !this._canForwardLogs) {
          return;
        }
        this._export(
          this.formatLogMessage(testEnvironmentMetadata, logMessage),
          this._logsWriter,
          "_logsTimer"
        );
      }
      flush(done = () => {
      }) {
        if (!this._isInitialized) {
          return done();
        }
        const writers = [
          this._writer,
          this._coverageWriter,
          this._logsWriter
        ].filter(Boolean);
        let remaining = writers.length;
        if (remaining === 0) {
          return done();
        }
        const onFlushComplete = () => {
          remaining -= 1;
          if (remaining === 0) {
            done();
          }
        };
        writers.forEach((writer) => writer.flush(onFlushComplete));
      }
      exportUncodedCoverages() {
        this._coverageBuffer.forEach((oldCoveragePayload) => {
          this.exportCoverage(oldCoveragePayload);
        });
        this._coverageBuffer = [];
      }
      _setUrl(url, coverageUrl = url) {
        try {
          url = new URL2(url);
          coverageUrl = new URL2(coverageUrl);
          this._url = url;
          this._coverageUrl = coverageUrl;
          this._writer.setUrl(url);
          this._coverageWriter.setUrl(coverageUrl);
        } catch (e) {
          log.error("Error setting CI exporter url", e);
        }
      }
      _getApiUrl() {
        return this._url;
      }
      // By the time addMetadataTags is called, the agent info request might not have finished
      addMetadataTags(tags) {
        if (this._writer?.addMetadataTags) {
          this._writer.addMetadataTags(tags);
        } else {
          this._canUseCiVisProtocolPromise.then(() => {
            if (this._writer?.addMetadataTags) {
              this._writer.addMetadataTags(tags);
            }
          });
        }
      }
    };
    module2.exports = CiVisibilityExporter;
  }
});

// ../../packages/dd-trace/src/ci-visibility/encode/json-encoder.js
var require_json_encoder = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/encode/json-encoder.js"(exports2, module2) {
    "use strict";
    var JSONEncoder = class {
      constructor() {
        this.payloads = [];
      }
      encode(payload) {
        this.payloads.push(payload);
      }
      count() {
        return this.payloads.length;
      }
      reset() {
        this.payloads = [];
      }
      makePayload() {
        const data = JSON.stringify(this.payloads);
        this.reset();
        return data;
      }
    };
    module2.exports = { JSONEncoder };
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/agentless/di-logs-writer.js
var require_di_logs_writer = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/agentless/di-logs-writer.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var log = require_log2();
    var { safeJSONStringify } = require_util3();
    var { JSONEncoder } = require_json_encoder();
    var { getEnvironmentVariable } = require_config_helper();
    var BaseWriter = require_writer3();
    var DynamicInstrumentationLogsWriter = class extends BaseWriter {
      constructor({ url, timeout, isAgentProxy = false }) {
        super(...arguments);
        this._url = url;
        this._encoder = new JSONEncoder();
        this._isAgentProxy = isAgentProxy;
        this.timeout = timeout;
      }
      _sendPayload(data, _2, done) {
        const options = {
          path: "/api/v2/logs",
          method: "POST",
          headers: {
            "dd-api-key": getEnvironmentVariable("DD_API_KEY"),
            "Content-Type": "application/json"
          },
          // TODO: what's a good value for timeout for the logs intake?
          timeout: this.timeout || 15e3,
          url: this._url
        };
        if (this._isAgentProxy) {
          delete options.headers["dd-api-key"];
          options.path = "/debugger/v1/input";
        }
        log.debug(() => `Request to the logs intake: ${safeJSONStringify(options)}`);
        request2(data, options, (err, res) => {
          if (err) {
            log.error("Error sending DI logs payload", err);
            done();
            return;
          }
          log.debug("Response from the logs intake:", res);
          done();
        });
      }
    };
    module2.exports = DynamicInstrumentationLogsWriter;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/agentless/index.js
var require_agentless = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/agentless/index.js"(exports2, module2) {
    "use strict";
    var URL2 = __require("url").URL;
    var Writer = require_writer7();
    var CoverageWriter = require_coverage_writer();
    var CiVisibilityExporter = require_ci_visibility_exporter();
    var log = require_log2();
    var AgentlessCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config);
        const { tags, site, url, isTestDynamicInstrumentationEnabled } = config;
        this._isInitialized = true;
        this._resolveCanUseCiVisProtocol(true);
        this._canForwardLogs = true;
        this._url = url || new URL2(`https://citestcycle-intake.${site}`);
        this._writer = new Writer({ url: this._url, tags });
        this._coverageUrl = url || new URL2(`https://citestcov-intake.${site}`);
        this._coverageWriter = new CoverageWriter({ url: this._coverageUrl });
        if (isTestDynamicInstrumentationEnabled) {
          const DynamicInstrumentationLogsWriter = require_di_logs_writer();
          this._logsUrl = url || new URL2(`https://http-intake.logs.${site}`);
          this._logsWriter = new DynamicInstrumentationLogsWriter({ url: this._logsUrl, tags });
        }
        this._apiUrl = url || new URL2(`https://api.${site}`);
        this._isGzipCompatible = true;
      }
      setUrl(url, coverageUrl = url, apiUrl = url) {
        this._setUrl(url, coverageUrl);
        try {
          apiUrl = new URL2(apiUrl);
          this._apiUrl = apiUrl;
        } catch (e) {
          log.error("Error setting CI exporter api url", e);
        }
      }
      _getApiUrl() {
        return this._apiUrl;
      }
    };
    module2.exports = AgentlessCiVisibilityExporter;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js
var require_agent_proxy = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/agent-proxy/index.js"(exports2, module2) {
    "use strict";
    var AgentWriter = require_writer6();
    var AgentlessWriter = require_writer7();
    var CoverageWriter = require_coverage_writer();
    var CiVisibilityExporter = require_ci_visibility_exporter();
    var AGENT_EVP_PROXY_PATH_PREFIX = "/evp_proxy/v";
    var AGENT_EVP_PROXY_PATH_REGEX = /\/evp_proxy\/v(\d+)\/?/;
    var AGENT_DEBUGGER_INPUT = "/debugger/v1/input";
    function getLatestEvpProxyVersion(err, agentInfo) {
      if (err) {
        return 0;
      }
      return agentInfo.endpoints.reduce((acc, endpoint) => {
        if (endpoint.includes(AGENT_EVP_PROXY_PATH_PREFIX)) {
          const version = Number(endpoint.replace(AGENT_EVP_PROXY_PATH_REGEX, "$1"));
          if (Number.isNaN(version)) {
            return acc;
          }
          return Math.max(version, acc);
        }
        return acc;
      }, 0);
    }
    function getCanForwardDebuggerLogs(err, agentInfo) {
      return !err && agentInfo.endpoints.includes(AGENT_DEBUGGER_INPUT);
    }
    var AgentProxyCiVisibilityExporter = class extends CiVisibilityExporter {
      constructor(config) {
        super(config);
        const {
          tags,
          prioritySampler,
          lookup,
          protocolVersion,
          headers,
          isTestDynamicInstrumentationEnabled
        } = config;
        this.getAgentInfo((err, agentInfo) => {
          this._isInitialized = true;
          let latestEvpProxyVersion = getLatestEvpProxyVersion(err, agentInfo);
          const isEvpCompatible = latestEvpProxyVersion >= 2;
          const isGzipCompatible = latestEvpProxyVersion >= 4;
          if (latestEvpProxyVersion === 3) {
            latestEvpProxyVersion = 2;
          }
          const evpProxyPrefix = `${AGENT_EVP_PROXY_PATH_PREFIX}${latestEvpProxyVersion}`;
          if (isEvpCompatible) {
            this._isUsingEvpProxy = true;
            this.evpProxyPrefix = evpProxyPrefix;
            this._writer = new AgentlessWriter({
              url: this._url,
              tags,
              evpProxyPrefix
            });
            this._coverageWriter = new CoverageWriter({
              url: this._url,
              evpProxyPrefix
            });
            if (isTestDynamicInstrumentationEnabled) {
              const canFowardLogs = getCanForwardDebuggerLogs(err, agentInfo);
              if (canFowardLogs) {
                const DynamicInstrumentationLogsWriter = require_di_logs_writer();
                this._logsWriter = new DynamicInstrumentationLogsWriter({
                  url: this._url,
                  tags,
                  isAgentProxy: true
                });
                this._canForwardLogs = true;
              }
            }
          } else {
            this._writer = new AgentWriter({
              url: this._url,
              prioritySampler,
              lookup,
              protocolVersion,
              headers
            });
            this._coverageBuffer = [];
          }
          this._resolveCanUseCiVisProtocol(isEvpCompatible);
          this.exportUncodedTraces();
          this.exportUncodedCoverages();
          this._isGzipCompatible = isGzipCompatible;
        });
      }
      setUrl(url, coverageUrl) {
        this._setUrl(url, coverageUrl);
      }
    };
    module2.exports = AgentProxyCiVisibilityExporter;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/test-worker/writer.js
var require_writer8 = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/test-worker/writer.js"(exports2, module2) {
    "use strict";
    var { JSONEncoder } = require_json_encoder();
    var { getEnvironmentVariable } = require_config_helper();
    var Writer = class {
      constructor(interprocessCode) {
        this._encoder = new JSONEncoder();
        this._interprocessCode = interprocessCode;
      }
      flush(onDone) {
        const count = this._encoder.count();
        if (count > 0) {
          const payload = this._encoder.makePayload();
          this._sendPayload(payload, onDone);
        }
      }
      append(payload) {
        this._encoder.encode(payload);
      }
      _sendPayload(data, onDone = () => {
      }) {
        if (process.send) {
          const isVitestWorker = !!getEnvironmentVariable("TINYPOOL_WORKER_ID");
          const payload = isVitestWorker ? { __tinypool_worker_message__: true, interprocessCode: this._interprocessCode, data } : [this._interprocessCode, data];
          process.send(payload, () => {
            onDone();
          });
        } else {
          onDone();
        }
      }
    };
    module2.exports = Writer;
  }
});

// ../../packages/dd-trace/src/ci-visibility/exporters/test-worker/index.js
var require_test_worker = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/exporters/test-worker/index.js"(exports2, module2) {
    "use strict";
    var Writer = require_writer8();
    var {
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_LOGS_PAYLOAD_CODE
    } = require_test();
    var { getEnvironmentVariable } = require_config_helper();
    function getInterprocessTraceCode() {
      if (getEnvironmentVariable("JEST_WORKER_ID")) {
        return JEST_WORKER_TRACE_PAYLOAD_CODE;
      }
      if (getEnvironmentVariable("CUCUMBER_WORKER_ID")) {
        return CUCUMBER_WORKER_TRACE_PAYLOAD_CODE;
      }
      if (getEnvironmentVariable("MOCHA_WORKER_ID")) {
        return MOCHA_WORKER_TRACE_PAYLOAD_CODE;
      }
      if (getEnvironmentVariable("DD_PLAYWRIGHT_WORKER")) {
        return PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE;
      }
      if (getEnvironmentVariable("TINYPOOL_WORKER_ID")) {
        return VITEST_WORKER_TRACE_PAYLOAD_CODE;
      }
      return null;
    }
    function getInterprocessCoverageCode() {
      if (getEnvironmentVariable("JEST_WORKER_ID")) {
        return JEST_WORKER_COVERAGE_PAYLOAD_CODE;
      }
      return null;
    }
    function getInterprocessLogsCode() {
      if (getEnvironmentVariable("JEST_WORKER_ID")) {
        return JEST_WORKER_LOGS_PAYLOAD_CODE;
      }
      if (getEnvironmentVariable("TINYPOOL_WORKER_ID")) {
        return VITEST_WORKER_LOGS_PAYLOAD_CODE;
      }
      return null;
    }
    var TestWorkerCiVisibilityExporter = class {
      constructor() {
        const interprocessTraceCode = getInterprocessTraceCode();
        const interprocessCoverageCode = getInterprocessCoverageCode();
        const interprocessLogsCode = getInterprocessLogsCode();
        this._writer = new Writer(interprocessTraceCode);
        this._coverageWriter = new Writer(interprocessCoverageCode);
        this._logsWriter = new Writer(interprocessLogsCode);
      }
      export(payload) {
        this._writer.append(payload);
      }
      exportCoverage(formattedCoverage) {
        this._coverageWriter.append(formattedCoverage);
      }
      exportDiLogs(testEnvironmentMetadata, logMessage) {
        this._logsWriter.append({ testEnvironmentMetadata, logMessage });
      }
      // TODO: add to other writers
      flush(onDone) {
        this._writer.flush(onDone);
        this._coverageWriter.flush();
        this._logsWriter.flush();
      }
    };
    module2.exports = TestWorkerCiVisibilityExporter;
  }
});

// ../../packages/dd-trace/src/exporter.js
var require_exporter2 = __commonJS({
  "../../packages/dd-trace/src/exporter.js"(exports2, module2) {
    "use strict";
    var exporters = require_exporters();
    var fs = __require("fs");
    var constants = require_constants3();
    var { getEnvironmentVariable } = require_config_helper();
    module2.exports = function getExporter(name) {
      switch (name) {
        case exporters.LOG:
          return require_log4();
        case exporters.AGENT:
          return require_agent();
        case exporters.DATADOG:
          return require_agentless();
        case exporters.AGENT_PROXY:
          return require_agent_proxy();
        case exporters.JEST_WORKER:
        case exporters.CUCUMBER_WORKER:
        case exporters.MOCHA_WORKER:
        case exporters.PLAYWRIGHT_WORKER:
        case exporters.VITEST_WORKER:
          return require_test_worker();
        default: {
          const inAWSLambda = getEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") !== void 0;
          const usingLambdaExtension = inAWSLambda && fs.existsSync(constants.DATADOG_LAMBDA_EXTENSION_PATH);
          return inAWSLambda && !usingLambdaExtension ? require_log4() : require_agent();
        }
      }
    };
  }
});

// ../../packages/dd-trace/src/opentracing/tracer.js
var require_tracer3 = __commonJS({
  "../../packages/dd-trace/src/opentracing/tracer.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var Span = require_span2();
    var SpanProcessor = require_span_processor2();
    var PrioritySampler = require_priority_sampler();
    var TextMapPropagator = require_text_map();
    var DSMTextMapPropagator = require_text_map_dsm();
    var HttpPropagator = require_http();
    var BinaryPropagator = require_binary();
    var LogPropagator = require_log3();
    var formats = require_formats();
    var log = require_log2();
    var runtimeMetrics = require_runtime_metrics2();
    var getExporter = require_exporter2();
    var SpanContext = require_span_context();
    var REFERENCE_CHILD_OF = "child_of";
    var REFERENCE_FOLLOWS_FROM = "follows_from";
    var DatadogTracer = class {
      constructor(config, prioritySampler) {
        const Exporter = getExporter(config.experimental.exporter);
        this._config = config;
        this._service = config.service;
        this._version = config.version;
        this._env = config.env;
        this._logInjection = config.logInjection;
        this._debug = config.debug;
        this._prioritySampler = prioritySampler ?? new PrioritySampler(config.env, config.sampler);
        this._exporter = new Exporter(config, this._prioritySampler);
        this._processor = new SpanProcessor(this._exporter, this._prioritySampler, config);
        this._url = this._exporter._url;
        this._enableGetRumData = config.experimental.enableGetRumData;
        this._traceId128BitGenerationEnabled = config.traceId128BitGenerationEnabled;
        this._propagators = {
          [formats.TEXT_MAP]: new TextMapPropagator(config),
          [formats.HTTP_HEADERS]: new HttpPropagator(config),
          [formats.BINARY]: new BinaryPropagator(config),
          [formats.LOG]: new LogPropagator(config),
          [formats.TEXT_MAP_DSM]: new DSMTextMapPropagator(config)
        };
        if (config.reportHostname) {
          this._hostname = os.hostname();
        }
      }
      startSpan(name, options = {}) {
        const parent = options.childOf ? getContext(options.childOf) : getParent(options.references);
        const tags = {
          "service.name": options?.tags?.service ? String(options.tags.service) : this._service
        };
        if (options?.tags?.service && options.tags.service !== this._service) {
          options.tags.version = void 0;
        }
        const span = new Span(this, this._processor, this._prioritySampler, {
          operationName: options.operationName || name,
          parent,
          tags,
          startTime: options.startTime,
          hostname: this._hostname,
          traceId128BitGenerationEnabled: this._traceId128BitGenerationEnabled,
          integrationName: options.integrationName,
          links: options.links
        }, this._debug);
        span.addTags(this._config.tags);
        span.addTags(options.tags);
        return span;
      }
      inject(context2, format, carrier) {
        if (context2 instanceof Span) {
          context2 = context2.context();
        }
        try {
          if (format !== "text_map_dsm" && format !== formats.LOG) {
            this._prioritySampler.sample(context2);
          }
          this._propagators[format].inject(context2, carrier);
        } catch (e) {
          log.error("Error injecting trace", e);
          runtimeMetrics.increment("datadog.tracer.node.inject.errors", true);
        }
      }
      extract(format, carrier) {
        try {
          return this._propagators[format].extract(carrier);
        } catch (e) {
          log.error("Error extracting trace", e);
          runtimeMetrics.increment("datadog.tracer.node.extract.errors", true);
          return null;
        }
      }
    };
    function getContext(spanContext) {
      if (spanContext instanceof Span) {
        spanContext = spanContext.context();
      }
      if (!(spanContext instanceof SpanContext)) {
        spanContext = null;
      }
      return spanContext;
    }
    function getParent(references = []) {
      let parent = null;
      for (const ref of references) {
        const type = ref.type();
        if (type === REFERENCE_CHILD_OF) {
          parent = ref.referencedContext();
          break;
        } else if (type === REFERENCE_FOLLOWS_FROM && !parent) {
          parent = ref.referencedContext();
        }
      }
      return parent;
    }
    module2.exports = DatadogTracer;
  }
});

// ../../packages/dd-trace/src/scope.js
var require_scope2 = __commonJS({
  "../../packages/dd-trace/src/scope.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var originals = /* @__PURE__ */ new WeakMap();
    var Scope = class {
      active() {
        const store = storage("legacy").getStore();
        return store && store.span || null;
      }
      activate(span, callback) {
        if (typeof callback !== "function") return callback;
        const oldStore = storage("legacy").getStore();
        const newStore = span ? storage("legacy").getStore(span._store) : oldStore;
        storage("legacy").enterWith({ ...newStore, span });
        try {
          return callback();
        } catch (e) {
          if (span && typeof span.setTag === "function") {
            span.setTag("error", e);
          }
          throw e;
        } finally {
          storage("legacy").enterWith(oldStore);
        }
      }
      bind(fn, span) {
        if (typeof fn !== "function") return fn;
        const scope = this;
        const spanOrActive = this._spanOrActive(span);
        const bound = function() {
          return scope.activate(spanOrActive, () => {
            return fn.apply(this, arguments);
          });
        };
        originals.set(bound, fn);
        return bound;
      }
      _spanOrActive(span) {
        return span === void 0 ? this.active() : span;
      }
      _isPromise(promise) {
        return promise && typeof promise.then === "function";
      }
    };
    module2.exports = Scope;
  }
});

// ../../packages/datadog-instrumentations/src/helpers/extract-package-and-module-path.js
var require_extract_package_and_module_path = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/extract-package-and-module-path.js"(exports2, module2) {
    "use strict";
    var NM = "node_modules/";
    module2.exports = function extractPackageAndModulePath(fullPath) {
      const nm = fullPath.lastIndexOf(NM);
      if (nm === -1) {
        return { pkg: null, path: null };
      }
      const subPath = fullPath.slice(nm + NM.length);
      const firstSlash = subPath.indexOf("/");
      const firstPath = fullPath.slice(0, nm + NM.length);
      const firstSlashSubPath = subPath.slice(Math.max(0, firstSlash + 1));
      if (subPath[0] === "@") {
        const secondSlash = firstSlashSubPath.indexOf("/");
        const pkg2 = subPath.slice(0, Math.max(0, firstSlash + 1 + secondSlash));
        return {
          pkg: pkg2,
          path: subPath.slice(Math.max(0, firstSlash + 1 + secondSlash + 1)),
          pkgJson: firstPath + pkg2 + "/package.json"
        };
      }
      const pkg = subPath.slice(0, Math.max(0, firstSlash));
      return {
        pkg,
        path: firstSlashSubPath,
        pkgJson: firstPath + pkg + "/package.json"
      };
    };
  }
});

// ../../packages/datadog-instrumentations/src/helpers/instrumentations.js
var require_instrumentations = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/instrumentations.js"(exports2, module2) {
    "use strict";
    var sym = Symbol.for("_ddtrace_instrumentations");
    global[sym] = global[sym] || {};
    module2.exports = global[sym];
  }
});

// ../../packages/datadog-instrumentations/src/helpers/instrument.js
var require_instrument = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/instrument.js"(exports2) {
    "use strict";
    var dc = require_dc_polyfill();
    var instrumentations = require_instrumentations();
    var { AsyncResource } = __require("async_hooks");
    var channelMap = {};
    exports2.channel = function(name) {
      const maybe = channelMap[name];
      if (maybe) return maybe;
      const ch = dc.channel(name);
      channelMap[name] = ch;
      return ch;
    };
    var tracingChannelMap = {};
    exports2.tracingChannel = function(name) {
      const maybe = tracingChannelMap[name];
      if (maybe) return maybe;
      const tc = dc.tracingChannel(name);
      tracingChannelMap[name] = tc;
      return tc;
    };
    exports2.addHook = function addHook({ name, versions, file, filePattern, patchDefault }, hook) {
      if (typeof name === "string") {
        name = [name];
      }
      for (const val of name) {
        if (!instrumentations[val]) {
          instrumentations[val] = [];
        }
        instrumentations[val].push({ name: val, versions, file, filePattern, hook, patchDefault });
      }
    };
    exports2.AsyncResource = AsyncResource;
  }
});

// ../../packages/datadog-shimmer/src/shimmer.js
var require_shimmer = __commonJS({
  "../../packages/datadog-shimmer/src/shimmer.js"(exports2, module2) {
    "use strict";
    var skipMethods = /* @__PURE__ */ new Set([
      "caller",
      "arguments",
      "name",
      "length"
    ]);
    var skipMethodSize = skipMethods.size;
    var nonConfigurableModuleExports = /* @__PURE__ */ new WeakMap();
    function copyProperties(original, wrapped) {
      if (original.constructor !== wrapped.constructor) {
        const proto = Object.getPrototypeOf(original);
        Object.setPrototypeOf(wrapped, proto);
      }
      const ownKeys = Reflect.ownKeys(original);
      if (original.length !== wrapped.length) {
        Object.defineProperty(wrapped, "length", { value: original.length, configurable: true });
      }
      if (original.name !== wrapped.name) {
        Object.defineProperty(wrapped, "name", { value: original.name, configurable: true });
      }
      if (ownKeys.length !== 2) {
        for (const key of ownKeys) {
          if (skipMethods.has(key)) continue;
          const descriptor = (
            /** @type {PropertyDescriptor} */
            Object.getOwnPropertyDescriptor(original, key)
          );
          if (descriptor.writable && descriptor.enumerable && descriptor.configurable) {
            wrapped[key] = original[key];
          } else if (descriptor.writable || descriptor.configurable || !Object.hasOwn(wrapped, key)) {
            Object.defineProperty(wrapped, key, descriptor);
          }
        }
      }
    }
    function copyObjectProperties(original, wrapped, skipKey) {
      const ownKeys = Reflect.ownKeys(original);
      for (const key of ownKeys) {
        if (key === skipKey) continue;
        const descriptor = (
          /** @type {PropertyDescriptor} */
          Object.getOwnPropertyDescriptor(original, key)
        );
        if (descriptor.writable && descriptor.enumerable && descriptor.configurable) {
          wrapped[key] = original[key];
        } else if (descriptor.writable || descriptor.configurable || !Object.hasOwn(wrapped, key)) {
          Object.defineProperty(wrapped, key, descriptor);
        }
      }
    }
    function wrapFunction(original, wrapper) {
      const wrapped = wrapper(original);
      if (typeof original === "function") {
        assertNotClass(original);
        copyProperties(original, wrapped);
      }
      return wrapped;
    }
    function wrap(target, name, wrapper, options) {
      if (typeof wrapper !== "function") {
        throw new TypeError(wrapper ? "Target is not a function" : "No function provided");
      }
      if (target == null) {
        return;
      }
      const descriptor = Object.getOwnPropertyDescriptor(target, name) ?? {
        value: target[name],
        writable: true,
        configurable: true,
        enumerable: false
      };
      if (descriptor.set && (!descriptor.get || options?.replaceGetter)) {
        throw new Error(options?.replaceGetter ? "Replacing a getter/setter pair is not supported. Implement if required." : "Replacing setters is not supported. Implement if required.");
      }
      const original = descriptor.value ?? options?.replaceGetter ? target[name] : descriptor.get;
      assertMethod(target, name, original);
      const wrapped = wrapper(original);
      copyProperties(original, wrapped);
      if (descriptor.writable) {
        if (descriptor.configurable && descriptor.enumerable) {
          target[name] = wrapped;
          return target;
        }
        descriptor.value = wrapped;
      } else {
        if (descriptor.get) {
          descriptor.get = options?.replaceGetter ? () => wrapped : wrapped;
        } else {
          descriptor.value = wrapped;
        }
        if (descriptor.configurable === false) {
          let moduleExports = nonConfigurableModuleExports.get(target);
          if (!moduleExports) {
            if (typeof target === "function") {
              const original2 = target;
              moduleExports = function(...args) {
                return original2.apply(original2, args);
              };
              skipMethods.add(name);
              copyProperties(target, moduleExports);
              if (skipMethods.size === skipMethodSize + 1) {
                skipMethods.delete(name);
              }
            } else {
              moduleExports = Object.create(target);
              copyObjectProperties(target, moduleExports, name);
            }
            nonConfigurableModuleExports.set(target, moduleExports);
          }
          target = moduleExports;
        }
      }
      Object.defineProperty(target, name, descriptor);
      return target;
    }
    function massWrap(targets, names, wrapper) {
      targets = toArray(targets);
      names = toArray(names);
      for (const target of targets) {
        for (const name of names) {
          wrap(target, name, wrapper);
        }
      }
    }
    function toArray(maybeArray) {
      return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
    }
    function assertMethod(target, name, method) {
      if (typeof method !== "function") {
        let message = "No target object provided";
        if (target) {
          if (typeof target !== "object" && typeof target !== "function") {
            message = "Invalid target";
          } else {
            name = String(name);
            message = method ? `Original method ${name} is not a function` : `No original method ${name}`;
          }
        }
        throw new TypeError(message);
      }
    }
    function assertNotClass(target) {
      if (Function.prototype.toString.call(target).startsWith("class")) {
        throw new TypeError("Target is a native class constructor and cannot be wrapped.");
      }
    }
    module2.exports = {
      wrap,
      wrapFunction,
      massWrap
    };
  }
});

// ../../packages/datadog-shimmer/index.js
var require_datadog_shimmer = __commonJS({
  "../../packages/datadog-shimmer/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_shimmer();
  }
});

// ../../packages/datadog-instrumentations/src/anthropic.js
var require_anthropic = __commonJS({
  "../../packages/datadog-instrumentations/src/anthropic.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { channel, tracingChannel } = require_dc_polyfill();
    var anthropicTracingChannel = tracingChannel("apm:anthropic:request");
    var onStreamedChunkCh = channel("apm:anthropic:request:chunk");
    function wrapStreamIterator(iterator, ctx) {
      return function() {
        const itr = iterator.apply(this, arguments);
        shimmer.wrap(itr, "next", (next) => function() {
          return next.apply(this, arguments).then((res) => {
            const { done, value: chunk } = res;
            onStreamedChunkCh.publish({ ctx, chunk, done });
            if (done) {
              finish(ctx);
            }
            return res;
          }).catch((error) => {
            finish(ctx, null, error);
            throw error;
          });
        });
        return itr;
      };
    }
    function wrapCreate(create) {
      return function() {
        if (!anthropicTracingChannel.start.hasSubscribers) {
          return create.apply(this, arguments);
        }
        const options = arguments[0];
        const stream = options.stream;
        const ctx = { options, resource: "create" };
        return anthropicTracingChannel.start.runStores(ctx, () => {
          let apiPromise;
          try {
            apiPromise = create.apply(this, arguments);
          } catch (error) {
            finish(ctx, null, error);
            throw error;
          }
          shimmer.wrap(apiPromise, "parse", (parse) => function() {
            return parse.apply(this, arguments).then((response) => {
              if (stream) {
                shimmer.wrap(response, Symbol.asyncIterator, (iterator) => wrapStreamIterator(iterator, ctx));
              } else {
                finish(ctx, response, null);
              }
              return response;
            }).catch((error) => {
              finish(ctx, null, error);
              throw error;
            });
          });
          anthropicTracingChannel.end.publish(ctx);
          return apiPromise;
        });
      };
    }
    function finish(ctx, result, error) {
      if (error) {
        ctx.error = error;
        anthropicTracingChannel.error.publish(ctx);
      }
      ctx.result ??= result;
      anthropicTracingChannel.asyncEnd.publish(ctx);
    }
    var extensions = ["js", "mjs"];
    for (const extension of extensions) {
      addHook({
        name: "@anthropic-ai/sdk",
        file: `resources/messages.${extension}`,
        versions: [">=0.14.0 <0.33.0"]
      }, (exports3) => {
        const Messages = exports3.Messages;
        shimmer.wrap(Messages.prototype, "create", wrapCreate);
        return exports3;
      });
      addHook({
        name: "@anthropic-ai/sdk",
        file: `resources/messages/messages.${extension}`,
        versions: [">=0.33.0"]
      }, (exports3) => {
        const Messages = exports3.Messages;
        shimmer.wrap(Messages.prototype, "create", wrapCreate);
        return exports3;
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/apollo-server.js
var require_apollo_server = __commonJS({
  "../../packages/datadog-instrumentations/src/apollo-server.js"() {
    "use strict";
    var dc = require_dc_polyfill();
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var graphqlMiddlewareChannel = dc.tracingChannel("datadog:apollo:middleware");
    var apolloHttpServerChannel = dc.tracingChannel("datadog:apollo:httpserver");
    var requestChannel = dc.tracingChannel("datadog:apollo:request");
    var HeaderMap;
    function wrapExecuteHTTPGraphQLRequest(originalExecuteHTTPGraphQLRequest) {
      return function executeHTTPGraphQLRequest() {
        if (!HeaderMap || !requestChannel.start.hasSubscribers) {
          return originalExecuteHTTPGraphQLRequest.apply(this, arguments);
        }
        const abortController = new AbortController();
        const abortData = {};
        const graphqlResponseData = requestChannel.tracePromise(
          originalExecuteHTTPGraphQLRequest,
          { abortController, abortData },
          this,
          ...arguments
        );
        const abortPromise = new Promise((resolve, reject) => {
          abortController.signal.addEventListener("abort", (event) => {
            const headers = new HeaderMap();
            Object.keys(abortData.headers).forEach((key) => {
              headers.set(key, abortData.headers[key]);
            });
            resolve({
              headers,
              status: abortData.statusCode,
              body: {
                kind: "complete",
                string: abortData.message
              }
            });
          }, { once: true });
        });
        return Promise.race([abortPromise, graphqlResponseData]);
      };
    }
    function apolloExpress4Hook(express4) {
      shimmer.wrap(express4, "expressMiddleware", function wrapExpressMiddleware(originalExpressMiddleware) {
        return function expressMiddleware(server2, options) {
          const originalMiddleware = originalExpressMiddleware.apply(this, arguments);
          return shimmer.wrapFunction(originalMiddleware, (originalMiddleware2) => function(req, res, next) {
            if (!graphqlMiddlewareChannel.start.hasSubscribers) {
              return originalMiddleware2.apply(this, arguments);
            }
            return graphqlMiddlewareChannel.traceSync(originalMiddleware2, { req }, this, ...arguments);
          });
        };
      });
      return express4;
    }
    function apolloHeaderMapHook(headerMap) {
      HeaderMap = headerMap.HeaderMap;
      return headerMap;
    }
    function apolloServerHook(apolloServer) {
      shimmer.wrap(apolloServer.ApolloServer.prototype, "executeHTTPGraphQLRequest", wrapExecuteHTTPGraphQLRequest);
      return apolloServer;
    }
    function wrapEmit(emit) {
      return function wrappedEmit(event, req, res) {
        if (event === "request" && req && res && apolloHttpServerChannel.start.hasSubscribers) {
          return apolloHttpServerChannel.traceSync(emit, { req }, this, ...arguments);
        }
        return emit.apply(this, arguments);
      };
    }
    function wrapListen(originalListen) {
      return function wrappedListen() {
        shimmer.wrap(this, "emit", wrapEmit);
        return originalListen.apply(this, arguments);
      };
    }
    function wrapHttpServer(original) {
      return function wrappedHttpServer(options) {
        if (options.httpServer && typeof options.httpServer.listen === "function") {
          shimmer.wrap(options.httpServer, "listen", wrapListen);
        }
        return original.apply(this, arguments);
      };
    }
    function apolloDrainHttpServerHook(drainModule) {
      shimmer.wrap(drainModule, "ApolloServerPluginDrainHttpServer", wrapHttpServer);
      return drainModule;
    }
    addHook({ name: "@apollo/server", file: "dist/cjs/ApolloServer.js", versions: ["4"] }, apolloServerHook);
    addHook({ name: "@apollo/server", file: "dist/cjs/express4/index.js", versions: ["4"] }, apolloExpress4Hook);
    addHook({ name: "@apollo/server", file: "dist/cjs/utils/HeaderMap.js", versions: ["4"] }, apolloHeaderMapHook);
    addHook(
      { name: "@apollo/server", file: "dist/cjs/plugin/drainHttpServer/index.js", versions: [">=5.0.0"] },
      apolloDrainHttpServerHook
    );
    addHook(
      { name: "@apollo/server", file: "dist/cjs/runHttpQuery.js", versions: [">=5.0.0"] },
      (runHttpQueryModule) => {
        shimmer.wrap(runHttpQueryModule, "runHttpQuery", function wrapRunHttpQuery(originalRunHttpQuery) {
          return wrapExecuteHTTPGraphQLRequest(originalRunHttpQuery);
        });
        return runHttpQueryModule;
      }
    );
  }
});

// ../../packages/datadog-instrumentations/src/apollo.js
var require_apollo = __commonJS({
  "../../packages/datadog-instrumentations/src/apollo.js"() {
    "use strict";
    var {
      addHook,
      channel
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var CHANNELS = {
      "gateway.request": tracingChannel("apm:apollo:gateway:request"),
      "gateway.plan": tracingChannel("apm:apollo:gateway:plan"),
      "gateway.validate": tracingChannel("apm:apollo:gateway:validate"),
      "gateway.execute": tracingChannel("apm:apollo:gateway:execute"),
      "gateway.fetch": tracingChannel("apm:apollo:gateway:fetch"),
      "gateway.postprocessing": tracingChannel("apm:apollo:gateway:postprocessing")
    };
    var generalErrorCh = channel("apm:apollo:gateway:general:error");
    function wrapApolloGateway(ApolloGateway) {
      class ApolloGatewayWrapper extends ApolloGateway {
        constructor(...args) {
          super(...args);
          shimmer.wrap(this, "executor", (originalExecutor) => (...args2) => {
            const channel2 = CHANNELS["gateway.request"];
            const ctx = { requestContext: args2[0], gateway: this };
            return channel2.tracePromise(originalExecutor, ctx, this, ...args2);
          });
        }
      }
      return ApolloGatewayWrapper;
    }
    function wrapRecordExceptions(recordExceptions) {
      return function wrappedRecordExceptions(...args) {
        const errors = args[1];
        generalErrorCh.publish({ error: errors.at(-1) });
        return recordExceptions.apply(this, args);
      };
    }
    function wrapStartActiveSpan(startActiveSpan) {
      return function(...args) {
        const firstArg = args[0];
        const cb = args.at(-1);
        if (typeof firstArg !== "string" || typeof cb !== "function") return startActiveSpan.apply(this, args);
        const method = CHANNELS[firstArg];
        let ctx = {};
        if (firstArg === "gateway.fetch") {
          ctx = { attributes: args[1].attributes };
        }
        switch (firstArg) {
          case "gateway.plan":
          case "gateway.validate": {
            args[args.length - 1] = function(...callbackArgs) {
              return method.traceSync(cb, ctx, this, ...callbackArgs);
            };
            break;
          }
          // Patch `executor` instead so the requestContext can be captured.
          case "gateway.request":
            break;
          case "gateway.execute":
          case "gateway.postprocessing":
          case "gateway.fetch": {
            args[args.length - 1] = function(...callbackArgs) {
              return method.tracePromise(cb, ctx, this, ...callbackArgs);
            };
            break;
          }
        }
        return startActiveSpan.apply(this, args);
      };
    }
    addHook(
      { name: "@apollo/gateway", file: "dist/utilities/opentelemetry.js", versions: [">=2.3.0"] },
      (obj) => {
        const newTracerObj = Object.create(obj.tracer);
        shimmer.wrap(newTracerObj, "startActiveSpan", wrapStartActiveSpan);
        obj.tracer = newTracerObj;
        return obj;
      }
    );
    addHook(
      { name: "@apollo/gateway", file: "dist/utilities/opentelemetry.js", versions: [">=2.6.0"] },
      (obj) => {
        shimmer.wrap(obj, "recordExceptions", wrapRecordExceptions);
        return obj;
      }
    );
    addHook({ name: "@apollo/gateway", versions: [">=2.3.0"] }, (gateway) => {
      shimmer.wrap(gateway, "ApolloGateway", wrapApolloGateway);
      return gateway;
    });
  }
});

// ../../packages/datadog-instrumentations/src/apollo-server-core.js
var require_apollo_server_core = __commonJS({
  "../../packages/datadog-instrumentations/src/apollo-server-core.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var requestChannel = dc.tracingChannel("datadog:apollo-server-core:request");
    addHook({ name: "apollo-server-core", file: "dist/runHttpQuery.js", versions: [">3.0.0"] }, (runHttpQueryModule) => {
      const HttpQueryError = runHttpQueryModule.HttpQueryError;
      shimmer.wrap(runHttpQueryModule, "runHttpQuery", function wrapRunHttpQuery(originalRunHttpQuery) {
        return function runHttpQuery() {
          if (!requestChannel.start.hasSubscribers) {
            return originalRunHttpQuery.apply(this, arguments);
          }
          const abortController = new AbortController();
          const abortData = {};
          const runHttpQueryResult = requestChannel.tracePromise(
            originalRunHttpQuery,
            { abortController, abortData },
            this,
            ...arguments
          );
          const abortPromise = new Promise((resolve, reject) => {
            abortController.signal.addEventListener("abort", (event) => {
              reject(new HttpQueryError(abortData.statusCode, abortData.message, true, abortData.headers));
            }, { once: true });
          });
          return Promise.race([runHttpQueryResult, abortPromise]);
        };
      });
      return runHttpQueryModule;
    });
  }
});

// ../../packages/datadog-instrumentations/src/aws-sdk.js
var require_aws_sdk = __commonJS({
  "../../packages/datadog-instrumentations/src/aws-sdk.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapRequest(send) {
      return function wrappedRequest(cb) {
        if (!this.service) return send.apply(this, arguments);
        const serviceIdentifier = this.service.serviceIdentifier;
        const channelSuffix = getChannelSuffix(serviceIdentifier);
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`);
        if (!startCh.hasSubscribers) return send.apply(this, arguments);
        const ctx = {
          serviceIdentifier,
          operation: this.operation,
          awsRegion: this.service.config && this.service.config.region,
          awsService: this.service.api && this.service.api.className,
          request: this,
          cbExists: typeof cb === "function"
        };
        this.on("complete", (response) => {
          ctx.response = response;
          channel(`apm:aws:request:complete:${channelSuffix}`).publish(ctx);
        });
        if (ctx.cbExists) {
          arguments[0] = wrapCb(cb, channelSuffix, ctx);
        }
        return startCh.runStores(ctx, send, this, ...arguments);
      };
    }
    function wrapDeserialize(deserialize, channelSuffix) {
      const headersCh = channel(`apm:aws:response:deserialize:${channelSuffix}`);
      return function(response) {
        if (headersCh.hasSubscribers) {
          headersCh.publish({ headers: response.headers });
        }
        return deserialize.apply(this, arguments);
      };
    }
    function wrapSmithySend(send) {
      return function(command, ...args) {
        const cb = args.at(-1);
        const serviceIdentifier = this.config.serviceId.toLowerCase();
        const channelSuffix = getChannelSuffix(serviceIdentifier);
        const commandName = command.constructor.name;
        const clientName = this.constructor.name.replace(/Client$/, "");
        const operation = `${commandName[0].toLowerCase()}${commandName.slice(1).replace(/Command$/, "")}`;
        const request2 = {
          operation,
          params: command.input
        };
        const startCh = channel(`apm:aws:request:start:${channelSuffix}`);
        const regionCh = channel(`apm:aws:request:region:${channelSuffix}`);
        const responseStartChannel = channel(`apm:aws:response:start:${channelSuffix}`);
        const responseFinishChannel = channel(`apm:aws:response:finish:${channelSuffix}`);
        if (typeof command.deserialize === "function") {
          shimmer.wrap(command, "deserialize", (deserialize) => wrapDeserialize(deserialize, channelSuffix));
        }
        const ctx = {
          serviceIdentifier,
          operation,
          awsService: clientName,
          request: request2
        };
        return startCh.runStores(ctx, () => {
          this.config.region().then((region) => {
            ctx.region = region;
            regionCh.publish(ctx);
          });
          if (typeof cb === "function") {
            args[args.length - 1] = shimmer.wrapFunction(cb, (cb2) => function(err, result) {
              addResponse(ctx, err, result);
              handleCompletion(result, ctx, channelSuffix);
              const responseCtx = { request: request2, response: ctx.response };
              responseStartChannel.runStores(responseCtx, () => {
                cb2.apply(this, arguments);
                responseFinishChannel.publish(responseCtx);
              });
            });
          } else {
            return send.call(this, command, ...args).then(
              (result) => {
                addResponse(ctx, null, result);
                handleCompletion(result, ctx, channelSuffix);
                return result;
              },
              (error) => {
                addResponse(ctx, error);
                handleCompletion(null, ctx, channelSuffix);
                throw error;
              }
            );
          }
          return send.call(this, command, ...args);
        });
      };
    }
    function handleCompletion(result, ctx, channelSuffix) {
      const completeChannel = channel(`apm:aws:request:complete:${channelSuffix}`);
      const streamedChunkChannel = channel(`apm:aws:response:streamed-chunk:${channelSuffix}`);
      const iterator = result?.body?.[Symbol.asyncIterator];
      if (!iterator) {
        completeChannel.publish(ctx);
        return;
      }
      shimmer.wrap(result.body, Symbol.asyncIterator, function(asyncIterator) {
        return function() {
          const iterator2 = asyncIterator.apply(this, arguments);
          shimmer.wrap(iterator2, "next", function(next) {
            return function() {
              return next.apply(this, arguments).then((result2) => {
                const { done, value: chunk } = result2;
                streamedChunkChannel.publish({ ctx, chunk, done });
                if (done) {
                  completeChannel.publish(ctx);
                }
                return result2;
              }).catch((err) => {
                addResponse(ctx, err);
                completeChannel.publish(ctx);
                throw err;
              });
            };
          });
          return iterator2;
        };
      });
    }
    function wrapCb(cb, serviceName, ctx) {
      return shimmer.wrapFunction(cb, (cb2) => function wrappedCb(err, response) {
        ctx = { request: ctx.request, response };
        return channel(`apm:aws:response:start:${serviceName}`).runStores(ctx, () => {
          const finishChannel = channel(`apm:aws:response:finish:${serviceName}`);
          try {
            let result = cb2.apply(this, arguments);
            if (result && result.then) {
              result = result.then((x) => {
                finishChannel.publish(ctx);
                return x;
              }, (e) => {
                ctx.error = e;
                finishChannel.publish(ctx);
                throw e;
              });
            } else {
              finishChannel.publish(ctx);
            }
            return result;
          } catch (e) {
            ctx.error = e;
            finishChannel.publish(ctx);
            throw e;
          }
        });
      });
    }
    function addResponse(ctx, error, result) {
      const request2 = ctx.request;
      const response = { request: request2, error, ...result };
      if (result && result.$metadata) {
        response.requestId = result.$metadata.requestId;
      }
      ctx.response = response;
    }
    function getChannelSuffix(name) {
      name = String(name).replaceAll(" ", "");
      return [
        "cloudwatchlogs",
        "dynamodb",
        "eventbridge",
        "kinesis",
        "lambda",
        "redshift",
        "s3",
        "sfn",
        "sns",
        "sqs",
        "states",
        "stepfunctions",
        "bedrockruntime"
      ].includes(name) ? name : "default";
    }
    addHook({ name: "@smithy/smithy-client", versions: [">=1.0.3"] }, (smithy) => {
      shimmer.wrap(smithy.Client.prototype, "send", wrapSmithySend);
      return smithy;
    });
    addHook({ name: "@aws-sdk/smithy-client", versions: [">=3"] }, (smithy) => {
      shimmer.wrap(smithy.Client.prototype, "send", wrapSmithySend);
      return smithy;
    });
    addHook({ name: "aws-sdk", versions: [">=2.3.0"] }, (AWS) => {
      shimmer.wrap(AWS.config, "setPromisesDependency", (setPromisesDependency) => {
        return function wrappedSetPromisesDependency(dep) {
          const result = setPromisesDependency.apply(this, arguments);
          shimmer.wrap(AWS.Request.prototype, "promise", wrapRequest);
          return result;
        };
      });
      return AWS;
    });
    addHook({ name: "aws-sdk", file: "lib/core.js", versions: [">=2.3.0"] }, (AWS) => {
      shimmer.wrap(AWS.Request.prototype, "promise", wrapRequest);
      return AWS;
    });
    addHook({ name: "aws-sdk", file: "lib/core.js", versions: [">=2.1.35"] }, (AWS) => {
      shimmer.wrap(AWS.Request.prototype, "send", wrapRequest);
      return AWS;
    });
  }
});

// ../../packages/datadog-instrumentations/src/azure-event-hubs.js
var require_azure_event_hubs = __commonJS({
  "../../packages/datadog-instrumentations/src/azure-event-hubs.js"() {
    "use strict";
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var producerCh = dc.tracingChannel("apm:azure-event-hubs:send");
    addHook({
      name: "@azure/event-hubs",
      versions: [">=6.0.0"]
    }, (obj) => {
      const EventHubProducerClient = obj.EventHubProducerClient;
      shimmer.wrap(
        EventHubProducerClient.prototype,
        "createBatch",
        (createBatch) => async function() {
          const batch = await createBatch.apply(this, arguments);
          shimmer.wrap(
            batch,
            "tryAdd",
            (tryAdd) => function(eventData) {
              const config = this._context.config;
              const functionName = tryAdd.name;
              return producerCh.tracePromise(
                tryAdd,
                { functionName, eventData, batch: this, config },
                this,
                ...arguments
              );
            }
          );
          return batch;
        }
      );
      shimmer.wrap(
        EventHubProducerClient.prototype,
        "sendBatch",
        (sendBatch) => function(eventData) {
          const config = this._context.config;
          const functionName = sendBatch.name;
          return producerCh.tracePromise(sendBatch, { functionName, eventData, config }, this, ...arguments);
        }
      );
      return obj;
    });
  }
});

// ../../packages/datadog-instrumentations/src/azure-functions.js
var require_azure_functions = __commonJS({
  "../../packages/datadog-instrumentations/src/azure-functions.js"() {
    "use strict";
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var azureFunctionsChannel = dc.tracingChannel("datadog:azure:functions:invoke");
    addHook({ name: "@azure/functions", versions: [">=4"], patchDefault: false }, (azureFunction) => {
      const { app } = azureFunction;
      shimmer.wrap(app, "deleteRequest", wrapHandler);
      shimmer.wrap(app, "http", wrapHandler);
      shimmer.wrap(app, "get", wrapHandler);
      shimmer.wrap(app, "patch", wrapHandler);
      shimmer.wrap(app, "post", wrapHandler);
      shimmer.wrap(app, "put", wrapHandler);
      shimmer.wrap(app, "serviceBusQueue", wrapHandler);
      shimmer.wrap(app, "serviceBusTopic", wrapHandler);
      shimmer.wrap(app, "eventHub", wrapHandler);
      return azureFunction;
    });
    function wrapHandler(method) {
      return function(name, arg) {
        if (arg !== null && typeof arg === "object" && arg.hasOwnProperty("handler")) {
          const options = arg;
          shimmer.wrap(options, "handler", (handler) => traceHandler(handler, name, method.name));
        } else if (typeof arg === "function") {
          const handler = arg;
          arguments[1] = shimmer.wrapFunction(handler, (handler2) => traceHandler(handler2, name, method.name));
        }
        return method.apply(this, arguments);
      };
    }
    function traceHandler(handler, functionName, methodName) {
      return function(...args) {
        const httpRequest = args[0];
        const invocationContext = args[1];
        return azureFunctionsChannel.tracePromise(
          handler,
          { functionName, httpRequest, invocationContext, methodName },
          this,
          ...args
        );
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/azure-service-bus.js
var require_azure_service_bus = __commonJS({
  "../../packages/datadog-instrumentations/src/azure-service-bus.js"() {
    "use strict";
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var producerCh = dc.tracingChannel("apm:azure-service-bus:send");
    addHook({ name: "@azure/service-bus", versions: [">=7.9.2"], patchDefault: false }, (obj) => {
      const ServiceBusClient = obj.ServiceBusClient;
      let didItShim = false;
      shimmer.wrap(
        ServiceBusClient.prototype,
        "createSender",
        (createSender) => function(queueOrTopicName) {
          const sender = createSender.apply(this, arguments);
          if (didItShim) return sender;
          const senderPrototype = sender.constructor.prototype;
          const senderSenderPrototype = sender._sender.constructor.prototype;
          shimmer.wrap(senderPrototype, "scheduleMessages", (scheduleMessages) => function(msg, scheduledEnqueueTimeUtc) {
            const functionName = scheduleMessages.name;
            const config = this._context.config;
            const entityPath = this._entityPath;
            return producerCh.tracePromise(
              scheduleMessages,
              { config, entityPath, functionName, msg, scheduledEnqueueTimeUtc },
              this,
              ...arguments
            );
          });
          shimmer.wrap(senderPrototype, "createMessageBatch", (createMessageBatch) => async function() {
            const batch = await createMessageBatch.apply(this, arguments);
            shimmer.wrap(batch.constructor.prototype, "tryAddMessage", (tryAddMessage) => function(msg) {
              const functionName = tryAddMessage.name;
              const config = this._context.config;
              return producerCh.tracePromise(
                tryAddMessage,
                { config, functionName, batch, msg },
                this,
                ...arguments
              );
            });
            return batch;
          });
          shimmer.wrap(senderSenderPrototype, "send", (send) => function(msg) {
            const functionName = send.name;
            const config = this._context.config;
            const entityPath = this.entityPath;
            return producerCh.tracePromise(
              send,
              { config, entityPath, functionName, msg },
              this,
              ...arguments
            );
          });
          shimmer.wrap(senderSenderPrototype, "sendBatch", (sendBatch) => function(msg) {
            const functionName = sendBatch.name;
            const config = this._context.config;
            const entityPath = this.entityPath;
            return producerCh.tracePromise(
              sendBatch,
              { config, entityPath, functionName, msg },
              this,
              ...arguments
            );
          });
          didItShim = true;
          return sender;
        }
      );
      return obj;
    });
  }
});

// ../../packages/datadog-instrumentations/src/cucumber.js
var require_cucumber = __commonJS({
  "../../packages/datadog-instrumentations/src/cucumber.js"() {
    "use strict";
    var { createCoverageMap } = require_istanbul_lib_coverage();
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var testStartCh = channel("ci:cucumber:test:start");
    var testRetryCh = channel("ci:cucumber:test:retry");
    var testFinishCh = channel("ci:cucumber:test:finish");
    var testFnCh = channel("ci:cucumber:test:fn");
    var testStepStartCh = channel("ci:cucumber:test-step:start");
    var errorCh = channel("ci:cucumber:error");
    var testSuiteStartCh = channel("ci:cucumber:test-suite:start");
    var testSuiteFinishCh = channel("ci:cucumber:test-suite:finish");
    var testSuiteCodeCoverageCh = channel("ci:cucumber:test-suite:code-coverage");
    var libraryConfigurationCh = channel("ci:cucumber:library-configuration");
    var knownTestsCh = channel("ci:cucumber:known-tests");
    var skippableSuitesCh = channel("ci:cucumber:test-suite:skippable");
    var sessionStartCh = channel("ci:cucumber:session:start");
    var sessionFinishCh = channel("ci:cucumber:session:finish");
    var testManagementTestsCh = channel("ci:cucumber:test-management-tests");
    var modifiedFilesCh = channel("ci:cucumber:modified-files");
    var isModifiedCh = channel("ci:cucumber:is-modified-test");
    var workerReportTraceCh = channel("ci:cucumber:worker-report:trace");
    var itrSkippedSuitesCh = channel("ci:cucumber:itr:skipped-suites");
    var getCodeCoverageCh = channel("ci:nyc:get-coverage");
    var {
      getCoveredFilenamesFromCoverage,
      resetCoverage,
      mergeCoverage,
      fromCoverageMapToCoverage,
      getTestSuitePath,
      CUCUMBER_WORKER_TRACE_PAYLOAD_CODE,
      getIsFaultyEarlyFlakeDetection
    } = require_test();
    var satisfies = require_semifies();
    var isMarkedAsUnskippable = (pickle) => {
      return pickle.tags.some((tag) => tag.name === "@datadog:unskippable");
    };
    var originalCoverageMap = createCoverageMap();
    var patched = /* @__PURE__ */ new WeakSet();
    var lastStatusByPickleId = /* @__PURE__ */ new Map();
    var numRetriesByPickleId = /* @__PURE__ */ new Map();
    var numAttemptToCtx = /* @__PURE__ */ new Map();
    var newTestsByTestFullname = /* @__PURE__ */ new Map();
    var modifiedTestsByPickleId = /* @__PURE__ */ new Map();
    var eventDataCollector = null;
    var pickleByFile = {};
    var pickleResultByFile = {};
    var skippableSuites = [];
    var itrCorrelationId = "";
    var isForcedToRun = false;
    var isUnskippable = false;
    var isSuitesSkippingEnabled = false;
    var isEarlyFlakeDetectionEnabled = false;
    var earlyFlakeDetectionNumRetries = 0;
    var earlyFlakeDetectionFaultyThreshold = 0;
    var isEarlyFlakeDetectionFaulty = false;
    var isFlakyTestRetriesEnabled = false;
    var isKnownTestsEnabled = false;
    var isTestManagementTestsEnabled = false;
    var isImpactedTestsEnabled = false;
    var testManagementAttemptToFixRetries = 0;
    var testManagementTests = {};
    var modifiedFiles = {};
    var numTestRetries = 0;
    var knownTests = {};
    var skippedSuites = [];
    var isSuitesSkipped = false;
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.cucumber;
    }
    function getSuiteStatusFromTestStatuses(testStatuses) {
      if (testStatuses.includes("fail")) {
        return "fail";
      }
      if (testStatuses.every((status) => status === "skip")) {
        return "skip";
      }
      return "pass";
    }
    function getStatusFromResult(result) {
      if (result.status === 1) {
        return { status: "pass" };
      }
      if (result.status === 2) {
        return { status: "skip" };
      }
      if (result.status === 4) {
        return { status: "skip", skipReason: "not implemented" };
      }
      return { status: "fail", errorMessage: result.message };
    }
    function getStatusFromResultLatest(result) {
      if (result.status === "PASSED") {
        return { status: "pass" };
      }
      if (result.status === "SKIPPED" || result.status === "PENDING") {
        return { status: "skip" };
      }
      if (result.status === "UNDEFINED") {
        return { status: "skip", skipReason: "not implemented" };
      }
      return { status: "fail", errorMessage: result.message };
    }
    function isNewTest(testSuite, testName) {
      if (!isValidKnownTests(knownTests)) {
        return false;
      }
      const testsForSuite = knownTests.cucumber[testSuite] || [];
      return !testsForSuite.includes(testName);
    }
    function getTestProperties(testSuite, testName) {
      const { attempt_to_fix: attemptToFix, disabled, quarantined } = testManagementTests?.cucumber?.suites?.[testSuite]?.tests?.[testName]?.properties || {};
      return { attemptToFix, disabled, quarantined };
    }
    function getTestStatusFromRetries(testStatuses) {
      if (testStatuses.every((status) => status === "fail")) {
        return "fail";
      }
      if (testStatuses.includes("pass")) {
        return "pass";
      }
      return "pass";
    }
    function getErrorFromCucumberResult(cucumberResult) {
      if (!cucumberResult.message) {
        return;
      }
      const [message] = cucumberResult.message.split("\n");
      const error = new Error(message);
      if (cucumberResult.exception) {
        error.type = cucumberResult.exception.type;
      }
      error.stack = cucumberResult.message;
      return error;
    }
    function getChannelPromise(channelToPublishTo, isParallel = false, frameworkVersion = null) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, isParallel, frameworkVersion });
      });
    }
    function getShouldBeSkippedSuite(pickle, suitesToSkip) {
      const testSuitePath = getTestSuitePath(pickle.uri, process.cwd());
      const isUnskippable2 = isMarkedAsUnskippable(pickle);
      const isSkipped = suitesToSkip.includes(testSuitePath);
      return [isSkipped && !isUnskippable2, testSuitePath];
    }
    function getFilteredPicklesNew(coordinator, suitesToSkip) {
      return coordinator.sourcedPickles.reduce((acc, sourcedPickle) => {
        const { pickle } = sourcedPickle;
        const [shouldBeSkipped, testSuitePath] = getShouldBeSkippedSuite(pickle, suitesToSkip);
        if (shouldBeSkipped) {
          acc.skippedSuites.add(testSuitePath);
        } else {
          acc.picklesToRun.push(sourcedPickle);
        }
        return acc;
      }, { skippedSuites: /* @__PURE__ */ new Set(), picklesToRun: [] });
    }
    function getFilteredPickles(runtime, suitesToSkip) {
      return runtime.pickleIds.reduce((acc, pickleId) => {
        const pickle = runtime.eventDataCollector.getPickle(pickleId);
        const [shouldBeSkipped, testSuitePath] = getShouldBeSkippedSuite(pickle, suitesToSkip);
        if (shouldBeSkipped) {
          acc.skippedSuites.add(testSuitePath);
        } else {
          acc.picklesToRun.push(pickleId);
        }
        return acc;
      }, { skippedSuites: /* @__PURE__ */ new Set(), picklesToRun: [] });
    }
    function getPickleByFileNew(coordinator) {
      return coordinator.sourcedPickles.reduce((acc, { pickle }) => {
        if (acc[pickle.uri]) {
          acc[pickle.uri].push(pickle);
        } else {
          acc[pickle.uri] = [pickle];
        }
        return acc;
      }, {});
    }
    function getPickleByFile(runtimeOrCoodinator) {
      return runtimeOrCoodinator.pickleIds.reduce((acc, pickleId) => {
        const test = runtimeOrCoodinator.eventDataCollector.getPickle(pickleId);
        if (acc[test.uri]) {
          acc[test.uri].push(test);
        } else {
          acc[test.uri] = [test];
        }
        return acc;
      }, {});
    }
    function wrapRun(pl, isLatestVersion, version) {
      if (patched.has(pl)) return;
      patched.add(pl);
      shimmer.wrap(pl.prototype, "run", (run) => function() {
        if (!testFinishCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        let numAttempt = 0;
        const testFileAbsolutePath = this.pickle.uri;
        const testSourceLine = this.gherkinDocument?.feature?.location?.line;
        const testStartPayload = {
          testName: this.pickle.name,
          testFileAbsolutePath,
          testSourceLine,
          isParallel: !!getEnvironmentVariable("CUCUMBER_WORKER_ID")
        };
        const ctx = testStartPayload;
        numAttemptToCtx.set(numAttempt, ctx);
        testStartCh.runStores(ctx, () => {
        });
        const promises = {};
        try {
          this.eventBroadcaster.on("envelope", shimmer.wrapFunction(null, () => async (testCase) => {
            if (testCase?.testCaseFinished) {
              const { testCaseFinished: { willBeRetried } } = testCase;
              if (willBeRetried) {
                let error;
                try {
                  const cucumberResult = this.getWorstStepResult();
                  error = getErrorFromCucumberResult(cucumberResult);
                } catch {
                }
                const failedAttemptCtx = numAttemptToCtx.get(numAttempt);
                const isFirstAttempt = numAttempt++ === 0;
                const isAtrRetry = !isFirstAttempt && isFlakyTestRetriesEnabled;
                if (promises.hitBreakpointPromise) {
                  await promises.hitBreakpointPromise;
                }
                testRetryCh.publish({ isFirstAttempt, error, isAtrRetry, ...failedAttemptCtx.currentStore });
                const newCtx = { ...testStartPayload, promises };
                numAttemptToCtx.set(numAttempt, newCtx);
                testStartCh.runStores(newCtx, () => {
                });
              }
            }
          }));
          let promise;
          testFnCh.runStores(ctx, () => {
            promise = run.apply(this, arguments);
          });
          promise.finally(async () => {
            const result = this.getWorstStepResult();
            const { status, skipReason } = isLatestVersion ? getStatusFromResultLatest(result) : getStatusFromResult(result);
            if (lastStatusByPickleId.has(this.pickle.id)) {
              lastStatusByPickleId.get(this.pickle.id).push(status);
            } else {
              lastStatusByPickleId.set(this.pickle.id, [status]);
            }
            let isNew = false;
            let isEfdRetry = false;
            let isAttemptToFix = false;
            let isAttemptToFixRetry = false;
            let hasFailedAllRetries = false;
            let hasPassedAllRetries = false;
            let hasFailedAttemptToFix = false;
            let isDisabled = false;
            let isQuarantined = false;
            let isModified = false;
            if (isTestManagementTestsEnabled) {
              const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd());
              const testProperties = getTestProperties(testSuitePath, this.pickle.name);
              const numRetries2 = numRetriesByPickleId.get(this.pickle.id);
              isAttemptToFix = testProperties.attemptToFix;
              isAttemptToFixRetry = isAttemptToFix && numRetries2 > 0;
              isDisabled = testProperties.disabled;
              isQuarantined = testProperties.quarantined;
              if (isAttemptToFixRetry) {
                const statuses = lastStatusByPickleId.get(this.pickle.id);
                if (statuses.length === testManagementAttemptToFixRetries + 1) {
                  const { pass, fail } = statuses.reduce((acc, status2) => {
                    acc[status2]++;
                    return acc;
                  }, { pass: 0, fail: 0 });
                  hasFailedAllRetries = fail === testManagementAttemptToFixRetries + 1;
                  hasPassedAllRetries = pass === testManagementAttemptToFixRetries + 1;
                  hasFailedAttemptToFix = fail > 0;
                }
              }
            }
            const numRetries = numRetriesByPickleId.get(this.pickle.id);
            if (isImpactedTestsEnabled) {
              isModified = modifiedTestsByPickleId.get(this.pickle.id);
            }
            if (isKnownTestsEnabled && status !== "skip") {
              isNew = numRetries !== void 0;
            }
            if (isNew || isModified) {
              isEfdRetry = numRetries > 0;
            }
            const attemptCtx = numAttemptToCtx.get(numAttempt);
            const error = getErrorFromCucumberResult(result);
            if (promises.hitBreakpointPromise) {
              await promises.hitBreakpointPromise;
            }
            testFinishCh.publish({
              status,
              skipReason,
              error,
              isNew,
              isEfdRetry,
              isFlakyRetry: numAttempt > 0,
              isAttemptToFix,
              isAttemptToFixRetry,
              hasFailedAllRetries,
              hasPassedAllRetries,
              hasFailedAttemptToFix,
              isDisabled,
              isQuarantined,
              isModified,
              ...attemptCtx.currentStore
            });
          });
          return promise;
        } catch (err) {
          ctx.err = err;
          errorCh.runStores(ctx, () => {
            throw err;
          });
        }
      });
      shimmer.wrap(pl.prototype, "runStep", (runStep) => function() {
        if (!testFinishCh.hasSubscribers) {
          return runStep.apply(this, arguments);
        }
        const testStep = arguments[0];
        let resource;
        if (isLatestVersion) {
          resource = testStep.text;
        } else {
          resource = testStep.isHook ? "hook" : testStep.pickleStep.text;
        }
        const ctx = { resource };
        return testStepStartCh.runStores(ctx, () => {
          try {
            const promise = runStep.apply(this, arguments);
            promise.then((result) => {
              const finalResult = satisfies(version, ">=12.0.0") ? result.result : result;
              const getStatus = satisfies(version, ">=7.3.0") ? getStatusFromResultLatest : getStatusFromResult;
              const { status, skipReason, errorMessage } = getStatus(finalResult);
              testFinishCh.publish({ isStep: true, status, skipReason, errorMessage, ...ctx.currentStore });
            });
            return promise;
          } catch (err) {
            ctx.err = err;
            errorCh.runStores(ctx, () => {
              throw err;
            });
          }
        });
      });
    }
    function pickleHook(PickleRunner, version) {
      const pl = PickleRunner.default;
      wrapRun(pl, false, version);
      return PickleRunner;
    }
    function testCaseHook(TestCaseRunner, version) {
      const pl = TestCaseRunner.default;
      wrapRun(pl, true, version);
      return TestCaseRunner;
    }
    function getCucumberOptions(adapterOrCoordinator) {
      if (adapterOrCoordinator.adapter) {
        return adapterOrCoordinator.adapter.worker?.options || adapterOrCoordinator.adapter.options;
      }
      return adapterOrCoordinator.options;
    }
    function getWrappedStart(start, frameworkVersion, isParallel = false, isCoordinator = false) {
      return async function() {
        if (!libraryConfigurationCh.hasSubscribers) {
          return start.apply(this, arguments);
        }
        const options = getCucumberOptions(this);
        if (!isParallel && this.adapter?.options) {
          isParallel = options.parallel > 0;
        }
        let errorSkippableRequest;
        const configurationResponse = await getChannelPromise(libraryConfigurationCh, isParallel, frameworkVersion);
        isEarlyFlakeDetectionEnabled = configurationResponse.libraryConfig?.isEarlyFlakeDetectionEnabled;
        earlyFlakeDetectionNumRetries = configurationResponse.libraryConfig?.earlyFlakeDetectionNumRetries;
        earlyFlakeDetectionFaultyThreshold = configurationResponse.libraryConfig?.earlyFlakeDetectionFaultyThreshold;
        isSuitesSkippingEnabled = configurationResponse.libraryConfig?.isSuitesSkippingEnabled;
        isFlakyTestRetriesEnabled = configurationResponse.libraryConfig?.isFlakyTestRetriesEnabled;
        numTestRetries = configurationResponse.libraryConfig?.flakyTestRetriesCount;
        isKnownTestsEnabled = configurationResponse.libraryConfig?.isKnownTestsEnabled;
        isTestManagementTestsEnabled = configurationResponse.libraryConfig?.isTestManagementEnabled;
        testManagementAttemptToFixRetries = configurationResponse.libraryConfig?.testManagementAttemptToFixRetries;
        isImpactedTestsEnabled = configurationResponse.libraryConfig?.isImpactedTestsEnabled;
        if (isKnownTestsEnabled) {
          const knownTestsResponse = await getChannelPromise(knownTestsCh);
          if (knownTestsResponse.err) {
            isEarlyFlakeDetectionEnabled = false;
            isKnownTestsEnabled = false;
          } else {
            knownTests = knownTestsResponse.knownTests;
          }
        }
        if (isSuitesSkippingEnabled) {
          const skippableResponse = await getChannelPromise(skippableSuitesCh);
          errorSkippableRequest = skippableResponse.err;
          skippableSuites = skippableResponse.skippableSuites;
          if (!errorSkippableRequest) {
            const filteredPickles = isCoordinator ? getFilteredPicklesNew(this, skippableSuites) : getFilteredPickles(this, skippableSuites);
            const { picklesToRun } = filteredPickles;
            const oldPickles = isCoordinator ? this.sourcedPickles : this.pickleIds;
            isSuitesSkipped = picklesToRun.length !== oldPickles.length;
            log.debug("%s out of %s suites are going to run.", picklesToRun.length, oldPickles.length);
            if (isCoordinator) {
              this.sourcedPickles = picklesToRun;
            } else {
              this.pickleIds = picklesToRun;
            }
            skippedSuites = [...filteredPickles.skippedSuites];
            itrCorrelationId = skippableResponse.itrCorrelationId;
          }
        }
        pickleByFile = isCoordinator ? getPickleByFileNew(this) : getPickleByFile(this);
        if (isKnownTestsEnabled) {
          const isFaulty = !isValidKnownTests(knownTests) || getIsFaultyEarlyFlakeDetection(
            Object.keys(pickleByFile),
            knownTests.cucumber,
            earlyFlakeDetectionFaultyThreshold
          );
          if (isFaulty) {
            isEarlyFlakeDetectionEnabled = false;
            isKnownTestsEnabled = false;
            isEarlyFlakeDetectionFaulty = true;
          }
        }
        if (isTestManagementTestsEnabled) {
          const testManagementTestsResponse = await getChannelPromise(testManagementTestsCh);
          if (testManagementTestsResponse.err) {
            isTestManagementTestsEnabled = false;
          } else {
            testManagementTests = testManagementTestsResponse.testManagementTests;
          }
        }
        if (isImpactedTestsEnabled) {
          const impactedTestsResponse = await getChannelPromise(modifiedFilesCh);
          if (!impactedTestsResponse.err) {
            modifiedFiles = impactedTestsResponse.modifiedFiles;
          }
        }
        const processArgv = process.argv.slice(2).join(" ");
        const command = getEnvironmentVariable("npm_lifecycle_script") || `cucumber-js ${processArgv}`;
        if (isFlakyTestRetriesEnabled && !options.retry && numTestRetries > 0) {
          options.retry = numTestRetries;
        }
        sessionStartCh.publish({ command, frameworkVersion });
        if (!errorSkippableRequest && skippedSuites.length) {
          itrSkippedSuitesCh.publish({ skippedSuites, frameworkVersion });
        }
        const success = await start.apply(this, arguments);
        let untestedCoverage;
        if (getCodeCoverageCh.hasSubscribers) {
          untestedCoverage = await getChannelPromise(getCodeCoverageCh);
        }
        let testCodeCoverageLinesTotal;
        if (global.__coverage__) {
          try {
            if (untestedCoverage) {
              originalCoverageMap.merge(fromCoverageMapToCoverage(untestedCoverage));
            }
            testCodeCoverageLinesTotal = originalCoverageMap.getCoverageSummary().lines.pct;
          } catch {
          }
          global.__coverage__ = fromCoverageMapToCoverage(originalCoverageMap);
        }
        sessionFinishCh.publish({
          status: success ? "pass" : "fail",
          isSuitesSkipped,
          testCodeCoverageLinesTotal,
          numSkippedSuites: skippedSuites.length,
          hasUnskippableSuites: isUnskippable,
          hasForcedToRunSuites: isForcedToRun,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          isParallel
        });
        eventDataCollector = null;
        return success;
      };
    }
    function getWrappedRunTestCase(runTestCaseFunction, isNewerCucumberVersion = false, isWorker = false) {
      return async function() {
        if (!testSuiteFinishCh.hasSubscribers) {
          return runTestCaseFunction.apply(this, arguments);
        }
        const pickle = isNewerCucumberVersion ? arguments[0].pickle : this.eventDataCollector.getPickle(arguments[0]);
        const testCase = isNewerCucumberVersion ? arguments[0].testCase : arguments[1];
        const gherkinDocument = isNewerCucumberVersion ? arguments[0].gherkinDocument : this.eventDataCollector.getGherkinDocument(pickle.uri);
        const testFileAbsolutePath = pickle.uri;
        const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd());
        if (!isWorker && !pickleResultByFile[testFileAbsolutePath]) {
          isUnskippable = isMarkedAsUnskippable(pickle);
          isForcedToRun = isUnskippable && skippableSuites.includes(testSuitePath);
          testSuiteStartCh.publish({
            testFileAbsolutePath,
            isUnskippable,
            isForcedToRun,
            itrCorrelationId
          });
        }
        let isNew = false;
        let isAttemptToFix = false;
        let isDisabled = false;
        let isQuarantined = false;
        let isModified = false;
        if (isTestManagementTestsEnabled) {
          const testProperties = getTestProperties(testSuitePath, pickle.name);
          isAttemptToFix = testProperties.attemptToFix;
          isDisabled = testProperties.disabled;
          isQuarantined = testProperties.quarantined;
          if (!isAttemptToFix && isDisabled) {
            this.options.dryRun = true;
          }
        }
        if (isImpactedTestsEnabled) {
          const setIsModified = (receivedIsModified) => {
            isModified = receivedIsModified;
          };
          const scenarios = gherkinDocument.feature?.children?.filter(
            (children) => pickle.astNodeIds.includes(children.scenario.id)
          ).map((scenario) => scenario.scenario);
          const stepIds = testCase?.testSteps?.flatMap((testStep) => testStep.stepDefinitionIds);
          isModifiedCh.publish({
            scenarios,
            testFileAbsolutePath: gherkinDocument.uri,
            modifiedFiles,
            stepIds,
            stepDefinitions: this.supportCodeLibrary.stepDefinitions,
            setIsModified
          });
          modifiedTestsByPickleId.set(pickle.id, isModified);
        }
        if (isKnownTestsEnabled && !isAttemptToFix) {
          isNew = isNewTest(testSuitePath, pickle.name);
          if (isNew) {
            numRetriesByPickleId.set(pickle.id, 0);
          }
        }
        let runTestCaseResult = await runTestCaseFunction.apply(this, arguments);
        const testStatuses = lastStatusByPickleId.get(pickle.id);
        const lastTestStatus = testStatuses.at(-1);
        if (isAttemptToFix && lastTestStatus !== "skip") {
          for (let retryIndex = 0; retryIndex < testManagementAttemptToFixRetries; retryIndex++) {
            numRetriesByPickleId.set(pickle.id, retryIndex + 1);
            runTestCaseResult = await runTestCaseFunction.apply(this, arguments);
          }
        }
        if (isEarlyFlakeDetectionEnabled && lastTestStatus !== "skip" && (isNew || isModified)) {
          for (let retryIndex = 0; retryIndex < earlyFlakeDetectionNumRetries; retryIndex++) {
            numRetriesByPickleId.set(pickle.id, retryIndex + 1);
            runTestCaseResult = await runTestCaseFunction.apply(this, arguments);
          }
        }
        let testStatus = lastTestStatus;
        let shouldBePassedByEFD = false;
        let shouldBePassedByTestManagement = false;
        if ((isNew || isModified) && isEarlyFlakeDetectionEnabled) {
          testStatus = getTestStatusFromRetries(testStatuses);
          if (testStatus === "pass") {
            shouldBePassedByEFD = true;
            this.success = true;
          }
        }
        if (isTestManagementTestsEnabled && (isDisabled || isQuarantined)) {
          this.success = true;
          shouldBePassedByTestManagement = true;
        }
        if (pickleResultByFile[testFileAbsolutePath]) {
          pickleResultByFile[testFileAbsolutePath].push(testStatus);
        } else {
          pickleResultByFile[testFileAbsolutePath] = [testStatus];
        }
        if (!isWorker && pickleResultByFile[testFileAbsolutePath].length === pickleByFile[testFileAbsolutePath].length) {
          const testSuiteStatus = getSuiteStatusFromTestStatuses(pickleResultByFile[testFileAbsolutePath]);
          if (global.__coverage__) {
            const coverageFiles = getCoveredFilenamesFromCoverage(global.__coverage__);
            testSuiteCodeCoverageCh.publish({
              coverageFiles,
              suiteFile: testFileAbsolutePath,
              testSuitePath
            });
            mergeCoverage(global.__coverage__, originalCoverageMap);
            resetCoverage(global.__coverage__);
          }
          testSuiteFinishCh.publish({ status: testSuiteStatus, testSuitePath });
        }
        if (isNewerCucumberVersion && isEarlyFlakeDetectionEnabled && (isNew || isModified)) {
          return shouldBePassedByEFD;
        }
        if (isNewerCucumberVersion && isTestManagementTestsEnabled && (isQuarantined || isDisabled)) {
          return shouldBePassedByTestManagement;
        }
        return runTestCaseResult;
      };
    }
    function getWrappedParseWorkerMessage(parseWorkerMessageFunction, isNewVersion) {
      return function(worker, message) {
        if (!testSuiteFinishCh.hasSubscribers) {
          return parseWorkerMessageFunction.apply(this, arguments);
        }
        if (Array.isArray(message)) {
          const [messageCode, payload] = message;
          if (messageCode === CUCUMBER_WORKER_TRACE_PAYLOAD_CODE) {
            workerReportTraceCh.publish(payload);
            return;
          }
        }
        const envelope = isNewVersion ? message.envelope : message.jsonEnvelope;
        if (!envelope) {
          return parseWorkerMessageFunction.apply(this, arguments);
        }
        let parsed = envelope;
        if (typeof parsed === "string") {
          try {
            parsed = JSON.parse(envelope);
          } catch {
            return parseWorkerMessageFunction.apply(this, arguments);
          }
        }
        let pickle;
        if (parsed.testCaseStarted) {
          if (isNewVersion) {
            pickle = this.inProgress[worker.id].pickle;
          } else {
            const { pickleId } = this.eventDataCollector.testCaseMap[parsed.testCaseStarted.testCaseId];
            pickle = this.eventDataCollector.getPickle(pickleId);
          }
          const testFileAbsolutePath = pickle.uri;
          if (!pickleResultByFile[testFileAbsolutePath]) {
            pickleResultByFile[testFileAbsolutePath] = [];
            testSuiteStartCh.publish({
              testFileAbsolutePath
            });
          }
        }
        const parseWorkerResponse = parseWorkerMessageFunction.apply(this, arguments);
        if (parsed.testCaseFinished) {
          let worstTestStepResult;
          if (isNewVersion && eventDataCollector) {
            pickle = this.inProgress[worker.id].pickle;
            worstTestStepResult = eventDataCollector.getTestCaseAttempt(parsed.testCaseFinished.testCaseStartedId).worstTestStepResult;
          } else {
            const testCase = this.eventDataCollector.getTestCaseAttempt(parsed.testCaseFinished.testCaseStartedId);
            worstTestStepResult = testCase.worstTestStepResult;
            pickle = testCase.pickle;
          }
          const { status } = getStatusFromResultLatest(worstTestStepResult);
          let isNew = false;
          if (isKnownTestsEnabled) {
            isNew = isNewTest(pickle.uri, pickle.name);
          }
          const testFileAbsolutePath = pickle.uri;
          const finished = pickleResultByFile[testFileAbsolutePath];
          if (isEarlyFlakeDetectionEnabled && isNew) {
            const testFullname = `${pickle.uri}:${pickle.name}`;
            let testStatuses = newTestsByTestFullname.get(testFullname);
            if (testStatuses) {
              testStatuses.push(status);
            } else {
              testStatuses = [status];
              newTestsByTestFullname.set(testFullname, testStatuses);
            }
            if (testStatuses.length === earlyFlakeDetectionNumRetries + 1) {
              const newTestFinalStatus = getTestStatusFromRetries(testStatuses);
              finished.push(newTestFinalStatus);
            }
          } else {
            const finished2 = pickleResultByFile[testFileAbsolutePath];
            finished2.push(status);
          }
          if (finished.length === pickleByFile[testFileAbsolutePath].length) {
            testSuiteFinishCh.publish({
              status: getSuiteStatusFromTestStatuses(finished),
              testSuitePath: getTestSuitePath(testFileAbsolutePath, process.cwd())
            });
          }
        }
        return parseWorkerResponse;
      };
    }
    addHook({
      name: "@cucumber/cucumber",
      versions: ["7.0.0 - 7.2.1"],
      file: "lib/runtime/pickle_runner.js"
    }, pickleHook);
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=7.3.0"],
      file: "lib/runtime/test_case_runner.js"
    }, testCaseHook);
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=7.3.0 <11.0.0"],
      file: "lib/runtime/index.js"
    }, (runtimePackage, frameworkVersion) => {
      shimmer.wrap(runtimePackage.default.prototype, "runTestCase", (runTestCase) => getWrappedRunTestCase(runTestCase));
      shimmer.wrap(runtimePackage.default.prototype, "start", (start) => getWrappedStart(start, frameworkVersion));
      return runtimePackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=7.0.0 <7.3.0"],
      file: "lib/runtime/index.js"
    }, (runtimePackage, frameworkVersion) => {
      shimmer.wrap(runtimePackage.default.prototype, "runPickle", (runPickle) => getWrappedRunTestCase(runPickle));
      shimmer.wrap(runtimePackage.default.prototype, "start", (start) => getWrappedStart(start, frameworkVersion));
      return runtimePackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=8.0.0 <11.0.0"],
      file: "lib/runtime/parallel/coordinator.js"
    }, (coordinatorPackage, frameworkVersion) => {
      shimmer.wrap(coordinatorPackage.default.prototype, "start", (start) => getWrappedStart(start, frameworkVersion, true));
      shimmer.wrap(
        coordinatorPackage.default.prototype,
        "parseWorkerMessage",
        (parseWorkerMessage) => getWrappedParseWorkerMessage(parseWorkerMessage)
      );
      return coordinatorPackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=11.0.0"],
      file: "lib/runtime/worker.js"
    }, (workerPackage) => {
      shimmer.wrap(
        workerPackage.Worker.prototype,
        "runTestCase",
        (runTestCase) => getWrappedRunTestCase(runTestCase, true, !!getEnvironmentVariable("CUCUMBER_WORKER_ID"))
      );
      return workerPackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=11.0.0"],
      file: "lib/runtime/coordinator.js"
    }, (coordinatorPackage, frameworkVersion) => {
      shimmer.wrap(
        coordinatorPackage.Coordinator.prototype,
        "run",
        (run) => getWrappedStart(run, frameworkVersion, false, true)
      );
      return coordinatorPackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=11.0.0"],
      file: "lib/formatter/helpers/event_data_collector.js"
    }, (eventDataCollectorPackage) => {
      shimmer.wrap(eventDataCollectorPackage.default.prototype, "parseEnvelope", (parseEnvelope) => function() {
        eventDataCollector = this;
        return parseEnvelope.apply(this, arguments);
      });
      return eventDataCollectorPackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=11.0.0"],
      file: "lib/runtime/parallel/adapter.js"
    }, (adapterPackage) => {
      shimmer.wrap(
        adapterPackage.ChildProcessAdapter.prototype,
        "parseWorkerMessage",
        (parseWorkerMessage) => getWrappedParseWorkerMessage(parseWorkerMessage, true)
      );
      shimmer.wrap(adapterPackage.ChildProcessAdapter.prototype, "startWorker", (startWorker) => function() {
        if (isKnownTestsEnabled && isValidKnownTests(knownTests)) {
          this.options.worldParameters._ddIsKnownTestsEnabled = true;
          this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled = isEarlyFlakeDetectionEnabled;
          this.options.worldParameters._ddKnownTests = knownTests;
          this.options.worldParameters._ddEarlyFlakeDetectionNumRetries = earlyFlakeDetectionNumRetries;
        } else {
          isEarlyFlakeDetectionEnabled = false;
          isKnownTestsEnabled = false;
          this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled = false;
          this.options.worldParameters._ddIsKnownTestsEnabled = false;
          this.options.worldParameters._ddEarlyFlakeDetectionNumRetries = 0;
        }
        if (isImpactedTestsEnabled) {
          this.options.worldParameters._ddImpactedTestsEnabled = isImpactedTestsEnabled;
          this.options.worldParameters._ddModifiedFiles = modifiedFiles;
        }
        return startWorker.apply(this, arguments);
      });
      return adapterPackage;
    });
    addHook({
      name: "@cucumber/cucumber",
      versions: [">=11.0.0"],
      file: "lib/runtime/parallel/worker.js"
    }, (workerPackage) => {
      shimmer.wrap(
        workerPackage.ChildProcessWorker.prototype,
        "initialize",
        (initialize) => async function() {
          await initialize.apply(this, arguments);
          isKnownTestsEnabled = !!this.options.worldParameters._ddIsKnownTestsEnabled;
          if (isKnownTestsEnabled) {
            knownTests = this.options.worldParameters._ddKnownTests;
            if (!isValidKnownTests(knownTests)) {
              isKnownTestsEnabled = false;
              knownTests = {};
            }
          }
          isEarlyFlakeDetectionEnabled = !!this.options.worldParameters._ddIsEarlyFlakeDetectionEnabled;
          if (isEarlyFlakeDetectionEnabled) {
            earlyFlakeDetectionNumRetries = this.options.worldParameters._ddEarlyFlakeDetectionNumRetries;
          }
          isImpactedTestsEnabled = !!this.options.worldParameters._ddImpactedTestsEnabled;
          if (isImpactedTestsEnabled) {
            modifiedFiles = this.options.worldParameters._ddModifiedFiles;
          }
        }
      );
      return workerPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/playwright.js
var require_playwright = __commonJS({
  "../../packages/datadog-instrumentations/src/playwright.js"() {
    "use strict";
    var satisfies = require_semifies();
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var {
      parseAnnotations,
      getTestSuitePath,
      PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE,
      getIsFaultyEarlyFlakeDetection
    } = require_test();
    var log = require_log2();
    var { DD_MAJOR } = require_version2();
    var testStartCh = channel("ci:playwright:test:start");
    var testFinishCh = channel("ci:playwright:test:finish");
    var testSessionStartCh = channel("ci:playwright:session:start");
    var testSessionFinishCh = channel("ci:playwright:session:finish");
    var libraryConfigurationCh = channel("ci:playwright:library-configuration");
    var knownTestsCh = channel("ci:playwright:known-tests");
    var testManagementTestsCh = channel("ci:playwright:test-management-tests");
    var modifiedFilesCh = channel("ci:playwright:modified-files");
    var isModifiedCh = channel("ci:playwright:test:is-modified");
    var testSuiteStartCh = channel("ci:playwright:test-suite:start");
    var testSuiteFinishCh = channel("ci:playwright:test-suite:finish");
    var workerReportCh = channel("ci:playwright:worker:report");
    var testPageGotoCh = channel("ci:playwright:test:page-goto");
    var testToCtx = /* @__PURE__ */ new WeakMap();
    var testSuiteToCtx = /* @__PURE__ */ new Map();
    var testSuiteToTestStatuses = /* @__PURE__ */ new Map();
    var testSuiteToErrors = /* @__PURE__ */ new Map();
    var testsToTestStatuses = /* @__PURE__ */ new Map();
    var applyRepeatEachIndex = null;
    var startedSuites = [];
    var STATUS_TO_TEST_STATUS = {
      passed: "pass",
      failed: "fail",
      timedOut: "fail",
      skipped: "skip"
    };
    var remainingTestsByFile = {};
    var isKnownTestsEnabled = false;
    var isEarlyFlakeDetectionEnabled = false;
    var earlyFlakeDetectionNumRetries = 0;
    var isEarlyFlakeDetectionFaulty = false;
    var earlyFlakeDetectionFaultyThreshold = 0;
    var isFlakyTestRetriesEnabled = false;
    var flakyTestRetriesCount = 0;
    var knownTests = {};
    var isTestManagementTestsEnabled = false;
    var testManagementAttemptToFixRetries = 0;
    var testManagementTests = {};
    var isImpactedTestsEnabled = false;
    var modifiedFiles = {};
    var quarantinedOrDisabledTestsAttemptToFix = [];
    var quarantinedButNotAttemptToFixFqns = /* @__PURE__ */ new Set();
    var rootDir = "";
    var MINIMUM_SUPPORTED_VERSION_RANGE_EFD = ">=1.38.0";
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.playwright;
    }
    function getTestFullyQualifiedName(test) {
      const fullname = getTestFullname(test);
      return `${test._requireFile} ${fullname}`;
    }
    function getTestProperties(test) {
      const testName = getTestFullname(test);
      const testSuite = getTestSuitePath(test._requireFile, rootDir);
      const { attempt_to_fix: attemptToFix, disabled, quarantined } = testManagementTests?.playwright?.suites?.[testSuite]?.tests?.[testName]?.properties || {};
      return { attemptToFix, disabled, quarantined };
    }
    function isNewTest(test) {
      if (!isValidKnownTests(knownTests)) {
        return false;
      }
      const testSuite = getTestSuitePath(test._requireFile, rootDir);
      const testsForSuite = knownTests.playwright[testSuite] || [];
      return !testsForSuite.includes(getTestFullname(test));
    }
    function getSuiteType(test, type) {
      let suite = test.parent;
      while (suite && suite._type !== type) {
        suite = suite.parent;
      }
      return suite;
    }
    function deepCloneSuite(suite, filterTest, tags = []) {
      const copy = suite._clone();
      for (const entry of suite._entries) {
        if (entry.constructor.name === "Suite") {
          copy._addSuite(deepCloneSuite(entry, filterTest, tags));
        } else {
          if (filterTest(entry)) {
            const copiedTest = entry._clone();
            tags.forEach((tag) => {
              const resolvedTag = typeof tag === "function" ? tag(entry) : tag;
              if (resolvedTag) {
                copiedTest[resolvedTag] = true;
              }
            });
            copy._addTest(copiedTest);
          }
        }
      }
      return copy;
    }
    function getTestsBySuiteFromTestGroups(testGroups) {
      return testGroups.reduce((acc, { requireFile, tests }) => {
        if (acc[requireFile]) {
          acc[requireFile].push(...tests);
        } else {
          acc[requireFile] = [...tests];
        }
        return acc;
      }, {});
    }
    function getTestsBySuiteFromTestsById(testsById) {
      const testsByTestSuite = {};
      for (const { test } of testsById.values()) {
        const { _requireFile } = test;
        if (test._type === "beforeAll" || test._type === "afterAll") {
          continue;
        }
        if (testsByTestSuite[_requireFile]) {
          testsByTestSuite[_requireFile].push(test);
        } else {
          testsByTestSuite[_requireFile] = [test];
        }
      }
      return testsByTestSuite;
    }
    function getPlaywrightConfig(playwrightRunner) {
      try {
        return playwrightRunner._configLoader.fullConfig();
      } catch {
        try {
          return playwrightRunner._loader.fullConfig();
        } catch {
          return playwrightRunner._config || {};
        }
      }
    }
    function getRootDir(playwrightRunner, configArg) {
      const config = configArg?.config || getPlaywrightConfig(playwrightRunner);
      if (config.rootDir) {
        return config.rootDir;
      }
      if (playwrightRunner._configDir) {
        return playwrightRunner._configDir;
      }
      if (playwrightRunner._config) {
        return playwrightRunner._config.config?.rootDir || process.cwd();
      }
      return process.cwd();
    }
    function getProjectsFromRunner(runner, configArg) {
      const config = configArg?.projects ? configArg : getPlaywrightConfig(runner);
      return config.projects?.map((project) => {
        if (project.project) {
          return project.project;
        }
        return project;
      });
    }
    function getProjectsFromDispatcher(dispatcher) {
      const newConfig = dispatcher._config?.config?.projects;
      if (newConfig) {
        return newConfig;
      }
      return dispatcher._loader?.fullConfig()?.projects;
    }
    function getBrowserNameFromProjects(projects, test) {
      if (!projects || !test) {
        return null;
      }
      const { _projectIndex, _projectId: testProjectId } = test;
      if (_projectIndex !== void 0) {
        return projects[_projectIndex]?.name;
      }
      return projects.find(({ __projectId, _id, name }) => {
        if (__projectId !== void 0) {
          return __projectId === testProjectId;
        }
        if (_id !== void 0) {
          return _id === testProjectId;
        }
        return name === testProjectId;
      })?.name;
    }
    function formatTestHookError(error, hookType, isTimeout) {
      let hookError = error;
      if (error) {
        hookError.message = `Error in ${hookType} hook: ${error.message}`;
      }
      if (!hookError && isTimeout) {
        hookError = new Error(`${hookType} hook timed out`);
      }
      return hookError;
    }
    function addErrorToTestSuite(testSuiteAbsolutePath, error) {
      if (testSuiteToErrors.has(testSuiteAbsolutePath)) {
        testSuiteToErrors.get(testSuiteAbsolutePath).push(error);
      } else {
        testSuiteToErrors.set(testSuiteAbsolutePath, [error]);
      }
    }
    function getTestSuiteError(testSuiteAbsolutePath) {
      const errors = testSuiteToErrors.get(testSuiteAbsolutePath);
      if (!errors) {
        return null;
      }
      if (errors.length === 1) {
        return errors[0];
      }
      return new Error(`${errors.length} errors in this test suite:
${errors.map((e) => e.message).join("\n------\n")}`);
    }
    function getTestByTestId(dispatcher, testId) {
      if (dispatcher._testById) {
        return dispatcher._testById.get(testId)?.test;
      }
      const allTests = dispatcher._allTests || dispatcher._ddAllTests;
      if (allTests) {
        return allTests.find(({ id }) => id === testId);
      }
    }
    function getChannelPromise(channelToPublishTo, params) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, ...params });
      });
    }
    function testWillRetry(test, testStatus) {
      return testStatus === "fail" && test.results.length <= test.retries;
    }
    function getTestFullname(test) {
      let parent = test.parent;
      const names = [test.title];
      while (parent?._type === "describe" || parent?._isDescribe) {
        if (parent.title) {
          names.unshift(parent.title);
        }
        parent = parent.parent;
      }
      return names.join(" ");
    }
    function testBeginHandler(test, browserName, isMainProcess) {
      const {
        _requireFile: testSuiteAbsolutePath,
        location: {
          line: testSourceLine
        },
        _type
      } = test;
      if (_type === "beforeAll" || _type === "afterAll") {
        return;
      }
      const isNewTestSuite = !startedSuites.includes(testSuiteAbsolutePath);
      if (isNewTestSuite) {
        startedSuites.push(testSuiteAbsolutePath);
        const testSuiteCtx = { testSuiteAbsolutePath };
        testSuiteToCtx.set(testSuiteAbsolutePath, testSuiteCtx);
        testSuiteStartCh.runStores(testSuiteCtx, () => {
        });
      }
      if (getTestProperties(test).attemptToFix) {
        test.retries = 0;
      }
      if (isMainProcess) {
        const testName = getTestFullname(test);
        const testCtx = {
          testName,
          testSuiteAbsolutePath,
          testSourceLine,
          browserName,
          isDisabled: test._ddIsDisabled
        };
        testToCtx.set(test, testCtx);
        testStartCh.runStores(testCtx, () => {
        });
      }
    }
    function testEndHandler(test, annotations, testStatus, error, isTimeout, isMainProcess) {
      const { _requireFile: testSuiteAbsolutePath, results, _type } = test;
      let annotationTags;
      if (annotations.length) {
        annotationTags = parseAnnotations(annotations);
      }
      if (_type === "beforeAll" || _type === "afterAll") {
        const hookError = formatTestHookError(error, _type, isTimeout);
        if (hookError) {
          addErrorToTestSuite(testSuiteAbsolutePath, hookError);
        }
        return;
      }
      const testFqn = getTestFullyQualifiedName(test);
      const testStatuses = testsToTestStatuses.get(testFqn) || [];
      if (testStatuses.length === 0) {
        testsToTestStatuses.set(testFqn, [testStatus]);
      } else {
        testStatuses.push(testStatus);
      }
      const testProperties = getTestProperties(test);
      if (testStatuses.length === testManagementAttemptToFixRetries + 1 && testProperties.attemptToFix) {
        if (testStatuses.includes("fail")) {
          test._ddHasFailedAttemptToFixRetries = true;
        }
        if (testStatuses.every((status) => status === "fail")) {
          test._ddHasFailedAllRetries = true;
        } else if (testStatuses.every((status) => status === "pass")) {
          test._ddHasPassedAttemptToFixRetries = true;
        }
      }
      if (isMainProcess) {
        const testResult = results.at(-1);
        const testCtx = testToCtx.get(test);
        const isAtrRetry = testResult?.retry > 0 && isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry;
        testFinishCh.publish({
          testStatus,
          steps: testResult?.steps || [],
          isRetry: testResult?.retry > 0,
          error,
          extraTags: annotationTags,
          isNew: test._ddIsNew,
          isAttemptToFix: test._ddIsAttemptToFix,
          isAttemptToFixRetry: test._ddIsAttemptToFixRetry,
          isQuarantined: test._ddIsQuarantined,
          isEfdRetry: test._ddIsEfdRetry,
          hasFailedAllRetries: test._ddHasFailedAllRetries,
          hasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
          hasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
          isAtrRetry,
          isModified: test._ddIsModified,
          ...testCtx.currentStore
        });
      }
      if (testSuiteToTestStatuses.has(testSuiteAbsolutePath)) {
        testSuiteToTestStatuses.get(testSuiteAbsolutePath).push(testStatus);
      } else {
        testSuiteToTestStatuses.set(testSuiteAbsolutePath, [testStatus]);
      }
      if (error) {
        addErrorToTestSuite(testSuiteAbsolutePath, error);
      }
      if (!testWillRetry(test, testStatus)) {
        remainingTestsByFile[testSuiteAbsolutePath] = remainingTestsByFile[testSuiteAbsolutePath].filter((currentTest) => currentTest !== test);
      }
      if (!remainingTestsByFile[testSuiteAbsolutePath].length) {
        const testStatuses2 = testSuiteToTestStatuses.get(testSuiteAbsolutePath);
        let testSuiteStatus = "pass";
        if (testStatuses2.includes("fail")) {
          testSuiteStatus = "fail";
        } else if (testStatuses2.every((status) => status === "skip")) {
          testSuiteStatus = "skip";
        }
        const suiteError = getTestSuiteError(testSuiteAbsolutePath);
        const testSuiteCtx = testSuiteToCtx.get(testSuiteAbsolutePath);
        testSuiteFinishCh.publish({ status: testSuiteStatus, error: suiteError, ...testSuiteCtx.currentStore });
      }
    }
    function dispatcherRunWrapper(run) {
      return function() {
        remainingTestsByFile = getTestsBySuiteFromTestsById(this._testById);
        return run.apply(this, arguments);
      };
    }
    function dispatcherRunWrapperNew(run) {
      return function(testGroups) {
        if (!this._allTests) {
          this._ddAllTests = testGroups.flatMap((g) => g.tests);
        }
        remainingTestsByFile = getTestsBySuiteFromTestGroups(testGroups);
        return run.apply(this, arguments);
      };
    }
    function dispatcherHook(dispatcherExport) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "run", dispatcherRunWrapper);
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "_createWorker", (createWorker) => function() {
        const dispatcher = this;
        const worker = createWorker.apply(this, arguments);
        worker.process.on("message", ({ method, params }) => {
          if (method === "testBegin") {
            const { test } = dispatcher._testById.get(params.testId);
            const projects = getProjectsFromDispatcher(dispatcher);
            const browser = getBrowserNameFromProjects(projects, test);
            testBeginHandler(test, browser, true);
          } else if (method === "testEnd") {
            const { test } = dispatcher._testById.get(params.testId);
            const { results } = test;
            const testResult = results.at(-1);
            const isTimeout = testResult.status === "timedOut";
            testEndHandler(
              test,
              params.annotations,
              STATUS_TO_TEST_STATUS[testResult.status],
              testResult.error,
              isTimeout,
              true
            );
          }
        });
        return worker;
      });
      return dispatcherExport;
    }
    function dispatcherHookNew(dispatcherExport, runWrapper) {
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "run", runWrapper);
      shimmer.wrap(dispatcherExport.Dispatcher.prototype, "_createWorker", (createWorker) => function() {
        const dispatcher = this;
        const worker = createWorker.apply(this, arguments);
        worker.on("testBegin", ({ testId }) => {
          const test = getTestByTestId(dispatcher, testId);
          const projects = getProjectsFromDispatcher(dispatcher);
          const browser = getBrowserNameFromProjects(projects, test);
          testBeginHandler(test, browser, false);
        });
        worker.on("testEnd", ({ testId, status, errors, annotations }) => {
          const test = getTestByTestId(dispatcher, testId);
          const isTimeout = status === "timedOut";
          testEndHandler(test, annotations, STATUS_TO_TEST_STATUS[status], errors && errors[0], isTimeout, false);
          const testResult = test.results.at(-1);
          const isAtrRetry = testResult?.retry > 0 && isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry;
          worker.process.send({
            type: "ddProperties",
            testId: test.id,
            properties: {
              _ddIsDisabled: test._ddIsDisabled,
              _ddIsQuarantined: test._ddIsQuarantined,
              _ddIsAttemptToFix: test._ddIsAttemptToFix,
              _ddIsAttemptToFixRetry: test._ddIsAttemptToFixRetry,
              _ddIsNew: test._ddIsNew,
              _ddIsEfdRetry: test._ddIsEfdRetry,
              _ddHasFailedAllRetries: test._ddHasFailedAllRetries,
              _ddHasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
              _ddHasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
              _ddIsAtrRetry: isAtrRetry,
              _ddIsModified: test._ddIsModified
            }
          });
        });
        return worker;
      });
      return dispatcherExport;
    }
    function runAllTestsWrapper(runAllTests, playwrightVersion) {
      return async function(config) {
        let onDone;
        rootDir = getRootDir(this, config);
        const processArgv = process.argv.slice(2).join(" ");
        const command = `playwright ${processArgv}`;
        testSessionStartCh.publish({ command, frameworkVersion: playwrightVersion, rootDir });
        try {
          const { err, libraryConfig } = await getChannelPromise(
            libraryConfigurationCh,
            { frameworkVersion: playwrightVersion }
          );
          if (!err) {
            isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled;
            isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled;
            earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries;
            earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold;
            isFlakyTestRetriesEnabled = libraryConfig.isFlakyTestRetriesEnabled;
            flakyTestRetriesCount = libraryConfig.flakyTestRetriesCount;
            isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled;
            testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries;
            isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled;
          }
        } catch (e) {
          isEarlyFlakeDetectionEnabled = false;
          isKnownTestsEnabled = false;
          isTestManagementTestsEnabled = false;
          isImpactedTestsEnabled = false;
          log.error("Playwright session start error", e);
        }
        if (isKnownTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, knownTests: receivedKnownTests } = await getChannelPromise(knownTestsCh);
            if (err) {
              isEarlyFlakeDetectionEnabled = false;
              isKnownTestsEnabled = false;
            } else {
              knownTests = receivedKnownTests;
            }
            if (!isValidKnownTests(receivedKnownTests)) {
              isEarlyFlakeDetectionFaulty = true;
              isEarlyFlakeDetectionEnabled = false;
              isKnownTestsEnabled = false;
            }
          } catch (err) {
            isEarlyFlakeDetectionEnabled = false;
            isKnownTestsEnabled = false;
            log.error("Playwright known tests error", err);
          }
        }
        if (isTestManagementTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, testManagementTests: receivedTestManagementTests } = await getChannelPromise(testManagementTestsCh);
            if (err) {
              isTestManagementTestsEnabled = false;
            } else {
              testManagementTests = receivedTestManagementTests;
            }
          } catch (err) {
            isTestManagementTestsEnabled = false;
            log.error("Playwright test management tests error", err);
          }
        }
        if (isImpactedTestsEnabled && satisfies(playwrightVersion, MINIMUM_SUPPORTED_VERSION_RANGE_EFD)) {
          try {
            const { err, modifiedFiles: receivedModifiedFiles } = await getChannelPromise(modifiedFilesCh);
            if (err) {
              isImpactedTestsEnabled = false;
            } else {
              modifiedFiles = receivedModifiedFiles;
            }
          } catch (err) {
            isImpactedTestsEnabled = false;
            log.error("Playwright impacted tests error", err);
          }
        }
        const projects = getProjectsFromRunner(this, config);
        const shouldSetRetries = isFlakyTestRetriesEnabled && flakyTestRetriesCount > 0 && !isTestManagementTestsEnabled;
        if (shouldSetRetries) {
          projects.forEach((project) => {
            if (project.retries === 0) {
              project.retries = flakyTestRetriesCount;
            }
          });
        }
        let runAllTestsReturn = await runAllTests.apply(this, arguments);
        Object.values(remainingTestsByFile).forEach((tests) => {
          tests.forEach((test) => {
            const browser = getBrowserNameFromProjects(projects, test);
            testBeginHandler(test, browser, true);
            testEndHandler(test, [], "skip", null, false, true);
          });
        });
        const sessionStatus = runAllTestsReturn.status || runAllTestsReturn;
        if (isTestManagementTestsEnabled && sessionStatus === "failed") {
          let totalFailedTestCount = 0;
          let totalAttemptToFixFailedTestCount = 0;
          let totalPureQuarantinedFailedTestCount = 0;
          for (const [fqn, testStatuses] of testsToTestStatuses.entries()) {
            const failedCount = testStatuses.filter((status) => status === "fail").length;
            totalFailedTestCount += failedCount;
            if (quarantinedButNotAttemptToFixFqns.has(fqn)) {
              totalPureQuarantinedFailedTestCount += failedCount;
            }
          }
          for (const test of quarantinedOrDisabledTestsAttemptToFix) {
            const testFqn = getTestFullyQualifiedName(test);
            const testStatuses = testsToTestStatuses.get(testFqn);
            totalAttemptToFixFailedTestCount += testStatuses.filter((status) => status === "fail").length;
          }
          const totalIgnorableFailures = totalAttemptToFixFailedTestCount + totalPureQuarantinedFailedTestCount;
          if (totalFailedTestCount > 0 && totalFailedTestCount === totalIgnorableFailures) {
            runAllTestsReturn = "passed";
          }
        }
        const flushWait = new Promise((resolve) => {
          onDone = resolve;
        });
        testSessionFinishCh.publish({
          status: STATUS_TO_TEST_STATUS[sessionStatus],
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onDone
        });
        await flushWait;
        startedSuites = [];
        remainingTestsByFile = {};
        quarantinedButNotAttemptToFixFqns = /* @__PURE__ */ new Set();
        return runAllTestsReturn;
      };
    }
    function runnerHook(runnerExport, playwrightVersion) {
      shimmer.wrap(
        runnerExport.Runner.prototype,
        "runAllTests",
        (runAllTests) => runAllTestsWrapper(runAllTests, playwrightVersion)
      );
    }
    function runnerHookNew(runnerExport, playwrightVersion) {
      runnerExport = shimmer.wrap(runnerExport, "runAllTestsWithConfig", function(originalGetter) {
        const originalFunction = originalGetter.call(this);
        return function() {
          return runAllTestsWrapper(originalFunction, playwrightVersion);
        };
      });
      return runnerExport;
    }
    if (DD_MAJOR < 6) {
      addHook({
        name: "@playwright/test",
        file: "lib/runner.js",
        versions: [">=1.18.0 <=1.30.0"]
      }, runnerHook);
      addHook({
        name: "@playwright/test",
        file: "lib/dispatcher.js",
        versions: [">=1.18.0 <1.30.0"]
      }, dispatcherHook);
      addHook({
        name: "@playwright/test",
        file: "lib/dispatcher.js",
        versions: [">=1.30.0 <1.31.0"]
      }, (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapper));
      addHook({
        name: "@playwright/test",
        file: "lib/runner/dispatcher.js",
        versions: [">=1.31.0 <1.38.0"]
      }, (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapperNew));
      addHook({
        name: "@playwright/test",
        file: "lib/runner/runner.js",
        versions: [">=1.31.0 <1.38.0"]
      }, runnerHook);
    }
    addHook({
      name: "playwright",
      file: "lib/runner/runner.js",
      versions: [">=1.38.0"]
    }, runnerHook);
    addHook({
      name: "playwright",
      file: "lib/runner/testRunner.js",
      versions: [">=1.55.0"]
    }, runnerHookNew);
    addHook({
      name: "playwright",
      file: "lib/runner/dispatcher.js",
      versions: [">=1.38.0"]
    }, (dispatcher) => dispatcherHookNew(dispatcher, dispatcherRunWrapperNew));
    addHook({
      name: "playwright",
      file: "lib/common/suiteUtils.js",
      versions: [">=1.38.0"]
    }, (suiteUtilsPackage) => {
      applyRepeatEachIndex = suiteUtilsPackage.applyRepeatEachIndex;
      return suiteUtilsPackage;
    });
    function applyRetriesToTests(fileSuitesWithTestsToRetry, filterTest, tagsToApply, numRetries) {
      for (const [fileSuite, projectSuite] of fileSuitesWithTestsToRetry.entries()) {
        for (let repeatEachIndex = 1; repeatEachIndex <= numRetries; repeatEachIndex++) {
          const copyFileSuite = deepCloneSuite(fileSuite, filterTest, tagsToApply);
          applyRepeatEachIndex(projectSuite._fullProject, copyFileSuite, repeatEachIndex + 1);
          projectSuite._addSuite(copyFileSuite);
        }
      }
    }
    addHook({
      name: "playwright",
      file: "lib/runner/loadUtils.js",
      versions: [">=1.38.0"]
    }, (loadUtilsPackage) => {
      const oldCreateRootSuite = loadUtilsPackage.createRootSuite;
      async function newCreateRootSuite() {
        if (!isKnownTestsEnabled && !isTestManagementTestsEnabled && !isImpactedTestsEnabled) {
          return oldCreateRootSuite.apply(this, arguments);
        }
        const createRootSuiteReturnValue = await oldCreateRootSuite.apply(this, arguments);
        const rootSuite = createRootSuiteReturnValue.rootSuite || createRootSuiteReturnValue;
        const allTests = rootSuite.allTests();
        if (isTestManagementTestsEnabled) {
          const fileSuitesWithManagedTestsToProjects = /* @__PURE__ */ new Map();
          for (const test of allTests) {
            const testProperties = getTestProperties(test);
            if (testProperties.disabled) {
              test._ddIsDisabled = true;
              test.expectedStatus = "skipped";
              continue;
            }
            if (testProperties.quarantined) {
              test._ddIsQuarantined = true;
              if (!testProperties.attemptToFix) {
                const testFqn = getTestFullyQualifiedName(test);
                quarantinedButNotAttemptToFixFqns.add(testFqn);
              }
            }
            if (testProperties.attemptToFix) {
              test._ddIsAttemptToFix = true;
              const fileSuite = getSuiteType(test, "file");
              if (!fileSuitesWithManagedTestsToProjects.has(fileSuite)) {
                fileSuitesWithManagedTestsToProjects.set(fileSuite, getSuiteType(test, "project"));
              }
              if (testProperties.disabled || testProperties.quarantined) {
                quarantinedOrDisabledTestsAttemptToFix.push(test);
              }
            }
          }
          applyRetriesToTests(
            fileSuitesWithManagedTestsToProjects,
            (test) => test._ddIsAttemptToFix,
            [
              (test) => test._ddIsQuarantined && "_ddIsQuarantined",
              "_ddIsAttemptToFix",
              "_ddIsAttemptToFixRetry"
            ],
            testManagementAttemptToFixRetries
          );
        }
        if (isImpactedTestsEnabled) {
          const impactedTests = allTests.filter((test) => {
            let isImpacted = false;
            isModifiedCh.publish({
              filePath: test._requireFile,
              modifiedFiles,
              onDone: (isModified) => {
                isImpacted = isModified;
              }
            });
            return isImpacted;
          });
          const fileSuitesWithImpactedTestsToProjects = /* @__PURE__ */ new Map();
          impactedTests.forEach((impactedTest) => {
            impactedTest._ddIsModified = true;
            if (isEarlyFlakeDetectionEnabled && impactedTest.expectedStatus !== "skipped") {
              const fileSuite = getSuiteType(impactedTest, "file");
              if (!fileSuitesWithImpactedTestsToProjects.has(fileSuite)) {
                fileSuitesWithImpactedTestsToProjects.set(fileSuite, getSuiteType(impactedTest, "project"));
              }
            }
          });
          applyRetriesToTests(
            fileSuitesWithImpactedTestsToProjects,
            () => true,
            [
              "_ddIsModified",
              "_ddIsEfdRetry",
              (test) => isKnownTestsEnabled && isNewTest(test) ? "_ddIsNew" : null
            ],
            earlyFlakeDetectionNumRetries
          );
        }
        if (isKnownTestsEnabled) {
          const newTests = allTests.filter(isNewTest);
          const isFaulty = getIsFaultyEarlyFlakeDetection(
            allTests.map((test) => getTestSuitePath(test._requireFile, rootDir)),
            knownTests.playwright,
            earlyFlakeDetectionFaultyThreshold
          );
          if (isFaulty) {
            isEarlyFlakeDetectionEnabled = false;
            isKnownTestsEnabled = false;
            isEarlyFlakeDetectionFaulty = true;
          } else {
            const fileSuitesWithNewTestsToProjects = /* @__PURE__ */ new Map();
            newTests.forEach((newTest) => {
              newTest._ddIsNew = true;
              if (isEarlyFlakeDetectionEnabled && newTest.expectedStatus !== "skipped" && !newTest._ddIsModified) {
                const fileSuite = getSuiteType(newTest, "file");
                if (!fileSuitesWithNewTestsToProjects.has(fileSuite)) {
                  fileSuitesWithNewTestsToProjects.set(fileSuite, getSuiteType(newTest, "project"));
                }
              }
            });
            applyRetriesToTests(
              fileSuitesWithNewTestsToProjects,
              isNewTest,
              ["_ddIsNew", "_ddIsEfdRetry"],
              earlyFlakeDetectionNumRetries
            );
          }
        }
        return createRootSuiteReturnValue;
      }
      const proxy = new Proxy(loadUtilsPackage, {
        get(target, prop) {
          if (prop === "createRootSuite") {
            return newCreateRootSuite;
          }
          return target[prop];
        }
      });
      return proxy;
    });
    addHook({
      name: "playwright",
      file: "lib/runner/processHost.js",
      versions: [">=1.38.0"]
    }, (processHostPackage) => {
      shimmer.wrap(processHostPackage.ProcessHost.prototype, "startRunner", (startRunner) => async function() {
        this._extraEnv = {
          ...this._extraEnv,
          // Used to detect that we're in a playwright worker
          DD_PLAYWRIGHT_WORKER: "1"
        };
        const res = await startRunner.apply(this, arguments);
        this.process.on("message", (message) => {
          if (Array.isArray(message) && message[0] === PLAYWRIGHT_WORKER_TRACE_PAYLOAD_CODE) {
            workerReportCh.publish(message[1]);
          }
        });
        return res;
      });
      return processHostPackage;
    });
    addHook({
      name: "playwright-core",
      file: "lib/client/page.js",
      versions: [">=1.38.0"]
    }, (pagePackage) => {
      shimmer.wrap(pagePackage.Page.prototype, "goto", (goto) => async function(url, options) {
        const response = await goto.apply(this, arguments);
        const page = this;
        try {
          if (page) {
            const isRumActive = await page.evaluate(() => {
              return window.DD_RUM && window.DD_RUM.getInternalContext ? !!window.DD_RUM.getInternalContext() : false;
            });
            if (isRumActive) {
              testPageGotoCh.publish({
                isRumActive,
                page
              });
            }
          }
        } catch {
        }
        return response;
      });
      return pagePackage;
    });
    addHook({
      name: "playwright",
      file: "lib/worker/workerMain.js",
      versions: [">=1.38.0"]
    }, (workerPackage) => {
      let steps = [];
      const stepInfoByStepId = {};
      shimmer.wrap(workerPackage.WorkerMain.prototype, "_runTest", (_runTest) => async function(test) {
        steps = [];
        const {
          _requireFile: testSuiteAbsolutePath,
          location: {
            line: testSourceLine
          }
        } = test;
        let res;
        let testInfo;
        const testName = getTestFullname(test);
        const browserName = this._project.project.name;
        const testCtx = {
          testName,
          testSuiteAbsolutePath,
          testSourceLine,
          browserName
        };
        testToCtx.set(test, testCtx);
        testStartCh.runStores(testCtx, () => {
          let existAfterEachHook = false;
          for (const hook of test.parent._hooks) {
            if (hook.type === "afterEach" && hook._ddHook) {
              existAfterEachHook = true;
              break;
            }
          }
          if (!existAfterEachHook) {
            test.parent._hooks.push({
              type: "afterEach",
              fn: async function({ page }) {
                try {
                  if (page) {
                    const isRumActive = await page.evaluate(() => {
                      if (window.DD_RUM && window.DD_RUM.stopSession) {
                        window.DD_RUM.stopSession();
                        return true;
                      }
                      return false;
                    });
                    if (isRumActive) {
                      const url = page.url();
                      if (url) {
                        const domain = new URL(url).hostname;
                        await page.context().addCookies([{
                          name: "datadog-ci-visibility-test-execution-id",
                          value: "",
                          domain,
                          expires: 0,
                          path: "/"
                        }]);
                      }
                    }
                  }
                } catch {
                }
              },
              title: "afterEach hook",
              _ddHook: true
            });
          }
          res = _runTest.apply(this, arguments);
          testInfo = this._currentTest;
        });
        await res;
        const { status, error, annotations, retry, testId } = testInfo;
        let annotationTags;
        if (annotations.length) {
          annotationTags = parseAnnotations(annotations);
        }
        let onDone;
        const flushPromise = new Promise((resolve) => {
          onDone = resolve;
        });
        const ddPropertiesPromise = new Promise((resolve) => {
          const messageHandler = ({ type, testId: testId2, properties }) => {
            if (type === "ddProperties" && testId2 === test.id) {
              if (properties) {
                Object.assign(test, properties);
              }
              process.removeListener("message", messageHandler);
              resolve();
            }
          };
          process.on("message", messageHandler);
        });
        await ddPropertiesPromise;
        testFinishCh.publish({
          testStatus: STATUS_TO_TEST_STATUS[status],
          steps: steps.filter((step) => step.testId === testId),
          error,
          extraTags: annotationTags,
          isNew: test._ddIsNew,
          isRetry: retry > 0,
          isEfdRetry: test._ddIsEfdRetry,
          isAttemptToFix: test._ddIsAttemptToFix,
          isDisabled: test._ddIsDisabled,
          isQuarantined: test._ddIsQuarantined,
          isAttemptToFixRetry: test._ddIsAttemptToFixRetry,
          hasFailedAllRetries: test._ddHasFailedAllRetries,
          hasPassedAttemptToFixRetries: test._ddHasPassedAttemptToFixRetries,
          hasFailedAttemptToFixRetries: test._ddHasFailedAttemptToFixRetries,
          isAtrRetry: test._ddIsAtrRetry,
          isModified: test._ddIsModified,
          onDone,
          ...testCtx.currentStore
        });
        await flushPromise;
        return res;
      });
      shimmer.wrap(workerPackage.WorkerMain.prototype, "dispatchEvent", (dispatchEvent) => function(event, payload) {
        if (event === "stepBegin") {
          stepInfoByStepId[payload.stepId] = {
            startTime: payload.wallTime,
            title: payload.title,
            testId: payload.testId
          };
        } else if (event === "stepEnd") {
          const stepInfo = stepInfoByStepId[payload.stepId];
          delete stepInfoByStepId[payload.stepId];
          steps.push({
            testId: stepInfo.testId,
            startTime: new Date(stepInfo.startTime),
            title: stepInfo.title,
            duration: payload.wallTime - stepInfo.startTime,
            error: payload.error
          });
        }
        return dispatchEvent.apply(this, arguments);
      });
      return workerPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/elasticsearch.js
var require_elasticsearch = __commonJS({
  "../../packages/datadog-instrumentations/src/elasticsearch.js"(exports2, module2) {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "@elastic/transport", file: "lib/Transport.js", versions: [">=8"] }, (exports3) => {
      shimmer.wrap(exports3.default.prototype, "request", createWrapRequest("elasticsearch"));
      shimmer.wrap(exports3.default.prototype, "getConnection", createWrapGetConnection("elasticsearch"));
      return exports3;
    });
    addHook({ name: "@elastic/elasticsearch", file: "lib/Transport.js", versions: [">=5.6.16 <8", ">=8"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("elasticsearch"));
      shimmer.wrap(Transport.prototype, "getConnection", createWrapGetConnection("elasticsearch"));
      return Transport;
    });
    addHook({ name: "elasticsearch", file: "src/lib/transport.js", versions: [">=10"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("elasticsearch"));
      return Transport;
    });
    addHook({ name: "elasticsearch", file: "src/lib/connection_pool.js", versions: [">=10"] }, (ConnectionPool) => {
      shimmer.wrap(ConnectionPool.prototype, "select", createWrapSelect("elasticsearch"));
      return ConnectionPool;
    });
    function createWrapGetConnection(name) {
      const connectCh = channel(`apm:${name}:query:connect`);
      return function wrapRequest(request2) {
        return function() {
          const connection = request2.apply(this, arguments);
          if (connectCh.hasSubscribers && connection && connection.url) {
            connectCh.publish(connection.url);
          }
          return connection;
        };
      };
    }
    function createWrapSelect() {
      const connectCh = channel("apm:elasticsearch:query:connect");
      return function wrapRequest(request2) {
        return function() {
          if (arguments.length === 1) {
            const cb = arguments[0];
            arguments[0] = shimmer.wrapFunction(cb, (cb2) => function(err, connection) {
              if (connectCh.hasSubscribers && connection && connection.host) {
                connectCh.publish({ hostname: connection.host.host, port: connection.host.port });
              }
              cb2(err, connection);
            });
          }
          return request2.apply(this, arguments);
        };
      };
    }
    function createWrapRequest(name) {
      const startCh = channel(`apm:${name}:query:start`);
      const finishCh = channel(`apm:${name}:query:finish`);
      const errorCh = channel(`apm:${name}:query:error`);
      return function wrapRequest(request2) {
        return function(params, options, cb) {
          if (!startCh.hasSubscribers) {
            return request2.apply(this, arguments);
          }
          if (!params) return request2.apply(this, arguments);
          const ctx = { params };
          return startCh.runStores(ctx, () => {
            try {
              const lastIndex = arguments.length - 1;
              cb = arguments[lastIndex];
              if (typeof cb === "function") {
                arguments[lastIndex] = shimmer.wrapFunction(cb, (cb2) => function(error) {
                  if (error) {
                    ctx.error = error;
                    errorCh.publish(ctx);
                  }
                  return finishCh.runStores(ctx, cb2, null, ...arguments);
                });
                return request2.apply(this, arguments);
              }
              const promise = request2.apply(this, arguments);
              if (promise && typeof promise.then === "function") {
                const onResolve = () => finish(ctx);
                const onReject = (e) => finish(ctx, e);
                promise.then(onResolve, onReject);
              } else {
                finish(ctx);
              }
              return promise;
            } catch (err) {
              err.stack;
              errorCh.publish(err);
              throw err;
            }
          });
        };
      };
      function finish(ctx, error) {
        if (error) {
          ctx.error = error;
          errorCh.publish(error);
        }
        return finishCh.runStores(ctx, () => {
        });
      }
    }
    module2.exports = { createWrapRequest, createWrapGetConnection };
  }
});

// ../../packages/datadog-instrumentations/src/google-cloud-pubsub.js
var require_google_cloud_pubsub = __commonJS({
  "../../packages/datadog-instrumentations/src/google-cloud-pubsub.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var requestStartCh = channel("apm:google-cloud-pubsub:request:start");
    var requestFinishCh = channel("apm:google-cloud-pubsub:request:finish");
    var requestErrorCh = channel("apm:google-cloud-pubsub:request:error");
    var receiveStartCh = channel("apm:google-cloud-pubsub:receive:start");
    var receiveFinishCh = channel("apm:google-cloud-pubsub:receive:finish");
    var receiveErrorCh = channel("apm:google-cloud-pubsub:receive:error");
    var publisherMethods = [
      "createTopic",
      "updateTopic",
      "publish",
      "getTopic",
      "listTopics",
      "listTopicSubscriptions",
      "listTopicSnapshots",
      "deleteTopic",
      "detachSubscription"
    ];
    var schemaServiceMethods = [
      "createSchema",
      "getSchema",
      "listSchemas",
      "listSchemaRevisions",
      "commitSchema",
      "rollbackSchema",
      "deleteSchemaRevision",
      "deleteSchema",
      "validateSchema",
      "validateMessage"
    ];
    var subscriberMethods = [
      "createSubscription",
      "getSubscription",
      "updateSubscription",
      "listSubscriptions",
      "deleteSubscription",
      "modifyAckDeadline",
      "acknowledge",
      "pull",
      "streamingPull",
      "modifyPushConfig",
      "getSnapshot",
      "listSnapshots",
      "createSnapshot",
      "updateSnapshot",
      "deleteSnapshot",
      "seek"
    ];
    function wrapMethod(method) {
      const api = method.name;
      return function(request2) {
        if (!requestStartCh.hasSubscribers) return method.apply(this, arguments);
        const ctx = { request: request2, api, projectId: this.auth._cachedProjectId };
        return requestStartCh.runStores(ctx, () => {
          const cb = arguments[arguments.length - 1];
          if (typeof cb === "function") {
            arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function(error) {
              if (error) {
                ctx.error = error;
                requestErrorCh.publish(ctx);
              }
              return requestFinishCh.runStores(ctx, cb2, this, ...arguments);
            });
            return method.apply(this, arguments);
          }
          return method.apply(this, arguments).then(
            (response) => {
              requestFinishCh.publish(ctx);
              return response;
            },
            (error) => {
              ctx.error = error;
              requestErrorCh.publish(ctx);
              requestFinishCh.publish(ctx);
              throw error;
            }
          );
        });
      };
    }
    function massWrap(obj, methods, wrapper) {
      for (const method of methods) {
        if (typeof obj[method] === "function") {
          shimmer.wrap(obj, method, wrapper);
        }
      }
    }
    addHook({ name: "@google-cloud/pubsub", versions: [">=1.2"] }, (obj) => {
      const Subscription = obj.Subscription;
      shimmer.wrap(Subscription.prototype, "emit", (emit) => function(eventName, message) {
        if (eventName !== "message" || !message) return emit.apply(this, arguments);
        const ctx = {};
        try {
          return emit.apply(this, arguments);
        } catch (err) {
          ctx.error = err;
          receiveErrorCh.publish(ctx);
          throw err;
        }
      });
      return obj;
    });
    addHook({ name: "@google-cloud/pubsub", versions: [">=1.2"], file: "build/src/lease-manager.js" }, (obj) => {
      const LeaseManager = obj.LeaseManager;
      const ctx = {};
      shimmer.wrap(LeaseManager.prototype, "_dispense", (dispense) => function(message) {
        if (receiveStartCh.hasSubscribers) {
          ctx.message = message;
          return receiveStartCh.runStores(ctx, dispense, this, ...arguments);
        }
        return dispense.apply(this, arguments);
      });
      shimmer.wrap(LeaseManager.prototype, "remove", (remove) => function(message) {
        return receiveFinishCh.runStores(ctx, remove, this, ...arguments);
      });
      shimmer.wrap(LeaseManager.prototype, "clear", (clear) => function() {
        for (const message of this._messages) {
          ctx.message = message;
          receiveFinishCh.publish(ctx);
        }
        return clear.apply(this, arguments);
      });
      return obj;
    });
    addHook({ name: "@google-cloud/pubsub", versions: [">=1.2"] }, (obj) => {
      const { PublisherClient, SchemaServiceClient, SubscriberClient } = obj.v1;
      massWrap(PublisherClient.prototype, publisherMethods, wrapMethod);
      massWrap(SubscriberClient.prototype, subscriberMethods, wrapMethod);
      if (SchemaServiceClient) {
        massWrap(SchemaServiceClient.prototype, schemaServiceMethods, wrapMethod);
      }
      return obj;
    });
  }
});

// ../../packages/datadog-instrumentations/src/google-cloud-vertexai.js
var require_google_cloud_vertexai = __commonJS({
  "../../packages/datadog-instrumentations/src/google-cloud-vertexai.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var vertexaiTracingChannel = require_dc_polyfill().tracingChannel("apm:vertexai:request");
    function wrapGenerate(generate) {
      return function(request2) {
        if (!vertexaiTracingChannel.start.hasSubscribers) {
          return generate.apply(this, arguments);
        }
        const ctx = {
          request: request2,
          instance: this,
          resource: [this.constructor.name, generate.name].join(".")
        };
        return vertexaiTracingChannel.tracePromise(generate, ctx, this, ...arguments);
      };
    }
    function wrapGenerateStream(generateStream) {
      return function(request2) {
        if (!vertexaiTracingChannel.start.hasSubscribers) {
          return generateStream.apply(this, arguments);
        }
        const ctx = {
          request: request2,
          instance: this,
          resource: [this.constructor.name, generateStream.name].join("."),
          stream: true
        };
        return vertexaiTracingChannel.start.runStores(ctx, () => {
          let streamingResult;
          try {
            streamingResult = generateStream.apply(this, arguments);
          } catch (e) {
            finish(ctx, null, e, true);
            throw e;
          }
          vertexaiTracingChannel.end.publish(ctx);
          return streamingResult.then((stream) => {
            stream.response.then((response) => {
              finish(ctx, response, null);
            }).catch((e) => {
              finish(ctx, null, e);
              throw e;
            });
            return stream;
          }).catch((e) => {
            finish(ctx, null, e);
            throw e;
          });
        });
      };
    }
    function finish(ctx, response, err, publishEndEvent = false) {
      if (err) {
        ctx.error = err;
        vertexaiTracingChannel.error.publish(ctx);
      }
      ctx.result = { response };
      if (publishEndEvent) vertexaiTracingChannel.end.publish(ctx);
      vertexaiTracingChannel.asyncEnd.publish(ctx);
    }
    addHook({
      name: "@google-cloud/vertexai",
      file: "build/src/models/generative_models.js",
      versions: [">=1"]
    }, (exports3) => {
      const GenerativeModel = exports3.GenerativeModel;
      shimmer.wrap(GenerativeModel.prototype, "generateContent", wrapGenerate);
      shimmer.wrap(GenerativeModel.prototype, "generateContentStream", wrapGenerateStream);
      return exports3;
    });
    addHook({
      name: "@google-cloud/vertexai",
      file: "build/src/models/chat_session.js",
      versions: [">=1"]
    }, (exports3) => {
      const ChatSession = exports3.ChatSession;
      shimmer.wrap(ChatSession.prototype, "sendMessage", wrapGenerate);
      shimmer.wrap(ChatSession.prototype, "sendMessageStream", wrapGenerateStream);
      return exports3;
    });
  }
});

// ../../packages/datadog-instrumentations/src/graphql.js
var require_graphql = __commonJS({
  "../../packages/datadog-instrumentations/src/graphql.js"() {
    "use strict";
    var {
      addHook,
      channel
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var contexts = /* @__PURE__ */ new WeakMap();
    var documentSources = /* @__PURE__ */ new WeakMap();
    var patchedResolvers = /* @__PURE__ */ new WeakSet();
    var patchedTypes = /* @__PURE__ */ new WeakSet();
    var startExecuteCh = channel("apm:graphql:execute:start");
    var finishExecuteCh = channel("apm:graphql:execute:finish");
    var executeErrorCh = channel("apm:graphql:execute:error");
    var startResolveCh = channel("apm:graphql:resolve:start");
    var finishResolveCh = channel("apm:graphql:resolve:finish");
    var updateFieldCh = channel("apm:graphql:resolve:updateField");
    var resolveErrorCh = channel("apm:graphql:resolve:error");
    var parseStartCh = channel("apm:graphql:parser:start");
    var parseFinishCh = channel("apm:graphql:parser:finish");
    var parseErrorCh = channel("apm:graphql:parser:error");
    var validateStartCh = channel("apm:graphql:validate:start");
    var validateFinishCh = channel("apm:graphql:validate:finish");
    var validateErrorCh = channel("apm:graphql:validate:error");
    var AbortError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "AbortError";
      }
    };
    var types = /* @__PURE__ */ new Set(["query", "mutation", "subscription"]);
    function getOperation(document, operationName) {
      if (!document || !Array.isArray(document.definitions)) {
        return;
      }
      for (const definition of document.definitions) {
        if (definition && types.has(definition.operation) && (!operationName || definition.name?.value === operationName)) {
          return definition;
        }
      }
    }
    function normalizeArgs(args, defaultFieldResolver) {
      if (args.length !== 1) return normalizePositional(args, defaultFieldResolver);
      args[0].contextValue ||= {};
      args[0].fieldResolver = wrapResolve(args[0].fieldResolver || defaultFieldResolver);
      return args[0];
    }
    function normalizePositional(args, defaultFieldResolver) {
      args[3] = args[3] || {};
      args[6] = wrapResolve(args[6] || defaultFieldResolver);
      args.length = Math.max(args.length, 7);
      return {
        schema: args[0],
        document: args[1],
        rootValue: args[2],
        contextValue: args[3],
        variableValues: args[4],
        operationName: args[5],
        fieldResolver: args[6]
      };
    }
    function wrapParse(parse) {
      return function(source) {
        if (!parseStartCh.hasSubscribers) {
          return parse.apply(this, arguments);
        }
        const ctx = { source };
        return parseStartCh.runStores(ctx, () => {
          try {
            ctx.document = parse.apply(this, arguments);
            const operation = getOperation(ctx.document);
            if (!operation) return ctx.document;
            if (source) {
              documentSources.set(ctx.document, source.body || source);
            }
            ctx.docSource = documentSources.get(ctx.document);
            return ctx.document;
          } catch (err) {
            err.stack;
            ctx.error = err;
            parseErrorCh.publish(ctx);
            throw err;
          } finally {
            parseFinishCh.publish(ctx);
          }
        });
      };
    }
    function wrapValidate(validate) {
      return function(_schema, document, _rules, _typeInfo) {
        if (!validateStartCh.hasSubscribers) {
          return validate.apply(this, arguments);
        }
        const ctx = { docSource: documentSources.get(document), document };
        return validateStartCh.runStores(ctx, () => {
          let errors;
          try {
            errors = validate.apply(this, arguments);
            if (errors && errors[0]) {
              ctx.error = errors && errors[0];
              validateErrorCh.publish(ctx);
            }
            return errors;
          } catch (err) {
            err.stack;
            ctx.error = err;
            validateErrorCh.publish(ctx);
            throw err;
          } finally {
            ctx.errors = errors;
            validateFinishCh.publish(ctx);
          }
        });
      };
    }
    function wrapExecute(execute) {
      return function(exe) {
        const defaultFieldResolver = execute.defaultFieldResolver;
        return function() {
          if (!startExecuteCh.hasSubscribers) {
            return exe.apply(this, arguments);
          }
          const args = normalizeArgs(arguments, defaultFieldResolver);
          const schema = args.schema;
          const document = args.document;
          const source = documentSources.get(document);
          const contextValue = args.contextValue;
          const operation = getOperation(document, args.operationName);
          if (contexts.has(contextValue)) {
            return exe.apply(this, arguments);
          }
          const ctx = {
            operation,
            args,
            docSource: documentSources.get(document),
            source,
            fields: {},
            abortController: new AbortController()
          };
          return startExecuteCh.runStores(ctx, () => {
            if (schema) {
              wrapFields(schema._queryType);
              wrapFields(schema._mutationType);
            }
            contexts.set(contextValue, ctx);
            return callInAsyncScope(exe, this, arguments, ctx.abortController, (err, res) => {
              if (finishResolveCh.hasSubscribers) finishResolvers(ctx);
              const error = err || res && res.errors && res.errors[0];
              if (error) {
                ctx.error = error;
                executeErrorCh.publish(ctx);
              }
              ctx.res = res;
              finishExecuteCh.publish(ctx);
            });
          });
        };
      };
    }
    function wrapResolve(resolve) {
      if (typeof resolve !== "function" || patchedResolvers.has(resolve)) return resolve;
      function resolveAsync(source, args, contextValue, info) {
        if (!startResolveCh.hasSubscribers) return resolve.apply(this, arguments);
        const ctx = contexts.get(contextValue);
        if (!ctx) return resolve.apply(this, arguments);
        const field = assertField(ctx, info, args);
        return callInAsyncScope(resolve, this, arguments, ctx.abortController, (err) => {
          field.ctx.error = err;
          field.ctx.info = info;
          field.ctx.field = field;
          updateFieldCh.publish(field.ctx);
        });
      }
      patchedResolvers.add(resolveAsync);
      return resolveAsync;
    }
    function callInAsyncScope(fn, thisArg, args, abortController, cb) {
      cb = cb || (() => {
      });
      if (abortController?.signal.aborted) {
        cb(null, null);
        throw new AbortError("Aborted");
      }
      try {
        const result = fn.apply(thisArg, args);
        if (result && typeof result.then === "function") {
          return result.then(
            (res) => {
              cb(null, res);
              return res;
            },
            (err) => {
              cb(err);
              throw err;
            }
          );
        }
        cb(null, result);
        return result;
      } catch (err) {
        cb(err);
        throw err;
      }
    }
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    function assertField(rootCtx, info, args) {
      const pathInfo = info && info.path;
      const path = pathToArray(pathInfo);
      const pathString = path.join(".");
      const fields = rootCtx.fields;
      let field = fields[pathString];
      if (!field) {
        const fieldCtx = { info, rootCtx, args };
        startResolveCh.publish(fieldCtx);
        field = fields[pathString] = {
          error: null,
          ctx: fieldCtx
        };
      }
      return field;
    }
    function wrapFields(type) {
      if (!type || !type._fields || patchedTypes.has(type)) {
        return;
      }
      patchedTypes.add(type);
      Object.keys(type._fields).forEach((key) => {
        const field = type._fields[key];
        wrapFieldResolve(field);
        wrapFieldType(field);
      });
    }
    function wrapFieldResolve(field) {
      if (!field || !field.resolve) return;
      field.resolve = wrapResolve(field.resolve);
    }
    function wrapFieldType(field) {
      if (!field || !field.type) return;
      let unwrappedType = field.type;
      while (unwrappedType.ofType) {
        unwrappedType = unwrappedType.ofType;
      }
      wrapFields(unwrappedType);
    }
    function finishResolvers({ fields }) {
      Object.keys(fields).reverse().forEach((key) => {
        const field = fields[key];
        field.ctx.finishTime = field.finishTime;
        field.ctx.field = field;
        if (field.error) {
          field.ctx.error = field.error;
          resolveErrorCh.publish(field.ctx);
        }
        finishResolveCh.publish(field.ctx);
      });
    }
    addHook({ name: "@graphql-tools/executor", versions: [">=0.0.14"] }, (executor) => {
      shimmer.wrap(executor, "execute", wrapExecute(executor));
      shimmer.wrap(executor, "normalizedExecutor", wrapExecute(executor));
      return executor;
    });
    addHook({ name: "@graphql-tools/executor", file: "cjs/execution/execute.js", versions: [">=0.0.14"] }, (execute) => {
      shimmer.wrap(execute, "execute", wrapExecute(execute));
      return execute;
    });
    addHook({ name: "graphql", file: "execution/execute.js", versions: [">=0.10"] }, (execute) => {
      shimmer.wrap(execute, "execute", wrapExecute(execute));
      return execute;
    });
    addHook({ name: "graphql", file: "language/parser.js", versions: [">=0.10"] }, (parser) => {
      shimmer.wrap(parser, "parse", wrapParse);
      return parser;
    });
    addHook({ name: "graphql", file: "validation/validate.js", versions: [">=0.10"] }, (validate) => {
      shimmer.wrap(validate, "validate", wrapValidate);
      return validate;
    });
  }
});

// ../../packages/datadog-instrumentations/src/grpc/types.js
var require_types2 = __commonJS({
  "../../packages/datadog-instrumentations/src/grpc/types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      unary: "unary",
      bidi: "bidi_streaming",
      client_stream: "client_streaming",
      clientStream: "client_streaming",
      server_stream: "server_streaming",
      serverStream: "server_streaming"
    };
  }
});

// ../../packages/datadog-instrumentations/src/grpc/client.js
var require_client = __commonJS({
  "../../packages/datadog-instrumentations/src/grpc/client.js"() {
    "use strict";
    var types = require_types2();
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var patched = /* @__PURE__ */ new WeakSet();
    var instances = /* @__PURE__ */ new WeakMap();
    var startChannel = channel("apm:grpc:client:request:start");
    var asyncStartChannel = channel("apm:grpc:client:request:asyncStart");
    var errorChannel = channel("apm:grpc:client:request:error");
    var finishChannel = channel("apm:grpc:client:request:finish");
    var emitChannel = channel("apm:grpc:client:request:emit");
    function createWrapMakeRequest(type, hasPeer = false) {
      return function wrapMakeRequest(makeRequest) {
        return function(path) {
          const args = ensureMetadata(this, arguments, 4);
          return callMethod(this, makeRequest, args, path, args[4], type, hasPeer);
        };
      };
    }
    function createWrapLoadPackageDefinition(hasPeer = false) {
      return function wrapLoadPackageDefinition(loadPackageDefinition) {
        return function(packageDef) {
          const result = loadPackageDefinition.apply(this, arguments);
          if (!result) return result;
          wrapPackageDefinition(result, hasPeer);
          return result;
        };
      };
    }
    function createWrapMakeClientConstructor(hasPeer = false) {
      return function wrapMakeClientConstructor(makeClientConstructor) {
        return function(methods) {
          const ServiceClient = makeClientConstructor.apply(this, arguments);
          wrapClientConstructor(ServiceClient, methods, hasPeer);
          return ServiceClient;
        };
      };
    }
    function wrapPackageDefinition(def, hasPeer = false) {
      for (const name in def) {
        if (def[name].format) continue;
        if (def[name].service && def[name].prototype) {
          wrapClientConstructor(def[name], def[name].service, hasPeer);
        } else {
          wrapPackageDefinition(def[name], hasPeer);
        }
      }
    }
    function wrapClientConstructor(ServiceClient, methods, hasPeer = false) {
      const proto = ServiceClient.prototype;
      if (typeof methods !== "object" || "format" in methods) return;
      Object.keys(methods).forEach((name) => {
        if (!methods[name]) return;
        const originalName = methods[name].originalName;
        const path = methods[name].path;
        const type = getType(methods[name]);
        if (methods[name]) {
          proto[name] = wrapMethod(proto[name], path, type, hasPeer);
        }
        if (originalName) {
          proto[originalName] = wrapMethod(proto[originalName], path, type, hasPeer);
        }
      });
    }
    function wrapMethod(method, path, type, hasPeer) {
      if (typeof method !== "function" || patched.has(method)) {
        return method;
      }
      const wrapped = shimmer.wrapFunction(method, (method2) => function() {
        const args = ensureMetadata(this, arguments, 1);
        return callMethod(this, method2, args, path, args[1], type, hasPeer);
      });
      patched.add(wrapped);
      return wrapped;
    }
    function wrapCallback(ctx, callback = () => {
    }) {
      return shimmer.wrapFunction(callback, (callback2) => function(err) {
        if (err) {
          ctx.error = err;
          errorChannel.publish(ctx);
        }
        return asyncStartChannel.runStores(ctx, () => {
          return callback2.apply(this, arguments);
        });
      });
    }
    var onStatusWithPeer = function(ctx, arg1, thisArg) {
      ctx.result = arg1;
      ctx.peer = thisArg.getPeer();
      finishChannel.publish(ctx);
    };
    var onStatusWithoutPeer = function(ctx, arg1) {
      ctx.result = arg1;
      finishChannel.publish(ctx);
    };
    function createWrapEmit(ctx, hasPeer = false) {
      const onStatus = hasPeer ? onStatusWithPeer : onStatusWithoutPeer;
      return function wrapEmit(emit) {
        return function(event, arg1) {
          switch (event) {
            case "error":
              ctx.error = arg1;
              errorChannel.publish(ctx);
              break;
            case "status":
              onStatus(ctx, arg1, this);
              break;
          }
          return emitChannel.runStores(ctx, () => {
            return emit.apply(this, arguments);
          });
        };
      };
    }
    function callMethod(client, method, args, path, metadata, type, hasPeer = false) {
      if (!startChannel.hasSubscribers) return method.apply(client, args);
      const length = args.length;
      const callback = args[length - 1];
      const ctx = { metadata, path, type };
      return startChannel.runStores(ctx, () => {
        try {
          if (type === types.unary || type === types.client_stream) {
            if (typeof callback === "function") {
              args[length - 1] = wrapCallback(ctx, callback);
            } else {
              args[length] = wrapCallback(ctx);
            }
          }
          const call = method.apply(client, args);
          if (call && typeof call.emit === "function") {
            shimmer.wrap(call, "emit", createWrapEmit(ctx, hasPeer));
          }
          return call;
        } catch (e) {
          ctx.error = e;
          errorChannel.publish(ctx);
        }
      });
    }
    function ensureMetadata(client, args, index) {
      const grpc = getGrpc(client);
      if (!client || !grpc) return args;
      const meta = args[index];
      const normalized = [];
      for (let i = 0; i < index; i++) {
        normalized.push(args[i]);
      }
      if (!meta || !meta.constructor || meta.constructor.name !== "Metadata") {
        normalized.push(new grpc.Metadata());
      }
      if (meta) {
        normalized.push(meta);
      }
      for (let i = index + 1; i < args.length; i++) {
        normalized.push(args[i]);
      }
      return normalized;
    }
    function getType(definition) {
      if (definition.requestStream) {
        if (definition.responseStream) {
          return types.bidi;
        }
        return types.client_stream;
      }
      if (definition.responseStream) {
        return types.server_stream;
      }
      return types.unary;
    }
    function getGrpc(client) {
      let proto = client;
      do {
        const instance = instances.get(proto);
        if (instance) return instance;
      } while (proto = Object.getPrototypeOf(proto));
    }
    function patch(hasPeer = false) {
      return function patch2(grpc) {
        const proto = grpc.Client.prototype;
        instances.set(proto, grpc);
        shimmer.wrap(proto, "makeBidiStreamRequest", createWrapMakeRequest(types.bidi, hasPeer));
        shimmer.wrap(proto, "makeClientStreamRequest", createWrapMakeRequest(types.clientStream, hasPeer));
        shimmer.wrap(proto, "makeServerStreamRequest", createWrapMakeRequest(types.serverStream, hasPeer));
        shimmer.wrap(proto, "makeUnaryRequest", createWrapMakeRequest(types.unary, hasPeer));
        return grpc;
      };
    }
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3 <1.1.4"] }, patch(false));
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3 <1.1.4"], file: "build/src/make-client.js" }, (client) => {
      shimmer.wrap(client, "makeClientConstructor", createWrapMakeClientConstructor(false));
      shimmer.wrap(client, "loadPackageDefinition", createWrapLoadPackageDefinition(false));
      return client;
    });
    addHook({ name: "@grpc/grpc-js", versions: [">=1.1.4"] }, patch(true));
    addHook({ name: "@grpc/grpc-js", versions: [">=1.1.4"], file: "build/src/make-client.js" }, (client) => {
      shimmer.wrap(client, "makeClientConstructor", createWrapMakeClientConstructor(true));
      shimmer.wrap(client, "loadPackageDefinition", createWrapLoadPackageDefinition(true));
      return client;
    });
  }
});

// ../../packages/datadog-instrumentations/src/grpc/server.js
var require_server = __commonJS({
  "../../packages/datadog-instrumentations/src/grpc/server.js"() {
    "use strict";
    var types = require_types2();
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:grpc:server:request:start");
    var asyncStartChannel = channel("apm:grpc:server:request:asyncStart");
    var errorChannel = channel("apm:grpc:server:request:error");
    var updateChannel = channel("apm:grpc:server:request:update");
    var finishChannel = channel("apm:grpc:server:request:finish");
    var emitChannel = channel("apm:grpc:server:request:emit");
    var OK = 0;
    var CANCELLED = 1;
    var isValid = (server2, args) => {
      return Boolean(startChannel.hasSubscribers && server2?.type && args[0] && (server2.type === "unary" ? typeof args[1] === "function" : isEmitter(args[0])));
    };
    function wrapHandler(func, name) {
      return function(call, callback) {
        if (!isValid(this, arguments)) return func.apply(this, arguments);
        const metadata = call.metadata;
        const type = types[this.type];
        const isStream = type !== "unary";
        const ctx = { name, metadata, type };
        return startChannel.runStores(ctx, () => {
          try {
            const onCancel = () => {
              ctx.code = CANCELLED;
              finishChannel.publish(ctx);
            };
            call.once("cancelled", onCancel);
            if (isStream) {
              wrapStream(call, ctx, onCancel);
            } else {
              arguments[1] = wrapCallback(callback, call, ctx, onCancel);
            }
            shimmer.wrap(call, "emit", (emit) => {
              return function() {
                return emitChannel.runStores(ctx, () => {
                  return emit.apply(this, arguments);
                });
              };
            });
            return func.apply(this, arguments);
          } catch (e) {
            ctx.error = e;
            errorChannel.publish(ctx);
          }
        });
      };
    }
    function wrapRegister(register2) {
      return function(name, handler, serialize, deserialize, type) {
        if (typeof handler === "function") {
          arguments[1] = wrapHandler(handler, name);
        }
        return register2.apply(this, arguments);
      };
    }
    function createWrapEmit(call, ctx, onCancel) {
      return function wrapEmit(emit) {
        return function(event, arg1) {
          switch (event) {
            case "error":
              ctx.error = arg1;
              errorChannel.publish(ctx);
              ctx.code = arg1.code;
              finishChannel.publish(ctx);
              call.removeListener("cancelled", onCancel);
              break;
            // Streams are always cancelled before `finish` since 1.10.0 so we have
            // to use `prefinish` instead to avoid cancellation false positives.
            case "prefinish":
              if (call.status) {
                updateChannel.publish(call.status);
              }
              if (!call.status || call.status.code === 0) {
                finishChannel.publish(ctx);
              }
              call.removeListener("cancelled", onCancel);
              break;
          }
          return emit.apply(this, arguments);
        };
      };
    }
    function wrapStream(call, ctx, onCancel) {
      if (call.call && call.call.sendStatus) {
        call.call.sendStatus = wrapSendStatus(call.call.sendStatus, ctx);
      }
      shimmer.wrap(call, "emit", createWrapEmit(call, ctx, onCancel));
    }
    function wrapCallback(callback = () => {
    }, call, ctx, onCancel) {
      return shimmer.wrapFunction(callback, (callback2) => function(err, value, trailer, flags) {
        if (err) {
          ctx.error = err;
          errorChannel.publish(ctx);
        } else {
          ctx.code = OK;
          ctx.trailer = trailer;
        }
        finishChannel.publish(ctx);
        call.removeListener("cancelled", onCancel);
        return asyncStartChannel.runStores(ctx, () => {
          return callback2.apply(this, arguments);
        });
      });
    }
    function wrapSendStatus(sendStatus, ctx) {
      return function(status) {
        ctx.status = status;
        updateChannel.publish(ctx);
        return sendStatus.apply(this, arguments);
      };
    }
    function isEmitter(obj) {
      return typeof obj.emit === "function" && typeof obj.once === "function";
    }
    addHook({ name: "@grpc/grpc-js", versions: [">=1.0.3"], file: "build/src/server.js" }, (server2) => {
      shimmer.wrap(server2.Server.prototype, "register", wrapRegister);
      return server2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/grpc.js
var require_grpc = __commonJS({
  "../../packages/datadog-instrumentations/src/grpc.js"() {
    "use strict";
    require_client();
    require_server();
  }
});

// ../../packages/datadog-instrumentations/src/hapi.js
var require_hapi = __commonJS({
  "../../packages/datadog-instrumentations/src/hapi.js"() {
    "use strict";
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var handleChannel = channel("apm:hapi:request:handle");
    var routeChannel = channel("apm:hapi:request:route");
    var errorChannel = channel("apm:hapi:request:error");
    var hapiTracingChannel = tracingChannel("apm:hapi:extension");
    function wrapServer(server2) {
      return function(options) {
        const app = server2.apply(this, arguments);
        if (!app) return app;
        if (typeof app.ext === "function") {
          app.ext = wrapExt(app.ext);
        }
        if (typeof app.start === "function") {
          app.start = wrapStart(app.start);
        }
        return app;
      };
    }
    function wrapStart(start) {
      return shimmer.wrapFunction(start, (start2) => function() {
        if (this && typeof this.ext === "function") {
          this.ext("onPreResponse", onPreResponse);
        }
        return start2.apply(this, arguments);
      });
    }
    function wrapExt(ext) {
      return shimmer.wrapFunction(ext, (ext2) => function(events, method, options) {
        if (events !== null && typeof events === "object") {
          arguments[0] = wrapEvents(events);
        } else {
          arguments[1] = Array.isArray(method) ? method.map(wrapHandler) : [wrapHandler(method)];
        }
        return ext2.apply(this, arguments);
      });
    }
    function wrapDispatch(dispatch) {
      return function(options) {
        const handler = dispatch.apply(this, arguments);
        if (typeof handler !== "function") return handler;
        return function(req, res) {
          handleChannel.publish({ req, res });
          return handler.apply(this, arguments);
        };
      };
    }
    function wrapRebuild(rebuild) {
      return function(event) {
        const result = rebuild.apply(this, arguments);
        if (this && Array.isArray(this._cycle)) {
          this._cycle = this._cycle.map(wrapHandler);
        }
        return result;
      };
    }
    function wrapEvents(events, flat = false) {
      const eventsArray = Array.isArray(events) ? events : [events];
      return eventsArray.map((event) => {
        if (!event?.method) return event;
        return { ...event, method: wrapHandler(event.method) };
      });
    }
    function wrapHandler(handler) {
      if (typeof handler !== "function") return handler;
      return shimmer.wrapFunction(handler, (handler2) => function(request2, h) {
        const req = request2?.raw?.req;
        if (!req) return handler2.apply(this, arguments);
        return hapiTracingChannel.traceSync(() => {
          return handler2.apply(this, arguments);
        });
      });
    }
    function onPreResponse(request2, h) {
      if (!request2 || !request2.raw) return reply(request2, h);
      const req = request2.raw.req;
      if (request2.response instanceof Error) {
        errorChannel.publish(request2.response);
      }
      if (request2.route) {
        routeChannel.publish({ req, route: request2.route.path });
      }
      return reply(request2, h);
    }
    function reply(request2, h) {
      if (h.continue) {
        return typeof h.continue === "function" ? h.continue() : h.continue;
      } else if (typeof h === "function") {
        return h();
      }
    }
    addHook({ name: "@hapi/hapi", versions: [">=17.9"] }, (hapi) => {
      shimmer.massWrap(hapi, ["server", "Server"], wrapServer);
      return hapi;
    });
    addHook({ name: "@hapi/hapi", versions: [">=17.9"], file: "lib/core.js" }, (Core) => {
      shimmer.wrap(Core.prototype, "_dispatch", wrapDispatch);
      return Core;
    });
    addHook({ name: "@hapi/hapi", versions: [">=17.9"], file: "lib/route.js" }, (Route) => {
      shimmer.wrap(Route.prototype, "rebuild", wrapRebuild);
      return Route;
    });
    addHook({ name: "hapi", versions: [">=17"] }, (hapi) => {
      shimmer.massWrap(hapi, ["server", "Server"], wrapServer);
      return hapi;
    });
    addHook({ name: "hapi", versions: ["16"] }, (hapi) => {
      shimmer.wrap(hapi.Server.prototype, "start", wrapStart);
      shimmer.wrap(hapi.Server.prototype, "ext", wrapExt);
      return hapi;
    });
    addHook({ name: "hapi", versions: ["16"], file: "lib/connection.js" }, (Connection) => {
      shimmer.wrap(Connection.prototype, "_dispatch", wrapDispatch);
      return Connection;
    });
    addHook({ name: "hapi", versions: [">=17"], file: "lib/core.js" }, (Core) => {
      shimmer.wrap(Core.prototype, "_dispatch", wrapDispatch);
      return Core;
    });
    addHook({ name: "hapi", versions: [">=16"], file: "lib/route.js" }, (Route) => {
      shimmer.wrap(Route.prototype, "rebuild", wrapRebuild);
      return Route;
    });
  }
});

// ../../node_modules/detect-newline/index.js
var require_detect_newline = __commonJS({
  "../../node_modules/detect-newline/index.js"(exports2, module2) {
    "use strict";
    var detectNewline = (string) => {
      if (typeof string !== "string") {
        throw new TypeError("Expected a string");
      }
      const newlines = string.match(/(?:\r?\n)/g) || [];
      if (newlines.length === 0) {
        return;
      }
      const crlf = newlines.filter((newline) => newline === "\r\n").length;
      const lf = newlines.length - crlf;
      return crlf > lf ? "\r\n" : "\n";
    };
    module2.exports = detectNewline;
    module2.exports.graceful = (string) => typeof string === "string" && detectNewline(string) || "\n";
  }
});

// ../../node_modules/jest-docblock/build/index.js
var require_build = __commonJS({
  "../../node_modules/jest-docblock/build/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.extract = extract;
    exports2.parse = parse;
    exports2.parseWithComments = parseWithComments;
    exports2.print = print;
    exports2.strip = strip;
    function _os() {
      const data = __require("os");
      _os = function() {
        return data;
      };
      return data;
    }
    function _detectNewline() {
      const data = _interopRequireDefault(require_detect_newline());
      _detectNewline = function() {
        return data;
      };
      return data;
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var commentEndRe = /\*\/$/;
    var commentStartRe = /^\/\*\*?/;
    var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
    var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
    var ltrimNewlineRe = /^(\r?\n)+/;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    var stringStartRe = /(\r?\n|^) *\* ?/g;
    var STRING_ARRAY = [];
    function extract(contents) {
      const match = contents.match(docblockRe);
      return match ? match[0].trimLeft() : "";
    }
    function strip(contents) {
      const match = contents.match(docblockRe);
      return match && match[0] ? contents.substring(match[0].length) : contents;
    }
    function parse(docblock) {
      return parseWithComments(docblock).pragmas;
    }
    function parseWithComments(docblock) {
      const line = (0, _detectNewline().default)(docblock) ?? _os().EOL;
      docblock = docblock.replace(commentStartRe, "").replace(commentEndRe, "").replace(stringStartRe, "$1");
      let prev = "";
      while (prev !== docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, `${line}$1 $2${line}`);
      }
      docblock = docblock.replace(ltrimNewlineRe, "").trimRight();
      const result = /* @__PURE__ */ Object.create(null);
      const comments = docblock.replace(propertyRe, "").replace(ltrimNewlineRe, "").trimRight();
      let match;
      while (match = propertyRe.exec(docblock)) {
        const nextPragma = match[2].replace(lineCommentRe, "");
        if (typeof result[match[1]] === "string" || Array.isArray(result[match[1]])) {
          result[match[1]] = STRING_ARRAY.concat(result[match[1]], nextPragma);
        } else {
          result[match[1]] = nextPragma;
        }
      }
      return {
        comments,
        pragmas: result
      };
    }
    function print({ comments = "", pragmas = {} }) {
      const line = (0, _detectNewline().default)(comments) ?? _os().EOL;
      const head = "/**";
      const start = " *";
      const tail = " */";
      const keys = Object.keys(pragmas);
      const printedObject = keys.flatMap((key) => printKeyValues(key, pragmas[key])).map((keyValue) => `${start} ${keyValue}${line}`).join("");
      if (!comments) {
        if (keys.length === 0) {
          return "";
        }
        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
          const value = pragmas[keys[0]];
          return `${head} ${printKeyValues(keys[0], value)[0]}${tail}`;
        }
      }
      const printedComments = comments.split(line).map((textLine) => `${start} ${textLine}`).join(line) + line;
      return head + line + (comments ? printedComments : "") + (comments && keys.length ? start + line : "") + printedObject + tail;
    }
    function printKeyValues(key, valueOrArray) {
      return STRING_ARRAY.concat(valueOrArray).map(
        (value) => `@${key} ${value}`.trim()
      );
    }
  }
});

// ../../packages/datadog-plugin-jest/src/util.js
var require_util4 = __commonJS({
  "../../packages/datadog-plugin-jest/src/util.js"(exports2, module2) {
    "use strict";
    var { readFileSync } = __require("fs");
    var { parse, extract } = require_build();
    var { getTestSuitePath } = require_test();
    var log = require_log2();
    function getFormattedJestTestParameters(testParameters) {
      if (!testParameters || !testParameters.length) {
        return;
      }
      const [parameterArray, ...parameterValues] = testParameters;
      if (parameterValues.length === 0) {
        return parameterArray;
      }
      const parameterKeys = parameterArray[0].split("|").map((key) => key.trim());
      const formattedParameters = [];
      let lastFormattedParameter = {};
      for (let index = 0; index < parameterValues.length; index++) {
        const parameterIndex = index % parameterKeys.length;
        if (parameterIndex === 0) {
          lastFormattedParameter = {};
          formattedParameters.push(lastFormattedParameter);
        }
        const key = parameterKeys[parameterIndex];
        lastFormattedParameter[key] = parameterValues[index];
      }
      return formattedParameters;
    }
    var SEED_SUFFIX_RE = /\s*\(with seed=-?\d+\)\s*$/i;
    function getJestTestName(test, shouldStripSeed = false) {
      const titles = [];
      let parent = test;
      do {
        titles.unshift(parent.name);
      } while (parent = parent.parent);
      titles.shift();
      const testName = titles.join(" ");
      if (shouldStripSeed) {
        return testName.replace(SEED_SUFFIX_RE, "");
      }
      return testName;
    }
    function isMarkedAsUnskippable(test) {
      let docblocks;
      try {
        const testSource = readFileSync(test.path, "utf8");
        docblocks = parse(extract(testSource));
      } catch {
        return false;
      }
      if (!docblocks?.datadog) {
        return false;
      }
      try {
        return JSON.parse(docblocks.datadog).unskippable;
      } catch {
        log.warn("@datadog block comment is malformed.");
        return true;
      }
    }
    function getJestSuitesToRun(skippableSuites, originalTests, rootDir) {
      const unskippableSuites = {};
      const forcedToRunSuites = {};
      const skippedSuites = [];
      const suitesToRun = [];
      for (const test of originalTests) {
        const relativePath = getTestSuitePath(test.path, rootDir);
        const shouldBeSkipped = skippableSuites.includes(relativePath);
        if (isMarkedAsUnskippable(test)) {
          suitesToRun.push(test);
          unskippableSuites[relativePath] = true;
          if (shouldBeSkipped) {
            forcedToRunSuites[relativePath] = true;
          }
          continue;
        }
        if (shouldBeSkipped) {
          skippedSuites.push(relativePath);
        } else {
          suitesToRun.push(test);
        }
      }
      const hasUnskippableSuites = Object.keys(unskippableSuites).length > 0;
      const hasForcedToRunSuites = Object.keys(forcedToRunSuites).length > 0;
      if (originalTests.length) {
        const [test] = originalTests;
        if (test?.context?.config?.testEnvironmentOptions) {
          if (hasUnskippableSuites) {
            test.context.config.testEnvironmentOptions._ddUnskippable = JSON.stringify(unskippableSuites);
          }
          if (hasForcedToRunSuites) {
            test.context.config.testEnvironmentOptions._ddForcedToRun = JSON.stringify(forcedToRunSuites);
          }
        }
      }
      return {
        skippedSuites,
        suitesToRun,
        hasUnskippableSuites,
        hasForcedToRunSuites
      };
    }
    module2.exports = { getFormattedJestTestParameters, getJestTestName, getJestSuitesToRun, isMarkedAsUnskippable };
  }
});

// ../../packages/datadog-instrumentations/src/jest.js
var require_jest = __commonJS({
  "../../packages/datadog-instrumentations/src/jest.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var path = __require("path");
    var {
      getCoveredFilenamesFromCoverage,
      JEST_WORKER_TRACE_PAYLOAD_CODE,
      JEST_WORKER_COVERAGE_PAYLOAD_CODE,
      getTestLineStart,
      getTestSuitePath,
      getTestParametersString,
      getIsFaultyEarlyFlakeDetection,
      JEST_WORKER_LOGS_PAYLOAD_CODE,
      getTestEndLine,
      isModifiedTest
    } = require_test();
    var {
      getFormattedJestTestParameters,
      getJestTestName,
      getJestSuitesToRun
    } = require_util4();
    var testSessionStartCh = channel("ci:jest:session:start");
    var testSessionFinishCh = channel("ci:jest:session:finish");
    var testSessionConfigurationCh = channel("ci:jest:session:configuration");
    var testSuiteStartCh = channel("ci:jest:test-suite:start");
    var testSuiteFinishCh = channel("ci:jest:test-suite:finish");
    var testSuiteErrorCh = channel("ci:jest:test-suite:error");
    var workerReportTraceCh = channel("ci:jest:worker-report:trace");
    var workerReportCoverageCh = channel("ci:jest:worker-report:coverage");
    var workerReportLogsCh = channel("ci:jest:worker-report:logs");
    var testSuiteCodeCoverageCh = channel("ci:jest:test-suite:code-coverage");
    var testStartCh = channel("ci:jest:test:start");
    var testSkippedCh = channel("ci:jest:test:skip");
    var testFinishCh = channel("ci:jest:test:finish");
    var testErrCh = channel("ci:jest:test:err");
    var testFnCh = channel("ci:jest:test:fn");
    var skippableSuitesCh = channel("ci:jest:test-suite:skippable");
    var libraryConfigurationCh = channel("ci:jest:library-configuration");
    var knownTestsCh = channel("ci:jest:known-tests");
    var testManagementTestsCh = channel("ci:jest:test-management-tests");
    var modifiedFilesCh = channel("ci:jest:modified-files");
    var itrSkippedSuitesCh = channel("ci:jest:itr:skipped-suites");
    var CHILD_MESSAGE_CALL = 1;
    var FLUSH_TIMEOUT = 1e4;
    var RETRY_TIMES = Symbol.for("RETRY_TIMES");
    var skippableSuites = [];
    var knownTests = {};
    var isCodeCoverageEnabled = false;
    var isSuitesSkippingEnabled = false;
    var isUserCodeCoverageEnabled = false;
    var isSuitesSkipped = false;
    var numSkippedSuites = 0;
    var hasUnskippableSuites = false;
    var hasForcedToRunSuites = false;
    var isEarlyFlakeDetectionEnabled = false;
    var earlyFlakeDetectionNumRetries = 0;
    var earlyFlakeDetectionFaultyThreshold = 30;
    var isEarlyFlakeDetectionFaulty = false;
    var hasFilteredSkippableSuites = false;
    var isKnownTestsEnabled = false;
    var isTestManagementTestsEnabled = false;
    var testManagementTests = {};
    var testManagementAttemptToFixRetries = 0;
    var isImpactedTestsEnabled = false;
    var modifiedFiles = {};
    var testContexts = /* @__PURE__ */ new WeakMap();
    var originalTestFns = /* @__PURE__ */ new WeakMap();
    var originalHookFns = /* @__PURE__ */ new WeakMap();
    var retriedTestsToNumAttempts = /* @__PURE__ */ new Map();
    var newTestsTestStatuses = /* @__PURE__ */ new Map();
    var attemptToFixRetriedTestsStatuses = /* @__PURE__ */ new Map();
    var wrappedWorkers = /* @__PURE__ */ new WeakSet();
    var testSuiteMockedFiles = /* @__PURE__ */ new Map();
    var testsToBeRetried = /* @__PURE__ */ new Set();
    var testSuiteAbsolutePathsWithFastCheck = /* @__PURE__ */ new Set();
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200;
    function formatJestError(errors) {
      let error;
      if (Array.isArray(errors)) {
        const [originalError, asyncError] = errors;
        if (originalError === null || !originalError.stack) {
          error = asyncError;
          error.message = originalError;
        } else {
          error = originalError;
        }
      } else {
        error = errors;
      }
      return error;
    }
    function getTestEnvironmentOptions(config) {
      if (config.projectConfig && config.projectConfig.testEnvironmentOptions) {
        return config.projectConfig.testEnvironmentOptions;
      }
      if (config.testEnvironmentOptions) {
        return config.testEnvironmentOptions;
      }
      return {};
    }
    function getTestStats(testStatuses) {
      return testStatuses.reduce((acc, testStatus) => {
        acc[testStatus]++;
        return acc;
      }, { pass: 0, fail: 0 });
    }
    function getWrappedEnvironment(BaseEnvironment, jestVersion) {
      return class DatadogEnvironment extends BaseEnvironment {
        constructor(config, context2) {
          super(config, context2);
          const rootDir = config.globalConfig ? config.globalConfig.rootDir : config.rootDir;
          this.rootDir = rootDir;
          this.testSuite = getTestSuitePath(context2.testPath, rootDir);
          this.nameToParams = {};
          this.global._ddtrace = global._ddtrace;
          this.hasSnapshotTests = void 0;
          this.testSuiteAbsolutePath = context2.testPath;
          this.displayName = config.projectConfig?.displayName?.name;
          this.testEnvironmentOptions = getTestEnvironmentOptions(config);
          const repositoryRoot = this.testEnvironmentOptions._ddRepositoryRoot;
          if (repositoryRoot) {
            this.testSourceFile = getTestSuitePath(context2.testPath, repositoryRoot);
            this.repositoryRoot = repositoryRoot;
          }
          this.isEarlyFlakeDetectionEnabled = this.testEnvironmentOptions._ddIsEarlyFlakeDetectionEnabled;
          this.isFlakyTestRetriesEnabled = this.testEnvironmentOptions._ddIsFlakyTestRetriesEnabled;
          this.flakyTestRetriesCount = this.testEnvironmentOptions._ddFlakyTestRetriesCount;
          this.isDiEnabled = this.testEnvironmentOptions._ddIsDiEnabled;
          this.isKnownTestsEnabled = this.testEnvironmentOptions._ddIsKnownTestsEnabled;
          this.isTestManagementTestsEnabled = this.testEnvironmentOptions._ddIsTestManagementTestsEnabled;
          this.isImpactedTestsEnabled = this.testEnvironmentOptions._ddIsImpactedTestsEnabled;
          if (this.isKnownTestsEnabled) {
            earlyFlakeDetectionNumRetries = this.testEnvironmentOptions._ddEarlyFlakeDetectionNumRetries;
            try {
              this.knownTestsForThisSuite = this.getKnownTestsForSuite(this.testEnvironmentOptions._ddKnownTests);
              if (!Array.isArray(this.knownTestsForThisSuite)) {
                log.warn("this.knownTestsForThisSuite is not an array so new test and Early Flake detection is disabled.");
                this.isEarlyFlakeDetectionEnabled = false;
                this.isKnownTestsEnabled = false;
              }
            } catch {
              this.isEarlyFlakeDetectionEnabled = false;
              this.isKnownTestsEnabled = false;
            }
          }
          if (this.isFlakyTestRetriesEnabled) {
            const currentNumRetries = this.global[RETRY_TIMES];
            if (!currentNumRetries) {
              this.global[RETRY_TIMES] = this.flakyTestRetriesCount;
            }
          }
          if (this.isTestManagementTestsEnabled) {
            try {
              const hasTestManagementTests = !!testManagementTests?.jest;
              testManagementAttemptToFixRetries = this.testEnvironmentOptions._ddTestManagementAttemptToFixRetries;
              this.testManagementTestsForThisSuite = hasTestManagementTests ? this.getTestManagementTestsForSuite(testManagementTests?.jest?.suites?.[this.testSuite]?.tests) : this.getTestManagementTestsForSuite(this.testEnvironmentOptions._ddTestManagementTests);
            } catch (e) {
              log.error("Error parsing test management tests", e);
              this.isTestManagementTestsEnabled = false;
            }
          }
          if (this.isImpactedTestsEnabled) {
            try {
              const hasImpactedTests = Object.keys(modifiedFiles).length > 0;
              this.modifiedFiles = hasImpactedTests ? modifiedFiles : this.testEnvironmentOptions._ddModifiedFiles;
            } catch (e) {
              log.error("Error parsing impacted tests", e);
              this.isImpactedTestsEnabled = false;
            }
          }
        }
        /**
         * Jest snapshot counter issue during test retries
         *
         * Problem:
         * - Jest tracks snapshot calls using an internal counter per test name
         * - Each `toMatchSnapshot()` call increments this counter
         * - When a test is retried, it keeps the same name but the counter continues from where it left off
         *
         * Example Issue:
         * Original test run creates: `exports["test can do multiple snapshots 1"] = "hello"`
         * Retried test expects:      `exports["test can do multiple snapshots 2"] = "hello"`
         *
         * This mismatch causes snapshot tests to fail on retry because Jest is looking
         * for the wrong snapshot number. The solution is to reset the snapshot state.
         */
        resetSnapshotState() {
          try {
            const expectGlobal = this.getVmContext().expect;
            const { snapshotState: { _counters: counters } } = expectGlobal.getState();
            if (counters) {
              counters.clear();
            }
          } catch (e) {
            log.warn("Error resetting snapshot state", e);
          }
        }
        // This function returns an array if the known tests are valid and null otherwise.
        getKnownTestsForSuite(suiteKnownTests) {
          if (suiteKnownTests) {
            return suiteKnownTests;
          }
          if (knownTests?.jest) {
            return knownTests.jest[this.testSuite] || [];
          }
          return null;
        }
        getTestManagementTestsForSuite(testManagementTests2) {
          if (this.testManagementTestsForThisSuite) {
            return this.testManagementTestsForThisSuite;
          }
          if (!testManagementTests2) {
            return {
              attemptToFix: [],
              disabled: [],
              quarantined: []
            };
          }
          let testManagementTestsForSuite = testManagementTests2;
          if (typeof testManagementTestsForSuite === "string") {
            testManagementTestsForSuite = JSON.parse(testManagementTestsForSuite);
          }
          const result = {
            attemptToFix: [],
            disabled: [],
            quarantined: []
          };
          Object.entries(testManagementTestsForSuite).forEach(([testName, { properties }]) => {
            if (properties?.attempt_to_fix) {
              result.attemptToFix.push(testName);
            }
            if (properties?.disabled) {
              result.disabled.push(testName);
            }
            if (properties?.quarantined) {
              result.quarantined.push(testName);
            }
          });
          return result;
        }
        // Generic function to handle test retries
        retryTest({
          jestEvent,
          retryCount,
          retryType
        }) {
          const { testName, fn, timeout } = jestEvent;
          for (let retryIndex = 0; retryIndex < retryCount; retryIndex++) {
            if (this.global.test) {
              this.global.test(testName, fn, timeout);
            } else {
              log.error("%s could not retry test because global.test is undefined", retryType);
            }
          }
        }
        getShouldStripSeedFromTestName() {
          return testSuiteAbsolutePathsWithFastCheck.has(this.testSuiteAbsolutePath);
        }
        // At the `add_test` event we don't have the test object yet, so we can't use it
        getTestNameFromAddTestEvent(event, state) {
          const describeSuffix = getJestTestName(state.currentDescribeBlock, this.getShouldStripSeedFromTestName());
          return describeSuffix ? `${describeSuffix} ${event.testName}` : event.testName;
        }
        async handleTestEvent(event, state) {
          if (super.handleTestEvent) {
            await super.handleTestEvent(event, state);
          }
          const setNameToParams = (name, params) => {
            this.nameToParams[name] = [...params];
          };
          if (event.name === "setup" && this.global.test) {
            shimmer.wrap(this.global.test, "each", (each) => function() {
              const testParameters = getFormattedJestTestParameters(arguments);
              const eachBind = each.apply(this, arguments);
              return function() {
                const [testName] = arguments;
                setNameToParams(testName, testParameters);
                return eachBind.apply(this, arguments);
              };
            });
          }
          if (event.name === "test_start") {
            const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName());
            if (testsToBeRetried.has(testName)) {
              this.resetSnapshotState();
            }
            let isNewTest = false;
            let numEfdRetry = null;
            let numOfAttemptsToFixRetries = null;
            const testParameters = getTestParametersString(this.nameToParams, event.test.name);
            let isAttemptToFix = false;
            let isDisabled = false;
            let isQuarantined = false;
            if (this.isTestManagementTestsEnabled) {
              isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testName);
              isDisabled = this.testManagementTestsForThisSuite?.disabled?.includes(testName);
              isQuarantined = this.testManagementTestsForThisSuite?.quarantined?.includes(testName);
              if (isAttemptToFix) {
                numOfAttemptsToFixRetries = retriedTestsToNumAttempts.get(testName);
                retriedTestsToNumAttempts.set(testName, numOfAttemptsToFixRetries + 1);
              } else if (isDisabled) {
                event.test.mode = "skip";
              }
            }
            let isModified = false;
            if (this.isImpactedTestsEnabled) {
              const testStartLine = getTestLineStart(event.test.asyncError, this.testSuite);
              const testEndLine = getTestEndLine(event.test.fn, testStartLine);
              isModified = isModifiedTest(
                this.testSourceFile,
                testStartLine,
                testEndLine,
                this.modifiedFiles,
                "jest"
              );
            }
            if (this.isKnownTestsEnabled) {
              isNewTest = retriedTestsToNumAttempts.has(testName);
            }
            if (this.isEarlyFlakeDetectionEnabled && (isNewTest || isModified)) {
              numEfdRetry = retriedTestsToNumAttempts.get(testName);
              retriedTestsToNumAttempts.set(testName, numEfdRetry + 1);
            }
            const isJestRetry = event.test?.invocations > 1;
            const ctx = {
              name: testName,
              suite: this.testSuite,
              testSourceFile: this.testSourceFile,
              displayName: this.displayName,
              testParameters,
              frameworkVersion: jestVersion,
              isNew: isNewTest,
              isEfdRetry: numEfdRetry > 0,
              isAttemptToFix,
              isAttemptToFixRetry: numOfAttemptsToFixRetries > 0,
              isJestRetry,
              isDisabled,
              isQuarantined,
              isModified,
              testSuiteAbsolutePath: this.testSuiteAbsolutePath
            };
            testContexts.set(event.test, ctx);
            testStartCh.runStores(ctx, () => {
              for (const hook of event.test.parent.hooks) {
                let hookFn = hook.fn;
                if (originalHookFns.has(hook)) {
                  hookFn = originalHookFns.get(hook);
                } else {
                  originalHookFns.set(hook, hookFn);
                }
                const wrapperHook = function() {
                  return testFnCh.runStores(ctx, () => hookFn.apply(this, arguments));
                };
                Object.defineProperty(wrapperHook, "length", { value: hookFn.length });
                hook.fn = wrapperHook;
              }
              const originalFn = event.test.fn;
              originalTestFns.set(event.test, originalFn);
              const wrapper = function() {
                return testFnCh.runStores(ctx, () => originalFn.apply(this, arguments));
              };
              Object.defineProperty(wrapper, "length", { value: originalFn.length });
              event.test.fn = wrapper;
            });
          }
          if (event.name === "add_test") {
            if (event.failing) {
              return;
            }
            const testFullName = this.getTestNameFromAddTestEvent(event, state);
            const isSkipped = event.mode === "todo" || event.mode === "skip";
            if (this.isTestManagementTestsEnabled) {
              const isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testFullName);
              if (isAttemptToFix && !isSkipped && !retriedTestsToNumAttempts.has(testFullName)) {
                retriedTestsToNumAttempts.set(testFullName, 0);
                testsToBeRetried.add(testFullName);
                this.retryTest({
                  jestEvent: event,
                  retryCount: testManagementAttemptToFixRetries,
                  retryType: "Test Management (Attempt to Fix)"
                });
              }
            }
            if (this.isImpactedTestsEnabled) {
              const testStartLine = getTestLineStart(event.asyncError, this.testSuite);
              const testEndLine = getTestEndLine(event.fn, testStartLine);
              const isModified = isModifiedTest(
                this.testSourceFile,
                testStartLine,
                testEndLine,
                this.modifiedFiles,
                "jest"
              );
              if (isModified && !retriedTestsToNumAttempts.has(testFullName) && this.isEarlyFlakeDetectionEnabled) {
                retriedTestsToNumAttempts.set(testFullName, 0);
                testsToBeRetried.add(testFullName);
                this.retryTest({
                  jestEvent: event,
                  retryCount: earlyFlakeDetectionNumRetries,
                  retryType: "Impacted tests"
                });
              }
            }
            if (this.isKnownTestsEnabled) {
              const isNew = !this.knownTestsForThisSuite.includes(testFullName);
              if (isNew && !isSkipped && !retriedTestsToNumAttempts.has(testFullName)) {
                retriedTestsToNumAttempts.set(testFullName, 0);
                if (this.isEarlyFlakeDetectionEnabled) {
                  testsToBeRetried.add(testFullName);
                  this.retryTest({
                    jestEvent: event,
                    retryCount: earlyFlakeDetectionNumRetries,
                    retryType: "Early flake detection"
                  });
                }
              }
            }
          }
          if (event.name === "test_done") {
            let status = "pass";
            if (event.test.errors && event.test.errors.length) {
              status = "fail";
            }
            event.test.fn = originalTestFns.get(event.test);
            let attemptToFixPassed = false;
            let attemptToFixFailed = false;
            let failedAllTests = false;
            let isAttemptToFix = false;
            if (this.isTestManagementTestsEnabled) {
              const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName());
              isAttemptToFix = this.testManagementTestsForThisSuite?.attemptToFix?.includes(testName);
              if (isAttemptToFix) {
                if (attemptToFixRetriedTestsStatuses.has(testName)) {
                  attemptToFixRetriedTestsStatuses.get(testName).push(status);
                } else {
                  attemptToFixRetriedTestsStatuses.set(testName, [status]);
                }
                const testStatuses = attemptToFixRetriedTestsStatuses.get(testName);
                if (testStatuses.length === testManagementAttemptToFixRetries + 1) {
                  if (testStatuses.includes("fail")) {
                    attemptToFixFailed = true;
                  }
                  if (testStatuses.every((status2) => status2 === "fail")) {
                    failedAllTests = true;
                  } else if (testStatuses.every((status2) => status2 === "pass")) {
                    attemptToFixPassed = true;
                  }
                }
              }
            }
            let isEfdRetry = false;
            if (this.isKnownTestsEnabled) {
              const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName());
              const isNewTest = retriedTestsToNumAttempts.has(testName);
              if (isNewTest) {
                if (newTestsTestStatuses.has(testName)) {
                  newTestsTestStatuses.get(testName).push(status);
                  isEfdRetry = true;
                } else {
                  newTestsTestStatuses.set(testName, [status]);
                }
              }
            }
            const promises = {};
            const numRetries = this.global[RETRY_TIMES];
            const numTestExecutions = event.test?.invocations;
            const willBeRetried = numRetries > 0 && numTestExecutions - 1 < numRetries;
            const mightHitBreakpoint = this.isDiEnabled && numTestExecutions >= 2;
            const ctx = testContexts.get(event.test);
            if (status === "fail") {
              const shouldSetProbe = this.isDiEnabled && willBeRetried && numTestExecutions === 1;
              testErrCh.publish({
                ...ctx.currentStore,
                error: formatJestError(event.test.errors[0]),
                shouldSetProbe,
                promises
              });
            }
            if (status === "fail" && mightHitBreakpoint) {
              await new Promise((resolve) => {
                setTimeout(() => {
                  resolve();
                }, BREAKPOINT_HIT_GRACE_PERIOD_MS);
              });
            }
            let isAtrRetry = false;
            if (this.isFlakyTestRetriesEnabled && event.test?.invocations > 1 && !isAttemptToFix && !isEfdRetry) {
              isAtrRetry = true;
            }
            testFinishCh.publish({
              ...ctx.currentStore,
              status,
              testStartLine: getTestLineStart(event.test.asyncError, this.testSuite),
              attemptToFixPassed,
              failedAllTests,
              attemptToFixFailed,
              isAtrRetry
            });
            if (promises.isProbeReady) {
              await promises.isProbeReady;
            }
          }
          if (event.name === "test_skip" || event.name === "test_todo") {
            const testName = getJestTestName(event.test, this.getShouldStripSeedFromTestName());
            testSkippedCh.publish({
              test: {
                name: testName,
                suite: this.testSuite,
                testSourceFile: this.testSourceFile,
                displayName: this.displayName,
                frameworkVersion: jestVersion,
                testStartLine: getTestLineStart(event.test.asyncError, this.testSuite)
              },
              isDisabled: this.testManagementTestsForThisSuite?.disabled?.includes(testName)
            });
          }
        }
        teardown() {
          if (this._globalProxy?.propertyToValue) {
            for (const [key] of this._globalProxy.propertyToValue) {
              if (typeof key === "string" && key.startsWith("_dd")) {
                this._globalProxy.propertyToValue.delete(key);
              }
            }
          }
          return super.teardown();
        }
      };
    }
    function getTestEnvironment(pkg, jestVersion) {
      if (pkg.default) {
        const wrappedTestEnvironment = getWrappedEnvironment(pkg.default, jestVersion);
        return new Proxy(pkg, {
          get(target, prop) {
            if (prop === "default") {
              return wrappedTestEnvironment;
            }
            if (prop === "TestEnvironment") {
              return wrappedTestEnvironment;
            }
            return target[prop];
          }
        });
      }
      return getWrappedEnvironment(pkg, jestVersion);
    }
    function applySuiteSkipping(originalTests, rootDir, frameworkVersion) {
      const jestSuitesToRun = getJestSuitesToRun(skippableSuites, originalTests, rootDir || process.cwd());
      hasFilteredSkippableSuites = true;
      log.debug(
        () => `${jestSuitesToRun.suitesToRun.length} out of ${originalTests.length} suites are going to run.`
      );
      hasUnskippableSuites = jestSuitesToRun.hasUnskippableSuites;
      hasForcedToRunSuites = jestSuitesToRun.hasForcedToRunSuites;
      isSuitesSkipped = jestSuitesToRun.suitesToRun.length !== originalTests.length;
      numSkippedSuites = jestSuitesToRun.skippedSuites.length;
      itrSkippedSuitesCh.publish({ skippedSuites: jestSuitesToRun.skippedSuites, frameworkVersion });
      return jestSuitesToRun.suitesToRun;
    }
    addHook({
      name: "jest-environment-node",
      versions: [">=24.8.0"]
    }, getTestEnvironment);
    addHook({
      name: "jest-environment-jsdom",
      versions: [">=24.8.0"]
    }, getTestEnvironment);
    addHook({
      name: "@happy-dom/jest-environment",
      versions: [">=10.0.0"]
    }, getTestEnvironment);
    function getWrappedScheduleTests(scheduleTests, frameworkVersion) {
      return function(tests) {
        if (!isSuitesSkippingEnabled || hasFilteredSkippableSuites) {
          return scheduleTests.apply(this, arguments);
        }
        const [test] = tests;
        const rootDir = test?.context?.config?.rootDir;
        arguments[0] = applySuiteSkipping(tests, rootDir, frameworkVersion);
        return scheduleTests.apply(this, arguments);
      };
    }
    function searchSourceWrapper(searchSourcePackage, frameworkVersion) {
      const SearchSource = searchSourcePackage.default ?? searchSourcePackage;
      shimmer.wrap(SearchSource.prototype, "getTestPaths", (getTestPaths) => async function() {
        const testPaths = await getTestPaths.apply(this, arguments);
        const [{ rootDir, shard }] = arguments;
        if (isKnownTestsEnabled) {
          const projectSuites = testPaths.tests.map((test) => getTestSuitePath(test.path, test.context.config.rootDir));
          const isFaulty = !knownTests?.jest || getIsFaultyEarlyFlakeDetection(projectSuites, knownTests.jest, earlyFlakeDetectionFaultyThreshold);
          if (isFaulty) {
            log.error("Early flake detection is disabled because the number of new suites is too high.");
            isEarlyFlakeDetectionEnabled = false;
            isKnownTestsEnabled = false;
            const testEnvironmentOptions = testPaths.tests[0]?.context?.config?.testEnvironmentOptions;
            if (testEnvironmentOptions) {
              testEnvironmentOptions._ddIsEarlyFlakeDetectionEnabled = false;
              testEnvironmentOptions._ddIsKnownTestsEnabled = false;
            }
            isEarlyFlakeDetectionFaulty = true;
          }
        }
        if (shard?.shardCount > 1 || !isSuitesSkippingEnabled || !skippableSuites.length) {
          return testPaths;
        }
        const { tests } = testPaths;
        const suitesToRun = applySuiteSkipping(tests, rootDir, frameworkVersion);
        return { ...testPaths, tests: suitesToRun };
      });
      return searchSourcePackage;
    }
    function getCliWrapper(isNewJestVersion) {
      return function cliWrapper(cli, jestVersion) {
        if (isNewJestVersion) {
          cli = shimmer.wrap(
            cli,
            "SearchSource",
            (searchSource) => searchSourceWrapper(searchSource, jestVersion),
            { replaceGetter: true }
          );
        }
        return shimmer.wrap(cli, "runCLI", (runCLI) => async function() {
          let onDone;
          const configurationPromise = new Promise((resolve) => {
            onDone = resolve;
          });
          if (!libraryConfigurationCh.hasSubscribers) {
            return runCLI.apply(this, arguments);
          }
          libraryConfigurationCh.publish({ onDone, frameworkVersion: jestVersion });
          try {
            const { err, libraryConfig } = await configurationPromise;
            if (!err) {
              isCodeCoverageEnabled = libraryConfig.isCodeCoverageEnabled;
              isSuitesSkippingEnabled = libraryConfig.isSuitesSkippingEnabled;
              isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled;
              earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries;
              earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold;
              isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled;
              isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled;
              testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries;
              isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled;
            }
          } catch (err) {
            log.error("Jest library configuration error", err);
          }
          if (isKnownTestsEnabled) {
            const knownTestsPromise = new Promise((resolve) => {
              onDone = resolve;
            });
            knownTestsCh.publish({ onDone });
            try {
              const { err, knownTests: receivedKnownTests } = await knownTestsPromise;
              if (err) {
                isEarlyFlakeDetectionEnabled = false;
                isKnownTestsEnabled = false;
              } else {
                knownTests = receivedKnownTests;
              }
            } catch (err) {
              log.error("Jest known tests error", err);
            }
          }
          if (isSuitesSkippingEnabled) {
            const skippableSuitesPromise = new Promise((resolve) => {
              onDone = resolve;
            });
            skippableSuitesCh.publish({ onDone });
            try {
              const { err, skippableSuites: receivedSkippableSuites } = await skippableSuitesPromise;
              if (!err) {
                skippableSuites = receivedSkippableSuites;
              }
            } catch (err) {
              log.error("Jest test-suite skippable error", err);
            }
          }
          if (isTestManagementTestsEnabled) {
            const testManagementTestsPromise = new Promise((resolve) => {
              onDone = resolve;
            });
            testManagementTestsCh.publish({ onDone });
            try {
              const { err, testManagementTests: receivedTestManagementTests } = await testManagementTestsPromise;
              if (err) {
                isTestManagementTestsEnabled = false;
                testManagementTests = {};
              } else {
                testManagementTests = receivedTestManagementTests;
              }
            } catch (err) {
              log.error("Jest test management tests error", err);
              isTestManagementTestsEnabled = false;
            }
          }
          if (isImpactedTestsEnabled) {
            const impactedTestsPromise = new Promise((resolve) => {
              onDone = resolve;
            });
            modifiedFilesCh.publish({ onDone });
            try {
              const { err, modifiedFiles: receivedModifiedFiles } = await impactedTestsPromise;
              if (!err) {
                modifiedFiles = receivedModifiedFiles;
              }
            } catch (err) {
              log.error("Jest impacted tests error", err);
            }
          }
          const processArgv = process.argv.slice(2).join(" ");
          testSessionStartCh.publish({ command: `jest ${processArgv}`, frameworkVersion: jestVersion });
          const result = await runCLI.apply(this, arguments);
          const {
            results: {
              success,
              coverageMap,
              numFailedTestSuites,
              numFailedTests,
              numTotalTests,
              numTotalTestSuites
            }
          } = result;
          let testCodeCoverageLinesTotal;
          if (isUserCodeCoverageEnabled) {
            try {
              const { pct, total } = coverageMap.getCoverageSummary().lines;
              testCodeCoverageLinesTotal = total === 0 ? 0 : pct;
            } catch {
            }
          }
          let status, error;
          if (success) {
            status = numTotalTests === 0 && numTotalTestSuites === 0 ? "skip" : "pass";
          } else {
            status = "fail";
            error = new Error(`Failed test suites: ${numFailedTestSuites}. Failed tests: ${numFailedTests}`);
          }
          let timeoutId;
          const flushPromise = new Promise((resolve) => {
            onDone = () => {
              clearTimeout(timeoutId);
              resolve();
            };
          });
          const timeoutPromise = new Promise((resolve) => {
            timeoutId = setTimeout(() => {
              resolve("timeout");
            }, FLUSH_TIMEOUT).unref();
          });
          testSessionFinishCh.publish({
            status,
            isSuitesSkipped,
            isSuitesSkippingEnabled,
            isCodeCoverageEnabled,
            testCodeCoverageLinesTotal,
            numSkippedSuites,
            hasUnskippableSuites,
            hasForcedToRunSuites,
            error,
            isEarlyFlakeDetectionEnabled,
            isEarlyFlakeDetectionFaulty,
            isTestManagementTestsEnabled,
            onDone
          });
          const waitingResult = await Promise.race([flushPromise, timeoutPromise]);
          if (waitingResult === "timeout") {
            log.error("Timeout waiting for the tracer to flush");
          }
          numSkippedSuites = 0;
          if (isEarlyFlakeDetectionEnabled) {
            let numFailedTestsToIgnore = 0;
            for (const testStatuses of newTestsTestStatuses.values()) {
              const { pass, fail } = getTestStats(testStatuses);
              if (pass > 0) {
                numFailedTestsToIgnore += fail;
              }
            }
            if (numFailedTestsToIgnore !== 0 && result.results.numFailedTests === numFailedTestsToIgnore) {
              result.results.success = true;
            }
          }
          if (isTestManagementTestsEnabled) {
            const failedTests = result.results.testResults.flatMap(({ testResults, testFilePath: testSuiteAbsolutePath }) => testResults.map(({ fullName: testName, status: status2 }) => ({ testName, testSuiteAbsolutePath, status: status2 }))).filter(({ status: status2 }) => status2 === "failed");
            let numFailedQuarantinedTests = 0;
            let numFailedQuarantinedOrDisabledAttemptedToFixTests = 0;
            for (const { testName, testSuiteAbsolutePath } of failedTests) {
              const testSuite = getTestSuitePath(testSuiteAbsolutePath, result.globalConfig.rootDir);
              const testManagementTest = testManagementTests?.jest?.suites?.[testSuite]?.tests?.[testName]?.properties;
              if (testManagementTest?.attempt_to_fix && (testManagementTest?.quarantined || testManagementTest?.disabled)) {
                numFailedQuarantinedOrDisabledAttemptedToFixTests++;
              } else if (testManagementTest?.quarantined) {
                numFailedQuarantinedTests++;
              }
            }
            if ((numFailedQuarantinedOrDisabledAttemptedToFixTests !== 0 || numFailedQuarantinedTests !== 0) && result.results.numFailedTests === numFailedQuarantinedTests + numFailedQuarantinedOrDisabledAttemptedToFixTests) {
              result.results.success = true;
            }
          }
          return result;
        }, {
          replaceGetter: true
        });
      };
    }
    function coverageReporterWrapper(coverageReporter) {
      const CoverageReporter = coverageReporter.default ?? coverageReporter;
      shimmer.wrap(CoverageReporter.prototype, "_addUntestedFiles", (addUntestedFiles) => function() {
        if (isSuitesSkippingEnabled && !isUserCodeCoverageEnabled) {
          return Promise.resolve();
        }
        return addUntestedFiles.apply(this, arguments);
      });
      return coverageReporter;
    }
    addHook({
      name: "@jest/core",
      file: "build/TestScheduler.js",
      versions: [">=27.0.0"]
    }, (testSchedulerPackage, frameworkVersion) => {
      const oldCreateTestScheduler = testSchedulerPackage.createTestScheduler;
      const newCreateTestScheduler = async function() {
        if (!isSuitesSkippingEnabled || hasFilteredSkippableSuites) {
          return oldCreateTestScheduler.apply(this, arguments);
        }
        const scheduler = await oldCreateTestScheduler.apply(this, arguments);
        shimmer.wrap(scheduler, "scheduleTests", (scheduleTests) => getWrappedScheduleTests(scheduleTests, frameworkVersion));
        return scheduler;
      };
      testSchedulerPackage.createTestScheduler = newCreateTestScheduler;
      return testSchedulerPackage;
    });
    addHook({
      name: "@jest/core",
      file: "build/TestScheduler.js",
      versions: [">=24.8.0 <27.0.0"]
    }, (testSchedulerPackage, frameworkVersion) => {
      shimmer.wrap(
        testSchedulerPackage.default.prototype,
        "scheduleTests",
        (scheduleTests) => getWrappedScheduleTests(scheduleTests, frameworkVersion)
      );
      return testSchedulerPackage;
    });
    addHook({
      name: "@jest/test-sequencer",
      versions: [">=28"]
    }, (sequencerPackage, frameworkVersion) => {
      shimmer.wrap(sequencerPackage.default.prototype, "shard", (shard) => function() {
        const shardedTests = shard.apply(this, arguments);
        if (!shardedTests.length || !isSuitesSkippingEnabled || !skippableSuites.length) {
          return shardedTests;
        }
        const [test] = shardedTests;
        const rootDir = test?.context?.config?.rootDir;
        return applySuiteSkipping(shardedTests, rootDir, frameworkVersion);
      });
      return sequencerPackage;
    });
    addHook({
      name: "@jest/reporters",
      file: "build/coverage_reporter.js",
      versions: [">=24.8.0 <26.6.2"]
    }, coverageReporterWrapper);
    addHook({
      name: "@jest/reporters",
      file: "build/CoverageReporter.js",
      versions: [">=26.6.2"]
    }, coverageReporterWrapper);
    addHook({
      name: "@jest/reporters",
      versions: [">=30.0.0"]
    }, (reporters) => {
      return shimmer.wrap(reporters, "CoverageReporter", coverageReporterWrapper, { replaceGetter: true });
    });
    addHook({
      name: "@jest/core",
      file: "build/cli/index.js",
      versions: [">=24.8.0 <30.0.0"]
    }, getCliWrapper(false));
    addHook({
      name: "@jest/core",
      versions: [">=30.0.0"]
    }, getCliWrapper(true));
    function jestAdapterWrapper(jestAdapter, jestVersion) {
      const adapter = jestAdapter.default ?? jestAdapter;
      const newAdapter = shimmer.wrapFunction(adapter, (adapter2) => function() {
        const environment = arguments[2];
        if (!environment || !environment.testEnvironmentOptions) {
          return adapter2.apply(this, arguments);
        }
        testSuiteStartCh.publish({
          testSuite: environment.testSuite,
          testEnvironmentOptions: environment.testEnvironmentOptions,
          testSourceFile: environment.testSourceFile,
          displayName: environment.displayName,
          frameworkVersion: jestVersion,
          testSuiteAbsolutePath: environment.testSuiteAbsolutePath
        });
        return adapter2.apply(this, arguments).then((suiteResults) => {
          const { numFailingTests, skipped, failureMessage: errorMessage } = suiteResults;
          let status = "pass";
          if (skipped) {
            status = "skipped";
          } else if (numFailingTests !== 0) {
            status = "fail";
          }
          if (environment.testEnvironmentOptions?._ddTestCodeCoverageEnabled) {
            const root = environment.repositoryRoot || environment.rootDir;
            const getFilesWithPath = (files) => files.map((file) => getTestSuitePath(file, root));
            const coverageFiles = getFilesWithPath(getCoveredFilenamesFromCoverage(environment.global.__coverage__));
            const mockedFiles = getFilesWithPath(testSuiteMockedFiles.get(environment.testSuiteAbsolutePath) || []);
            testSuiteCodeCoverageCh.publish({
              coverageFiles,
              testSuite: environment.testSourceFile,
              mockedFiles,
              testSuiteAbsolutePath: environment.testSuiteAbsolutePath
            });
          }
          testSuiteFinishCh.publish({ status, errorMessage, testSuiteAbsolutePath: environment.testSuiteAbsolutePath });
          return suiteResults;
        }).catch((error) => {
          testSuiteFinishCh.publish({ status: "fail", error, testSuiteAbsolutePath: environment.testSuiteAbsolutePath });
          throw error;
        });
      });
      if (jestAdapter.default) {
        jestAdapter.default = newAdapter;
      } else {
        jestAdapter = newAdapter;
      }
      return jestAdapter;
    }
    addHook({
      name: "jest-circus",
      file: "build/runner.js",
      versions: [">=30.0.0"]
    }, jestAdapterWrapper);
    addHook({
      name: "jest-circus",
      file: "build/legacy-code-todo-rewrite/jestAdapter.js",
      versions: [">=24.8.0"]
    }, jestAdapterWrapper);
    function configureTestEnvironment(readConfigsResult) {
      const { configs } = readConfigsResult;
      testSessionConfigurationCh.publish(configs.map((config) => config.testEnvironmentOptions));
      configs.forEach((config) => {
        config.testEnvironmentOptions._ddTestCodeCoverageEnabled = isCodeCoverageEnabled;
      });
      isUserCodeCoverageEnabled = !!readConfigsResult.globalConfig.collectCoverage;
      if (readConfigsResult.globalConfig.forceExit) {
        log.warn("Jest's '--forceExit' flag has been passed. This may cause loss of data.");
      }
      if (isCodeCoverageEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          collectCoverage: true
        };
        readConfigsResult.globalConfig = globalConfig;
      }
      if (isSuitesSkippingEnabled) {
        const globalConfig = {
          ...readConfigsResult.globalConfig,
          coverageReporters: ["none"],
          passWithNoTests: true
        };
        readConfigsResult.globalConfig = globalConfig;
      }
      return readConfigsResult;
    }
    function jestConfigAsyncWrapper(jestConfig) {
      return shimmer.wrap(jestConfig, "readConfigs", (readConfigs) => async function() {
        const readConfigsResult = await readConfigs.apply(this, arguments);
        configureTestEnvironment(readConfigsResult);
        return readConfigsResult;
      });
    }
    function jestConfigSyncWrapper(jestConfig) {
      return shimmer.wrap(jestConfig, "readConfigs", (readConfigs) => function() {
        const readConfigsResult = readConfigs.apply(this, arguments);
        configureTestEnvironment(readConfigsResult);
        return readConfigsResult;
      });
    }
    addHook({
      name: "@jest/transform",
      versions: [">=24.8.0"],
      file: "build/ScriptTransformer.js"
    }, (transformPackage) => {
      const originalCreateScriptTransformer = transformPackage.createScriptTransformer;
      transformPackage.createScriptTransformer = function(config) {
        const { testEnvironmentOptions, ...restOfConfig } = config;
        const {
          _ddTestModuleId,
          _ddTestSessionId,
          _ddTestCommand,
          _ddTestSessionName,
          _ddForcedToRun,
          _ddUnskippable,
          _ddItrCorrelationId,
          _ddKnownTests,
          _ddIsEarlyFlakeDetectionEnabled,
          _ddEarlyFlakeDetectionNumRetries,
          _ddRepositoryRoot,
          _ddIsFlakyTestRetriesEnabled,
          _ddFlakyTestRetriesCount,
          _ddIsDiEnabled,
          _ddIsKnownTestsEnabled,
          _ddIsTestManagementTestsEnabled,
          _ddTestManagementTests,
          _ddTestManagementAttemptToFixRetries,
          _ddModifiedFiles,
          ...restOfTestEnvironmentOptions
        } = testEnvironmentOptions;
        restOfConfig.testEnvironmentOptions = restOfTestEnvironmentOptions;
        arguments[0] = restOfConfig;
        return originalCreateScriptTransformer.apply(this, arguments);
      };
      return transformPackage;
    });
    addHook({
      name: "@jest/core",
      versions: [">=24.8.0 <30.0.0"],
      file: "build/SearchSource.js"
    }, searchSourceWrapper);
    addHook({
      name: "jest-config",
      versions: [">=25.1.0"]
    }, jestConfigAsyncWrapper);
    addHook({
      name: "jest-config",
      versions: ["24.8.0 - 24.9.0"]
    }, jestConfigSyncWrapper);
    var LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE = /* @__PURE__ */ new Set([
      "selenium-webdriver",
      "selenium-webdriver/chrome",
      "selenium-webdriver/edge",
      "selenium-webdriver/safari",
      "selenium-webdriver/firefox",
      "selenium-webdriver/ie",
      "selenium-webdriver/chromium",
      "winston"
    ]);
    addHook({
      name: "jest-runtime",
      versions: [">=24.8.0"]
    }, (runtimePackage) => {
      const Runtime = runtimePackage.default ?? runtimePackage;
      shimmer.wrap(Runtime.prototype, "_createJestObjectFor", (_createJestObjectFor) => function(from) {
        const result = _createJestObjectFor.apply(this, arguments);
        const suiteFilePath = this._testPath;
        shimmer.wrap(result, "mock", (mock) => function(moduleName2) {
          if (LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.has(moduleName2)) {
            LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.delete(moduleName2);
          }
          if (suiteFilePath) {
            const existingMockedFiles = testSuiteMockedFiles.get(suiteFilePath) || [];
            const suiteDir = path.dirname(suiteFilePath);
            const mockPath = path.resolve(suiteDir, moduleName2);
            existingMockedFiles.push(mockPath);
            testSuiteMockedFiles.set(suiteFilePath, existingMockedFiles);
          }
          return mock.apply(this, arguments);
        });
        return result;
      });
      shimmer.wrap(Runtime.prototype, "requireModuleOrMock", (requireModuleOrMock) => function(from, moduleName2) {
        const originalPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = function(error, structuredStackTrace) {
          const filteredStackTrace = structuredStackTrace.filter((callSite) => !callSite.getFileName()?.includes("datadog-instrumentations/src/jest.js"));
          return originalPrepareStackTrace(error, filteredStackTrace);
        };
        try {
          if (LIBRARIES_BYPASSING_JEST_REQUIRE_ENGINE.has(moduleName2)) {
            return this._requireCoreModule(moduleName2);
          }
          if (moduleName2 === "@fast-check/jest") {
            testSuiteAbsolutePathsWithFastCheck.add(this._testPath);
          }
          const returnedValue = requireModuleOrMock.apply(this, arguments);
          if (process.exitCode === 1) {
            if (this.loggedReferenceErrors?.size > 0) {
              const errorMessage = [...this.loggedReferenceErrors][0];
              testSuiteErrorCh.publish({
                errorMessage,
                testSuiteAbsolutePath: this._testPath
              });
            } else {
              testSuiteErrorCh.publish({
                errorMessage: "An error occurred while importing a module",
                testSuiteAbsolutePath: this._testPath
              });
            }
          }
          return returnedValue;
        } catch (error) {
          testSuiteErrorCh.publish({ error, testSuiteAbsolutePath: this._testPath });
          throw error;
        } finally {
          Error.prepareStackTrace = originalPrepareStackTrace;
        }
      });
      return runtimePackage;
    });
    function onMessageWrapper(onMessage) {
      return function() {
        const [code, data] = arguments[0];
        if (code === JEST_WORKER_TRACE_PAYLOAD_CODE) {
          workerReportTraceCh.publish(data);
          return;
        }
        if (code === JEST_WORKER_COVERAGE_PAYLOAD_CODE) {
          workerReportCoverageCh.publish(data);
          return;
        }
        if (code === JEST_WORKER_LOGS_PAYLOAD_CODE) {
          workerReportLogsCh.publish(data);
          return;
        }
        return onMessage.apply(this, arguments);
      };
    }
    function sendWrapper(send) {
      return function(request2) {
        if (!isKnownTestsEnabled && !isTestManagementTestsEnabled && !isImpactedTestsEnabled) {
          return send.apply(this, arguments);
        }
        const [type] = request2;
        if (type === CHILD_MESSAGE_CALL) {
          const args = request2.at(-1);
          if (args.length > 1) {
            return send.apply(this, arguments);
          }
          if (!args[0]?.config) {
            return send.apply(this, arguments);
          }
          const [{ globalConfig, config, path: testSuiteAbsolutePath }] = args;
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, globalConfig.rootDir || process.cwd());
          const suiteKnownTests = knownTests?.jest?.[testSuite] || [];
          const suiteTestManagementTests = testManagementTests?.jest?.suites?.[testSuite]?.tests || {};
          args[0].config = {
            ...config,
            testEnvironmentOptions: {
              ...config.testEnvironmentOptions,
              _ddKnownTests: suiteKnownTests,
              _ddTestManagementTests: suiteTestManagementTests,
              // TODO: figure out if we can reduce the size of the modified files object
              // Can we use `testSuite` (it'd have to be relative to repository root though)
              _ddModifiedFiles: modifiedFiles
            }
          };
        }
        return send.apply(this, arguments);
      };
    }
    function enqueueWrapper(enqueue) {
      return function() {
        shimmer.wrap(arguments[0], "onStart", (onStart) => function(worker) {
          if (worker && !wrappedWorkers.has(worker)) {
            shimmer.wrap(worker._child, "send", sendWrapper);
            shimmer.wrap(worker, "_onMessage", onMessageWrapper);
            worker._child.removeAllListeners("message");
            worker._child.on("message", worker._onMessage.bind(worker));
            wrappedWorkers.add(worker);
          }
          return onStart.apply(this, arguments);
        });
        return enqueue.apply(this, arguments);
      };
    }
    addHook({
      name: "jest-worker",
      versions: [">=24.9.0 <30.0.0"],
      file: "build/workers/ChildProcessWorker.js"
    }, (childProcessWorker) => {
      const ChildProcessWorker = childProcessWorker.default;
      shimmer.wrap(ChildProcessWorker.prototype, "send", sendWrapper);
      shimmer.wrap(ChildProcessWorker.prototype, "_onMessage", onMessageWrapper);
      return childProcessWorker;
    });
    addHook({
      name: "jest-worker",
      versions: [">=30.0.0"]
    }, (jestWorkerPackage) => {
      shimmer.wrap(jestWorkerPackage.FifoQueue.prototype, "enqueue", enqueueWrapper);
      shimmer.wrap(jestWorkerPackage.PriorityQueue.prototype, "enqueue", enqueueWrapper);
      return jestWorkerPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/koa.js
var require_koa = __commonJS({
  "../../packages/datadog-instrumentations/src/koa.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var enterChannel = channel("apm:koa:middleware:enter");
    var exitChannel = channel("apm:koa:middleware:exit");
    var errorChannel = channel("apm:koa:middleware:error");
    var nextChannel = channel("apm:koa:middleware:next");
    var finishChannel = channel("apm:koa:middleware:finish");
    var handleChannel = channel("apm:koa:request:handle");
    var routeChannel = channel("apm:koa:request:route");
    var originals = /* @__PURE__ */ new WeakMap();
    function wrapCallback(callback) {
      return function callbackWithTrace() {
        const handleRequest = callback.apply(this, arguments);
        if (typeof handleRequest !== "function") return handleRequest;
        return function handleRequestWithTrace(req, res) {
          handleChannel.publish({ req, res });
          return handleRequest.apply(this, arguments);
        };
      };
    }
    function wrapUse(use) {
      return function useWithTrace() {
        const result = use.apply(this, arguments);
        if (!Array.isArray(this.middleware)) return result;
        const fn = this.middleware.pop();
        this.middleware.push(wrapMiddleware(fn));
        return result;
      };
    }
    function wrapRegister(register2) {
      return function registerWithTrace(path, methods, middleware, opts) {
        const route = register2.apply(this, arguments);
        if (!Array.isArray(path) && route && Array.isArray(route.stack)) {
          wrapStack(route);
        }
        return route;
      };
    }
    function wrapRouterUse(use) {
      return function useWithTrace() {
        const router = use.apply(this, arguments);
        router.stack.forEach(wrapStack);
        return router;
      };
    }
    function wrapStack(layer) {
      layer.stack = layer.stack.map((middleware) => {
        if (typeof middleware !== "function") return middleware;
        const original = originals.get(middleware);
        middleware = original || middleware;
        const handler = shimmer.wrapFunction(middleware, (middleware2) => wrapMiddleware(middleware2, layer));
        originals.set(handler, middleware);
        return handler;
      });
    }
    function wrapMiddleware(fn, layer) {
      if (typeof fn !== "function") return fn;
      const name = fn.name;
      return shimmer.wrapFunction(fn, (fn2) => function(ctx, next) {
        if (!ctx || !enterChannel.hasSubscribers) return fn2.apply(this, arguments);
        const req = ctx.req;
        const path = layer && layer.path;
        const route = typeof path === "string" && !path.endsWith("(.*)") && !path.endsWith("([^/]*)") && path;
        enterChannel.publish({ req, name, route });
        if (typeof next === "function") {
          arguments[1] = wrapNext(req, next);
        }
        try {
          const result = fn2.apply(this, arguments);
          if (result && typeof result.then === "function") {
            return result.then(
              (result2) => {
                fulfill(ctx);
                return result2;
              },
              (err) => {
                fulfill(ctx, err);
                throw err;
              }
            );
          }
          fulfill(ctx);
          return result;
        } catch (e) {
          fulfill(ctx, e);
          throw e;
        } finally {
          exitChannel.publish({ req });
        }
      });
    }
    function fulfill(ctx, error) {
      const req = ctx.req;
      const route = ctx.routePath;
      if (error) {
        errorChannel.publish({ req, error });
      }
      if (route) {
        routeChannel.publish({ req, route });
      }
      finishChannel.publish({ req });
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(next, (next2) => function() {
        nextChannel.publish({ req });
        return next2.apply(this, arguments);
      });
    }
    addHook({ name: "koa", versions: [">=2"] }, (Koa) => {
      shimmer.wrap(Koa.prototype, "callback", wrapCallback);
      shimmer.wrap(Koa.prototype, "use", wrapUse);
      return Koa;
    });
    addHook({ name: "@koa/router", versions: [">=8"] }, (Router) => {
      shimmer.wrap(Router.prototype, "register", wrapRegister);
      shimmer.wrap(Router.prototype, "use", wrapRouterUse);
      return Router;
    });
    addHook({ name: "koa-router", versions: [">=7"] }, (Router) => {
      shimmer.wrap(Router.prototype, "register", wrapRegister);
      shimmer.wrap(Router.prototype, "use", wrapRouterUse);
      return Router;
    });
  }
});

// ../../packages/datadog-instrumentations/src/langchain.js
var require_langchain = __commonJS({
  "../../packages/datadog-instrumentations/src/langchain.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracingChannel = require_dc_polyfill().tracingChannel;
    function wrap(obj, name, channelName, namespace2) {
      const channel = tracingChannel(channelName);
      shimmer.wrap(obj, name, function(original) {
        return function() {
          if (!channel.start.hasSubscribers) {
            return original.apply(this, arguments);
          }
          const ctx = { self: this, arguments };
          if (namespace2) {
            ctx.namespace = namespace2;
          }
          return channel.tracePromise(original, ctx, this, ...arguments);
        };
      });
    }
    var extensions = ["js", "cjs"];
    for (const extension of extensions) {
      addHook({ name: "@langchain/core", file: `dist/runnables/base.${extension}`, versions: [">=0.1"] }, (exports3) => {
        if (extension === "cjs") {
          wrap(exports3.RunnableSequence.prototype, "invoke", "orchestrion:@langchain/core:RunnableSequence_invoke");
          wrap(exports3.RunnableSequence.prototype, "batch", "orchestrion:@langchain/core:RunnableSequence_batch");
        }
        return exports3;
      });
      addHook({
        name: "@langchain/core",
        file: `dist/language_models/chat_models.${extension}`,
        versions: [">=0.1"]
      }, (exports3) => {
        if (extension === "cjs") {
          wrap(exports3.BaseChatModel.prototype, "generate", "orchestrion:@langchain/core:BaseChatModel_generate");
        }
        return exports3;
      });
      addHook({ name: "@langchain/core", file: `dist/language_models/llms.${extension}`, versions: [">=0.1"] }, (exports3) => {
        if (extension === "cjs") {
          wrap(exports3.BaseLLM.prototype, "generate", "orchestrion:@langchain/core:BaseLLM_generate");
        }
        return exports3;
      });
      addHook({ name: "@langchain/core", file: `dist/tools/index.${extension}`, versions: [">=0.1"] }, (exports3) => {
        if (extension === "cjs") {
          wrap(exports3.StructuredTool.prototype, "invoke", "orchestrion:@langchain/core:Tool_invoke");
        }
        return exports3;
      });
      addHook({ name: "@langchain/core", file: `dist/vectorstores.${extension}`, versions: [">=0.1"] }, (exports3) => {
        if (extension === "cjs") {
          wrap(
            exports3.VectorStore.prototype,
            "similaritySearch",
            "orchestrion:@langchain/core:VectorStore_similaritySearch"
          );
          wrap(
            exports3.VectorStore.prototype,
            "similaritySearchWithScore",
            "orchestrion:@langchain/core:VectorStore_similaritySearchWithScore"
          );
        }
        return exports3;
      });
      addHook({ name: "@langchain/core", file: `dist/embeddings.${extension}`, versions: [">=0.1"] }, (exports3) => {
        if (extension === "cjs") {
          shimmer.wrap(exports3, "Embeddings", (Embeddings) => {
            return class extends Embeddings {
              constructor(...args) {
                super(...args);
                const namespace2 = ["langchain", "embeddings"];
                if (this.constructor.name === "OpenAIEmbeddings") {
                  namespace2.push("openai");
                }
                wrap(this, "embedQuery", "apm:@langchain/core:Embeddings_embedQuery", namespace2);
                wrap(this, "embedDocuments", "apm:@langchain/core:Embeddings_embedDocuments", namespace2);
              }
            };
          });
        } else {
          const channel = tracingChannel("orchestrion:@langchain/core:Embeddings_constructor");
          channel.subscribe({
            end(ctx) {
              const { self: self2 } = ctx;
              const namespace2 = ["langchain", "embeddings"];
              if (self2.constructor.name === "OpenAIEmbeddings") {
                namespace2.push("openai");
              }
              wrap(self2, "embedQuery", "apm:@langchain/core:Embeddings_embedQuery", namespace2);
              wrap(self2, "embedDocuments", "apm:@langchain/core:Embeddings_embedDocuments", namespace2);
            }
          });
        }
        return exports3;
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/redis.js
var require_redis = __commonJS({
  "../../packages/datadog-instrumentations/src/redis.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:redis:command:start");
    var finishCh = channel("apm:redis:command:finish");
    var errorCh = channel("apm:redis:command:error");
    var createClientUrl;
    function wrapAddCommand(addCommand) {
      return function(command) {
        if (!startCh.hasSubscribers) {
          return addCommand.apply(this, arguments);
        }
        const name = command[0];
        const args = command.slice(1);
        const ctx = getStartCtx(this, name, args, this._url);
        return startCh.runStores(ctx, () => {
          const res = addCommand.apply(this, arguments);
          res.then(() => finish(finishCh, errorCh, ctx), (err) => finish(finishCh, errorCh, ctx, err));
          return res;
        });
      };
    }
    function wrapCommandQueueClass(cls) {
      const ret = class RedisCommandQueue extends cls {
        constructor(...args) {
          super(...args);
          if (createClientUrl) {
            try {
              const parsed = new URL(createClientUrl);
              if (parsed) {
                this._url = { host: parsed.hostname, port: Number(parsed.port) || 6379 };
              }
            } catch {
            }
          }
          this._url = this._url || { host: "localhost", port: 6379 };
        }
      };
      return ret;
    }
    function wrapCreateClient(request2) {
      return function(opts) {
        createClientUrl = opts && opts.url;
        const ret = request2.apply(this, arguments);
        createClientUrl = void 0;
        return ret;
      };
    }
    addHook({ name: "@node-redis/client", file: "dist/lib/client/commands-queue.js", versions: [">=1"] }, (redis) => {
      redis.default = wrapCommandQueueClass(redis.default);
      shimmer.wrap(redis.default.prototype, "addCommand", wrapAddCommand);
      return redis;
    });
    addHook({ name: "@node-redis/client", file: "dist/lib/client/index.js", versions: [">=1"] }, (redis) => {
      shimmer.wrap(redis.default, "create", wrapCreateClient);
      return redis;
    });
    addHook({ name: "@redis/client", file: "dist/lib/client/index.js", versions: [">=1.1"] }, (redis) => {
      shimmer.wrap(redis.default, "create", wrapCreateClient);
      return redis;
    });
    addHook({ name: "@redis/client", file: "dist/lib/client/commands-queue.js", versions: [">=1.1"] }, (redis) => {
      redis.default = wrapCommandQueueClass(redis.default);
      shimmer.wrap(redis.default.prototype, "addCommand", wrapAddCommand);
      return redis;
    });
    addHook({ name: "redis", versions: [">=2.6 <4"] }, (redis) => {
      shimmer.wrap(redis.RedisClient.prototype, "internal_send_command", (internalSendCommand) => function(options) {
        if (!startCh.hasSubscribers) return internalSendCommand.apply(this, arguments);
        if (!options.callback) return internalSendCommand.apply(this, arguments);
        const ctx = getStartCtx(this, options.command, options.args);
        return startCh.runStores(ctx, () => {
          options.callback = wrapCallback(finishCh, errorCh, ctx, options.callback);
          try {
            return internalSendCommand.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return redis;
    });
    addHook({ name: "redis", versions: [">=0.12 <2.6"] }, (redis) => {
      shimmer.wrap(redis.RedisClient.prototype, "send_command", (sendCommand) => function(command, args, callback) {
        if (!startCh.hasSubscribers) {
          return sendCommand.apply(this, arguments);
        }
        const ctx = getStartCtx(this, command, args);
        return startCh.runStores(ctx, () => {
          if (typeof callback === "function") {
            arguments[2] = wrapCallback(finishCh, errorCh, ctx, callback);
          } else if (Array.isArray(args) && typeof args.at(-1) === "function") {
            args[args.length - 1] = wrapCallback(finishCh, errorCh, ctx, args.at(-1));
          } else {
            arguments[2] = wrapCallback(finishCh, errorCh, ctx);
          }
          try {
            return sendCommand.apply(this, arguments);
          } catch (err) {
            ctx.error = err;
            errorCh.publish(ctx);
            throw err;
          }
        });
      });
      return redis;
    });
    function getStartCtx(client, command, args, url = {}) {
      return {
        db: client.selected_db,
        command,
        args,
        connectionOptions: client.connection_options || client.connection_option || client.connectionOption || url
      };
    }
    function wrapCallback(finishCh2, errorCh2, ctx, callback) {
      return shimmer.wrapFunction(callback, (callback2) => function(err) {
        return finish(finishCh2, errorCh2, ctx, err, callback2, this, arguments);
      });
    }
    function finish(finishCh2, errorCh2, ctx, error, callback, thisArg, args) {
      if (error) {
        ctx.error = error;
        errorCh2.publish(ctx);
      }
      if (callback) {
        return finishCh2.runStores(ctx, callback, thisArg, ...args);
      }
      finishCh2.publish(ctx);
    }
  }
});

// ../../packages/datadog-instrumentations/src/opensearch.js
var require_opensearch = __commonJS({
  "../../packages/datadog-instrumentations/src/opensearch.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { createWrapRequest, createWrapGetConnection } = require_elasticsearch();
    addHook({ name: "@opensearch-project/opensearch", file: "lib/Transport.js", versions: [">=1"] }, (Transport) => {
      shimmer.wrap(Transport.prototype, "request", createWrapRequest("opensearch"));
      shimmer.wrap(Transport.prototype, "getConnection", createWrapGetConnection("opensearch"));
      return Transport;
    });
  }
});

// ../../packages/datadog-instrumentations/src/otel-sdk-trace.js
var require_otel_sdk_trace = __commonJS({
  "../../packages/datadog-instrumentations/src/otel-sdk-trace.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracer2 = require_dd_trace();
    var { getEnvironmentVariable } = require_config_helper();
    var otelSdkEnabled = getEnvironmentVariable("DD_TRACE_OTEL_ENABLED") || getEnvironmentVariable("OTEL_SDK_DISABLED") ? !getEnvironmentVariable("OTEL_SDK_DISABLED") : void 0;
    if (otelSdkEnabled) {
      addHook({
        name: "@opentelemetry/sdk-trace-node",
        file: "build/src/NodeTracerProvider.js",
        versions: ["*"]
      }, (mod2) => {
        shimmer.wrap(mod2, "NodeTracerProvider", () => {
          return tracer2.TracerProvider;
        });
        return mod2;
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/prisma.js
var require_prisma = __commonJS({
  "../../packages/datadog-instrumentations/src/prisma.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var prismaEngineStart = channel("apm:prisma:engine:start");
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var clientCH = tracingChannel("apm:prisma:client");
    var allowedClientSpanOperations = /* @__PURE__ */ new Set([
      "operation",
      "serialize",
      "transaction"
    ]);
    var TracingHelper = class {
      dbConfig = null;
      isEnabled() {
        return true;
      }
      // needs a sampled tracecontext to generate engine spans
      getTraceParent(context2) {
        return "00-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-bbbbbbbbbbbbbbbb-01";
      }
      dispatchEngineSpans(spans) {
        for (const span of spans) {
          if (span.parentId === null) {
            prismaEngineStart.publish({ engineSpan: span, allEngineSpans: spans, dbConfig: this.dbConfig });
          }
        }
      }
      getActiveContext() {
      }
      runInChildSpan(options, callback) {
        if (typeof options === "string") {
          options = {
            name: options
          };
        }
        if (allowedClientSpanOperations.has(options.name)) {
          const ctx = {
            resourceName: options.name,
            attributes: options.attributes || {}
          };
          if (options.name !== "serialize") {
            return clientCH.tracePromise(callback, ctx, this, ...arguments);
          }
          return clientCH.traceSync(callback, ctx, this, ...arguments);
        }
        return callback();
      }
      setDbString(dbConfig) {
        this.dbConfig = dbConfig;
      }
    };
    addHook({ name: "@prisma/client", versions: [">=6.1.0"] }, (prisma, version) => {
      const tracingHelper = new TracingHelper();
      const originalRequest = prisma.PrismaClient.prototype._request;
      prisma.PrismaClient.prototype._request = function() {
        if (!tracingHelper.dbConfig) {
          const inlineDatasources = this._engine?.config.inlineDatasources;
          const overrideDatasources = this._engine?.config.overrideDatasources;
          const datasources = inlineDatasources?.db.url?.value ?? overrideDatasources?.db?.url;
          if (datasources) {
            const result = parseDBString(datasources);
            tracingHelper.setDbString(result);
          }
        }
        return originalRequest.apply(this, arguments);
      };
      const versions = version.split(".");
      if (versions[0] === "6" && versions[1] < 4) {
        global.PRISMA_INSTRUMENTATION = {
          helper: tracingHelper
        };
      } else {
        global[`V${versions[0]}_PRISMA_INSTRUMENTATION`] = {
          helper: tracingHelper
        };
      }
      return prisma;
    });
    function parseDBString(dbString) {
      const url = new URL(dbString);
      const dbConfig = {
        user: url.username,
        password: url.password,
        host: url.hostname,
        port: url.port,
        database: url.pathname.slice(1)
        // Remove leading slash
      };
      return dbConfig;
    }
  }
});

// ../../packages/datadog-instrumentations/src/vitest.js
var require_vitest = __commonJS({
  "../../packages/datadog-instrumentations/src/vitest.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var {
      VITEST_WORKER_TRACE_PAYLOAD_CODE,
      VITEST_WORKER_LOGS_PAYLOAD_CODE
    } = require_test();
    var testStartCh = channel("ci:vitest:test:start");
    var testFinishTimeCh = channel("ci:vitest:test:finish-time");
    var testPassCh = channel("ci:vitest:test:pass");
    var testErrorCh = channel("ci:vitest:test:error");
    var testSkipCh = channel("ci:vitest:test:skip");
    var isNewTestCh = channel("ci:vitest:test:is-new");
    var isAttemptToFixCh = channel("ci:vitest:test:is-attempt-to-fix");
    var isDisabledCh = channel("ci:vitest:test:is-disabled");
    var isQuarantinedCh = channel("ci:vitest:test:is-quarantined");
    var isModifiedCh = channel("ci:vitest:test:is-modified");
    var testSuiteStartCh = channel("ci:vitest:test-suite:start");
    var testSuiteFinishCh = channel("ci:vitest:test-suite:finish");
    var testSuiteErrorCh = channel("ci:vitest:test-suite:error");
    var testSessionStartCh = channel("ci:vitest:session:start");
    var testSessionFinishCh = channel("ci:vitest:session:finish");
    var libraryConfigurationCh = channel("ci:vitest:library-configuration");
    var knownTestsCh = channel("ci:vitest:known-tests");
    var isEarlyFlakeDetectionFaultyCh = channel("ci:vitest:is-early-flake-detection-faulty");
    var testManagementTestsCh = channel("ci:vitest:test-management-tests");
    var modifiedFilesCh = channel("ci:vitest:modified-files");
    var workerReportTraceCh = channel("ci:vitest:worker-report:trace");
    var workerReportLogsCh = channel("ci:vitest:worker-report:logs");
    var taskToCtx = /* @__PURE__ */ new WeakMap();
    var taskToStatuses = /* @__PURE__ */ new WeakMap();
    var newTasks = /* @__PURE__ */ new WeakSet();
    var disabledTasks = /* @__PURE__ */ new WeakSet();
    var quarantinedTasks = /* @__PURE__ */ new WeakSet();
    var attemptToFixTasks = /* @__PURE__ */ new WeakSet();
    var modifiedTasks = /* @__PURE__ */ new WeakSet();
    var isRetryReasonEfd = false;
    var isRetryReasonAttemptToFix = false;
    var switchedStatuses = /* @__PURE__ */ new WeakSet();
    var workerProcesses = /* @__PURE__ */ new WeakSet();
    var isFlakyTestRetriesEnabled = false;
    var flakyTestRetriesCount = 0;
    var isEarlyFlakeDetectionEnabled = false;
    var earlyFlakeDetectionNumRetries = 0;
    var isEarlyFlakeDetectionFaulty = false;
    var isKnownTestsEnabled = false;
    var isTestManagementTestsEnabled = false;
    var isImpactedTestsEnabled = false;
    var testManagementAttemptToFixRetries = 0;
    var isDiEnabled = false;
    var testCodeCoverageLinesTotal;
    var isSessionStarted = false;
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 400;
    function getTestCommand() {
      return `vitest ${process.argv.slice(2).join(" ")}`;
    }
    function waitForHitProbe() {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        }, BREAKPOINT_HIT_GRACE_PERIOD_MS);
      });
    }
    function isValidKnownTests(receivedKnownTests) {
      return !!receivedKnownTests.vitest;
    }
    function getProvidedContext() {
      try {
        const {
          _ddIsEarlyFlakeDetectionEnabled,
          _ddIsDiEnabled,
          _ddKnownTests: knownTests,
          _ddEarlyFlakeDetectionNumRetries: numRepeats,
          _ddIsKnownTestsEnabled: isKnownTestsEnabled2,
          _ddIsTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          _ddTestManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
          _ddTestManagementTests: testManagementTests,
          _ddIsFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2,
          _ddIsImpactedTestsEnabled: isImpactedTestsEnabled2,
          _ddModifiedFiles: modifiedFiles
        } = globalThis.__vitest_worker__.providedContext;
        return {
          isDiEnabled: _ddIsDiEnabled,
          isEarlyFlakeDetectionEnabled: _ddIsEarlyFlakeDetectionEnabled,
          knownTests,
          numRepeats,
          isKnownTestsEnabled: isKnownTestsEnabled2,
          isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
          testManagementTests,
          isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2,
          isImpactedTestsEnabled: isImpactedTestsEnabled2,
          modifiedFiles
        };
      } catch {
        log.error("Vitest workers could not parse provided context, so some features will not work.");
        return {
          isDiEnabled: false,
          isEarlyFlakeDetectionEnabled: false,
          knownTests: {},
          numRepeats: 0,
          isKnownTestsEnabled: false,
          isTestManagementTestsEnabled: false,
          testManagementAttemptToFixRetries: 0,
          testManagementTests: {},
          isFlakyTestRetriesEnabled: false,
          isImpactedTestsEnabled: false,
          modifiedFiles: {}
        };
      }
    }
    function isReporterPackage(vitestPackage) {
      return vitestPackage.B?.name === "BaseSequencer";
    }
    function isReporterPackageNew(vitestPackage) {
      return vitestPackage.e?.name === "BaseSequencer";
    }
    function isReporterPackageNewest(vitestPackage) {
      return vitestPackage.h?.name === "BaseSequencer";
    }
    function isBaseSequencer(vitestPackage) {
      return vitestPackage.b?.name === "BaseSequencer";
    }
    function getChannelPromise(channelToPublishTo, frameworkVersion) {
      return new Promise((resolve) => {
        channelToPublishTo.publish({ onDone: resolve, frameworkVersion });
      });
    }
    function isCliApiPackage(vitestPackage) {
      return vitestPackage.s?.name === "startVitest";
    }
    function getSessionStatus(state) {
      if (state.getCountOfFailedTests() > 0) {
        return "fail";
      }
      if (state.pathsSet.size === 0) {
        return "skip";
      }
      return "pass";
    }
    function getVitestTestStatus(test, retryCount) {
      if (test.result.state !== "fail") {
        if (!test.repeats) {
          return "pass";
        } else if (test.repeats && (test.retry ?? 0) === retryCount) {
          return "pass";
        }
      }
      return "fail";
    }
    function getTypeTasks(fileTasks, type = "test") {
      const typeTasks = [];
      function getTasks(tasks) {
        for (const task of tasks) {
          if (task.type === type) {
            typeTasks.push(task);
          } else if (task.tasks) {
            getTasks(task.tasks);
          }
        }
      }
      getTasks(fileTasks);
      return typeTasks;
    }
    function getTestName(task) {
      let testName = task.name;
      let currentTask = task.suite;
      while (currentTask) {
        if (currentTask.name) {
          testName = `${currentTask.name} ${testName}`;
        }
        currentTask = currentTask.suite;
      }
      return testName;
    }
    function getSortWrapper(sort, frameworkVersion) {
      return async function() {
        if (!testSessionFinishCh.hasSubscribers) {
          return sort.apply(this, arguments);
        }
        try {
          const { err, libraryConfig } = await getChannelPromise(libraryConfigurationCh, frameworkVersion);
          if (!err) {
            isFlakyTestRetriesEnabled = libraryConfig.isFlakyTestRetriesEnabled;
            flakyTestRetriesCount = libraryConfig.flakyTestRetriesCount;
            isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled;
            earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries;
            isDiEnabled = libraryConfig.isDiEnabled;
            isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled;
            isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled;
            testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries;
            isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled;
          }
        } catch {
          isFlakyTestRetriesEnabled = false;
          isEarlyFlakeDetectionEnabled = false;
          isDiEnabled = false;
          isKnownTestsEnabled = false;
          isImpactedTestsEnabled = false;
        }
        if (isFlakyTestRetriesEnabled && !this.ctx.config.retry && flakyTestRetriesCount > 0) {
          this.ctx.config.retry = flakyTestRetriesCount;
          try {
            const workspaceProject = this.ctx.getCoreWorkspaceProject();
            workspaceProject._provided._ddIsFlakyTestRetriesEnabled = isFlakyTestRetriesEnabled;
          } catch {
            log.warn("Could not send library configuration to workers.");
          }
        }
        if (isKnownTestsEnabled) {
          const knownTestsResponse = await getChannelPromise(knownTestsCh);
          if (knownTestsResponse.err) {
            isEarlyFlakeDetectionEnabled = false;
          } else {
            const knownTests = knownTestsResponse.knownTests;
            const getFilePaths = this.ctx.getTestFilepaths || this.ctx._globTestFilepaths;
            const testFilepaths = await getFilePaths.call(this.ctx);
            if (isValidKnownTests(knownTests)) {
              isEarlyFlakeDetectionFaultyCh.publish({
                knownTests: knownTests.vitest,
                testFilepaths,
                onDone: (isFaulty) => {
                  isEarlyFlakeDetectionFaulty = isFaulty;
                }
              });
              if (isEarlyFlakeDetectionFaulty) {
                isEarlyFlakeDetectionEnabled = false;
                log.warn("New test detection is disabled because the number of new tests is too high.");
              } else {
                try {
                  const workspaceProject = this.ctx.getCoreWorkspaceProject();
                  workspaceProject._provided._ddIsKnownTestsEnabled = isKnownTestsEnabled;
                  workspaceProject._provided._ddKnownTests = knownTests;
                  workspaceProject._provided._ddIsEarlyFlakeDetectionEnabled = isEarlyFlakeDetectionEnabled;
                  workspaceProject._provided._ddEarlyFlakeDetectionNumRetries = earlyFlakeDetectionNumRetries;
                } catch {
                  log.warn("Could not send known tests to workers so Early Flake Detection will not work.");
                }
              }
            } else {
              isEarlyFlakeDetectionFaulty = true;
              isEarlyFlakeDetectionEnabled = false;
            }
          }
        }
        if (isDiEnabled) {
          try {
            const workspaceProject = this.ctx.getCoreWorkspaceProject();
            workspaceProject._provided._ddIsDiEnabled = isDiEnabled;
          } catch {
            log.warn("Could not send Dynamic Instrumentation configuration to workers.");
          }
        }
        if (isTestManagementTestsEnabled) {
          const { err, testManagementTests: receivedTestManagementTests } = await getChannelPromise(testManagementTestsCh);
          if (err) {
            isTestManagementTestsEnabled = false;
            log.error("Could not get test management tests.");
          } else {
            const testManagementTests = receivedTestManagementTests;
            try {
              const workspaceProject = this.ctx.getCoreWorkspaceProject();
              workspaceProject._provided._ddIsTestManagementTestsEnabled = isTestManagementTestsEnabled;
              workspaceProject._provided._ddTestManagementAttemptToFixRetries = testManagementAttemptToFixRetries;
              workspaceProject._provided._ddTestManagementTests = testManagementTests;
            } catch {
              log.warn("Could not send test management tests to workers so Test Management will not work.");
            }
          }
        }
        if (isImpactedTestsEnabled) {
          const { err, modifiedFiles } = await getChannelPromise(modifiedFilesCh);
          if (err) {
            log.error("Could not get modified tests.");
          } else {
            try {
              const workspaceProject = this.ctx.getCoreWorkspaceProject();
              workspaceProject._provided._ddIsImpactedTestsEnabled = isImpactedTestsEnabled;
              workspaceProject._provided._ddModifiedFiles = modifiedFiles;
            } catch {
              log.warn("Could not send modified tests to workers so Impacted Tests will not work.");
            }
          }
        }
        if (this.ctx.coverageProvider?.generateCoverage) {
          shimmer.wrap(this.ctx.coverageProvider, "generateCoverage", (generateCoverage) => async function() {
            const totalCodeCoverage = await generateCoverage.apply(this, arguments);
            try {
              testCodeCoverageLinesTotal = totalCodeCoverage.getCoverageSummary().lines.pct;
            } catch {
            }
            return totalCodeCoverage;
          });
        }
        shimmer.wrap(this.ctx, "exit", getFinishWrapper);
        shimmer.wrap(this.ctx, "close", getFinishWrapper);
        return sort.apply(this, arguments);
      };
    }
    function getFinishWrapper(exitOrClose) {
      let isClosed = false;
      return async function() {
        if (isClosed) {
          return exitOrClose.apply(this, arguments);
        }
        isClosed = true;
        let onFinish;
        const flushPromise = new Promise((resolve) => {
          onFinish = resolve;
        });
        const failedSuites = this.state.getFailedFilepaths();
        let error;
        if (failedSuites.length) {
          error = new Error(`Test suites failed: ${failedSuites.length}.`);
        }
        testSessionFinishCh.publish({
          status: getSessionStatus(this.state),
          testCodeCoverageLinesTotal,
          error,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onFinish
        });
        await flushPromise;
        return exitOrClose.apply(this, arguments);
      };
    }
    function getCliOrStartVitestWrapper(frameworkVersion) {
      return function(oldCliOrStartVitest) {
        return function() {
          if (!testSessionStartCh.hasSubscribers || isSessionStarted) {
            return oldCliOrStartVitest.apply(this, arguments);
          }
          isSessionStarted = true;
          testSessionStartCh.publish({ command: getTestCommand(), frameworkVersion });
          return oldCliOrStartVitest.apply(this, arguments);
        };
      };
    }
    function getCreateCliWrapper(vitestPackage, frameworkVersion) {
      shimmer.wrap(vitestPackage, "c", getCliOrStartVitestWrapper(frameworkVersion));
      return vitestPackage;
    }
    function threadHandler(thread) {
      if (workerProcesses.has(thread.process)) {
        return;
      }
      workerProcesses.add(thread.process);
      thread.process.on("message", (message) => {
        if (message.__tinypool_worker_message__ && message.data) {
          if (message.interprocessCode === VITEST_WORKER_TRACE_PAYLOAD_CODE) {
            workerReportTraceCh.publish(message.data);
          } else if (message.interprocessCode === VITEST_WORKER_LOGS_PAYLOAD_CODE) {
            workerReportLogsCh.publish(message.data);
          }
        }
      });
    }
    addHook({
      name: "tinypool",
      versions: [">=1.0.0"],
      file: "dist/index.js"
    }, (TinyPool) => {
      shimmer.wrap(TinyPool.prototype, "run", (run) => async function() {
        this.threads.forEach(threadHandler);
        const runResult = await run.apply(this, arguments);
        this.threads.forEach(threadHandler);
        return runResult;
      });
      return TinyPool;
    });
    function getStartVitestWrapper(cliApiPackage, frameworkVersion) {
      if (!isCliApiPackage(cliApiPackage)) {
        return cliApiPackage;
      }
      shimmer.wrap(cliApiPackage, "s", getCliOrStartVitestWrapper(frameworkVersion));
      return cliApiPackage;
    }
    addHook({
      name: "vitest",
      versions: [">=1.6.0"],
      file: "dist/runners.js"
    }, (vitestPackage) => {
      const { VitestTestRunner } = vitestPackage;
      shimmer.wrap(VitestTestRunner.prototype, "onBeforeRunTask", (onBeforeRunTask) => function(task) {
        const testName = getTestName(task);
        const {
          knownTests,
          isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2,
          isKnownTestsEnabled: isKnownTestsEnabled2,
          numRepeats,
          isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2,
          testManagementTests,
          isImpactedTestsEnabled: isImpactedTestsEnabled2,
          modifiedFiles
        } = getProvidedContext();
        if (isTestManagementTestsEnabled2) {
          isAttemptToFixCh.publish({
            testManagementTests,
            testSuiteAbsolutePath: task.file.filepath,
            testName,
            onDone: (isAttemptToFix) => {
              if (isAttemptToFix) {
                isRetryReasonAttemptToFix = task.repeats !== testManagementAttemptToFixRetries2;
                task.repeats = testManagementAttemptToFixRetries2;
                attemptToFixTasks.add(task);
                taskToStatuses.set(task, []);
              }
            }
          });
          isDisabledCh.publish({
            testManagementTests,
            testSuiteAbsolutePath: task.file.filepath,
            testName,
            onDone: (isTestDisabled) => {
              if (isTestDisabled) {
                disabledTasks.add(task);
                if (!attemptToFixTasks.has(task)) {
                  task.mode = "skip";
                }
              }
            }
          });
        }
        if (isImpactedTestsEnabled2) {
          isModifiedCh.publish({
            modifiedFiles,
            testSuiteAbsolutePath: task.file.filepath,
            onDone: (isImpacted) => {
              if (isImpacted) {
                if (isEarlyFlakeDetectionEnabled2) {
                  isRetryReasonEfd = task.repeats !== numRepeats;
                  task.repeats = numRepeats;
                }
                modifiedTasks.add(task);
                taskToStatuses.set(task, []);
              }
            }
          });
        }
        if (isKnownTestsEnabled2) {
          isNewTestCh.publish({
            knownTests,
            testSuiteAbsolutePath: task.file.filepath,
            testName,
            onDone: (isNew) => {
              if (isNew && !attemptToFixTasks.has(task)) {
                if (isEarlyFlakeDetectionEnabled2 && !modifiedTasks.has(task)) {
                  isRetryReasonEfd = task.repeats !== numRepeats;
                  task.repeats = numRepeats;
                }
                newTasks.add(task);
                taskToStatuses.set(task, []);
              }
            }
          });
        }
        return onBeforeRunTask.apply(this, arguments);
      });
      shimmer.wrap(VitestTestRunner.prototype, "onAfterRunTask", (onAfterRunTask) => function(task) {
        const { isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2, isTestManagementTestsEnabled: isTestManagementTestsEnabled2 } = getProvidedContext();
        if (isTestManagementTestsEnabled2) {
          const isAttemptingToFix = attemptToFixTasks.has(task);
          const isDisabled = disabledTasks.has(task);
          const isQuarantined = quarantinedTasks.has(task);
          if (isAttemptingToFix && (isDisabled || isQuarantined)) {
            if (task.result.state === "fail") {
              switchedStatuses.add(task);
            }
            task.result.state = "pass";
          } else if (isQuarantined) {
            task.result.state = "pass";
          }
        }
        if (isEarlyFlakeDetectionEnabled2 && taskToStatuses.has(task) && !attemptToFixTasks.has(task)) {
          const statuses = taskToStatuses.get(task);
          if (statuses.includes("pass")) {
            if (task.result.state === "fail") {
              switchedStatuses.add(task);
            }
            task.result.state = "pass";
          }
        }
        return onAfterRunTask.apply(this, arguments);
      });
      shimmer.wrap(VitestTestRunner.prototype, "onBeforeTryTask", (onBeforeTryTask) => async function(task, retryInfo) {
        if (!testPassCh.hasSubscribers && !testErrorCh.hasSubscribers && !testSkipCh.hasSubscribers) {
          return onBeforeTryTask.apply(this, arguments);
        }
        const testName = getTestName(task);
        let isNew = false;
        let isQuarantined = false;
        const {
          isKnownTestsEnabled: isKnownTestsEnabled2,
          isEarlyFlakeDetectionEnabled: isEarlyFlakeDetectionEnabled2,
          isDiEnabled: isDiEnabled2,
          isTestManagementTestsEnabled: isTestManagementTestsEnabled2,
          testManagementTests,
          isFlakyTestRetriesEnabled: isFlakyTestRetriesEnabled2
        } = getProvidedContext();
        if (isKnownTestsEnabled2) {
          isNew = newTasks.has(task);
        }
        if (isTestManagementTestsEnabled2) {
          isQuarantinedCh.publish({
            testManagementTests,
            testSuiteAbsolutePath: task.file.filepath,
            testName,
            onDone: (isTestQuarantined) => {
              isQuarantined = isTestQuarantined;
              if (isTestQuarantined) {
                quarantinedTasks.add(task);
              }
            }
          });
        }
        const { retry: numAttempt, repeats: numRepetition } = retryInfo;
        if (numAttempt > 0) {
          const shouldWaitForHitProbe = isDiEnabled2 && numAttempt > 1;
          if (shouldWaitForHitProbe) {
            await waitForHitProbe();
          }
          const promises = {};
          const shouldSetProbe = isDiEnabled2 && numAttempt === 1;
          const ctx2 = taskToCtx.get(task);
          const testError = task.result?.errors?.[0];
          if (ctx2) {
            testErrorCh.publish({
              error: testError,
              shouldSetProbe,
              promises,
              ...ctx2.currentStore
            });
            if (promises.setProbePromise) {
              await promises.setProbePromise;
            }
          }
        }
        const lastExecutionStatus = task.result.state;
        const shouldFlipStatus = isEarlyFlakeDetectionEnabled2 || attemptToFixTasks.has(task);
        const statuses = taskToStatuses.get(task);
        if (numRepetition > 0 && numRepetition < task.repeats) {
          const ctx2 = taskToCtx.get(task);
          if (ctx2) {
            if (lastExecutionStatus === "fail") {
              const testError = task.result?.errors?.[0];
              testErrorCh.publish({ error: testError, ...ctx2.currentStore });
            } else {
              testPassCh.publish({ task, ...ctx2.currentStore });
            }
            if (shouldFlipStatus) {
              statuses.push(lastExecutionStatus);
              task.result.state = "pass";
            }
          }
        } else if (numRepetition === task.repeats) {
          if (shouldFlipStatus) {
            statuses.push(lastExecutionStatus);
          }
          const ctx2 = taskToCtx.get(task);
          if (lastExecutionStatus === "fail") {
            const testError = task.result?.errors?.[0];
            testErrorCh.publish({ error: testError, ...ctx2.currentStore });
          } else {
            testPassCh.publish({ task, ...ctx2.currentStore });
          }
        }
        const isRetryReasonAtr = numAttempt > 0 && isFlakyTestRetriesEnabled2 && !isRetryReasonAttemptToFix && !isRetryReasonEfd;
        const ctx = {
          testName,
          testSuiteAbsolutePath: task.file.filepath,
          isRetry: numAttempt > 0 || numRepetition > 0,
          isRetryReasonEfd,
          isRetryReasonAttemptToFix: isRetryReasonAttemptToFix && numRepetition > 0,
          isNew,
          mightHitProbe: isDiEnabled2 && numAttempt > 0,
          isAttemptToFix: attemptToFixTasks.has(task),
          isDisabled: disabledTasks.has(task),
          isQuarantined,
          isRetryReasonAtr,
          isModified: modifiedTasks.has(task)
        };
        taskToCtx.set(task, ctx);
        testStartCh.runStores(ctx, () => {
        });
        return onBeforeTryTask.apply(this, arguments);
      });
      shimmer.wrap(VitestTestRunner.prototype, "onAfterTryTask", (onAfterTryTask) => async function(task, { retry: retryCount }) {
        if (!testPassCh.hasSubscribers && !testErrorCh.hasSubscribers && !testSkipCh.hasSubscribers) {
          return onAfterTryTask.apply(this, arguments);
        }
        const result = await onAfterTryTask.apply(this, arguments);
        const { testManagementAttemptToFixRetries: testManagementAttemptToFixRetries2 } = getProvidedContext();
        const status = getVitestTestStatus(task, retryCount);
        const ctx = taskToCtx.get(task);
        const { isDiEnabled: isDiEnabled2 } = getProvidedContext();
        if (isDiEnabled2 && retryCount > 1) {
          await waitForHitProbe();
        }
        let attemptToFixPassed = false;
        let attemptToFixFailed = false;
        if (attemptToFixTasks.has(task)) {
          const statuses = taskToStatuses.get(task);
          if (statuses.length === testManagementAttemptToFixRetries2) {
            if (statuses.every((status2) => status2 === "pass")) {
              attemptToFixPassed = true;
            } else if (statuses.includes("fail")) {
              attemptToFixFailed = true;
            }
          }
        }
        if (ctx) {
          ctx.status = status;
          ctx.task = task;
          ctx.attemptToFixPassed = attemptToFixPassed;
          ctx.attemptToFixFailed = attemptToFixFailed;
          testFinishTimeCh.runStores(ctx, () => {
          });
        }
        return result;
      });
      return vitestPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=1.6.0 <2.0.0"],
      filePattern: "dist/vendor/index.*"
    }, (vitestPackage) => {
      if (isReporterPackage(vitestPackage)) {
        shimmer.wrap(vitestPackage.B.prototype, "sort", getSortWrapper);
      }
      return vitestPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=2.0.0 <2.0.5"],
      filePattern: "dist/vendor/index.*"
    }, (vitestPackage) => {
      if (isReporterPackageNew(vitestPackage)) {
        shimmer.wrap(vitestPackage.e.prototype, "sort", getSortWrapper);
      }
      return vitestPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=2.0.5 <2.1.0"],
      filePattern: "dist/chunks/index.*"
    }, (vitestPackage) => {
      if (isReporterPackageNewest(vitestPackage)) {
        shimmer.wrap(vitestPackage.h.prototype, "sort", getSortWrapper);
      }
      return vitestPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=2.1.0 <3.0.0"],
      filePattern: "dist/chunks/RandomSequencer.*"
    }, (randomSequencerPackage) => {
      shimmer.wrap(randomSequencerPackage.B.prototype, "sort", getSortWrapper);
      return randomSequencerPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=3.0.9"],
      filePattern: "dist/chunks/coverage.*"
    }, (coveragePackage) => {
      if (isBaseSequencer(coveragePackage)) {
        shimmer.wrap(coveragePackage.b.prototype, "sort", getSortWrapper);
      }
      return coveragePackage;
    });
    addHook({
      name: "vitest",
      versions: [">=3.0.0 <3.0.9"],
      filePattern: "dist/chunks/resolveConfig.*"
    }, (resolveConfigPackage) => {
      shimmer.wrap(resolveConfigPackage.B.prototype, "sort", getSortWrapper);
      return resolveConfigPackage;
    });
    addHook({
      name: "vitest",
      versions: [">=1.6.0 <2.0.5"],
      filePattern: "dist/vendor/cac.*"
    }, getCreateCliWrapper);
    addHook({
      name: "vitest",
      versions: [">=2.0.5"],
      filePattern: "dist/chunks/cac.*"
    }, getCreateCliWrapper);
    addHook({
      name: "vitest",
      versions: [">=1.6.0 <2.0.5"],
      filePattern: "dist/vendor/cli-api.*"
    }, getStartVitestWrapper);
    addHook({
      name: "vitest",
      versions: [">=2.0.5"],
      filePattern: "dist/chunks/cli-api.*"
    }, getStartVitestWrapper);
    addHook({
      name: "@vitest/runner",
      versions: [">=1.6.0"],
      file: "dist/index.js"
    }, (vitestPackage, frameworkVersion) => {
      shimmer.wrap(vitestPackage, "startTests", (startTests) => async function(testPaths) {
        let testSuiteError = null;
        if (!testSuiteFinishCh.hasSubscribers) {
          return startTests.apply(this, arguments);
        }
        const testSuiteAbsolutePath = testPaths[0]?.filepath || testPaths[0];
        const testSuiteCtx = { testSuiteAbsolutePath, frameworkVersion };
        testSuiteStartCh.runStores(testSuiteCtx, () => {
        });
        const startTestsResponse = await startTests.apply(this, arguments);
        let onFinish = null;
        const onFinishPromise = new Promise((resolve) => {
          onFinish = resolve;
        });
        const testTasks = getTypeTasks(startTestsResponse[0].tasks);
        testTasks.forEach((task) => {
          const testCtx = taskToCtx.get(task);
          const { result } = task;
          const isSwitchedStatus = switchedStatuses.has(task);
          if (result) {
            const { state, duration, errors } = result;
            if (state === "skip") {
              testSkipCh.publish({
                testName: getTestName(task),
                testSuiteAbsolutePath: task.file.filepath,
                isNew: newTasks.has(task),
                isDisabled: disabledTasks.has(task)
              });
            } else if (state === "pass" && !isSwitchedStatus) {
              if (testCtx) {
                testPassCh.publish({ task, ...testCtx.currentStore });
              }
            } else if (state === "fail" || isSwitchedStatus) {
              let testError;
              if (errors?.length) {
                testError = errors[0];
              }
              let hasFailedAllRetries = false;
              let attemptToFixFailed = false;
              if (attemptToFixTasks.has(task)) {
                const statuses = taskToStatuses.get(task);
                if (statuses.includes("fail")) {
                  attemptToFixFailed = true;
                }
                if (statuses.every((status) => status === "fail")) {
                  hasFailedAllRetries = true;
                }
              }
              if (testCtx) {
                const isRetry = task.result?.retryCount > 0;
                testErrorCh.publish({
                  duration: isRetry ? void 0 : duration,
                  error: testError,
                  hasFailedAllRetries,
                  attemptToFixFailed,
                  ...testCtx.currentStore
                });
              }
              if (errors?.length) {
                testSuiteError = testError;
              }
            }
          } else {
            testSkipCh.publish({
              testName: getTestName(task),
              testSuiteAbsolutePath: task.file.filepath,
              isNew: newTasks.has(task),
              isDisabled: disabledTasks.has(task)
            });
          }
        });
        const testSuiteResult = startTestsResponse[0].result;
        if (testSuiteResult.errors?.length) {
          testSuiteError = testSuiteResult.errors[0];
        } else if (testSuiteResult.state === "fail") {
          const suiteTasks = getTypeTasks(startTestsResponse[0].tasks, "suite");
          const failedSuites = suiteTasks.filter((task) => task.result?.state === "fail");
          if (failedSuites.length && failedSuites[0].result?.errors?.length) {
            testSuiteError = failedSuites[0].result.errors[0];
          }
        }
        if (testSuiteError) {
          testSuiteCtx.error = testSuiteError;
          testSuiteErrorCh.runStores(testSuiteCtx, () => {
          });
        }
        testSuiteFinishCh.publish({ status: testSuiteResult.state, onFinish, ...testSuiteCtx.currentStore });
        await onFinishPromise;
        return startTestsResponse;
      });
      return vitestPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/aerospike.js
var require_aerospike = __commonJS({
  "../../packages/datadog-instrumentations/src/aerospike.js"() {
    "use strict";
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var ch = tracingChannel("apm:aerospike:command");
    function wrapCreateCommand(createCommand) {
      if (typeof createCommand !== "function") return createCommand;
      return function commandWithTrace() {
        const CommandClass = createCommand.apply(this, arguments);
        if (!CommandClass) return CommandClass;
        shimmer.wrap(CommandClass.prototype, "process", wrapProcess);
        return CommandClass;
      };
    }
    function wrapProcess(process2) {
      return function(...args) {
        const cb = args[0];
        if (typeof cb !== "function") return process2.apply(this, args);
        const ctx = {
          commandName: this.constructor.name,
          commandArgs: this.args,
          clientConfig: this.client.config
        };
        return ch.traceCallback(process2, -1, ctx, this, ...args);
      };
    }
    addHook(
      {
        name: "aerospike",
        file: "lib/commands/command.js",
        versions: ["4", "5", "6"]
      },
      (commandFactory) => {
        return shimmer.wrapFunction(commandFactory, (f) => wrapCreateCommand(f));
      }
    );
  }
});

// ../../packages/datadog-instrumentations/src/ai.js
var require_ai = __commonJS({
  "../../packages/datadog-instrumentations/src/ai.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { channel, tracingChannel } = require_dc_polyfill();
    var toolCreationChannel = channel("dd-trace:vercel-ai:tool");
    var TRACED_FUNCTIONS = {
      generateText: wrapWithTracer,
      streamText: wrapWithTracer,
      generateObject: wrapWithTracer,
      streamObject: wrapWithTracer,
      embed: wrapWithTracer,
      embedMany: wrapWithTracer,
      tool: wrapTool
    };
    var vercelAiTracingChannel = tracingChannel("dd-trace:vercel-ai");
    var vercelAiSpanSetAttributesChannel = channel("dd-trace:vercel-ai:span:setAttributes");
    var noopTracer = {
      startActiveSpan() {
        const fn = arguments[arguments.length - 1];
        const span = {
          spanContext() {
            return { traceId: "", spanId: "", traceFlags: 0 };
          },
          setAttribute() {
            return this;
          },
          setAttributes() {
            return this;
          },
          addEvent() {
            return this;
          },
          addLink() {
            return this;
          },
          addLinks() {
            return this;
          },
          setStatus() {
            return this;
          },
          updateName() {
            return this;
          },
          end() {
            return this;
          },
          isRecording() {
            return false;
          },
          recordException() {
            return this;
          }
        };
        return fn(span);
      }
    };
    function wrapTracer(tracer2) {
      if (Object.hasOwn(tracer2, Symbol.for("_dd.wrapped"))) return;
      shimmer.wrap(tracer2, "startActiveSpan", function(startActiveSpan) {
        return function() {
          const name = arguments[0];
          const options = arguments.length > 2 ? arguments[1] ?? {} : {};
          const cb = arguments[arguments.length - 1];
          const ctx = {
            name,
            attributes: options.attributes ?? {}
          };
          arguments[arguments.length - 1] = shimmer.wrapFunction(cb, function(originalCb) {
            return function(span) {
              shimmer.wrap(span, "end", function(spanEnd) {
                return function() {
                  vercelAiTracingChannel.asyncEnd.publish(ctx);
                  return spanEnd.apply(this, arguments);
                };
              });
              shimmer.wrap(span, "setAttributes", function(setAttributes) {
                return function(attributes) {
                  vercelAiSpanSetAttributesChannel.publish({ ctx, attributes });
                  return setAttributes.apply(this, arguments);
                };
              });
              shimmer.wrap(span, "recordException", function(recordException) {
                return function(exception) {
                  ctx.error = exception;
                  vercelAiTracingChannel.error.publish(ctx);
                  return recordException.apply(this, arguments);
                };
              });
              return originalCb.apply(this, arguments);
            };
          });
          return vercelAiTracingChannel.start.runStores(ctx, () => {
            const result = startActiveSpan.apply(this, arguments);
            vercelAiTracingChannel.end.publish(ctx);
            return result;
          });
        };
      });
      Object.defineProperty(tracer2, Symbol.for("_dd.wrapped"), { value: true });
    }
    function wrapWithTracer(fn) {
      return function() {
        const options = arguments[0];
        const experimentalTelemetry = options.experimental_telemetry;
        if (experimentalTelemetry?.isEnabled === false) {
          return fn.apply(this, arguments);
        }
        if (experimentalTelemetry == null) {
          options.experimental_telemetry = { isEnabled: true, tracer: noopTracer };
        } else {
          experimentalTelemetry.isEnabled = true;
          experimentalTelemetry.tracer ??= noopTracer;
        }
        wrapTracer(options.experimental_telemetry.tracer);
        return fn.apply(this, arguments);
      };
    }
    function wrapTool(tool) {
      return function() {
        const args = arguments[0];
        toolCreationChannel.publish(args);
        return tool.apply(this, arguments);
      };
    }
    addHook({
      name: "ai",
      versions: [">=4.0.0"]
    }, (exports3) => {
      for (const [fnName, patchingFn] of Object.entries(TRACED_FUNCTIONS)) {
        exports3 = shimmer.wrap(exports3, fnName, patchingFn, { replaceGetter: true });
      }
      return exports3;
    });
    addHook({
      name: "ai",
      versions: [">=4.0.0"],
      file: "dist/index.mjs"
    }, (exports3) => {
      for (const [fnName, patchingFn] of Object.entries(TRACED_FUNCTIONS)) {
        exports3 = shimmer.wrap(exports3, fnName, patchingFn, { replaceGetter: true });
      }
      return exports3;
    });
  }
});

// ../../packages/datadog-instrumentations/src/amqp10.js
var require_amqp10 = __commonJS({
  "../../packages/datadog-instrumentations/src/amqp10.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "amqp10", file: "lib/sender_link.js", versions: [">=3"] }, (SenderLink) => {
      const startCh = channel("apm:amqp10:send:start");
      const finishCh = channel("apm:amqp10:send:finish");
      const errorCh = channel("apm:amqp10:send:error");
      shimmer.wrap(SenderLink.prototype, "send", (send) => function(msg, options) {
        if (!startCh.hasSubscribers) {
          return send.apply(this, arguments);
        }
        const ctx = { link: this };
        return startCh.runStores(ctx, () => {
          try {
            const promise = send.apply(this, arguments);
            if (!promise) {
              finish(finishCh, errorCh);
              return promise;
            }
            promise.then(
              () => finish(finishCh, errorCh, null, ctx),
              (e) => finish(finishCh, errorCh, e, ctx)
            );
            return promise;
          } catch (err) {
            finish(finishCh, errorCh, err, ctx);
            throw err;
          }
        });
      });
      return SenderLink;
    });
    addHook({ name: "amqp10", file: "lib/receiver_link.js", versions: [">=3"] }, (ReceiverLink) => {
      const startCh = channel("apm:amqp10:receive:start");
      const finishCh = channel("apm:amqp10:receive:finish");
      const errorCh = channel("apm:amqp10:receive:error");
      shimmer.wrap(ReceiverLink.prototype, "_messageReceived", (messageReceived) => function(transferFrame) {
        if (!transferFrame || transferFrame.aborted || transferFrame.more) {
          return messageReceived.apply(this, arguments);
        }
        const ctx = { link: this };
        return startCh.runStores(ctx, () => {
          try {
            return messageReceived.apply(this, arguments);
          } catch (err) {
            ctx.error = err;
            errorCh.publish(ctx);
            throw err;
          } finally {
            finishCh.publish(ctx);
          }
        });
      });
      return ReceiverLink;
    });
    function finish(finishCh, errorCh, error, ctx) {
      if (error) {
        ctx.error = error;
        errorCh.publish(ctx);
      }
      finishCh.publish(ctx);
    }
  }
});

// ../../packages/datadog-core/src/utils/src/kebabcase.js
var require_kebabcase = __commonJS({
  "../../packages/datadog-core/src/utils/src/kebabcase.js"(exports2, module2) {
    "use strict";
    module2.exports = function kebabcase(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.trim().replaceAll(/([a-z])([A-Z])/g, "$1-$2").replaceAll(/[\s_]+/g, "-").replaceAll(/^-+|-+$/g, "").toLowerCase();
    };
  }
});

// ../../packages/datadog-instrumentations/src/amqplib.js
var require_amqplib = __commonJS({
  "../../packages/datadog-instrumentations/src/amqplib.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var kebabCase = require_kebabcase();
    var shimmer = require_datadog_shimmer();
    var { NODE_MAJOR, NODE_MINOR } = require_version2();
    var MIN_VERSION = NODE_MAJOR > 22 || NODE_MAJOR === 22 && NODE_MINOR >= 2 ? ">=0.5.3" : ">=0.5.0";
    var commandStartCh = channel("apm:amqplib:command:start");
    var commandFinishCh = channel("apm:amqplib:command:finish");
    var commandErrorCh = channel("apm:amqplib:command:error");
    var consumeStartCh = channel("apm:amqplib:consume:start");
    var consumeFinishCh = channel("apm:amqplib:consume:finish");
    var publishStartCh = channel("apm:amqplib:publish:start");
    var publishFinishCh = channel("apm:amqplib:publish:finish");
    var publishErrorCh = channel("apm:amqplib:publish:error");
    var methods = {};
    addHook({ name: "amqplib", file: "lib/defs.js", versions: [MIN_VERSION] }, (defs) => {
      for (const [key, value] of Object.entries(defs)) {
        if (Number.isInteger(value) && isCamelCase(key)) {
          methods[value] = kebabCase(key).replaceAll("-", ".");
        }
      }
      return defs;
    });
    addHook({ name: "amqplib", file: "lib/channel_model.js", versions: [MIN_VERSION] }, (x) => {
      shimmer.wrap(x.Channel.prototype, "get", (getMessage) => function(queue, options) {
        return getMessage.apply(this, arguments).then((message) => {
          if (message === null) {
            return message;
          }
          const ctx = { method: "basic.get", message, fields: message.fields, queue };
          consumeStartCh.runStores(ctx, () => {
            consumeFinishCh.publish(ctx);
          });
          return message;
        });
      });
      shimmer.wrap(x.Channel.prototype, "consume", (consume) => function(queue, callback, options) {
        if (!consumeStartCh.hasSubscribers) {
          return consume.apply(this, arguments);
        }
        arguments[1] = (message, ...args) => {
          if (message === null) {
            return callback(message, ...args);
          }
          const ctx = { method: "basic.deliver", message, fields: message.fields, queue };
          return consumeStartCh.runStores(ctx, () => {
            const result = callback(message, ...args);
            consumeFinishCh.publish(ctx);
            return result;
          });
        };
        return consume.apply(this, arguments);
      });
      return x;
    });
    addHook({ name: "amqplib", file: "lib/callback_model.js", versions: [MIN_VERSION] }, (channel2) => {
      shimmer.wrap(channel2.Channel.prototype, "get", (getMessage) => function(queue, options, callback) {
        if (!commandStartCh.hasSubscribers) {
          return getMessage.apply(this, arguments);
        }
        arguments[2] = (error, message, ...args) => {
          if (error !== null || message === null) {
            return callback(error, message, ...args);
          }
          const ctx = { method: "basic.get", message, fields: message.fields, queue };
          return consumeStartCh.runStores(ctx, () => {
            const result = callback(error, message, ...args);
            consumeFinishCh.publish(ctx);
            return result;
          });
        };
        return getMessage.apply(this, arguments);
      });
      shimmer.wrap(channel2.Channel.prototype, "consume", (consume) => function(queue, callback) {
        if (!consumeStartCh.hasSubscribers) {
          return consume.apply(this, arguments);
        }
        arguments[1] = (message, ...args) => {
          if (message === null) {
            return callback(message, ...args);
          }
          const ctx = { method: "basic.deliver", message, fields: message.fields, queue };
          return consumeStartCh.runStores(ctx, () => {
            const result = callback(message, ...args);
            consumeFinishCh.publish(ctx);
            return result;
          });
        };
        return consume.apply(this, arguments);
      });
      return channel2;
    });
    addHook({ name: "amqplib", file: "lib/channel.js", versions: [MIN_VERSION] }, (channel2) => {
      shimmer.wrap(channel2.Channel.prototype, "sendImmediately", (sendImmediately) => function(method, fields) {
        return instrument(
          sendImmediately,
          this,
          arguments,
          methods[method],
          fields,
          null,
          commandStartCh,
          commandFinishCh,
          commandErrorCh
        );
      });
      shimmer.wrap(channel2.Channel.prototype, "sendMessage", (sendMessage) => function(fields) {
        return instrument(
          sendMessage,
          this,
          arguments,
          "basic.publish",
          fields,
          arguments[2],
          publishStartCh,
          publishFinishCh,
          publishErrorCh
        );
      });
      return channel2;
    });
    function instrument(send, channel2, args, method, fields, message, startCh, finishCh, errorCh) {
      if (!startCh.hasSubscribers || method === "basic.get") {
        return send.apply(channel2, args);
      }
      const ctx = { channel: channel2, method, fields, message };
      return startCh.runStores(ctx, () => {
        try {
          return send.apply(channel2, args);
        } catch (err) {
          ctx.error = err;
          errorCh.publish(ctx);
          throw err;
        } finally {
          finishCh.publish(ctx);
        }
      });
    }
    function isCamelCase(str) {
      return /([A-Z][a-z0-9]+)+/.test(str);
    }
  }
});

// ../../packages/datadog-instrumentations/src/avsc.js
var require_avsc = __commonJS({
  "../../packages/datadog-instrumentations/src/avsc.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook } = require_instrument();
    var dc = require_dc_polyfill();
    var serializeChannel = dc.channel("apm:avsc:serialize-start");
    var deserializeChannel = dc.channel("apm:avsc:deserialize-end");
    function wrapSerialization(Type) {
      shimmer.wrap(Type.prototype, "toBuffer", (original) => function() {
        if (!serializeChannel.hasSubscribers) {
          return original.apply(this, arguments);
        }
        serializeChannel.publish({ messageClass: this });
        return original.apply(this, arguments);
      });
    }
    function wrapDeserialization(Type) {
      shimmer.wrap(Type.prototype, "fromBuffer", (original) => function() {
        if (!deserializeChannel.hasSubscribers) {
          return original.apply(this, arguments);
        }
        const result = original.apply(this, arguments);
        deserializeChannel.publish({ messageClass: result });
        return result;
      });
    }
    addHook({
      name: "avsc",
      versions: [">=5.0.0"]
    }, (avro) => {
      wrapDeserialization(avro.Type);
      wrapSerialization(avro.Type);
      return avro;
    });
  }
});

// ../../packages/datadog-instrumentations/src/helpers/promise.js
var require_promise2 = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/promise.js"(exports2) {
    "use strict";
    var { AsyncResource } = __require("async_hooks");
    exports2.wrapThen = function wrapThen(origThen) {
      return function then(onFulfilled, onRejected, onProgress) {
        const ar = new AsyncResource("bound-anonymous-fn");
        arguments[0] = wrapCallback(ar, onFulfilled);
        arguments[1] = wrapCallback(ar, onRejected);
        if (onProgress) {
          arguments[2] = wrapCallback(ar, onProgress);
        }
        return origThen.apply(this, arguments);
      };
    };
    function wrapCallback(ar, callback) {
      if (typeof callback !== "function") return callback;
      return function() {
        return ar.runInAsyncScope(() => {
          return callback.apply(this, arguments);
        });
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/bluebird.js
var require_bluebird = __commonJS({
  "../../packages/datadog-instrumentations/src/bluebird.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    function createGetNewLibraryCopyWrap(originalLib) {
      return function wrapGetNewLibraryCopy(getNewLibraryCopy) {
        return function getNewLibraryCopyWithTrace() {
          const libraryCopy = getNewLibraryCopy.apply(this, arguments);
          shimmer.wrap(libraryCopy.prototype, "_then", wrapThen);
          shimmer.wrap(libraryCopy, "getNewLibraryCopy", createGetNewLibraryCopyWrap(originalLib));
          return libraryCopy;
        };
      };
    }
    addHook({ name: "bluebird", versions: [">=2.0.2"] }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "_then", wrapThen);
      return Promise2;
    });
    addHook({ name: "bluebird", versions: ["^2.11.0", "^3.4.1"] }, (Promise2) => {
      shimmer.wrap(Promise2, "getNewLibraryCopy", createGetNewLibraryCopyWrap(Promise2));
      return Promise2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/body-parser.js
var require_body_parser = __commonJS({
  "../../packages/datadog-instrumentations/src/body-parser.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook, AsyncResource } = require_instrument();
    var bodyParserReadCh = channel("datadog:body-parser:read:finish");
    function publishRequestBodyAndNext(req, res, next) {
      return shimmer.wrapFunction(next, (next2) => function() {
        if (bodyParserReadCh.hasSubscribers && req) {
          const abortController = new AbortController();
          const body = req.body;
          bodyParserReadCh.publish({ req, res, body, abortController });
          if (abortController.signal.aborted) return;
        }
        return next2.apply(this, arguments);
      });
    }
    addHook({
      name: "body-parser",
      file: "lib/read.js",
      versions: [">=1.4.0 <1.20.0"]
    }, (read) => {
      return shimmer.wrapFunction(read, (read2) => function(req, res, next) {
        const nextResource = new AsyncResource("bound-anonymous-fn");
        arguments[2] = nextResource.bind(publishRequestBodyAndNext(req, res, next));
        return read2.apply(this, arguments);
      });
    });
    addHook({
      name: "body-parser",
      file: "lib/read.js",
      versions: [">=1.20.0"]
    }, (read) => {
      return shimmer.wrapFunction(read, (read2) => function(req, res, next) {
        arguments[2] = publishRequestBodyAndNext(req, res, next);
        return read2.apply(this, arguments);
      });
    });
  }
});

// ../../packages/datadog-instrumentations/src/bunyan.js
var require_bunyan = __commonJS({
  "../../packages/datadog-instrumentations/src/bunyan.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "bunyan", versions: [">=1"] }, (Logger) => {
      const logCh = channel("apm:bunyan:log");
      shimmer.wrap(Logger.prototype, "_emit", (emit) => {
        return function wrappedEmit(rec) {
          if (logCh.hasSubscribers) {
            const payload = { message: rec };
            logCh.publish(payload);
            arguments[0] = payload.message;
          }
          return emit.apply(this, arguments);
        };
      });
      return Logger;
    });
  }
});

// ../../packages/datadog-instrumentations/src/cassandra-driver.js
var require_cassandra_driver = __commonJS({
  "../../packages/datadog-instrumentations/src/cassandra-driver.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:cassandra-driver:query:start");
    var finishCh = channel("apm:cassandra-driver:query:finish");
    var errorCh = channel("apm:cassandra-driver:query:error");
    var connectCh = channel("apm:cassandra-driver:query:connect");
    var startCtx = {};
    addHook({ name: "cassandra-driver", versions: [">=3.0.0"] }, (cassandra) => {
      shimmer.wrap(cassandra.Client.prototype, "batch", (batch) => function(queries, options, callback) {
        if (!startCh.hasSubscribers) {
          return batch.apply(this, arguments);
        }
        const lastIndex = arguments.length - 1;
        const cb = arguments[lastIndex];
        startCtx = { keyspace: this.keyspace, query: queries, contactPoints: this.options && this.options.contactPoints };
        return startCh.runStores(startCtx, () => {
          if (typeof cb === "function") {
            arguments[lastIndex] = wrapCallback(finishCh, errorCh, startCtx, cb);
          }
          try {
            const res = batch.apply(this, arguments);
            if (typeof res === "function" || !res) {
              return wrapCallback(finishCh, errorCh, startCtx, res);
            }
            return res.then(
              () => finish(finishCh, errorCh, startCtx),
              (err) => finish(finishCh, errorCh, startCtx, err)
            );
          } catch (e) {
            finish(finishCh, errorCh, startCtx, e);
            throw e;
          }
        });
      });
      return cassandra;
    });
    addHook({ name: "cassandra-driver", versions: [">=4.4"], patchDefault: false }, (cassandra) => {
      shimmer.wrap(cassandra.Client.prototype, "_execute", (_execute) => function(query, params, execOptions, callback) {
        if (!startCh.hasSubscribers) {
          return _execute.apply(this, arguments);
        }
        startCtx = { keyspace: this.keyspace, query, contactPoints: this.options && this.options.contactPoints };
        return startCh.runStores(startCtx, () => {
          const promise = _execute.apply(this, arguments);
          promise.then(
            () => finish(finishCh, errorCh, startCtx),
            (err) => finish(finishCh, errorCh, startCtx, err)
          );
          return promise;
        });
      });
      return cassandra;
    });
    var isValid = (args) => {
      return args.length === 4 || typeof args[3] === "function";
    };
    addHook({ name: "cassandra-driver", versions: ["3 - 4.3"], patchDefault: false }, (cassandra) => {
      shimmer.wrap(
        cassandra.Client.prototype,
        "_innerExecute",
        (_innerExecute) => function(query, params, execOptions, callback) {
          if (!startCh.hasSubscribers) {
            return _innerExecute.apply(this, arguments);
          }
          if (!isValid(arguments)) {
            return _innerExecute.apply(this, arguments);
          }
          startCtx = { keyspace: this.keyspace, query, contactPoints: this.options && this.options.contactPoints };
          return startCh.runStores(startCtx, () => {
            const lastIndex = arguments.length - 1;
            const cb = arguments[lastIndex];
            if (typeof cb === "function") {
              arguments[lastIndex] = wrapCallback(finishCh, errorCh, startCtx, cb);
            }
            try {
              return _innerExecute.apply(this, arguments);
            } catch (e) {
              finish(finishCh, errorCh, startCtx, e);
              throw e;
            }
          });
        }
      );
      return cassandra;
    });
    addHook({ name: "cassandra-driver", versions: [">=3.3"], file: "lib/request-execution.js" }, (RequestExecution) => {
      shimmer.wrap(RequestExecution.prototype, "_sendOnConnection", (_sendOnConnection) => function() {
        if (!startCh.hasSubscribers) {
          return _sendOnConnection.apply(this, arguments);
        }
        startCtx = { hostname: this._connection.address, port: this._connection.port, ...startCtx };
        connectCh.publish(startCtx);
        return _sendOnConnection.apply(this, arguments);
      });
      return RequestExecution;
    });
    addHook({ name: "cassandra-driver", versions: ["3.3 - 4.3"], file: "lib/request-execution.js" }, (RequestExecution) => {
      shimmer.wrap(RequestExecution.prototype, "start", (start) => function(getHostCallback) {
        if (!startCh.hasSubscribers) {
          return getHostCallback.apply(this, arguments);
        }
        const execution = this;
        if (!isRequestValid(this, arguments, 1)) {
          return start.apply(this, arguments);
        }
        arguments[0] = function() {
          startCtx = { hostname: execution._connection.address, port: execution._connection.port, ...startCtx };
          return connectCh.runStores(startCtx, getHostCallback, this, ...arguments);
        };
        return start.apply(this, arguments);
      });
      return RequestExecution;
    });
    addHook({ name: "cassandra-driver", versions: ["3 - 3.2"], file: "lib/request-handler.js" }, (RequestHandler) => {
      shimmer.wrap(RequestHandler.prototype, "send", (send) => function(request2, options, callback) {
        if (!startCh.hasSubscribers) {
          return send.apply(this, arguments);
        }
        const handler = this;
        if (!isRequestValid(this, arguments, 3)) {
          return send.apply(this, arguments);
        }
        arguments[2] = function() {
          startCtx = { hostname: handler.connection.address, port: handler.connection.port, ...startCtx };
          return connectCh.runStores(startCtx, callback, this, ...arguments);
        };
        return send.apply(this, arguments);
      });
      return RequestHandler;
    });
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error;
        errorCh2.publish(ctx);
      }
      finishCh2.runStores(ctx, () => {
      });
    }
    function wrapCallback(finishCh2, errorCh2, ctx, callback) {
      return shimmer.wrapFunction(callback, (callback2) => function(err) {
        if (err) {
          ctx.error = err;
          errorCh2.publish(ctx);
        }
        return finishCh2.runStores(ctx, callback2, this, ...arguments);
      });
    }
    function isRequestValid(exec, args, length) {
      if (!exec) return false;
      if (args.length !== length || typeof args[length - 1] !== "function") return false;
      return true;
    }
  }
});

// ../../packages/datadog-instrumentations/src/child_process.js
var require_child_process = __commonJS({
  "../../packages/datadog-instrumentations/src/child_process.js"() {
    "use strict";
    var { errorMonitor } = __require("events");
    var util = __require("util");
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var childProcessChannel = dc.tracingChannel("datadog:child_process:execution");
    var execAsyncMethods = ["execFile", "spawn"];
    var names = ["child_process", "node:child_process"];
    var patched = false;
    function throwSyncError(error) {
      throw error;
    }
    function returnSpawnSyncError(error, context2) {
      context2.result = {
        error,
        status: null,
        signal: null,
        output: null,
        stdout: null,
        stderr: null,
        pid: 0
      };
      return context2.result;
    }
    names.forEach((name) => {
      addHook({ name }, (childProcess) => {
        if (!patched) {
          patched = true;
          shimmer.massWrap(childProcess, execAsyncMethods, wrapChildProcessAsyncMethod(childProcess.ChildProcess));
          shimmer.wrap(childProcess, "execSync", wrapChildProcessSyncMethod(throwSyncError, true));
          shimmer.wrap(childProcess, "execFileSync", wrapChildProcessSyncMethod(throwSyncError));
          shimmer.wrap(childProcess, "spawnSync", wrapChildProcessSyncMethod(returnSpawnSyncError));
        }
        return childProcess;
      });
    });
    function normalizeArgs(args, shell) {
      const childProcessInfo = {
        command: args[0],
        file: args[0]
      };
      if (Array.isArray(args[1])) {
        childProcessInfo.command = childProcessInfo.command + " " + args[1].join(" ");
        childProcessInfo.fileArgs = args[1];
        if (args[2] !== null && typeof args[2] === "object") {
          childProcessInfo.options = args[2];
        }
      } else if (args[1] !== null && typeof args[1] === "object") {
        childProcessInfo.options = args[1];
      }
      childProcessInfo.shell = shell || childProcessInfo.options?.shell === true || typeof childProcessInfo.options?.shell === "string";
      return childProcessInfo;
    }
    function createContextFromChildProcessInfo(childProcessInfo) {
      const context2 = {
        command: childProcessInfo.command,
        file: childProcessInfo.file,
        shell: childProcessInfo.shell,
        abortController: new AbortController()
      };
      if (childProcessInfo.fileArgs) {
        context2.fileArgs = childProcessInfo.fileArgs;
      }
      return context2;
    }
    function wrapChildProcessSyncMethod(returnError, shell = false) {
      return function wrapMethod(childProcessMethod) {
        return function() {
          if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
            return childProcessMethod.apply(this, arguments);
          }
          const childProcessInfo = normalizeArgs(arguments, shell);
          const context2 = createContextFromChildProcessInfo(childProcessInfo);
          return childProcessChannel.start.runStores(context2, () => {
            try {
              if (context2.abortController.signal.aborted) {
                const error = context2.abortController.signal.reason || new Error("Aborted");
                return returnError(error, context2);
              }
              const result = childProcessMethod.apply(this, arguments);
              context2.result = result;
              return result;
            } catch (err) {
              context2.error = err;
              childProcessChannel.error.publish(context2);
              throw err;
            } finally {
              childProcessChannel.end.publish(context2);
            }
          });
        };
      };
    }
    function wrapChildProcessCustomPromisifyMethod(customPromisifyMethod, shell) {
      return function() {
        if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
          return customPromisifyMethod.apply(this, arguments);
        }
        const childProcessInfo = normalizeArgs(arguments, shell);
        const context2 = createContextFromChildProcessInfo(childProcessInfo);
        const { start, end, asyncStart, asyncEnd, error } = childProcessChannel;
        start.publish(context2);
        let result;
        if (context2.abortController.signal.aborted) {
          result = Promise.reject(context2.abortController.signal.reason || new Error("Aborted"));
        } else {
          try {
            result = customPromisifyMethod.apply(this, arguments);
          } catch (error2) {
            context2.error = error2;
            error2.publish(context2);
            throw error2;
          } finally {
            end.publish(context2);
          }
        }
        function reject(err) {
          context2.error = err;
          error.publish(context2);
          asyncStart.publish(context2);
          asyncEnd.publish(context2);
          return Promise.reject(err);
        }
        function resolve(result2) {
          context2.result = result2;
          asyncStart.publish(context2);
          asyncEnd.publish(context2);
          return result2;
        }
        return Promise.resolve(result).then(resolve, reject);
      };
    }
    function wrapChildProcessAsyncMethod(ChildProcess, shell = false) {
      return function wrapMethod(childProcessMethod) {
        function wrappedChildProcessMethod() {
          if (!childProcessChannel.start.hasSubscribers || arguments.length === 0) {
            return childProcessMethod.apply(this, arguments);
          }
          const childProcessInfo = normalizeArgs(arguments, shell);
          const context2 = createContextFromChildProcessInfo(childProcessInfo);
          return childProcessChannel.start.runStores(context2, () => {
            let childProcess;
            if (context2.abortController.signal.aborted) {
              childProcess = new ChildProcess();
              childProcess.on("error", () => {
              });
              process.nextTick(() => {
                const error = context2.abortController.signal.reason || new Error("Aborted");
                childProcess.emit("error", error);
                const cb = arguments[arguments.length - 1];
                if (typeof cb === "function") {
                  cb(error);
                }
                childProcess.emit("close");
              });
            } else {
              childProcess = childProcessMethod.apply(this, arguments);
            }
            if (childProcess) {
              let errorExecuted = false;
              childProcess.on(errorMonitor, (e) => {
                errorExecuted = true;
                context2.error = e;
                childProcessChannel.error.publish(context2);
              });
              childProcess.on("close", (code = 0) => {
                if (!errorExecuted && code !== 0) {
                  childProcessChannel.error.publish(context2);
                }
                context2.result = code;
                childProcessChannel.asyncEnd.publish(context2);
              });
            }
            return childProcess;
          });
        }
        if (childProcessMethod[util.promisify.custom]) {
          const wrapedChildProcessCustomPromisifyMethod = shimmer.wrapFunction(
            childProcessMethod[util.promisify.custom],
            (promisify) => wrapChildProcessCustomPromisifyMethod(promisify, shell)
          );
          const descriptor = Object.getOwnPropertyDescriptor(childProcessMethod, util.promisify.custom);
          Object.defineProperty(
            wrappedChildProcessMethod,
            util.promisify.custom,
            {
              ...descriptor,
              value: wrapedChildProcessCustomPromisifyMethod
            }
          );
        }
        return wrappedChildProcessMethod;
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/connect.js
var require_connect = __commonJS({
  "../../packages/datadog-instrumentations/src/connect.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var enterChannel = channel("apm:connect:middleware:enter");
    var exitChannel = channel("apm:connect:middleware:exit");
    var errorChannel = channel("apm:connect:middleware:error");
    var nextChannel = channel("apm:connect:middleware:next");
    var finishChannel = channel("apm:connect:middleware:finish");
    var handleChannel = channel("apm:connect:request:handle");
    function wrapConnect(connect) {
      if (typeof connect !== "function") return connect;
      return function connectWithTrace() {
        const app = connect();
        if (!app) return app;
        shimmer.wrap(app, "use", wrapUse);
        shimmer.wrap(app, "handle", wrapHandle);
        return app;
      };
    }
    function wrapUse(use) {
      if (typeof use !== "function") return use;
      return function useWithTrace(route, fn) {
        const result = use.apply(this, arguments);
        if (!this || !Array.isArray(this.stack)) return result;
        const index = this.stack.length - 1;
        const layer = this.stack[index];
        if (layer && layer.handle) {
          this.stack[index].handle = wrapLayerHandle(layer);
        }
        return result;
      };
    }
    function wrapHandle(handle) {
      return function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req, res });
        }
        return handle.apply(this, arguments);
      };
    }
    function wrapLayerHandle(layer) {
      if (typeof layer.handle !== "function") return layer.handle;
      const original = layer.handle;
      return shimmer.wrapFunction(original, (original2) => function() {
        if (!enterChannel.hasSubscribers) return original2.apply(this, arguments);
        const lastIndex = arguments.length - 1;
        const name = original2._name || original2.name;
        const req = arguments[arguments.length > 3 ? 1 : 0];
        const next = arguments[lastIndex];
        if (typeof next === "function") {
          arguments[lastIndex] = wrapNext(req, next);
        }
        const route = layer.route;
        enterChannel.publish({ name, req, route });
        try {
          return original2.apply(this, arguments);
        } catch (error) {
          errorChannel.publish({ req, error });
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          throw error;
        } finally {
          exitChannel.publish({ req });
        }
      });
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(next, (next2) => function(error) {
        if (error) {
          errorChannel.publish({ req, error });
        }
        nextChannel.publish({ req });
        finishChannel.publish({ req });
        next2.apply(this, arguments);
      });
    }
    addHook({ name: "connect", versions: [">=3.4.0"] }, (connect) => {
      return shimmer.wrapFunction(connect, (connect2) => wrapConnect(connect2));
    });
    addHook({ name: "connect", versions: [">=3 <3.4.0"], file: "lib/connect.js" }, (connect) => {
      return shimmer.wrapFunction(connect, (connect2) => wrapConnect(connect2));
    });
    addHook({ name: "connect", versions: ["2.2.2"], file: "lib/connect.js" }, (connect) => {
      shimmer.wrap(connect.proto, "use", wrapUse);
      shimmer.wrap(connect.proto, "handle", wrapHandle);
      return connect;
    });
  }
});

// ../../packages/datadog-instrumentations/src/cookie.js
var require_cookie = __commonJS({
  "../../packages/datadog-instrumentations/src/cookie.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var cookieParseCh = channel("datadog:cookie:parse:finish");
    function wrapParse(originalParse) {
      return function() {
        const cookies = originalParse.apply(this, arguments);
        if (cookieParseCh.hasSubscribers && cookies) {
          cookieParseCh.publish({ cookies });
        }
        return cookies;
      };
    }
    addHook({ name: "cookie", versions: [">=0.4"] }, (cookie) => {
      shimmer.wrap(cookie, "parse", wrapParse);
      return cookie;
    });
  }
});

// ../../packages/datadog-instrumentations/src/cookie-parser.js
var require_cookie_parser = __commonJS({
  "../../packages/datadog-instrumentations/src/cookie-parser.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var cookieParserReadCh = channel("datadog:cookie-parser:read:finish");
    function publishRequestCookieAndNext(req, res, next) {
      return shimmer.wrapFunction(next, (next2) => function cookieParserWrapper() {
        if (cookieParserReadCh.hasSubscribers && req) {
          const abortController = new AbortController();
          const mergedCookies = { ...req.cookies, ...req.signedCookies };
          cookieParserReadCh.publish({ req, res, abortController, cookies: mergedCookies });
          if (abortController.signal.aborted) return;
        }
        return next2.apply(this, arguments);
      });
    }
    addHook({
      name: "cookie-parser",
      versions: [">=1.0.0"]
    }, (cookieParser) => {
      if (cookieParser.default) return cookieParser;
      return shimmer.wrapFunction(cookieParser, (cookieParser2) => function() {
        const cookieMiddleware = cookieParser2.apply(this, arguments);
        return shimmer.wrapFunction(cookieMiddleware, (cookieMiddleware2) => function(req, res, next) {
          arguments[2] = publishRequestCookieAndNext(req, res, next);
          return cookieMiddleware2.apply(this, arguments);
        });
      });
    });
  }
});

// ../../packages/datadog-instrumentations/src/couchbase.js
var require_couchbase = __commonJS({
  "../../packages/datadog-instrumentations/src/couchbase.js"() {
    "use strict";
    var { errorMonitor } = __require("events");
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function findCallbackIndex(args, lowerbound = 2) {
      for (let i = args.length - 1; i >= lowerbound; i--) {
        if (typeof args[i] === "function") return i;
      }
      return -1;
    }
    function getQueryResource(q) {
      return q && (typeof q === "string" ? q : q.statement);
    }
    function wrapAllNames(names, action) {
      names.forEach((name) => action(name));
    }
    function wrapCallback(callback, ctx, channelPrefix) {
      const callbackStartCh = channel(`${channelPrefix}:callback:start`);
      const callbackFinishCh = channel(`${channelPrefix}:callback:finish`);
      const wrapped = callbackStartCh.runStores(ctx, () => {
        return function(...args) {
          return callbackFinishCh.runStores(ctx, () => {
            return callback.apply(this, args);
          });
        };
      });
      Object.defineProperty(wrapped, "_dd_wrapped", { value: true });
      return wrapped;
    }
    function wrapQuery(query) {
      return function(q, params, callback) {
        const cb = arguments[arguments.length - 1];
        if (typeof cb === "function") {
          const ctx = {};
          arguments[arguments.length - 1] = wrapCallback(cb, ctx, "apm:couchbase:query");
        }
        return query.apply(this, arguments);
      };
    }
    function wrapCallbackFinish(callback, thisArg, _args, errorCh, finishCh, ctx, channelPrefix) {
      const callbackStartCh = channel(`${channelPrefix}:callback:start`);
      const callbackFinishCh = channel(`${channelPrefix}:callback:finish`);
      const wrapped = callbackStartCh.runStores(ctx, () => {
        return function finish(error, result) {
          return callbackFinishCh.runStores(ctx, () => {
            if (error) {
              ctx.error = error;
              errorCh.publish(ctx);
            }
            finishCh.publish(ctx);
            return callback.apply(thisArg, [error, result]);
          });
        };
      });
      Object.defineProperty(wrapped, "_dd_wrapped", { value: true });
      return wrapped;
    }
    function wrap(prefix, fn) {
      const startCh = channel(prefix + ":start");
      const finishCh = channel(prefix + ":finish");
      const errorCh = channel(prefix + ":error");
      const wrapped = function() {
        if (!startCh.hasSubscribers) {
          return fn.apply(this, arguments);
        }
        const callbackIndex = findCallbackIndex(arguments, 1);
        if (callbackIndex < 0) return fn.apply(this, arguments);
        const ctx = { bucket: { name: this.name || this._name }, seedNodes: this._dd_hosts };
        return startCh.runStores(ctx, () => {
          const cb = arguments[callbackIndex];
          arguments[callbackIndex] = shimmer.wrapFunction(cb, (cb2) => {
            return wrapCallbackFinish(cb2, this, arguments, errorCh, finishCh, ctx, prefix);
          });
          try {
            return fn.apply(this, arguments);
          } catch (error) {
            ctx.error = error;
            error.stack;
            errorCh.publish(ctx);
            throw error;
          }
        });
      };
      return wrapped;
    }
    function wrapMaybeInvoke(_maybeInvoke, channelPrefix) {
      return function(fn, args) {
        if (!Array.isArray(args)) return _maybeInvoke.apply(this, arguments);
        const callbackIndex = findCallbackIndex(args, 0);
        if (callbackIndex === -1) return _maybeInvoke.apply(this, arguments);
        const callback = args[callbackIndex];
        if (typeof callback === "function" && !callback._dd_wrapped) {
          const ctx = {};
          args[callbackIndex] = wrapCallback(callback, ctx, channelPrefix);
        }
        return _maybeInvoke.apply(this, arguments);
      };
    }
    function wrapCBandPromise(fn, name, startData, thisArg, args) {
      const startCh = channel(`apm:couchbase:${name}:start`);
      const finishCh = channel(`apm:couchbase:${name}:finish`);
      const errorCh = channel(`apm:couchbase:${name}:error`);
      if (!startCh.hasSubscribers) return fn.apply(thisArg, args);
      const ctx = startData;
      return startCh.runStores(ctx, () => {
        try {
          const cbIndex = findCallbackIndex(args, 1);
          if (cbIndex >= 0) {
            args[cbIndex] = shimmer.wrapFunction(args[cbIndex], (cb) => {
              return wrapCallbackFinish(cb, thisArg, args, errorCh, finishCh, ctx, `apm:couchbase:${name}`);
            });
          }
          const res = fn.apply(thisArg, args);
          res.then(
            (result) => {
              ctx.result = result;
              finishCh.publish(ctx);
            },
            (err) => {
              ctx.error = err;
              errorCh.publish(ctx);
              finishCh.publish(ctx);
            }
          );
          return res;
        } catch (e) {
          e.stack;
          ctx.error = e;
          errorCh.publish(ctx);
          throw e;
        }
      });
    }
    function wrapWithName(name) {
      return function(operation) {
        return function() {
          return wrapCBandPromise(operation, name, {
            collection: { name: this._name || "_default" },
            bucket: { name: this._scope._bucket._name },
            seedNodes: this._dd_connStr
          }, this, arguments);
        };
      };
    }
    function wrapV3Query(query) {
      return function(q) {
        const resource = getQueryResource(q);
        return wrapCBandPromise(query, "query", { resource, seedNodes: this._connStr }, this, arguments);
      };
    }
    addHook({ name: "couchbase", file: "lib/bucket.js", versions: ["^2.6.12"] }, (Bucket) => {
      shimmer.wrap(Bucket.prototype, "_maybeInvoke", (maybeInvoke) => {
        return wrapMaybeInvoke(maybeInvoke, "apm:couchbase:bucket:maybeInvoke");
      });
      const startCh = channel("apm:couchbase:query:start");
      const finishCh = channel("apm:couchbase:query:finish");
      const errorCh = channel("apm:couchbase:query:error");
      shimmer.wrap(Bucket.prototype, "query", (query) => wrapQuery(query));
      shimmer.wrap(Bucket.prototype, "_n1qlReq", (_n1qlReq) => function(host, q, adhoc, emitter) {
        if (!startCh.hasSubscribers) {
          return _n1qlReq.apply(this, arguments);
        }
        if (!emitter || !emitter.once) return _n1qlReq.apply(this, arguments);
        const n1qlQuery = getQueryResource(q);
        const ctx = { resource: n1qlQuery, bucket: { name: this.name || this._name }, seedNodes: this._dd_hosts };
        return startCh.runStores(ctx, () => {
          emitter.once("rows", () => {
            finishCh.publish(ctx);
          });
          emitter.once(errorMonitor, (error) => {
            if (!error) return;
            ctx.error = error;
            errorCh.publish(ctx);
            finishCh.publish(ctx);
          });
          try {
            return _n1qlReq.apply(this, arguments);
          } catch (err) {
            err.stack;
            ctx.error = err;
            errorCh.publish(ctx);
            throw err;
          }
        });
      });
      wrapAllNames(["upsert", "insert", "replace", "append", "prepend"], (name) => {
        shimmer.wrap(Bucket.prototype, name, (fn) => wrap(`apm:couchbase:${name}`, fn));
      });
      return Bucket;
    });
    addHook({ name: "couchbase", file: "lib/cluster.js", versions: ["^2.6.12"] }, (Cluster) => {
      shimmer.wrap(Cluster.prototype, "_maybeInvoke", (maybeInvoke) => {
        return wrapMaybeInvoke(maybeInvoke, "apm:couchbase:cluster:maybeInvoke");
      });
      shimmer.wrap(Cluster.prototype, "query", (query) => wrapQuery(query));
      shimmer.wrap(Cluster.prototype, "openBucket", (openBucket) => {
        return function() {
          const bucket = openBucket.apply(this, arguments);
          const hosts = this.dsnObj.hosts;
          bucket._dd_hosts = hosts.map((hostAndPort) => hostAndPort.join(":")).join(",");
          return bucket;
        };
      });
      return Cluster;
    });
    addHook({ name: "couchbase", file: "lib/bucket.js", versions: ["^3.0.7", "^3.1.3"] }, (Bucket) => {
      shimmer.wrap(Bucket.prototype, "collection", (getCollection) => {
        return function() {
          const collection = getCollection.apply(this, arguments);
          const connStr = this._cluster._connStr;
          collection._dd_connStr = connStr;
          return collection;
        };
      });
      return Bucket;
    });
    addHook({ name: "couchbase", file: "lib/collection.js", versions: ["^3.0.7", "^3.1.3"] }, (Collection) => {
      wrapAllNames(["upsert", "insert", "replace"], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name));
      });
      return Collection;
    });
    addHook({ name: "couchbase", file: "lib/cluster.js", versions: ["^3.0.7", "^3.1.3"] }, (Cluster) => {
      shimmer.wrap(Cluster.prototype, "query", wrapV3Query);
      return Cluster;
    });
    addHook({ name: "couchbase", file: "dist/collection.js", versions: [">=3.2.2"] }, (collection) => {
      const Collection = collection.Collection;
      wrapAllNames(["upsert", "insert", "replace"], (name) => {
        shimmer.wrap(Collection.prototype, name, wrapWithName(name));
      });
      return collection;
    });
    addHook({ name: "couchbase", file: "dist/bucket.js", versions: [">=3.2.2"] }, (bucket) => {
      const Bucket = bucket.Bucket;
      shimmer.wrap(Bucket.prototype, "collection", (getCollection) => {
        return function() {
          const collection = getCollection.apply(this, arguments);
          const connStr = this._cluster._connStr;
          collection._dd_connStr = connStr;
          return collection;
        };
      });
      return bucket;
    });
    addHook({ name: "couchbase", file: "dist/cluster.js", versions: [">=3.2.2"] }, (cluster) => {
      const Cluster = cluster.Cluster;
      shimmer.wrap(Cluster.prototype, "query", wrapV3Query);
      return cluster;
    });
  }
});

// ../../packages/datadog-instrumentations/src/crypto.js
var require_crypto = __commonJS({
  "../../packages/datadog-instrumentations/src/crypto.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var cryptoHashCh = channel("datadog:crypto:hashing:start");
    var cryptoCipherCh = channel("datadog:crypto:cipher:start");
    var hashMethods = ["createHash", "createHmac", "createSign", "createVerify", "sign", "verify"];
    var cipherMethods = ["createCipheriv", "createDecipheriv"];
    var names = ["crypto", "node:crypto"];
    addHook({ name: names }, (crypto) => {
      shimmer.massWrap(crypto, hashMethods, wrapCryptoMethod(cryptoHashCh));
      shimmer.massWrap(crypto, cipherMethods, wrapCryptoMethod(cryptoCipherCh));
      return crypto;
    });
    function wrapCryptoMethod(channel2) {
      function wrapMethod(cryptoMethod) {
        return function() {
          if (channel2.hasSubscribers && arguments.length > 0) {
            const algorithm = arguments[0];
            channel2.publish({ algorithm });
          }
          return cryptoMethod.apply(this, arguments);
        };
      }
      return wrapMethod;
    }
  }
});

// ../../packages/datadog-instrumentations/src/cypress.js
var require_cypress = __commonJS({
  "../../packages/datadog-instrumentations/src/cypress.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { DD_MAJOR } = require_version2();
    addHook({
      name: "cypress",
      versions: DD_MAJOR >= 6 ? [">=10.2.0"] : [">=6.7.0"]
    }, (lib) => lib);
  }
});

// ../../packages/datadog-instrumentations/src/dd-trace-api.js
var require_dd_trace_api = __commonJS({
  "../../packages/datadog-instrumentations/src/dd-trace-api.js"() {
    "use strict";
    var { addHook } = require_instrument();
    addHook({ name: "dd-trace-api" }, (api) => api);
  }
});

// ../../packages/datadog-instrumentations/src/dns.js
var require_dns = __commonJS({
  "../../packages/datadog-instrumentations/src/dns.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var rrtypes = {
      resolveAny: "ANY",
      resolve4: "A",
      resolve6: "AAAA",
      resolveCname: "CNAME",
      resolveMx: "MX",
      resolveNs: "NS",
      resolveTxt: "TXT",
      resolveSrv: "SRV",
      resolvePtr: "PTR",
      resolveNaptr: "NAPTR",
      resolveSoa: "SOA"
    };
    var rrtypeMap = /* @__PURE__ */ new WeakMap();
    var names = ["dns", "node:dns"];
    addHook({ name: names }, (dns) => {
      shimmer.wrap(dns, "lookup", (fn) => wrap("apm:dns:lookup", fn, 2));
      shimmer.wrap(dns, "lookupService", (fn) => wrap("apm:dns:lookup_service", fn, 2));
      shimmer.wrap(dns, "resolve", (fn) => wrap("apm:dns:resolve", fn, 2));
      shimmer.wrap(dns, "reverse", (fn) => wrap("apm:dns:reverse", fn, 2));
      patchResolveShorthands(dns);
      if (dns.Resolver) {
        shimmer.wrap(dns.Resolver.prototype, "resolve", (fn) => wrap("apm:dns:resolve", fn, 2));
        shimmer.wrap(dns.Resolver.prototype, "reverse", (fn) => wrap("apm:dns:reverse", fn, 2));
        patchResolveShorthands(dns.Resolver.prototype);
      }
      return dns;
    });
    function patchResolveShorthands(prototype) {
      for (const method of Object.keys(rrtypes)) {
        if (prototype[method]) {
          rrtypeMap.set(prototype[method], rrtypes[method]);
          shimmer.wrap(prototype, method, (fn) => wrap("apm:dns:resolve", fn, 2, rrtypes[method]));
        }
      }
    }
    function wrap(prefix, fn, expectedArgs, rrtype) {
      const startCh = channel(prefix + ":start");
      const finishCh = channel(prefix + ":finish");
      const errorCh = channel(prefix + ":error");
      const wrapped = function() {
        const cb = arguments[arguments.length - 1];
        if (!startCh.hasSubscribers || arguments.length < expectedArgs || typeof cb !== "function") {
          return fn.apply(this, arguments);
        }
        const args = [...arguments];
        args.pop();
        if (rrtype) {
          args.push(rrtype);
        }
        const ctx = { args };
        return startCh.runStores(ctx, () => {
          arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function(error, result, ...args2) {
            if (error) {
              ctx.error = error;
              errorCh.publish(ctx);
            }
            ctx.result = result;
            finishCh.runStores(ctx, cb2, this, error, result, ...args2);
          });
          try {
            return fn.apply(this, arguments);
          } catch (error) {
            error.stack;
            ctx.error = error;
            errorCh.publish(ctx);
            throw error;
          }
        });
      };
      return wrapped;
    }
  }
});

// ../../node_modules/path-to-regexp/index.js
var require_path_to_regexp = __commonJS({
  "../../node_modules/path-to-regexp/index.js"(exports2, module2) {
    module2.exports = pathToRegexp;
    var MATCHING_GROUP_REGEXP = /\\.|\((?:\?<(.*?)>)?(?!\?)/g;
    function pathToRegexp(path, keys, options) {
      options = options || {};
      keys = keys || [];
      var strict = options.strict;
      var end = options.end !== false;
      var flags = options.sensitive ? "" : "i";
      var lookahead = options.lookahead !== false;
      var extraOffset = 0;
      var keysOffset = keys.length;
      var i = 0;
      var name = 0;
      var pos = 0;
      var backtrack = "";
      var m;
      if (path instanceof RegExp) {
        while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {
          if (m[0][0] === "\\") continue;
          keys.push({
            name: m[1] || name++,
            optional: false,
            offset: m.index
          });
        }
        return path;
      }
      if (Array.isArray(path)) {
        path = path.map(function(value) {
          return pathToRegexp(value, keys, options).source;
        });
        return new RegExp(path.join("|"), flags);
      }
      if (typeof path !== "string") {
        throw new TypeError("path must be a string, array of strings, or regular expression");
      }
      path = path.replace(
        /\\.|(\/)?(\.)?:(\w+)(\(.*?\))?(\*)?(\?)?|[.*]|\/\(/g,
        function(match, slash, format, key, capture, star, optional, offset) {
          if (match[0] === "\\") {
            backtrack += match;
            pos += 2;
            return match;
          }
          if (match === ".") {
            backtrack += "\\.";
            extraOffset += 1;
            pos += 1;
            return "\\.";
          }
          if (slash || format) {
            backtrack = "";
          } else {
            backtrack += path.slice(pos, offset);
          }
          pos = offset + match.length;
          if (match === "*") {
            extraOffset += 3;
            return "(.*)";
          }
          if (match === "/(") {
            backtrack += "/";
            extraOffset += 2;
            return "/(?:";
          }
          slash = slash || "";
          format = format ? "\\." : "";
          optional = optional || "";
          capture = capture ? capture.replace(/\\.|\*/, function(m2) {
            return m2 === "*" ? "(.*)" : m2;
          }) : backtrack ? "((?:(?!/|" + backtrack + ").)+?)" : "([^/" + format + "]+?)";
          keys.push({
            name: key,
            optional: !!optional,
            offset: offset + extraOffset
          });
          var result = "(?:" + format + slash + capture + (star ? "((?:[/" + format + "].+?)?)" : "") + ")" + optional;
          extraOffset += result.length - match.length;
          return result;
        }
      );
      while (m = MATCHING_GROUP_REGEXP.exec(path)) {
        if (m[0][0] === "\\") continue;
        if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {
          keys.splice(keysOffset + i, 0, {
            name: name++,
            // Unnamed matching groups must be consistently linear.
            optional: false,
            offset: m.index
          });
        }
        i++;
      }
      path += strict ? "" : path[path.length - 1] === "/" ? "?" : "/?";
      if (end) {
        path += "$";
      } else if (path[path.length - 1] !== "/") {
        path += lookahead ? "(?=/|$)" : "(?:/|$)";
      }
      return new RegExp("^" + path, flags);
    }
  }
});

// ../../packages/datadog-instrumentations/src/helpers/router-helper.js
var require_router_helper = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/router-helper.js"(exports2, module2) {
    "use strict";
    var { channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var routerMountPaths = /* @__PURE__ */ new WeakMap();
    var layerMatchers = /* @__PURE__ */ new WeakMap();
    var appMountedRouters = /* @__PURE__ */ new WeakSet();
    var METHODS2 = [...__require("http").METHODS.map((v) => v.toLowerCase()), "all"];
    var routeAddedChannel = channel("apm:express:route:added");
    function joinPath(base, path) {
      if (!base || base === "/") return path || "/";
      if (!path || path === "/") return base;
      if (path !== "" && !path.startsWith("/")) return null;
      if (!base.startsWith("/")) return null;
      if (base.endsWith("/") && path.startsWith("/")) {
        return base + path.slice(1);
      }
      return base + path;
    }
    function normalizeRoutePath(path) {
      if (path == null) return null;
      if (typeof path === "string") return path;
      if (path instanceof RegExp) return path.toString();
      return String(path);
    }
    function collectRoutesFromRouter(router, prefix) {
      if (!router?.stack?.length) return;
      for (const layer of router.stack) {
        if (layer.route) {
          const route = layer.route;
          const fullPaths = getRouteFullPaths(route, prefix);
          for (const fullPath of fullPaths) {
            for (const [method, enabled] of Object.entries(route.methods || {})) {
              if (!enabled) continue;
              routeAddedChannel.publish({
                method: normalizeMethodName(method),
                path: fullPath
              });
            }
          }
        } else if (layer.handle?.stack?.length) {
          const mountPath = typeof layer.path === "string" ? layer.path : getLayerMatchers(layer)?.[0]?.path || "";
          const nestedPrefix = joinPath(prefix, mountPath);
          if (nestedPrefix === null) continue;
          setRouterMountPath(layer.handle, nestedPrefix);
          markAppMounted(layer.handle);
          collectRoutesFromRouter(layer.handle, nestedPrefix);
        }
      }
    }
    function normalizeRoutePaths(path) {
      if (path == null) return [];
      if (Array.isArray(path) === false) {
        const normalized = normalizeRoutePath(path);
        return [normalized];
      }
      const paths = path.flat(Infinity);
      const result = [];
      for (const _path of paths) {
        const normalized = normalizeRoutePath(_path);
        if (normalized !== null) {
          result.push(normalized);
        }
      }
      return result;
    }
    function setRouterMountPath(router, mountPath) {
      if (!router || typeof mountPath !== "string") return;
      const existing = routerMountPaths.get(router);
      if (existing) {
        existing.add(mountPath);
      } else {
        routerMountPaths.set(router, /* @__PURE__ */ new Set([mountPath]));
      }
    }
    function getRouterMountPaths(router) {
      const paths = routerMountPaths.get(router);
      if (!paths) return [];
      return [...paths];
    }
    function setLayerMatchers(layer, matchers) {
      layerMatchers.set(layer, matchers);
    }
    function getLayerMatchers(layer) {
      return layerMatchers.get(layer);
    }
    function normalizeMethodName(method) {
      return method === "_all" || method === "all" ? "*" : method;
    }
    function getRouteFullPaths(route, prefix) {
      if (!route) return [];
      const routePaths = normalizeRoutePaths(route.path);
      const pathsToPublish = routePaths.length ? routePaths : [""];
      return pathsToPublish.map((routePath) => joinPath(prefix, routePath)).filter((path) => path !== null);
    }
    function markAppMounted(router) {
      if (router) appMountedRouters.add(router);
    }
    function isAppMounted(router) {
      return appMountedRouters.has(router);
    }
    function extractMountPaths(path) {
      const hasMount = typeof path === "string" || path instanceof RegExp || Array.isArray(path);
      if (!hasMount) {
        return { mountPaths: ["/"], startIdx: 0 };
      }
      const paths = normalizeRoutePaths(path);
      return {
        mountPaths: paths.length ? paths : ["/"],
        startIdx: 1
      };
    }
    function hasRouterCycle(router, stack = /* @__PURE__ */ new Set()) {
      if (!router?.stack?.length) return false;
      if (stack.has(router)) return true;
      stack.add(router);
      for (const layer of router.stack) {
        if (!layer?.route && layer?.handle?.stack?.length) {
          const hasCycle = hasRouterCycle(layer.handle, stack);
          if (hasCycle) {
            return true;
          }
        }
      }
      stack.delete(router);
      return false;
    }
    function wrapRouteMethodsAndPublish(route, paths, publish) {
      if (!route || !paths.length) return;
      const filteredPaths = paths.filter(Boolean);
      if (!filteredPaths.length) return;
      const uniquePaths = new Set(filteredPaths);
      METHODS2.forEach((method) => {
        if (typeof route[method] !== "function") return;
        shimmer.wrap(route, method, (originalMethod) => function wrappedRouteMethod(...args) {
          const normalizedMethod = normalizeMethodName(method);
          for (const path of uniquePaths) {
            publish({
              method: normalizedMethod,
              path
            });
          }
          return originalMethod.apply(this, args);
        });
      });
    }
    module2.exports = {
      setRouterMountPath,
      getRouterMountPaths,
      joinPath,
      setLayerMatchers,
      getLayerMatchers,
      markAppMounted,
      isAppMounted,
      normalizeRoutePath,
      normalizeRoutePaths,
      getRouteFullPaths,
      wrapRouteMethodsAndPublish,
      extractMountPaths,
      hasRouterCycle,
      collectRoutesFromRouter
    };
  }
});

// ../../packages/datadog-instrumentations/src/router.js
var require_router = __commonJS({
  "../../packages/datadog-instrumentations/src/router.js"(exports2, module2) {
    "use strict";
    var METHODS2 = [...__require("http").METHODS.map((v) => v.toLowerCase()), "all"];
    var pathToRegExp = require_path_to_regexp();
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var {
      getRouterMountPaths,
      joinPath,
      getLayerMatchers,
      setLayerMatchers,
      isAppMounted,
      setRouterMountPath,
      extractMountPaths,
      getRouteFullPaths,
      wrapRouteMethodsAndPublish,
      collectRoutesFromRouter
    } = require_router_helper();
    function isFastStar(layer, matchers) {
      return layer.regexp?.fast_star ?? matchers.some((matcher) => matcher.path === "*");
    }
    function isFastSlash(layer, matchers) {
      return layer.regexp?.fast_slash ?? matchers.some((matcher) => matcher.path === "/");
    }
    function createWrapRouterMethod(name) {
      const enterChannel = channel(`apm:${name}:middleware:enter`);
      const exitChannel = channel(`apm:${name}:middleware:exit`);
      const finishChannel = channel(`apm:${name}:middleware:finish`);
      const errorChannel = channel(`apm:${name}:middleware:error`);
      const nextChannel = channel(`apm:${name}:middleware:next`);
      const routeAddedChannel = channel(`apm:${name}:route:added`);
      const regexpCache = /* @__PURE__ */ Object.create(null);
      function wrapLayerHandle(layer, original) {
        original._name = original._name || layer.name;
        return shimmer.wrapFunction(original, (original2) => function() {
          if (!enterChannel.hasSubscribers) return original2.apply(this, arguments);
          const matchers = getLayerMatchers(layer);
          const lastIndex = arguments.length - 1;
          const name2 = original2._name || original2.name;
          const req = arguments[arguments.length > 3 ? 1 : 0];
          const next = arguments[lastIndex];
          if (typeof next === "function") {
            arguments[lastIndex] = wrapNext(req, next);
          }
          let route;
          if (matchers) {
            for (const matcher of matchers) {
              if (matcher.test(layer)) {
                route = matcher.path;
                break;
              }
            }
          }
          enterChannel.publish({ name: name2, req, route, layer });
          try {
            return original2.apply(this, arguments);
          } catch (error) {
            errorChannel.publish({ req, error });
            nextChannel.publish({ req });
            finishChannel.publish({ req });
            throw error;
          } finally {
            exitChannel.publish({ req });
          }
        });
      }
      function wrapStack(layers, matchers) {
        for (const layer of layers) {
          if (layer.__handle) {
            layer.__handle = wrapLayerHandle(layer, layer.__handle);
          } else {
            layer.handle = wrapLayerHandle(layer, layer.handle);
          }
          setLayerMatchers(layer, matchers);
          if (layer.route) {
            METHODS2.forEach((method) => {
              if (typeof layer.route.stack === "function") {
                layer.route.stack = [{ handle: layer.route.stack }];
              }
              layer.route[method] = wrapMethod(layer.route[method]);
            });
          }
        }
      }
      function wrapNext(req, next) {
        return shimmer.wrapFunction(next, (next2) => function(error) {
          if (error && error !== "route" && error !== "router") {
            errorChannel.publish({ req, error });
          }
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          next2.apply(this, arguments);
        });
      }
      function extractMatchers(fn) {
        const arg = Array.isArray(fn) ? fn.flat(Infinity) : [fn];
        if (typeof arg[0] === "function") {
          return [];
        }
        return arg.map((pattern) => ({
          path: pattern instanceof RegExp ? `(${pattern})` : pattern,
          test: (layer) => {
            const matchers = getLayerMatchers(layer);
            return !isFastStar(layer, matchers) && !isFastSlash(layer, matchers) && cachedPathToRegExp(pattern).test(layer.path);
          }
        }));
      }
      function cachedPathToRegExp(pattern) {
        const maybeCached = regexpCache[pattern];
        if (maybeCached) {
          return maybeCached;
        }
        const regexp = pathToRegExp(pattern);
        regexpCache[pattern] = regexp;
        return regexp;
      }
      function wrapMethod(original) {
        return shimmer.wrapFunction(original, (original2) => function methodWithTrace(fn, ...otherArgs) {
          let offset = 0;
          if (this.stack) {
            offset = Array.isArray(this.stack) ? this.stack.length : 1;
          }
          const router = original2.call(this, fn, ...otherArgs);
          if (typeof this.stack === "function") {
            this.stack = [{ handle: this.stack }];
          }
          if (routeAddedChannel.hasSubscribers) {
            routeAddedChannel.publish({ topOfStackFunc: methodWithTrace, layer: this.stack.at(-1) });
          }
          if (routeAddedChannel.hasSubscribers && isAppMounted(this) && this.stack?.length > offset) {
            if (original2.name === "use" && otherArgs.length >= 1) {
              const { mountPaths: mountPaths2, startIdx } = extractMountPaths(fn);
              if (mountPaths2.length) {
                const parentPaths = getRouterMountPaths(this);
                const callArgs = [fn, ...otherArgs];
                for (let i = startIdx; i < callArgs.length; i++) {
                  const nestedRouter = callArgs[i];
                  if (!nestedRouter || typeof nestedRouter !== "function") continue;
                  for (const parentPath of parentPaths) {
                    for (const normalizedMountPath of mountPaths2) {
                      const fullMountPath = joinPath(parentPath, normalizedMountPath);
                      if (fullMountPath === null) continue;
                      setRouterMountPath(nestedRouter, fullMountPath);
                      collectRoutesFromRouter(nestedRouter, fullMountPath);
                    }
                  }
                }
              }
            }
            const mountPaths = getRouterMountPaths(this);
            if (mountPaths.length) {
              const layer = this.stack.at(-1);
              if (layer?.route) {
                const route = layer.route;
                const fullPaths = mountPaths.flatMap((mountPath) => getRouteFullPaths(route, mountPath));
                wrapRouteMethodsAndPublish(route, fullPaths, (payload) => {
                  routeAddedChannel.publish(payload);
                });
              }
            }
          }
          if (this.stack.length > offset) {
            wrapStack(this.stack.slice(offset), extractMatchers(fn));
          }
          return router;
        });
      }
      return wrapMethod;
    }
    var wrapRouterMethod = createWrapRouterMethod("router");
    addHook({ name: "router", versions: [">=1 <2"] }, (Router) => {
      shimmer.wrap(Router.prototype, "use", wrapRouterMethod);
      shimmer.wrap(Router.prototype, "route", wrapRouterMethod);
      return Router;
    });
    var queryParserReadCh = channel("datadog:query:read:finish");
    addHook({ name: "router", versions: [">=2"] }, (Router) => {
      const WrappedRouter = shimmer.wrapFunction(Router, function(originalRouter) {
        return function wrappedMethod() {
          const router = originalRouter.apply(this, arguments);
          shimmer.wrap(router, "handle", function wrapHandle(originalHandle) {
            return function wrappedHandle(req, res, next) {
              const abortController = new AbortController();
              if (queryParserReadCh.hasSubscribers && req) {
                queryParserReadCh.publish({ req, res, query: req.query, abortController });
                if (abortController.signal.aborted) return;
              }
              return originalHandle.apply(this, arguments);
            };
          });
          return router;
        };
      });
      shimmer.wrap(WrappedRouter.prototype, "use", wrapRouterMethod);
      shimmer.wrap(WrappedRouter.prototype, "route", wrapRouterMethod);
      return WrappedRouter;
    });
    var routerParamStartCh = channel("datadog:router:param:start");
    var visitedParams = /* @__PURE__ */ new WeakSet();
    function wrapHandleRequest(original) {
      return function wrappedHandleRequest(req, res, next) {
        if (routerParamStartCh.hasSubscribers && !visitedParams.has(req.params) && Object.keys(req.params).length) {
          visitedParams.add(req.params);
          const abortController = new AbortController();
          routerParamStartCh.publish({
            req,
            res,
            params: req?.params,
            abortController
          });
          if (abortController.signal.aborted) return;
        }
        return original.apply(this, arguments);
      };
    }
    addHook({
      name: "router",
      file: "lib/layer.js",
      versions: [">=2"]
    }, (Layer) => {
      shimmer.wrap(Layer.prototype, "handleRequest", wrapHandleRequest);
      return Layer;
    });
    function wrapParam(original) {
      return function wrappedProcessParams() {
        arguments[1] = shimmer.wrapFunction(arguments[1], (originalFn) => {
          return function wrappedFn(req, res) {
            if (routerParamStartCh.hasSubscribers && Object.keys(req.params).length && !visitedParams.has(req.params)) {
              visitedParams.add(req.params);
              const abortController = new AbortController();
              routerParamStartCh.publish({
                req,
                res,
                params: req?.params,
                abortController
              });
              if (abortController.signal.aborted) return;
            }
            return originalFn.apply(this, arguments);
          };
        });
        return original.apply(this, arguments);
      };
    }
    addHook({
      name: "router",
      versions: [">=2"]
    }, (router) => {
      shimmer.wrap(router.prototype, "param", wrapParam);
      return router;
    });
    module2.exports = { createWrapRouterMethod };
  }
});

// ../../packages/datadog-instrumentations/src/express.js
var require_express = __commonJS({
  "../../packages/datadog-instrumentations/src/express.js"() {
    "use strict";
    var { createWrapRouterMethod } = require_router();
    var shimmer = require_datadog_shimmer();
    var { addHook, channel, tracingChannel } = require_instrument();
    var {
      setRouterMountPath,
      markAppMounted,
      normalizeRoutePaths,
      wrapRouteMethodsAndPublish,
      extractMountPaths,
      hasRouterCycle,
      collectRoutesFromRouter
    } = require_router_helper();
    var handleChannel = channel("apm:express:request:handle");
    var routeAddedChannel = channel("apm:express:route:added");
    function wrapHandle(handle) {
      return function handleWithTrace(req, res) {
        if (handleChannel.hasSubscribers) {
          handleChannel.publish({ req });
        }
        return handle.apply(this, arguments);
      };
    }
    var wrapRouterMethod = createWrapRouterMethod("express");
    var responseJsonChannel = channel("datadog:express:response:json:start");
    function wrapResponseJson(json) {
      return function wrappedJson(obj) {
        if (responseJsonChannel.hasSubscribers) {
          if (arguments.length === 2 && typeof arguments[1] !== "number") {
            obj = arguments[1];
          }
          responseJsonChannel.publish({ req: this.req, res: this, body: obj });
        }
        return json.apply(this, arguments);
      };
    }
    var responseRenderChannel = tracingChannel("datadog:express:response:render");
    function wrapResponseRender(render) {
      return function wrappedRender(view, options, callback) {
        if (!responseRenderChannel.start.hasSubscribers) {
          return render.apply(this, arguments);
        }
        return responseRenderChannel.traceSync(
          render,
          {
            req: this.req,
            view,
            options
          },
          this,
          ...arguments
        );
      };
    }
    function wrapAppAll(all) {
      return function wrappedAll(path, ...otherArgs) {
        if (!routeAddedChannel.hasSubscribers) return all.call(this, path, ...otherArgs);
        const paths = normalizeRoutePaths(path);
        for (const p of paths) {
          routeAddedChannel.publish({ method: "*", path: p });
        }
        return all.call(this, path, ...otherArgs);
      };
    }
    function wrapAppRoute(route) {
      return function wrappedRoute(path, ...otherArgs) {
        const routeObj = route.call(this, path, ...otherArgs);
        if (!routeAddedChannel.hasSubscribers) return routeObj;
        const paths = normalizeRoutePaths(path);
        if (!paths.length) return routeObj;
        wrapRouteMethodsAndPublish(routeObj, paths, ({ method, path: path2 }) => {
          routeAddedChannel.publish({ method, path: path2 });
        });
        return routeObj;
      };
    }
    function wrapAppUse(use) {
      return function wrappedUse(...args) {
        if (!args.length) return use.call(this);
        const { mountPaths, startIdx } = extractMountPaths(args[0]);
        const pathsToRegister = mountPaths.length ? mountPaths : ["/"];
        for (let i = startIdx; i < args.length; i++) {
          const router = args[i];
          if (!router || typeof router !== "function") continue;
          markAppMounted(router);
          let skipCollection = false;
          if (routeAddedChannel.hasSubscribers) {
            skipCollection = hasRouterCycle(router);
          }
          for (const mountPath of pathsToRegister) {
            const normalizedMountPath = mountPath || "/";
            setRouterMountPath(router, normalizedMountPath);
            if (!skipCollection && routeAddedChannel.hasSubscribers) {
              collectRoutesFromRouter(router, normalizedMountPath);
            }
          }
        }
        return use.apply(this, args);
      };
    }
    addHook({ name: "express", versions: [">=4"], file: ["lib/express.js"] }, (express) => {
      shimmer.wrap(express.application, "handle", wrapHandle);
      shimmer.wrap(express.application, "all", wrapAppAll);
      shimmer.wrap(express.application, "route", wrapAppRoute);
      shimmer.wrap(express.application, "use", wrapAppUse);
      shimmer.wrap(express.response, "json", wrapResponseJson);
      shimmer.wrap(express.response, "jsonp", wrapResponseJson);
      shimmer.wrap(express.response, "render", wrapResponseRender);
      return express;
    });
    addHook({ name: "express", versions: ["4"], file: "lib/express.js" }, (express) => {
      shimmer.wrap(express.Router, "use", wrapRouterMethod);
      shimmer.wrap(express.Router, "route", wrapRouterMethod);
      return express;
    });
    var queryParserReadCh = channel("datadog:query:read:finish");
    function publishQueryParsedAndNext(req, res, next) {
      return shimmer.wrapFunction(next, (next2) => function() {
        if (queryParserReadCh.hasSubscribers && req) {
          const abortController = new AbortController();
          const query = req.query;
          queryParserReadCh.publish({ req, res, query, abortController });
          if (abortController.signal.aborted) return;
        }
        return next2.apply(this, arguments);
      });
    }
    addHook({
      name: "express",
      versions: ["4"],
      file: "lib/middleware/query.js"
    }, (query) => {
      return shimmer.wrapFunction(query, (query2) => function() {
        const queryMiddleware = query2.apply(this, arguments);
        return shimmer.wrapFunction(queryMiddleware, (queryMiddleware2) => function(req, res, next) {
          arguments[2] = publishQueryParsedAndNext(req, res, next);
          return queryMiddleware2.apply(this, arguments);
        });
      });
    });
    var processParamsStartCh = channel("datadog:express:process_params:start");
    function wrapProcessParamsMethod(requestPositionInArguments) {
      return function wrapProcessParams(original) {
        return function wrappedProcessParams() {
          if (processParamsStartCh.hasSubscribers) {
            const req = arguments[requestPositionInArguments];
            const abortController = new AbortController();
            processParamsStartCh.publish({
              req,
              res: req?.res,
              abortController,
              params: req?.params
            });
            if (abortController.signal.aborted) return;
          }
          return original.apply(this, arguments);
        };
      };
    }
    addHook({ name: "express", versions: [">=4.0.0 <4.3.0"], file: ["lib/express.js"] }, (express) => {
      shimmer.wrap(express.Router, "process_params", wrapProcessParamsMethod(1));
      return express;
    });
    addHook({ name: "express", versions: [">=4.3.0 <5.0.0"], file: ["lib/express.js"] }, (express) => {
      shimmer.wrap(express.Router, "process_params", wrapProcessParamsMethod(2));
      return express;
    });
    var queryReadCh = channel("datadog:express:query:finish");
    addHook({ name: "express", file: ["lib/request.js"], versions: [">=5.0.0"] }, (request2) => {
      shimmer.wrap(request2, "query", function(originalGet) {
        return function wrappedGet() {
          const query = originalGet.call(this);
          if (queryReadCh.hasSubscribers && query) {
            queryReadCh.publish({ query });
          }
          return query;
        };
      });
      return request2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/express-mongo-sanitize.js
var require_express_mongo_sanitize = __commonJS({
  "../../packages/datadog-instrumentations/src/express-mongo-sanitize.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var sanitizeMethodFinished = channel("datadog:express-mongo-sanitize:sanitize:finish");
    var sanitizeMiddlewareFinished = channel("datadog:express-mongo-sanitize:filter:finish");
    var propertiesToSanitize = ["body", "params", "headers", "query"];
    addHook({ name: "express-mongo-sanitize", versions: [">=1.0.0"] }, (expressMongoSanitize) => {
      shimmer.wrap(expressMongoSanitize, "sanitize", (sanitize) => function() {
        const sanitizedObject = sanitize.apply(this, arguments);
        if (sanitizeMethodFinished.hasSubscribers) {
          sanitizeMethodFinished.publish({ sanitizedObject });
        }
        return sanitizedObject;
      });
      return shimmer.wrapFunction(expressMongoSanitize, (expressMongoSanitize2) => function() {
        const middleware = expressMongoSanitize2.apply(this, arguments);
        return shimmer.wrapFunction(middleware, (middleware2) => function(req, res, next) {
          if (!sanitizeMiddlewareFinished.hasSubscribers) {
            return middleware2.apply(this, arguments);
          }
          const wrappedNext = shimmer.wrapFunction(next, (next2) => function() {
            sanitizeMiddlewareFinished.publish({
              sanitizedProperties: propertiesToSanitize,
              req
            });
            return next2.apply(this, arguments);
          });
          return middleware2.call(this, req, res, wrappedNext);
        });
      });
    });
  }
});

// ../../packages/datadog-instrumentations/src/express-session.js
var require_express_session = __commonJS({
  "../../packages/datadog-instrumentations/src/express-session.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var sessionMiddlewareFinishCh = channel("datadog:express-session:middleware:finish");
    function wrapSessionMiddleware(sessionMiddleware) {
      return function wrappedSessionMiddleware(req, res, next) {
        shimmer.wrap(arguments, 2, function wrapNext(next2) {
          return function wrappedNext() {
            if (sessionMiddlewareFinishCh.hasSubscribers) {
              const abortController = new AbortController();
              sessionMiddlewareFinishCh.publish({ req, res, sessionId: req.sessionID, abortController });
              if (abortController.signal.aborted) return;
            }
            return next2.apply(this, arguments);
          };
        });
        return sessionMiddleware.apply(this, arguments);
      };
    }
    function wrapSession(session) {
      return function wrappedSession() {
        const sessionMiddleware = session.apply(this, arguments);
        return shimmer.wrapFunction(sessionMiddleware, wrapSessionMiddleware);
      };
    }
    addHook({
      name: "express-session",
      versions: [">=1.5.0"]
    }, (session) => {
      if (session.default) return session;
      return shimmer.wrapFunction(session, wrapSession);
    });
  }
});

// ../../packages/datadog-instrumentations/src/fastify.js
var require_fastify = __commonJS({
  "../../packages/datadog-instrumentations/src/fastify.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var errorChannel = channel("apm:fastify:middleware:error");
    var handleChannel = channel("apm:fastify:request:handle");
    var routeAddedChannel = channel("apm:fastify:route:added");
    var bodyParserReadCh = channel("datadog:fastify:body-parser:finish");
    var queryParamsReadCh = channel("datadog:fastify:query-params:finish");
    var cookieParserReadCh = channel("datadog:fastify-cookie:read:finish");
    var responsePayloadReadCh = channel("datadog:fastify:response:finish");
    var pathParamsReadCh = channel("datadog:fastify:path-params:finish");
    var finishSetHeaderCh = channel("datadog:fastify:set-header:finish");
    var preParsingCh = channel("datadog:fastify:pre-parsing:start");
    var preValidationCh = channel("datadog:fastify:pre-validation:start");
    var callbackFinishCh = channel("datadog:fastify:callback:execute");
    var parsingContexts = /* @__PURE__ */ new WeakMap();
    var cookiesPublished = /* @__PURE__ */ new WeakSet();
    var bodyPublished = /* @__PURE__ */ new WeakSet();
    function wrapFastify(fastify, hasParsingEvents) {
      if (typeof fastify !== "function") return fastify;
      return function fastifyWithTrace() {
        const app = fastify.apply(this, arguments);
        if (!app || typeof app.addHook !== "function") return app;
        app.addHook("onRoute", onRoute);
        app.addHook("onRequest", onRequest);
        app.addHook("preHandler", preHandler);
        if (hasParsingEvents) {
          app.addHook("preParsing", preParsing);
          app.addHook("preValidation", preValidation);
        } else {
          app.addHook("onRequest", preParsing);
          app.addHook("preHandler", preValidation);
        }
        app.addHook = wrapAddHook(app.addHook);
        return app;
      };
    }
    function wrapAddHook(addHook2) {
      return shimmer.wrapFunction(addHook2, (addHook3) => function addHookWithTrace(name, fn) {
        fn = arguments[arguments.length - 1];
        if (typeof fn !== "function") return addHook3.apply(this, arguments);
        arguments[arguments.length - 1] = shimmer.wrapFunction(fn, (fn2) => function(request2, reply, done) {
          const req = getReq(request2);
          const ctx = { req };
          try {
            const doneCallback = arguments[arguments.length - 1];
            if (typeof doneCallback === "function") {
              arguments[arguments.length - 1] = function(err) {
                ctx.error = err;
                publishError(ctx);
                const hasCookies = request2.cookies && Object.keys(request2.cookies).length > 0;
                if (cookieParserReadCh.hasSubscribers && hasCookies && !cookiesPublished.has(req)) {
                  ctx.res = getRes(reply);
                  ctx.abortController = new AbortController();
                  ctx.cookies = request2.cookies;
                  cookieParserReadCh.publish(ctx);
                  cookiesPublished.add(req);
                  if (ctx.abortController.signal.aborted) return;
                }
                if (name === "onRequest" || name === "preParsing") {
                  parsingContexts.set(req, ctx);
                  return callbackFinishCh.runStores(ctx, () => {
                    return doneCallback.apply(this, arguments);
                  });
                }
                return doneCallback.apply(this, arguments);
              };
              return fn2.apply(this, arguments);
            }
            const promise = fn2.apply(this, arguments);
            if (promise && typeof promise.catch === "function") {
              return promise.catch((err) => {
                ctx.error = err;
                return publishError(ctx);
              });
            }
            return promise;
          } catch (e) {
            ctx.error = e;
            throw publishError(ctx);
          }
        });
        return addHook3.apply(this, arguments);
      });
    }
    function onRequest(request2, reply, done) {
      if (typeof done !== "function") return;
      const req = getReq(request2);
      const res = getRes(reply);
      const routeConfig = getRouteConfig(request2);
      const ctx = { req, res, routeConfig };
      handleChannel.publish(ctx);
      return done();
    }
    function preHandler(request2, reply, done) {
      if (typeof done !== "function") return;
      if (!reply || typeof reply.send !== "function") return done();
      const req = getReq(request2);
      const res = getRes(reply);
      const ctx = { req, res };
      const hasBody = request2.body && Object.keys(request2.body).length > 0;
      if (bodyParserReadCh.hasSubscribers && hasBody && !bodyPublished.has(req)) {
        ctx.abortController = new AbortController();
        ctx.body = request2.body;
        bodyParserReadCh.publish(ctx);
        bodyPublished.add(req);
        if (ctx.abortController.signal.aborted) return;
      }
      reply.send = wrapSend(reply.send, req);
      done();
    }
    function preValidation(request2, reply, done) {
      const req = getReq(request2);
      const res = getRes(reply);
      const ctx = parsingContexts.get(req);
      ctx.res = res;
      const processInContext = () => {
        let abortController;
        if (queryParamsReadCh.hasSubscribers && request2.query) {
          abortController ??= new AbortController();
          ctx.abortController = abortController;
          ctx.query = request2.query;
          queryParamsReadCh.publish(ctx);
          if (abortController.signal.aborted) return;
        }
        if (bodyParserReadCh.hasSubscribers && request2.body && !bodyPublished.has(req)) {
          abortController ??= new AbortController();
          ctx.abortController = abortController;
          ctx.body = request2.body;
          bodyParserReadCh.publish(ctx);
          bodyPublished.add(req);
          if (abortController.signal.aborted) return;
        }
        if (pathParamsReadCh.hasSubscribers && request2.params) {
          abortController ??= new AbortController();
          ctx.abortController = abortController;
          ctx.params = request2.params;
          pathParamsReadCh.publish(ctx);
          if (abortController.signal.aborted) return;
        }
        done();
      };
      if (!ctx) return processInContext();
      preValidationCh.runStores(ctx, processInContext);
    }
    function preParsing(request2, reply, payload, done) {
      if (typeof done !== "function") {
        done = payload;
      }
      const req = getReq(request2);
      const ctx = { req };
      parsingContexts.set(req, ctx);
      preParsingCh.runStores(ctx, () => done());
    }
    function wrapSend(send, req) {
      return function sendWithTrace(payload) {
        const ctx = { req };
        if (payload instanceof Error) {
          ctx.error = payload;
          errorChannel.publish(ctx);
        } else if (canPublishResponsePayload(payload)) {
          const res = getRes(this);
          ctx.res = res;
          ctx.body = payload;
          responsePayloadReadCh.publish(ctx);
        }
        return send.apply(this, arguments);
      };
    }
    function getReq(request2) {
      return request2 && (request2.raw || request2.req || request2);
    }
    function getRes(reply) {
      return reply && (reply.raw || reply.res || reply);
    }
    function getRouteConfig(request2) {
      return request2?.routeOptions?.config;
    }
    function publishError(ctx) {
      if (ctx.error) {
        errorChannel.publish(ctx);
      }
      return ctx.error;
    }
    function onRoute(routeOptions) {
      const ctx = { routeOptions, onRoute };
      routeAddedChannel.publish(ctx);
    }
    function canPublishResponsePayload(payload) {
      return responsePayloadReadCh.hasSubscribers && payload && typeof payload === "object" && typeof payload.pipe !== "function" && // Node streams
      typeof payload.body?.pipe !== "function" && // Response with body stream
      !Buffer.isBuffer(payload) && // Buffer
      !(payload instanceof ArrayBuffer) && // ArrayBuffer
      !ArrayBuffer.isView(payload);
    }
    addHook({ name: "fastify", versions: [">=3"] }, (fastify) => {
      const wrapped = shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, true));
      wrapped.fastify = wrapped;
      wrapped.default = wrapped;
      return wrapped;
    });
    addHook({ name: "fastify", versions: ["2"] }, (fastify) => {
      return shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, true));
    });
    addHook({ name: "fastify", versions: ["1"] }, (fastify) => {
      return shimmer.wrapFunction(fastify, (fastify2) => wrapFastify(fastify2, false));
    });
    function wrapReplyHeader(Reply) {
      shimmer.wrap(Reply.prototype, "header", (header) => function(key, value) {
        const result = header.apply(this, arguments);
        if (finishSetHeaderCh.hasSubscribers && key && value) {
          const ctx = { name: key, value, res: getRes(this) };
          finishSetHeaderCh.publish(ctx);
        }
        return result;
      });
      return Reply;
    }
    addHook({ name: "fastify", file: "lib/reply.js", versions: ["1", "2", ">=3"] }, wrapReplyHeader);
  }
});

// ../../packages/datadog-instrumentations/src/find-my-way.js
var require_find_my_way = __commonJS({
  "../../packages/datadog-instrumentations/src/find-my-way.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var routeChannel = channel("apm:find-my-way:request:route");
    function wrapOn(on) {
      return function onWithTrace(method, path, opts) {
        const index = typeof opts === "function" ? 2 : 3;
        const handler = arguments[index];
        const wrapper = shimmer.wrapFunction(handler, (handler2) => function(req) {
          routeChannel.publish({ req, route: path });
          return handler2.apply(this, arguments);
        });
        if (typeof handler === "function") {
          arguments[index] = wrapper;
        }
        return on.apply(this, arguments);
      };
    }
    addHook({ name: "find-my-way", versions: [">=1"] }, (Router) => {
      shimmer.wrap(Router.prototype, "on", wrapOn);
      return Router;
    });
  }
});

// ../../packages/datadog-instrumentations/src/fs.js
var require_fs = __commonJS({
  "../../packages/datadog-instrumentations/src/fs.js"() {
    "use strict";
    var { errorMonitor } = __require("events");
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:fs:operation:start");
    var finishChannel = channel("apm:fs:operation:finish");
    var errorChannel = channel("apm:fs:operation:error");
    var ddFhSym = Symbol("ddFileHandle");
    var kHandle;
    var kDirReadPromisified;
    var kDirClosePromisified;
    var paramsByMethod = {
      access: ["path", "mode"],
      appendFile: ["path", "data", "options"],
      chmod: ["path", "mode"],
      chown: ["path", "uid", "gid"],
      close: ["fd"],
      copyFile: ["src", "dest", "mode"],
      cp: ["src", "dest", "options"],
      exists: ["path"],
      fchmod: ["fd", "mode"],
      fchown: ["fd", "uid", "gid"],
      fdatasync: ["fd"],
      fstat: ["fd", "options"],
      fsync: ["fd"],
      ftruncate: ["fd", "len"],
      futimes: ["fd", "atime", "mtime"],
      lchmod: ["path", "mode"],
      lchown: ["path", "uid", "gid"],
      link: ["existingPath", "newPath"],
      lstat: ["path", "options"],
      lutimes: ["path", "atime", "mtime"],
      mkdir: ["path", "options"],
      mkdtemp: ["prefix", "options"],
      open: ["path", "flag", "mode"],
      opendir: ["path", "options"],
      read: ["fd"],
      readdir: ["path", "options"],
      readFile: ["path", "options"],
      readlink: ["path", "options"],
      readv: ["fd"],
      realpath: ["path", "options"],
      rename: ["oldPath", "newPath"],
      rmdir: ["path", "options"],
      rm: ["path", "options"],
      stat: ["path", "options"],
      symlink: ["target", "path", "type"],
      truncate: ["path", "len"],
      unlink: ["path"],
      utimes: ["path", "atime", "mtime"],
      write: ["fd"],
      writeFile: ["file", "data", "options"],
      writev: ["fd"]
    };
    var watchMethods = {
      unwatchFile: ["path", "listener"],
      watch: ["path", "options", "listener"],
      watchFile: ["path", "options", "listener"]
    };
    var paramsByFileHandleMethods = {
      appendFile: ["data", "options"],
      chmod: ["mode"],
      chown: ["uid", "gid"],
      close: [],
      createReadStream: ["options"],
      createWriteStream: ["options"],
      datasync: [],
      read: ["buffer", "offset", "length", "position"],
      readableWebStream: [],
      readFile: ["options"],
      readLines: ["options"],
      readv: ["buffers", "position"],
      stat: ["options"],
      sync: [],
      truncate: ["len"],
      utimes: ["atime", "mtime"],
      write: ["buffer", "offset", "length", "position"],
      writeFile: ["data", "options"],
      writev: ["buffers", "position"]
    };
    var names = ["fs", "node:fs"];
    names.forEach((name) => {
      addHook({ name }, (fs) => {
        const asyncMethods = Object.keys(paramsByMethod);
        const syncMethods = asyncMethods.map((name2) => `${name2}Sync`);
        massWrap(fs, asyncMethods, createWrapFunction());
        massWrap(fs, syncMethods, createWrapFunction());
        massWrap(fs.promises, asyncMethods, createWrapFunction("promises."));
        wrap(fs.realpath, "native", createWrapFunction("", "realpath.native"));
        wrap(fs.realpathSync, "native", createWrapFunction("", "realpath.native"));
        wrap(fs.promises.realpath, "native", createWrapFunction("", "realpath.native"));
        wrap(fs, "createReadStream", wrapCreateStream);
        wrap(fs, "createWriteStream", wrapCreateStream);
        if (fs.Dir) {
          wrap(fs.Dir.prototype, "close", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "closeSync", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "read", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, "readSync", createWrapFunction("dir."));
          wrap(fs.Dir.prototype, Symbol.asyncIterator, createWrapDirAsyncIterator());
        }
        wrap(fs, "unwatchFile", createWatchWrapFunction());
        wrap(fs, "watch", createWatchWrapFunction());
        wrap(fs, "watchFile", createWatchWrapFunction());
        return fs;
      });
    });
    function isFirstMethodReturningFileHandle(original) {
      return !kHandle && original.name === "open";
    }
    function wrapFileHandle(fh) {
      const fileHandlePrototype = getFileHandlePrototype(fh);
      const desc = Reflect.getOwnPropertyDescriptor(fileHandlePrototype, kHandle);
      if (!desc || !desc.get) {
        Reflect.defineProperty(fileHandlePrototype, kHandle, {
          get() {
            return this[ddFhSym];
          },
          set(h) {
            this[ddFhSym] = h;
            wrap(this, "close", createWrapFunction("filehandle."));
          },
          configurable: true
        });
      }
      for (const name of Reflect.ownKeys(fileHandlePrototype)) {
        if (typeof name !== "string" || name === "constructor" || name === "fd" || name === "getAsyncId") {
          continue;
        }
        wrap(fileHandlePrototype, name, createWrapFunction("filehandle."));
      }
    }
    function getFileHandlePrototype(fh) {
      if (!kHandle) {
        kHandle = Reflect.ownKeys(fh).find((key) => typeof key === "symbol" && key.toString().includes("kHandle"));
      }
      return Object.getPrototypeOf(fh);
    }
    function getSymbolName(sym) {
      return sym.description || sym.toString();
    }
    function initDirAsyncIteratorProperties(iterator) {
      const keys = Reflect.ownKeys(iterator);
      for (const key of keys) {
        if (kDirReadPromisified && kDirClosePromisified) break;
        if (typeof key !== "symbol") continue;
        if (!kDirReadPromisified && getSymbolName(key).includes("kDirReadPromisified")) {
          kDirReadPromisified = key;
        }
        if (!kDirClosePromisified && getSymbolName(key).includes("kDirClosePromisified")) {
          kDirClosePromisified = key;
        }
      }
    }
    function createWrapDirAsyncIterator() {
      return function wrapDirAsyncIterator(asyncIterator) {
        return function wrappedAsyncIterator() {
          if (!kDirReadPromisified || !kDirClosePromisified) {
            initDirAsyncIteratorProperties(this);
          }
          wrap(this, kDirReadPromisified, createWrapFunction("dir.", "read"));
          wrap(this, kDirClosePromisified, createWrapFunction("dir.", "close"));
          return asyncIterator.apply(this, arguments);
        };
      };
    }
    function wrapCreateStream(original) {
      const classes = {
        createReadStream: "ReadStream",
        createWriteStream: "WriteStream"
      };
      const name = classes[original.name];
      return function(path, options) {
        if (!startChannel.hasSubscribers) return original.apply(this, arguments);
        const ctx = getMessage(name, ["path", "options"], arguments);
        return startChannel.runStores(ctx, () => {
          try {
            const stream = original.apply(this, arguments);
            const onError = (error) => {
              ctx.error = error;
              errorChannel.publish(ctx);
              onFinish();
            };
            const onFinish = () => {
              finishChannel.runStores(ctx, () => {
              });
              stream.removeListener("close", onFinish);
              stream.removeListener("end", onFinish);
              stream.removeListener("finish", onFinish);
              stream.removeListener(errorMonitor, onError);
            };
            stream.once("close", onFinish);
            stream.once("end", onFinish);
            stream.once("finish", onFinish);
            stream.once(errorMonitor, onError);
            return stream;
          } catch (error) {
            ctx.error = error;
            errorChannel.publish(ctx);
            finishChannel.runStores(ctx, () => {
            });
          }
        });
      };
    }
    function getMethodParamsRelationByPrefix(prefix) {
      if (prefix === "filehandle.") {
        return paramsByFileHandleMethods;
      }
      return paramsByMethod;
    }
    function createWatchWrapFunction(override = "") {
      return function wrapFunction(original) {
        const name = override || original.name;
        const method = name;
        const operation = name;
        return function() {
          if (!startChannel.hasSubscribers) return original.apply(this, arguments);
          const ctx = getMessage(method, watchMethods[operation], arguments, this);
          return startChannel.runStores(ctx, () => {
            try {
              const result = original.apply(this, arguments);
              finishChannel.runStores(ctx, () => {
              });
              return result;
            } catch (error) {
              ctx.error = error;
              errorChannel.publish(ctx);
              finishChannel.runStores(ctx, () => {
              });
              throw error;
            }
          });
        };
      };
    }
    function createWrapFunction(prefix = "", override = "") {
      return function wrapFunction(original) {
        const name = override || original.name;
        const method = `${prefix}${name}`;
        const operation = name.match(/^(.+?)(Sync)?(\.native)?$/)[1];
        return function() {
          if (!startChannel.hasSubscribers) return original.apply(this, arguments);
          const lastIndex = arguments.length - 1;
          const cb = typeof arguments[lastIndex] === "function" && arguments[lastIndex];
          const params = getMethodParamsRelationByPrefix(prefix)[operation];
          const abortController = new AbortController();
          const ctx = { ...getMessage(method, params, arguments, this), abortController };
          const finish = function(error, cb2 = () => {
          }) {
            if (error !== null && typeof error === "object") {
              ctx.error = error;
              errorChannel.publish(ctx);
            }
            return finishChannel.runStores(ctx, cb2);
          };
          if (cb) {
            arguments[lastIndex] = shimmer.wrapFunction(cb, (cb2) => function(e) {
              return finish(e, () => cb2.apply(this, arguments));
            });
          }
          return startChannel.runStores(ctx, () => {
            if (abortController.signal.aborted) {
              const error = abortController.signal.reason || new Error("Aborted");
              if (prefix === "promises.") {
                finish(error);
                return Promise.reject(error);
              } else if (name.includes("Sync") || !cb) {
                finish(error);
                throw error;
              } else if (cb) {
                arguments[lastIndex](error);
                return;
              }
            }
            try {
              const result = original.apply(this, arguments);
              if (cb) return result;
              if (result && typeof result.then === "function") {
                return result.then(
                  (value) => {
                    if (isFirstMethodReturningFileHandle(original)) {
                      wrapFileHandle(value);
                    }
                    finishChannel.runStores(ctx, () => {
                    });
                    return value;
                  },
                  (error) => {
                    ctx.error = error;
                    errorChannel.publish(ctx);
                    finishChannel.runStores(ctx, () => {
                    });
                    throw error;
                  }
                );
              }
              finishChannel.runStores(ctx, () => {
              });
              return result;
            } catch (error) {
              ctx.error = error;
              errorChannel.publish(ctx);
              finishChannel.runStores(ctx, () => {
              });
              throw error;
            }
          });
        };
      };
    }
    function getMessage(operation, params, args, self2) {
      const metadata = {};
      if (params) {
        for (let i = 0; i < params.length; i++) {
          if (!params[i] || typeof args[i] === "function") continue;
          metadata[params[i]] = args[i];
        }
      }
      if (self2) {
        if (self2.path) {
          metadata.path = self2.path;
        }
        if (self2.fd) {
          metadata.fd = self2.fd;
        }
      }
      return { operation, ...metadata };
    }
    function massWrap(target, methods, wrapper) {
      for (const method of methods) {
        wrap(target, method, wrapper);
      }
    }
    function wrap(target, method, wrapper) {
      try {
        shimmer.wrap(target, method, wrapper);
      } catch {
      }
    }
  }
});

// ../../packages/datadog-instrumentations/src/generic-pool.js
var require_generic_pool = __commonJS({
  "../../packages/datadog-instrumentations/src/generic-pool.js"() {
    "use strict";
    var { addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function createWrapAcquire() {
      return function wrapAcquire(acquire) {
        return function acquireWithTrace(callback, priority) {
          if (typeof callback === "function") {
            arguments[0] = AsyncResource.bind(callback);
          }
          return acquire.apply(this, arguments);
        };
      };
    }
    function createWrapPool() {
      return function wrapPool(Pool) {
        if (typeof Pool !== "function") return Pool;
        return function PoolWithTrace(factory) {
          const pool = Pool.apply(this, arguments);
          if (pool && typeof pool.acquire === "function") {
            shimmer.wrap(pool, "acquire", createWrapAcquire());
          }
          return pool;
        };
      };
    }
    addHook({
      name: "generic-pool",
      versions: ["^2.4"]
    }, (genericPool) => {
      shimmer.wrap(genericPool.Pool.prototype, "acquire", createWrapAcquire());
      return genericPool;
    });
    addHook({
      name: "generic-pool",
      versions: ["2 - 2.3"]
    }, (genericPool) => {
      shimmer.wrap(genericPool, "Pool", createWrapPool());
      return genericPool;
    });
  }
});

// ../../packages/datadog-instrumentations/src/handlebars.js
var require_handlebars = __commonJS({
  "../../packages/datadog-instrumentations/src/handlebars.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var handlebarsCompileCh = channel("datadog:handlebars:compile:start");
    var handlebarsRegisterPartialCh = channel("datadog:handlebars:register-partial:start");
    function wrapCompile(compile) {
      return function wrappedCompile(source) {
        if (handlebarsCompileCh.hasSubscribers) {
          handlebarsCompileCh.publish({ source });
        }
        return compile.apply(this, arguments);
      };
    }
    function wrapRegisterPartial(registerPartial) {
      return function wrappedRegisterPartial(name, partial) {
        if (handlebarsRegisterPartialCh.hasSubscribers) {
          handlebarsRegisterPartialCh.publish({ partial });
        }
        return registerPartial.apply(this, arguments);
      };
    }
    addHook({ name: "handlebars", file: "dist/cjs/handlebars/compiler/compiler.js", versions: [">=4.0.0"] }, (compiler) => {
      shimmer.wrap(compiler, "compile", wrapCompile);
      shimmer.wrap(compiler, "precompile", wrapCompile);
      return compiler;
    });
    addHook({ name: "handlebars", file: "dist/cjs/handlebars/base.js", versions: [">=4.0.0"] }, (base) => {
      shimmer.wrap(base.HandlebarsEnvironment.prototype, "registerPartial", wrapRegisterPartial);
      return base;
    });
  }
});

// ../../packages/datadog-instrumentations/src/hono.js
var require_hono = __commonJS({
  "../../packages/datadog-instrumentations/src/hono.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var {
      addHook,
      channel
    } = require_instrument();
    var routeChannel = channel("apm:hono:request:route");
    var handleChannel = channel("apm:hono:request:handle");
    var errorChannel = channel("apm:hono:request:error");
    function wrapFetch(fetch2) {
      return function(request2, env, executionCtx) {
        handleChannel.publish({ req: env.incoming });
        return fetch2.apply(this, arguments);
      };
    }
    function onErrorFn(error, _context_) {
      throw error;
    }
    function wrapCompose(compose) {
      return function(middlewares, onError, onNotFound) {
        onError ??= onErrorFn;
        const instrumentedOnError = (...args) => {
          const [error, context2] = args;
          const req = context2.env.incoming;
          errorChannel.publish({ req, error });
          return onError(...args);
        };
        const instrumentedMiddlewares = middlewares.map((h) => {
          const [[fn, meta], params] = h;
          const instrumentedFn = (...args) => {
            const context2 = args[0];
            routeChannel.publish({
              req: context2.env.incoming,
              route: meta?.path
            });
            return fn(...args);
          };
          return [[instrumentedFn, meta], params];
        });
        return compose.call(this, instrumentedMiddlewares, instrumentedOnError, onNotFound);
      };
    }
    addHook({
      name: "hono",
      versions: [">=4"],
      file: "dist/hono.js"
    }, (hono) => {
      class Hono extends hono.Hono {
        constructor(...args) {
          super(...args);
          shimmer.wrap(this, "fetch", wrapFetch);
        }
      }
      hono.Hono = Hono;
      return hono;
    });
    addHook({
      name: "hono",
      versions: [">=4"],
      file: "dist/cjs/hono.js"
    }, (hono) => {
      class Hono extends hono.Hono {
        constructor(...args) {
          super(...args);
          shimmer.wrap(this, "fetch", wrapFetch);
        }
      }
      return Object.create(hono, {
        Hono: {
          get() {
            return Hono;
          },
          enumerable: true
        }
      });
    });
    addHook({
      name: "hono",
      versions: [">=4"],
      file: "dist/cjs/compose.js"
    }, (Compose) => {
      return shimmer.wrap(Compose, "compose", wrapCompose, { replaceGetter: true });
    });
    addHook({
      name: "hono",
      versions: [">=4"],
      file: "dist/compose.js"
    }, (Compose) => {
      return shimmer.wrap(Compose, "compose", wrapCompose);
    });
  }
});

// ../../packages/datadog-instrumentations/src/http/client.js
var require_client2 = __commonJS({
  "../../packages/datadog-instrumentations/src/http/client.js"() {
    "use strict";
    var url = __require("url");
    var { errorMonitor } = __require("events");
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var startChannel = channel("apm:http:client:request:start");
    var finishChannel = channel("apm:http:client:request:finish");
    var endChannel = channel("apm:http:client:request:end");
    var asyncStartChannel = channel("apm:http:client:request:asyncStart");
    var errorChannel = channel("apm:http:client:request:error");
    var names = ["http", "https", "node:http", "node:https"];
    addHook({ name: names }, hookFn);
    function hookFn(http) {
      patch(http, "request");
      patch(http, "get");
      return http;
    }
    function combineOptions(inputURL, inputOptions) {
      return inputOptions !== null && typeof inputOptions === "object" ? Object.assign(inputURL || {}, inputOptions) : inputURL;
    }
    function normalizeHeaders(options) {
      options.headers ??= {};
    }
    function normalizeCallback(inputOptions, callback, inputURL) {
      return typeof inputOptions === "function" ? [inputOptions, inputURL || {}] : [callback, inputOptions];
    }
    function patch(http, methodName) {
      shimmer.wrap(http, methodName, instrumentRequest);
      function instrumentRequest(request2) {
        return function() {
          if (!startChannel.hasSubscribers) {
            return request2.apply(this, arguments);
          }
          let args;
          try {
            args = normalizeArgs.apply(null, arguments);
          } catch (e) {
            log.error("Error normalising http req arguments", e);
            return request2.apply(this, arguments);
          }
          const abortController = new AbortController();
          const ctx = { args, http, abortController };
          return startChannel.runStores(ctx, () => {
            let finished = false;
            let callback = args.callback;
            if (callback) {
              callback = shimmer.wrapFunction(args.callback, (cb) => function() {
                return asyncStartChannel.runStores(ctx, () => {
                  return cb.apply(this, arguments);
                });
              });
            }
            const options = args.options;
            const finish = () => {
              if (!finished) {
                finished = true;
                finishChannel.publish(ctx);
              }
            };
            try {
              const req = request2.call(this, options, callback);
              const emit = req.emit;
              const setTimeout2 = req.setTimeout;
              ctx.req = req;
              let customRequestTimeout = false;
              req.setTimeout = function() {
                customRequestTimeout = true;
                return setTimeout2.apply(this, arguments);
              };
              req.emit = function(eventName, arg) {
                switch (eventName) {
                  case "response": {
                    const res = arg;
                    ctx.res = res;
                    res.on("end", finish);
                    res.on(errorMonitor, finish);
                    break;
                  }
                  case "connect":
                  case "upgrade":
                    ctx.res = arg;
                    finish();
                    break;
                  case "error":
                  case "timeout":
                    ctx.error = arg;
                    ctx.customRequestTimeout = customRequestTimeout;
                    errorChannel.publish(ctx);
                  case "abort":
                  // deprecated and replaced by `close` in node 17
                  case "close":
                    finish();
                }
                return emit.apply(this, arguments);
              };
              if (abortController.signal.aborted) {
                req.destroy(abortController.signal.reason || new Error("Aborted"));
              }
              return req;
            } catch (e) {
              ctx.error = e;
              errorChannel.publish(ctx);
              if (!ctx.req) {
                finish();
              }
              throw e;
            } finally {
              endChannel.publish(ctx);
            }
          });
        };
      }
      function normalizeArgs(inputURL, inputOptions, cb) {
        const originalUrl = inputURL;
        inputURL = normalizeOptions(inputURL);
        const [callback, inputOptionsNormalized] = normalizeCallback(inputOptions, cb, inputURL);
        const options = combineOptions(inputURL, inputOptionsNormalized);
        normalizeHeaders(options);
        const uri = url.format(options);
        return { uri, options, callback, originalUrl };
      }
      function normalizeOptions(inputURL) {
        if (typeof inputURL === "string") {
          try {
            return urlToOptions(new url.URL(inputURL));
          } catch {
            return url.parse(inputURL);
          }
        } else if (inputURL instanceof url.URL) {
          return urlToOptions(inputURL);
        } else {
          return inputURL;
        }
      }
      function urlToOptions(url2) {
        const agent = url2.agent || http.globalAgent;
        const options = {
          protocol: url2.protocol || agent.protocol,
          hostname: typeof url2.hostname === "string" && url2.hostname.startsWith("[") ? url2.hostname.slice(1, -1) : url2.hostname || url2.host || "localhost",
          hash: url2.hash,
          search: url2.search,
          pathname: url2.pathname,
          path: `${url2.pathname || ""}${url2.search || ""}`,
          href: url2.href
        };
        if (url2.port !== "") {
          options.port = Number(url2.port);
        }
        if (url2.username || url2.password) {
          options.auth = `${url2.username}:${url2.password}`;
        }
        return options;
      }
    }
  }
});

// ../../packages/datadog-instrumentations/src/http/server.js
var require_server2 = __commonJS({
  "../../packages/datadog-instrumentations/src/http/server.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startServerCh = channel("apm:http:server:request:start");
    var exitServerCh = channel("apm:http:server:request:exit");
    var errorServerCh = channel("apm:http:server:request:error");
    var finishServerCh = channel("apm:http:server:request:finish");
    var startWriteHeadCh = channel("apm:http:server:response:writeHead:start");
    var finishSetHeaderCh = channel("datadog:http:server:response:set-header:finish");
    var startSetHeaderCh = channel("datadog:http:server:response:set-header:start");
    var requestFinishedSet = /* @__PURE__ */ new WeakSet();
    var httpNames = ["http", "node:http"];
    var httpsNames = ["https", "node:https"];
    addHook({ name: httpNames }, (http) => {
      shimmer.wrap(http.ServerResponse.prototype, "emit", wrapResponseEmit);
      shimmer.wrap(http.Server.prototype, "emit", wrapEmit);
      shimmer.wrap(http.ServerResponse.prototype, "writeHead", wrapWriteHead);
      shimmer.wrap(http.ServerResponse.prototype, "write", wrapWrite);
      shimmer.wrap(http.ServerResponse.prototype, "end", wrapEnd);
      shimmer.wrap(http.ServerResponse.prototype, "setHeader", wrapSetHeader);
      shimmer.wrap(http.ServerResponse.prototype, "removeHeader", wrapAppendOrRemoveHeader);
      if (http.ServerResponse.prototype.appendHeader) {
        shimmer.wrap(http.ServerResponse.prototype, "appendHeader", wrapAppendOrRemoveHeader);
      }
      return http;
    });
    addHook({ name: httpsNames }, (http) => {
      shimmer.wrap(http.Server.prototype, "emit", wrapEmit);
      return http;
    });
    function wrapResponseEmit(emit) {
      return function(eventName, event) {
        if (!finishServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (["finish", "close"].includes(eventName) && !requestFinishedSet.has(this)) {
          finishServerCh.publish({ req: this.req });
          requestFinishedSet.add(this);
        }
        return emit.apply(this, arguments);
      };
    }
    function wrapEmit(emit) {
      return function(eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (eventName === "request") {
          res.req = req;
          const abortController = new AbortController();
          startServerCh.publish({ req, res, abortController });
          try {
            if (abortController.signal.aborted) {
              return this.listenerCount(eventName) > 0;
            }
            return emit.apply(this, arguments);
          } catch (err) {
            errorServerCh.publish(err);
            throw err;
          } finally {
            exitServerCh.publish({ req });
          }
        }
        return emit.apply(this, arguments);
      };
    }
    function wrapWriteHead(writeHead) {
      return function wrappedWriteHead(statusCode, reason, obj) {
        if (!startWriteHeadCh.hasSubscribers) {
          return writeHead.apply(this, arguments);
        }
        const abortController = new AbortController();
        if (typeof reason !== "string") {
          obj ??= reason;
        }
        if (Array.isArray(obj)) {
          const headers = {};
          for (let i = 0; i < obj.length; i += 2) {
            headers[obj[i]] = obj[i + 1];
          }
          obj = headers;
        }
        const responseHeaders = Object.assign(this.getHeaders(), obj);
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode,
          responseHeaders
        });
        if (abortController.signal.aborted) {
          return this;
        }
        return writeHead.apply(this, arguments);
      };
    }
    function wrapWrite(write) {
      return function wrappedWrite() {
        if (!startWriteHeadCh.hasSubscribers) {
          return write.apply(this, arguments);
        }
        const abortController = new AbortController();
        const responseHeaders = this.getHeaders();
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode: this.statusCode,
          responseHeaders
        });
        if (abortController.signal.aborted) {
          return true;
        }
        return write.apply(this, arguments);
      };
    }
    function wrapSetHeader(setHeader) {
      return function wrappedSetHeader(name, value) {
        if (!startSetHeaderCh.hasSubscribers && !finishSetHeaderCh.hasSubscribers) {
          return setHeader.apply(this, arguments);
        }
        if (startSetHeaderCh.hasSubscribers) {
          const abortController = new AbortController();
          startSetHeaderCh.publish({ res: this, abortController });
          if (abortController.signal.aborted) {
            return;
          }
        }
        const setHeaderResult = setHeader.apply(this, arguments);
        if (finishSetHeaderCh.hasSubscribers) {
          finishSetHeaderCh.publish({ name, value, res: this });
        }
        return setHeaderResult;
      };
    }
    function wrapAppendOrRemoveHeader(originalMethod) {
      return function wrappedAppendOrRemoveHeader() {
        if (!startSetHeaderCh.hasSubscribers) {
          return originalMethod.apply(this, arguments);
        }
        const abortController = new AbortController();
        startSetHeaderCh.publish({ res: this, abortController });
        if (abortController.signal.aborted) {
          return this;
        }
        return originalMethod.apply(this, arguments);
      };
    }
    function wrapEnd(end) {
      return function wrappedEnd() {
        if (!startWriteHeadCh.hasSubscribers) {
          return end.apply(this, arguments);
        }
        const abortController = new AbortController();
        const responseHeaders = this.getHeaders();
        startWriteHeadCh.publish({
          req: this.req,
          res: this,
          abortController,
          statusCode: this.statusCode,
          responseHeaders
        });
        if (abortController.signal.aborted) {
          return this;
        }
        return end.apply(this, arguments);
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/http.js
var require_http2 = __commonJS({
  "../../packages/datadog-instrumentations/src/http.js"() {
    "use strict";
    require_client2();
    require_server2();
  }
});

// ../../packages/datadog-instrumentations/src/http2/client.js
var require_client3 = __commonJS({
  "../../packages/datadog-instrumentations/src/http2/client.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var connectChannel = channel("apm:http2:client:connect:start");
    var startChannel = channel("apm:http2:client:request:start");
    var endChannel = channel("apm:http2:client:request:end");
    var asyncStartChannel = channel("apm:http2:client:request:asyncStart");
    var asyncEndChannel = channel("apm:http2:client:request:asyncEnd");
    var errorChannel = channel("apm:http2:client:request:error");
    var names = ["http2", "node:http2"];
    function createWrapEmit(ctx) {
      return function wrapEmit(emit) {
        return function(event, arg1) {
          ctx.eventName = event;
          ctx.eventData = arg1;
          return asyncStartChannel.runStores(ctx, () => {
            try {
              return emit.apply(this, arguments);
            } finally {
              asyncEndChannel.publish(ctx);
            }
          });
        };
      };
    }
    function createWrapRequest(authority, options) {
      return function wrapRequest(request2) {
        return function(headers) {
          if (!startChannel.hasSubscribers) return request2.apply(this, arguments);
          const ctx = { headers, authority, options };
          return startChannel.runStores(ctx, () => {
            try {
              const req = request2.apply(this, arguments);
              shimmer.wrap(req, "emit", createWrapEmit(ctx));
              return req;
            } catch (e) {
              ctx.error = e;
              errorChannel.publish(ctx);
              throw e;
            } finally {
              endChannel.publish(ctx);
            }
          });
        };
      };
    }
    function wrapConnect(connect) {
      return function(authority, options) {
        if (connectChannel.hasSubscribers) {
          connectChannel.publish({ authority });
        }
        const session = connect.apply(this, arguments);
        shimmer.wrap(session, "request", createWrapRequest(authority, options));
        return session;
      };
    }
    addHook({ name: names }, (http2) => {
      shimmer.wrap(http2, "connect", wrapConnect);
      if (http2.default) http2.default.connect = http2.connect;
      return http2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/http2/server.js
var require_server3 = __commonJS({
  "../../packages/datadog-instrumentations/src/http2/server.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startServerCh = channel("apm:http2:server:request:start");
    var errorServerCh = channel("apm:http2:server:request:error");
    var emitCh = channel("apm:http2:server:response:emit");
    var names = ["http2", "node:http2"];
    addHook({ name: names }, (http2) => {
      shimmer.wrap(http2, "createSecureServer", wrapCreateServer);
      shimmer.wrap(http2, "createServer", wrapCreateServer);
    });
    function wrapCreateServer(createServer2) {
      return function(...args) {
        const server2 = createServer2.apply(this, args);
        shimmer.wrap(server2, "emit", wrapEmit);
        return server2;
      };
    }
    function wrapResponseEmit(emit, ctx) {
      return function(eventName, event) {
        ctx.req = this.req;
        ctx.eventName = eventName;
        return emitCh.runStores(ctx, emit, this, ...arguments);
      };
    }
    function wrapEmit(emit) {
      return function(eventName, req, res) {
        if (!startServerCh.hasSubscribers) {
          return emit.apply(this, arguments);
        }
        if (eventName === "request") {
          res.req = req;
          const ctx = { req, res };
          return startServerCh.runStores(ctx, () => {
            shimmer.wrap(res, "emit", (emit2) => wrapResponseEmit(emit2, ctx));
            try {
              return emit.apply(this, arguments);
            } catch (error) {
              ctx.error = error;
              errorServerCh.publish(ctx);
              throw error;
            }
          });
        }
        return emit.apply(this, arguments);
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/http2.js
var require_http22 = __commonJS({
  "../../packages/datadog-instrumentations/src/http2.js"() {
    "use strict";
    require_client3();
    require_server3();
  }
});

// ../../packages/datadog-instrumentations/src/ioredis.js
var require_ioredis = __commonJS({
  "../../packages/datadog-instrumentations/src/ioredis.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:ioredis:command:start");
    var finishCh = channel("apm:ioredis:command:finish");
    var errorCh = channel("apm:ioredis:command:error");
    function wrapRedis(Redis) {
      shimmer.wrap(Redis.prototype, "sendCommand", (sendCommand) => function(command, stream) {
        if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments);
        if (!command || !command.promise) return sendCommand.apply(this, arguments);
        const options = this.options || {};
        const connectionName = options.connectionName;
        const db = options.db;
        const connectionOptions = { host: options.host, port: options.port };
        const ctx = { db, command: command.name, args: command.args, connectionOptions, connectionName };
        return startCh.runStores(ctx, () => {
          command.promise.then(() => finish(finishCh, errorCh, ctx), (err) => finish(finishCh, errorCh, ctx, err));
          try {
            return sendCommand.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return Redis;
    }
    addHook({ name: "ioredis", versions: [">=2 <4"], file: "lib/redis.js" }, wrapRedis);
    addHook({ name: "ioredis", versions: [">=4 <4.11.0"], file: "built/redis.js" }, wrapRedis);
    addHook({ name: "ioredis", versions: [">=4.11.0 <5"], file: "built/redis/index.js" }, (exports3) => {
      wrapRedis(exports3.default);
      return exports3;
    });
    addHook({ name: "ioredis", versions: [">=5"] }, wrapRedis);
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error;
        errorCh2.publish(ctx);
      }
      finishCh2.publish(ctx);
    }
  }
});

// ../../packages/datadog-instrumentations/src/iovalkey.js
var require_iovalkey = __commonJS({
  "../../packages/datadog-instrumentations/src/iovalkey.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:iovalkey:command:start");
    var finishCh = channel("apm:iovalkey:command:finish");
    var errorCh = channel("apm:iovalkey:command:error");
    addHook({ name: "iovalkey", versions: [">=0.0.1"] }, (Valkey) => {
      shimmer.wrap(Valkey.prototype, "sendCommand", (sendCommand) => function(command, stream) {
        if (!startCh.hasSubscribers) return sendCommand.apply(this, arguments);
        if (!command?.promise) return sendCommand.apply(this, arguments);
        const options = this.options || {};
        const connectionName = options.connectionName;
        const db = options.db;
        const connectionOptions = { host: options.host, port: options.port };
        const ctx = { db, command: command.name, args: command.args, connectionOptions, connectionName };
        return startCh.runStores(ctx, () => {
          command.promise.then(() => finish(finishCh, errorCh, ctx), (err) => finish(finishCh, errorCh, ctx, err));
          try {
            return sendCommand.apply(this, arguments);
          } catch (err) {
            ctx.error = err;
            errorCh.publish(ctx);
            throw err;
          }
        });
      });
      return Valkey;
    });
    function finish(finishCh2, errorCh2, ctx, error) {
      if (error) {
        ctx.error = error;
        errorCh2.publish(ctx);
      }
      finishCh2.publish(ctx);
    }
  }
});

// ../../packages/datadog-instrumentations/src/knex.js
var require_knex = __commonJS({
  "../../packages/datadog-instrumentations/src/knex.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    var startRawQueryCh = channel("datadog:knex:raw:start");
    var rawQuerySubscribes = channel("datadog:knex:raw:subscribes");
    var finishRawQueryCh = channel("datadog:knex:raw:finish");
    patch("lib/query/builder.js");
    patch("lib/raw.js");
    patch("lib/schema/builder.js");
    function patch(file) {
      addHook({
        name: "knex",
        versions: [">=0.8.0"],
        file
      }, (Builder) => {
        shimmer.wrap(Builder.prototype, "then", wrapThen);
        return Builder;
      });
    }
    function finish(context2, cb) {
      finishRawQueryCh.runStores(context2, cb);
    }
    addHook({
      name: "knex",
      versions: [">=2"],
      file: "lib/knex-builder/Knex.js"
    }, (Knex) => {
      shimmer.wrap(Knex.Client.prototype, "raw", (raw) => function() {
        if (!startRawQueryCh.hasSubscribers) {
          return raw.apply(this, arguments);
        }
        const sql = arguments[0];
        if (sql === "DEFAULT") {
          return raw.apply(this, arguments);
        }
        const context2 = { sql, dialect: this.dialect };
        return startRawQueryCh.runStores(context2, () => {
          const rawResult = raw.apply(this, arguments);
          shimmer.wrap(rawResult, "then", (originalThen) => function() {
            return rawQuerySubscribes.runStores(context2, () => {
              arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context2);
              if (arguments[1]) arguments[1] = wrapCallbackWithFinish(arguments[1], finish, context2);
              const originalThenResult = originalThen.apply(this, arguments);
              shimmer.wrap(originalThenResult, "catch", (originalCatch) => function() {
                arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context2);
                return originalCatch.apply(this, arguments);
              });
              return originalThenResult;
            });
          });
          shimmer.wrap(rawResult, "asCallback", (originalAsCallback) => function() {
            return rawQuerySubscribes.runStores(context2, () => {
              arguments[0] = wrapCallbackWithFinish(arguments[0], finish, context2);
              return originalAsCallback.apply(this, arguments);
            });
          });
          return rawResult;
        });
      });
      return Knex;
    });
    function wrapCallbackWithFinish(callback, finish2, context2) {
      if (typeof callback !== "function") return callback;
      return shimmer.wrapFunction(callback, (callback2) => function() {
        finish2(context2, () => callback2.apply(this, arguments));
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/confluentinc-kafka-javascript.js
var require_confluentinc_kafka_javascript = __commonJS({
  "../../packages/datadog-instrumentations/src/confluentinc-kafka-javascript.js"() {
    "use strict";
    var {
      addHook,
      channel
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var channels = {
      producerStart: channel("apm:confluentinc-kafka-javascript:produce:start"),
      producerFinish: channel("apm:confluentinc-kafka-javascript:produce:finish"),
      producerError: channel("apm:confluentinc-kafka-javascript:produce:error"),
      producerCommit: channel("apm:confluentinc-kafka-javascript:produce:commit"),
      consumerStart: channel("apm:confluentinc-kafka-javascript:consume:start"),
      consumerFinish: channel("apm:confluentinc-kafka-javascript:consume:finish"),
      consumerError: channel("apm:confluentinc-kafka-javascript:consume:error"),
      consumerCommit: channel("apm:confluentinc-kafka-javascript:consume:commit"),
      // batch operations
      batchConsumerStart: channel("apm:confluentinc-kafka-javascript:consume-batch:start"),
      batchConsumerFinish: channel("apm:confluentinc-kafka-javascript:consume-batch:finish"),
      batchConsumerError: channel("apm:confluentinc-kafka-javascript:consume-batch:error"),
      batchConsumerCommit: channel("apm:confluentinc-kafka-javascript:consume-batch:commit")
    };
    var disabledHeaderWeakSet = /* @__PURE__ */ new WeakSet();
    var latestConsumerOffsets = /* @__PURE__ */ new Map();
    addHook({ name: "@confluentinc/kafka-javascript", versions: [">=1.0.0"] }, (module3) => {
      instrumentBaseModule(module3);
      if (module3.KafkaJS) {
        instrumentKafkaJS(module3.KafkaJS);
      }
      return module3;
    });
    function instrumentBaseModule(module3) {
      function wrapProducerClass(ProducerClass, className) {
        return shimmer.wrap(module3, className, function wrapProducer(Original) {
          return function wrappedProducer() {
            const producer = new Original(...arguments);
            if (typeof producer?.produce === "function") {
              shimmer.wrap(producer, "produce", function wrapProduce(produce) {
                return function wrappedProduce(topic, partition, message, key, timestamp, opaque, headers) {
                  if (!channels.producerStart.hasSubscribers) {
                    return produce.apply(this, arguments);
                  }
                  const brokers = this.globalConfig?.["bootstrap.servers"];
                  const ctx = {
                    topic,
                    messages: [{ key, value: message }],
                    bootstrapServers: brokers
                  };
                  return channels.producerStart.runStores(ctx, () => {
                    try {
                      const headers2 = convertHeaders(ctx.messages[0].headers);
                      const result = produce.apply(this, [topic, partition, message, key, timestamp, opaque, headers2]);
                      ctx.result = result;
                      channels.producerCommit.publish(ctx);
                      channels.producerFinish.publish(ctx);
                      return result;
                    } catch (error) {
                      ctx.error = error;
                      channels.producerError.publish(ctx);
                      channels.producerFinish.publish(ctx);
                      throw error;
                    }
                  });
                };
              });
            }
            return producer;
          };
        });
      }
      function wrapConsumerClass(ConsumerClass, className) {
        return shimmer.wrap(module3, className, function wrapConsumer(Original) {
          return function wrappedConsumer() {
            const consumer = new Original(...arguments);
            const groupId = this.groupId || arguments[0]?.["group.id"];
            if (typeof consumer?.consume === "function") {
              shimmer.wrap(consumer, "consume", function wrapConsume(consume) {
                return function wrappedConsume(numMessages, callback) {
                  if (!channels.consumerStart.hasSubscribers) {
                    return consume.apply(this, arguments);
                  }
                  if (!callback && typeof numMessages === "function") {
                    callback = numMessages;
                  }
                  const ctx = {
                    groupId
                  };
                  if (typeof callback === "function") {
                    return consume.call(this, numMessages, function wrappedCallback(err, messages) {
                      if (messages && messages.length > 0) {
                        messages.forEach((message) => {
                          ctx.topic = message?.topic;
                          ctx.partition = message?.partition;
                          ctx.message = message;
                          channels.consumerStart.runStores(ctx, () => {
                          });
                          updateLatestOffset(message?.topic, message?.partition, message?.offset, groupId);
                        });
                      }
                      if (err) {
                        ctx.error = err;
                        channels.consumerError.publish(ctx);
                      }
                      try {
                        const result = callback.apply(this, arguments);
                        if (messages && messages.length > 0) {
                          channels.consumerFinish.publish(ctx);
                        }
                        return result;
                      } catch (error) {
                        ctx.error = error;
                        channels.consumerError.publish(ctx);
                        channels.consumerFinish.publish(ctx);
                        throw error;
                      }
                    });
                  }
                  return consume.apply(this, arguments);
                };
              });
              if (consumer && typeof consumer.commit === "function") {
                shimmer.wrap(consumer, "commit", wrapCommit);
              }
            }
            return consumer;
          };
        });
      }
      if (typeof module3.Producer === "function") {
        wrapProducerClass(module3.Producer, "Producer");
      }
      if (typeof module3.KafkaProducer === "function") {
        wrapProducerClass(module3.KafkaProducer, "KafkaProducer");
      }
      if (typeof module3.Consumer === "function") {
        wrapConsumerClass(module3.Consumer, "Consumer");
      }
      if (typeof module3.KafkaConsumer === "function") {
        wrapConsumerClass(module3.KafkaConsumer, "KafkaConsumer");
      }
    }
    function instrumentKafkaJS(kafkaJS) {
      if (typeof kafkaJS?.Kafka === "function") {
        shimmer.wrap(kafkaJS, "Kafka", function wrapKafka(OriginalKafka) {
          return function KafkaWrapper(options) {
            const kafka = new OriginalKafka(options);
            const kafkaJSOptions = options?.kafkaJS || options;
            const brokers = kafkaJSOptions?.brokers ? kafkaJSOptions.brokers.join(",") : "";
            kafka._ddBrokers = brokers;
            if (typeof kafka?.producer === "function") {
              shimmer.wrap(kafka, "producer", function wrapProducerMethod(producerMethod) {
                return function wrappedProducerMethod() {
                  const producer = producerMethod.apply(this, arguments);
                  if (!brokers && arguments?.[0]?.["bootstrap.servers"]) {
                    kafka._ddBrokers = arguments[0]["bootstrap.servers"];
                  }
                  if (producer && typeof producer.send === "function") {
                    shimmer.wrap(producer, "send", function wrapSend(send) {
                      return function wrappedSend(payload) {
                        if (!channels.producerStart.hasSubscribers) {
                          return send.apply(this, arguments);
                        }
                        const ctx = {
                          topic: payload?.topic,
                          messages: payload?.messages || [],
                          bootstrapServers: kafka._ddBrokers,
                          disableHeaderInjection: disabledHeaderWeakSet.has(producer)
                        };
                        return channels.producerStart.runStores(ctx, () => {
                          try {
                            const result = send.apply(this, arguments);
                            result.then((res) => {
                              ctx.result = res;
                              channels.producerCommit.publish(ctx);
                              channels.producerFinish.publish(ctx);
                            }, (err) => {
                              if (err) {
                                if (err.name === "KafkaJSError" && err.type === "ERR_UNKNOWN") {
                                  disabledHeaderWeakSet.add(producer);
                                  log.error("Kafka Broker responded with UNKNOWN_SERVER_ERROR (-1). Please look at broker logs for more information. Tracer message header injection for Kafka is disabled.");
                                }
                                ctx.error = err;
                                channels.producerError.publish(ctx);
                              }
                              channels.producerFinish.publish(ctx);
                            });
                            return result;
                          } catch (e) {
                            ctx.error = e;
                            channels.producerError.publish(ctx);
                            channels.producerFinish.publish(ctx);
                            throw e;
                          }
                        });
                      };
                    });
                  }
                  return producer;
                };
              });
            }
            if (typeof kafka?.consumer === "function") {
              shimmer.wrap(kafka, "consumer", function wrapConsumerMethod(consumerMethod) {
                return function wrappedConsumerMethod(config) {
                  const consumer = consumerMethod.apply(this, arguments);
                  const groupId = getGroupId(config);
                  if (typeof consumer?.run === "function") {
                    shimmer.wrap(consumer, "run", function wrapRun(run) {
                      return function wrappedRun(options2) {
                        if (!channels.consumerStart.hasSubscribers) {
                          return run.apply(this, arguments);
                        }
                        const eachMessage = options2?.eachMessage;
                        const eachBatch = options2?.eachBatch;
                        if (eachMessage) {
                          options2.eachMessage = wrapKafkaCallback(
                            eachMessage,
                            {
                              startCh: channels.consumerStart,
                              commitCh: channels.consumerCommit,
                              finishCh: channels.consumerFinish,
                              errorCh: channels.consumerError
                            },
                            (payload) => {
                              return {
                                topic: payload?.topic,
                                partition: payload?.partition,
                                offset: payload?.message?.offset,
                                message: payload?.message,
                                groupId
                              };
                            }
                          );
                        } else if (eachBatch) {
                          options2.eachBatch = wrapKafkaCallback(
                            eachBatch,
                            {
                              startCh: channels.batchConsumerStart,
                              commitCh: channels.batchConsumerCommit,
                              finishCh: channels.batchConsumerFinish,
                              errorCh: channels.batchConsumerError
                            },
                            (payload) => {
                              const { batch } = payload;
                              return {
                                topic: batch?.topic,
                                partition: batch?.partition,
                                offset: batch?.messages[batch?.messages?.length - 1]?.offset,
                                messages: batch?.messages,
                                groupId
                              };
                            }
                          );
                        }
                        return run.apply(this, arguments);
                      };
                    });
                  }
                  if (typeof consumer?.commitOffsets === "function") {
                    shimmer.wrap(consumer, "commitOffsets", wrapCommit);
                  }
                  return consumer;
                };
              });
            }
            return kafka;
          };
        });
      }
    }
    function wrapCommit(commit) {
      return function wrappedCommit(options) {
        if (!channels.consumerCommit.hasSubscribers) {
          return commit.apply(this, arguments);
        }
        const result = commit.apply(this, arguments);
        channels.consumerCommit.publish(getLatestOffsets());
        latestConsumerOffsets.clear();
        return result;
      };
    }
    function wrapKafkaCallback(callback, { startCh, commitCh, finishCh, errorCh }, getPayload) {
      return function wrappedKafkaCallback(payload) {
        const commitPayload = getPayload(payload);
        const ctx = {
          extractedArgs: commitPayload
        };
        return startCh.runStores(ctx, () => {
          updateLatestOffset(commitPayload?.topic, commitPayload?.partition, commitPayload?.offset, commitPayload?.groupId);
          try {
            const result = callback.apply(this, arguments);
            if (result && typeof result.then === "function") {
              return result.then((res) => {
                ctx.result = res;
                finishCh.publish(ctx);
                return res;
              }).catch((err) => {
                ctx.error = err;
                errorCh.publish(ctx);
                finishCh.publish(ctx);
                throw err;
              });
            }
            finishCh.publish(ctx);
            return result;
          } catch (error) {
            ctx.error = error;
            errorCh.publish(ctx);
            finishCh.publish(ctx);
            throw error;
          }
        });
      };
    }
    function getGroupId(config) {
      if (!config) return "";
      if (config.kafkaJS?.groupId) return config.kafkaJS.groupId;
      if (config?.groupId) return config.groupId;
      if (config["group.id"]) return config["group.id"];
      return "";
    }
    function updateLatestOffset(topic, partition, offset, groupId) {
      const key = `${topic}:${partition}`;
      latestConsumerOffsets.set(key, {
        topic,
        partition,
        offset,
        groupId
      });
    }
    function getLatestOffsets() {
      return [...latestConsumerOffsets.values()];
    }
    function convertHeaders(headers) {
      return Object.entries(headers).map(([key, value]) => ({ [key.toString()]: value.toString() }));
    }
  }
});

// ../../packages/datadog-instrumentations/src/kafkajs.js
var require_kafkajs = __commonJS({
  "../../packages/datadog-instrumentations/src/kafkajs.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var producerStartCh = channel("apm:kafkajs:produce:start");
    var producerCommitCh = channel("apm:kafkajs:produce:commit");
    var producerFinishCh = channel("apm:kafkajs:produce:finish");
    var producerErrorCh = channel("apm:kafkajs:produce:error");
    var consumerStartCh = channel("apm:kafkajs:consume:start");
    var consumerCommitCh = channel("apm:kafkajs:consume:commit");
    var consumerFinishCh = channel("apm:kafkajs:consume:finish");
    var consumerErrorCh = channel("apm:kafkajs:consume:error");
    var batchConsumerStartCh = channel("apm:kafkajs:consume-batch:start");
    var batchConsumerFinishCh = channel("apm:kafkajs:consume-batch:finish");
    var batchConsumerErrorCh = channel("apm:kafkajs:consume-batch:error");
    var disabledHeaderWeakSet = /* @__PURE__ */ new WeakSet();
    function commitsFromEvent(event) {
      const { payload: { groupId, topics } } = event;
      const commitList = [];
      for (const { topic, partitions } of topics) {
        for (const { partition, offset } of partitions) {
          commitList.push({
            groupId,
            partition,
            offset,
            topic
          });
        }
      }
      consumerCommitCh.publish(commitList);
    }
    addHook({ name: "kafkajs", file: "src/index.js", versions: [">=1.4"] }, (BaseKafka) => {
      class Kafka extends BaseKafka {
        constructor(options) {
          super(options);
          this._brokers = options.brokers && typeof options.brokers !== "function" ? options.brokers.join(",") : void 0;
        }
      }
      shimmer.wrap(Kafka.prototype, "producer", (createProducer) => function() {
        const producer = createProducer.apply(this, arguments);
        const send = producer.send;
        const bootstrapServers = this._brokers;
        const kafkaClusterIdPromise = getKafkaClusterId(this);
        producer.send = function() {
          const wrappedSend = (clusterId) => {
            const { topic, messages = [] } = arguments[0];
            const ctx = {
              bootstrapServers,
              clusterId,
              disableHeaderInjection: disabledHeaderWeakSet.has(producer),
              messages,
              topic
            };
            for (const message of messages) {
              if (message !== null && typeof message === "object" && !ctx.disableHeaderInjection) {
                message.headers = message.headers || {};
              }
            }
            return producerStartCh.runStores(ctx, () => {
              try {
                const result = send.apply(this, arguments);
                result.then(
                  (res) => {
                    ctx.result = res;
                    producerFinishCh.publish(ctx);
                    producerCommitCh.publish(ctx);
                  },
                  (err) => {
                    ctx.error = err;
                    if (err) {
                      if (err.name === "KafkaJSProtocolError" && err.type === "UNKNOWN") {
                        disabledHeaderWeakSet.add(producer);
                        log.error("Kafka Broker responded with UNKNOWN_SERVER_ERROR (-1). Please look at broker logs for more information. Tracer message header injection for Kafka is disabled.");
                      }
                      producerErrorCh.publish(err);
                    }
                    producerFinishCh.publish(ctx);
                  }
                );
                return result;
              } catch (e) {
                ctx.error = e;
                producerErrorCh.publish(ctx);
                producerFinishCh.publish(ctx);
                throw e;
              }
            });
          };
          if (isPromise(kafkaClusterIdPromise)) {
            return kafkaClusterIdPromise.then((clusterId) => {
              return wrappedSend(clusterId);
            });
          }
          return wrappedSend(kafkaClusterIdPromise);
        };
        return producer;
      });
      shimmer.wrap(Kafka.prototype, "consumer", (createConsumer) => function() {
        if (!consumerStartCh.hasSubscribers) {
          return createConsumer.apply(this, arguments);
        }
        const kafkaClusterIdPromise = getKafkaClusterId(this);
        const eachMessageExtractor = (args, clusterId) => {
          const { topic, partition, message } = args[0];
          return { topic, partition, message, groupId, clusterId };
        };
        const eachBatchExtractor = (args, clusterId) => {
          const { batch } = args[0];
          const { topic, partition, messages } = batch;
          return { topic, partition, messages, groupId, clusterId };
        };
        const consumer = createConsumer.apply(this, arguments);
        consumer.on(consumer.events.COMMIT_OFFSETS, commitsFromEvent);
        const run = consumer.run;
        const groupId = arguments[0].groupId;
        consumer.run = function({ eachMessage, eachBatch, ...runArgs }) {
          const wrapConsume = (clusterId) => {
            return run({
              eachMessage: wrappedCallback(
                eachMessage,
                consumerStartCh,
                consumerFinishCh,
                consumerErrorCh,
                eachMessageExtractor,
                clusterId
              ),
              eachBatch: wrappedCallback(
                eachBatch,
                batchConsumerStartCh,
                batchConsumerFinishCh,
                batchConsumerErrorCh,
                eachBatchExtractor,
                clusterId
              ),
              ...runArgs
            });
          };
          if (isPromise(kafkaClusterIdPromise)) {
            return kafkaClusterIdPromise.then((clusterId) => {
              return wrapConsume(clusterId);
            });
          }
          return wrapConsume(kafkaClusterIdPromise);
        };
        return consumer;
      });
      return Kafka;
    });
    var wrappedCallback = (fn, startCh, finishCh, errorCh, extractArgs, clusterId) => {
      return typeof fn === "function" ? function(...args) {
        const extractedArgs = extractArgs(args, clusterId);
        const ctx = {
          extractedArgs
        };
        return startCh.runStores(ctx, () => {
          try {
            const result = fn.apply(this, args);
            if (result && typeof result.then === "function") {
              result.then(
                (res) => {
                  ctx.result = res;
                  finishCh.publish(ctx);
                },
                (err) => {
                  ctx.error = err;
                  if (err) {
                    errorCh.publish(ctx);
                  }
                  finishCh.publish(ctx);
                }
              );
            } else {
              finishCh.publish(ctx);
            }
            return result;
          } catch (e) {
            ctx.error = e;
            errorCh.publish(ctx);
            finishCh.publish(ctx);
            throw e;
          }
        });
      } : fn;
    };
    var getKafkaClusterId = (kafka) => {
      if (kafka._ddKafkaClusterId) {
        return kafka._ddKafkaClusterId;
      }
      if (!kafka.admin) {
        return null;
      }
      const admin = kafka.admin();
      if (!admin.describeCluster) {
        return null;
      }
      return admin.connect().then(() => {
        return admin.describeCluster();
      }).then((clusterInfo) => {
        const clusterId = clusterInfo?.clusterId;
        kafka._ddKafkaClusterId = clusterId;
        admin.disconnect();
        return clusterId;
      }).catch((error) => {
        throw error;
      });
    };
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
  }
});

// ../../packages/datadog-instrumentations/src/ldapjs.js
var require_ldapjs = __commonJS({
  "../../packages/datadog-instrumentations/src/ldapjs.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function isString(value) {
      return typeof value === "string" || value instanceof String;
    }
    function getCallbackArgIndex(args) {
      let callbackIndex = -1;
      for (let i = args.length - 1; i >= 0; i--) {
        if (typeof args[i] === "function") {
          callbackIndex = i;
          break;
        }
      }
      return callbackIndex;
    }
    function wrapEmitter(corkedEmitter) {
      const callbackMap = /* @__PURE__ */ new WeakMap();
      const addListener = (on) => function(name, fn) {
        if (typeof fn === "function") {
          let bindedFn = callbackMap.get(fn);
          if (!bindedFn) {
            const callbackResource = new AsyncResource("bound-anonymous-fn");
            bindedFn = callbackResource.bind(fn);
            callbackMap.set(fn, bindedFn);
          }
          arguments[1] = bindedFn;
        }
        return on.apply(this, arguments);
      };
      shimmer.wrap(corkedEmitter, "on", addListener);
      shimmer.wrap(corkedEmitter, "addListener", addListener);
      const removeListener = (off) => function(name, fn) {
        if (typeof fn === "function") {
          const emitterOn = callbackMap.get(fn);
          if (emitterOn) {
            arguments[1] = emitterOn;
          }
        }
        return off.apply(this, arguments);
      };
      shimmer.wrap(corkedEmitter, "off", removeListener);
      shimmer.wrap(corkedEmitter, "removeListener", removeListener);
    }
    addHook({ name: "ldapjs", versions: [">=2"] }, (ldapjs) => {
      const ldapSearchCh = channel("datadog:ldapjs:client:search");
      shimmer.wrap(ldapjs.Client.prototype, "search", (search) => function(base, options) {
        if (ldapSearchCh.hasSubscribers) {
          let filter;
          if (isString(options)) {
            filter = options;
          } else if (options !== null && typeof options === "object" && options.filter && isString(options.filter)) {
            filter = options.filter;
          }
          ldapSearchCh.publish({ base, filter });
        }
        return search.apply(this, arguments);
      });
      shimmer.wrap(ldapjs.Client.prototype, "_send", (_send) => function() {
        const callbackIndex = getCallbackArgIndex(arguments);
        if (callbackIndex > -1) {
          const callback = arguments[callbackIndex];
          arguments[callbackIndex] = shimmer.wrapFunction(callback, (callback2) => function(err, corkedEmitter) {
            if (corkedEmitter !== null && typeof corkedEmitter === "object" && typeof corkedEmitter.on === "function") {
              wrapEmitter(corkedEmitter);
            }
            callback2.apply(this, arguments);
          });
        }
        return _send.apply(this, arguments);
      });
      shimmer.wrap(ldapjs.Client.prototype, "bind", (bind) => function(dn, password, controls, callback) {
        if (typeof controls === "function") {
          arguments[2] = AsyncResource.bind(controls);
        } else if (typeof callback === "function") {
          arguments[3] = AsyncResource.bind(callback);
        }
        return bind.apply(this, arguments);
      });
      return ldapjs;
    });
  }
});

// ../../packages/datadog-instrumentations/src/limitd-client.js
var require_limitd_client = __commonJS({
  "../../packages/datadog-instrumentations/src/limitd-client.js"() {
    "use strict";
    var { addHook, AsyncResource } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapRequest(original) {
      return function() {
        const id = arguments.length - 1;
        arguments[id] = AsyncResource.bind(arguments[id]);
        return original.apply(this, arguments);
      };
    }
    addHook({
      name: "limitd-client",
      versions: [">=2.8"],
      file: ["client.js"]
    }, (LimitdClient) => {
      shimmer.wrap(LimitdClient.prototype, "_directRequest", wrapRequest);
      shimmer.wrap(LimitdClient.prototype, "_retriedRequest", wrapRequest);
      return LimitdClient;
    });
  }
});

// ../../packages/datadog-instrumentations/src/lodash.js
var require_lodash = __commonJS({
  "../../packages/datadog-instrumentations/src/lodash.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "lodash", versions: [">=4"] }, (lodash) => {
      const lodashOperationCh = channel("datadog:lodash:operation");
      const instrumentedLodashFn = ["trim", "trimStart", "trimEnd", "toLower", "toUpper", "join"];
      shimmer.massWrap(
        lodash,
        instrumentedLodashFn,
        (lodashFn) => {
          return function() {
            if (!lodashOperationCh.hasSubscribers) {
              return lodashFn.apply(this, arguments);
            }
            const result = lodashFn.apply(this, arguments);
            const message = { operation: lodashFn.name, arguments, result };
            lodashOperationCh.publish(message);
            return message.result;
          };
        }
      );
      return lodash;
    });
  }
});

// ../../packages/datadog-instrumentations/src/mariadb.js
var require_mariadb = __commonJS({
  "../../packages/datadog-instrumentations/src/mariadb.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var commandAddCh = channel("apm:mariadb:command:add");
    var connectionStartCh = channel("apm:mariadb:connection:start");
    var connectionFinishCh = channel("apm:mariadb:connection:finish");
    var startCh = channel("apm:mariadb:query:start");
    var finishCh = channel("apm:mariadb:query:finish");
    var errorCh = channel("apm:mariadb:query:error");
    var skipCh = channel("apm:mariadb:pool:skip");
    function wrapCommandStart(start, ctx) {
      return shimmer.wrapFunction(start, (start2) => function() {
        if (!startCh.hasSubscribers) return start2.apply(this, arguments);
        const { reject, resolve } = this;
        shimmer.wrap(this, "resolve", function wrapResolve() {
          return function() {
            return finishCh.runStores(ctx, resolve, this, ...arguments);
          };
        });
        shimmer.wrap(this, "reject", function wrapReject() {
          return function(error) {
            ctx.error = error;
            errorCh.publish(ctx);
            return finishCh.runStores(ctx, reject, this, ...arguments);
          };
        });
        return startCh.runStores(ctx, start2, this, ...arguments);
      });
    }
    function wrapCommand(Command) {
      return class extends Command {
        constructor(...args) {
          super(...args);
          if (!this.start) return;
          const ctx = { sql: this.sql, conf: this.opts };
          commandAddCh.publish(ctx);
          this.start = wrapCommandStart(this.start, ctx);
        }
      };
    }
    function createWrapQuery(options) {
      return function wrapQuery(query) {
        return function(sql) {
          if (!startCh.hasSubscribers) return query.apply(this, arguments);
          const ctx = { sql, conf: options };
          return startCh.runStores(ctx, query, this, ...arguments).then((result) => {
            ctx.result = result;
            finishCh.publish(ctx);
            return result;
          }, (error) => {
            ctx.error;
            errorCh.publish(ctx);
            finishCh.publish(ctx);
            throw error;
          });
        };
      };
    }
    function createWrapQueryCallback(options) {
      return function wrapQuery(query) {
        return function(sql) {
          if (!startCh.hasSubscribers) return query.apply(this, arguments);
          const cb = arguments[arguments.length - 1];
          const ctx = { sql, conf: options };
          if (typeof cb !== "function") {
            arguments.length += 1;
          }
          arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function(err) {
            if (err) {
              ctx.error = err;
              errorCh.publish(ctx);
            }
            return typeof cb2 === "function" ? finishCh.runStores(ctx, cb2, this, ...arguments) : finishCh.publish(ctx);
          });
          return startCh.runStores(ctx, query, this, ...arguments);
        };
      };
    }
    function wrapConnection(promiseMethod, Connection) {
      return function(options) {
        Connection.apply(this, arguments);
        shimmer.wrap(this, promiseMethod, createWrapQuery(options));
        shimmer.wrap(this, "_queryCallback", createWrapQueryCallback(options));
      };
    }
    function wrapPoolBase(PoolBase) {
      return function(options, processTask, createConnectionPool, pingPromise) {
        arguments[1] = wrapPoolMethod(processTask);
        arguments[2] = wrapPoolMethod(createConnectionPool);
        PoolBase.apply(this, arguments);
        shimmer.wrap(this, "query", createWrapQuery(options.connOptions));
      };
    }
    function wrapPoolMethod(createConnection) {
      return function() {
        return skipCh.runStores({}, createConnection, this, ...arguments);
      };
    }
    function wrapPoolGetConnectionMethod(getConnection) {
      return function wrappedGetConnection() {
        const cb = arguments[arguments.length - 1];
        if (typeof cb !== "function") return getConnection.apply(this, arguments);
        const ctx = {};
        arguments[arguments.length - 1] = function() {
          return connectionFinishCh.runStores(ctx, cb, this, ...arguments);
        };
        connectionStartCh.publish(ctx);
        return getConnection.apply(this, arguments);
      };
    }
    var name = "mariadb";
    addHook({ name, file: "lib/cmd/query.js", versions: [">=3"] }, (Query) => {
      return wrapCommand(Query);
    });
    addHook({ name, file: "lib/cmd/execute.js", versions: [">=3"] }, (Execute) => {
      return wrapCommand(Execute);
    });
    addHook({ name, file: "lib/pool.js", versions: [">=3.4.1"] }, (Pool) => {
      shimmer.wrap(Pool.prototype, "getConnection", wrapPoolGetConnectionMethod);
      return Pool;
    });
    addHook({ name, file: "lib/pool.js", versions: [">=3"] }, (Pool) => {
      shimmer.wrap(Pool.prototype, "_createConnection", wrapPoolMethod);
      return Pool;
    });
    addHook({ name, file: "lib/connection.js", versions: [">=2.5.2 <3"] }, (Connection) => {
      return shimmer.wrapFunction(Connection, wrapConnection.bind(null, "_queryPromise"));
    });
    addHook({ name, file: "lib/connection.js", versions: [">=2.0.4 <=2.5.1"] }, (Connection) => {
      return shimmer.wrapFunction(Connection, wrapConnection.bind(null, "query"));
    });
    addHook({ name, file: "lib/pool-base.js", versions: [">=2.0.4 <3"] }, (PoolBase) => {
      return shimmer.wrapFunction(PoolBase, wrapPoolBase);
    });
  }
});

// ../../packages/datadog-instrumentations/src/memcached.js
var require_memcached = __commonJS({
  "../../packages/datadog-instrumentations/src/memcached.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "memcached", versions: [">=2.2"] }, (Memcached) => {
      const startCh = channel("apm:memcached:command:start");
      const finishCh = channel("apm:memcached:command:finish");
      const errorCh = channel("apm:memcached:command:error");
      shimmer.wrap(Memcached.prototype, "command", (command) => function(queryCompiler, server2) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        const client = this;
        const wrappedQueryCompiler = function() {
          const query = queryCompiler.apply(this, arguments);
          const ctx = { client, server: server2, query };
          startCh.runStores(ctx, () => {
            query.callback = shimmer.wrapFunction(query.callback, (callback) => function(err) {
              if (err) {
                ctx.error = err;
                errorCh.publish(ctx);
              }
              finishCh.publish(ctx);
              return finishCh.runStores(ctx, callback, this, ...arguments);
            });
          });
          return query;
        };
        arguments[0] = wrappedQueryCompiler;
        return command.apply(this, arguments);
      });
      return Memcached;
    });
  }
});

// ../../packages/datadog-instrumentations/src/microgateway-core.js
var require_microgateway_core = __commonJS({
  "../../packages/datadog-instrumentations/src/microgateway-core.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var handleChannel = channel("apm:microgateway-core:request:handle");
    var routeChannel = channel("apm:microgateway-core:request:route");
    var errorChannel = channel("apm:microgateway-core:request:error");
    var name = "microgateway-core";
    var versions = [">=2.1 <=3.0.0"];
    var requestContexts = /* @__PURE__ */ new WeakMap();
    function wrapConfigProxyFactory(configProxyFactory) {
      return function() {
        const configProxy = configProxyFactory.apply(this, arguments);
        return function(req, res, next) {
          const ctx = { req, res };
          requestContexts.set(req, ctx);
          handleChannel.publish(ctx);
          return configProxy.apply(this, arguments);
        };
      };
    }
    function wrapPluginsFactory(pluginsFactory) {
      return function(plugins) {
        const pluginsMiddleware = pluginsFactory.apply(this, arguments);
        return function pluginsMiddlewareWithTrace(req, res, next) {
          arguments[2] = wrapNext(req, res, next);
          return pluginsMiddleware.apply(this, arguments);
        };
      };
    }
    function wrapNext(req, res, next) {
      return shimmer.wrapFunction(next, (next2) => function nextWithTrace(err) {
        const ctx = requestContexts.get(req);
        if (err) {
          ctx.error = err;
          errorChannel.publish(ctx);
        }
        if (res.proxy && res.proxy.base_path) {
          ctx.req = req;
          ctx.res = res;
          ctx.route = res.proxy.base_path;
          routeChannel.publish(ctx);
        }
        return next2.apply(this, arguments);
      });
    }
    addHook({ name, versions, file: "lib/config-proxy-middleware.js" }, (configProxyFactory) => {
      return shimmer.wrapFunction(configProxyFactory, wrapConfigProxyFactory);
    });
    addHook({ name, versions, file: "lib/plugins-middleware.js" }, (pluginsFactory) => {
      return shimmer.wrapFunction(pluginsFactory, wrapPluginsFactory);
    });
  }
});

// ../../packages/datadog-instrumentations/src/mocha/utils.js
var require_utils3 = __commonJS({
  "../../packages/datadog-instrumentations/src/mocha/utils.js"(exports2, module2) {
    "use strict";
    var { getTestSuitePath } = require_test();
    var { channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var testStartCh = channel("ci:mocha:test:start");
    var testFinishCh = channel("ci:mocha:test:finish");
    var testRetryCh = channel("ci:mocha:test:retry");
    var errorCh = channel("ci:mocha:test:error");
    var skipCh = channel("ci:mocha:test:skip");
    var testFnCh = channel("ci:mocha:test:fn");
    var isModifiedCh = channel("ci:mocha:test:is-modified");
    var testSuiteErrorCh = channel("ci:mocha:test-suite:error");
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200;
    var testToContext = /* @__PURE__ */ new WeakMap();
    var originalFns = /* @__PURE__ */ new WeakMap();
    var testToStartLine = /* @__PURE__ */ new WeakMap();
    var testFileToSuiteCtx = /* @__PURE__ */ new Map();
    var wrappedFunctions = /* @__PURE__ */ new WeakSet();
    var newTests = {};
    var testsAttemptToFix = /* @__PURE__ */ new Set();
    var testsQuarantined = /* @__PURE__ */ new Set();
    var testsStatuses = /* @__PURE__ */ new Map();
    function getAfterEachHooks(testOrHook) {
      const hooks = [];
      while (testOrHook.parent) {
        if (testOrHook.parent._afterEach) {
          hooks.push(...testOrHook.parent._afterEach);
        }
        testOrHook = testOrHook.parent;
      }
      return hooks;
    }
    function getTestProperties(test, testManagementTests) {
      const testSuite = getTestSuitePath(test.file, process.cwd());
      const testName = test.fullTitle();
      const { attempt_to_fix: isAttemptToFix, disabled: isDisabled, quarantined: isQuarantined } = testManagementTests?.mocha?.suites?.[testSuite]?.tests?.[testName]?.properties || {};
      return { isAttemptToFix, isDisabled, isQuarantined };
    }
    function isNewTest(test, knownTests) {
      if (!knownTests?.mocha) {
        return false;
      }
      const testSuite = getTestSuitePath(test.file, process.cwd());
      const testName = test.fullTitle();
      const testsForSuite = knownTests.mocha?.[testSuite] || [];
      return !testsForSuite.includes(testName);
    }
    function retryTest(test, numRetries, tags) {
      const suite = test.parent;
      for (let retryIndex = 0; retryIndex < numRetries; retryIndex++) {
        const clonedTest = test.clone();
        suite.addTest(clonedTest);
        tags.forEach((tag) => {
          if (tag) {
            clonedTest[tag] = true;
          }
        });
      }
    }
    function getSuitesByTestFile(root) {
      const suitesByTestFile = {};
      function getSuites(suite) {
        if (suite.file) {
          if (suitesByTestFile[suite.file]) {
            suitesByTestFile[suite.file].push(suite);
          } else {
            suitesByTestFile[suite.file] = [suite];
          }
        }
        suite.suites.forEach((suite2) => {
          getSuites(suite2);
        });
      }
      getSuites(root);
      const numSuitesByTestFile = Object.keys(suitesByTestFile).reduce((acc, testFile) => {
        acc[testFile] = suitesByTestFile[testFile].length;
        return acc;
      }, {});
      return { suitesByTestFile, numSuitesByTestFile };
    }
    function isMochaRetry(test) {
      return test._currentRetry !== void 0 && test._currentRetry !== 0;
    }
    function getIsLastRetry(test) {
      return test._currentRetry === test._retries;
    }
    function getTestFullName(test) {
      return `mocha.${getTestSuitePath(test.file, process.cwd())}.${test.fullTitle()}`;
    }
    function getTestStatus(test) {
      if (test.isPending()) {
        return "skip";
      }
      if (test.isFailed() || test.timedOut) {
        return "fail";
      }
      return "pass";
    }
    function getTestToContextKey(test) {
      if (!test.fn) {
        return test;
      }
      if (!wrappedFunctions.has(test.fn)) {
        return test.fn;
      }
      const originalFn = originalFns.get(test.fn);
      return originalFn;
    }
    function getTestContext(test) {
      const key = getTestToContextKey(test);
      return testToContext.get(key);
    }
    function runnableWrapper(RunnablePackage, libraryConfig) {
      shimmer.wrap(RunnablePackage.prototype, "run", (run) => function() {
        if (!testFinishCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        if (libraryConfig?.isFlakyTestRetriesEnabled) {
          this.retries(libraryConfig?.flakyTestRetriesCount);
        }
        const isBeforeEach = this.parent._beforeEach.includes(this);
        const isAfterEach = this.parent._afterEach.includes(this);
        const isTestHook = isBeforeEach || isAfterEach;
        if (wrappedFunctions.has(this.fn)) {
          const originalFn = originalFns.get(this.fn);
          this.fn = originalFn;
          wrappedFunctions.delete(this.fn);
        }
        if (isTestHook || this.type === "test") {
          const test = isTestHook ? this.ctx.currentTest : this;
          const ctx = getTestContext(test);
          if (ctx) {
            const newFn = shimmer.wrapFunction(this.fn, (originalFn) => function() {
              return testFnCh.runStores(ctx, () => originalFn.apply(this, arguments));
            });
            originalFns.set(newFn, this.fn);
            this.fn = newFn;
            wrappedFunctions.add(this.fn);
          }
        }
        return run.apply(this, arguments);
      });
      return RunnablePackage;
    }
    function getOnTestHandler(isMain) {
      return function(test) {
        const testStartLine = testToStartLine.get(test);
        if (wrappedFunctions.has(test.fn)) {
          const originalFn = originalFns.get(test.fn);
          test.fn = originalFn;
          wrappedFunctions.delete(test.fn);
        }
        const {
          file: testSuiteAbsolutePath,
          title,
          _ddIsNew: isNew,
          _ddIsEfdRetry: isEfdRetry,
          _ddIsAttemptToFix: isAttemptToFix,
          _ddIsDisabled: isDisabled,
          _ddIsQuarantined: isQuarantined,
          _ddIsModified: isModified
        } = test;
        const testInfo = {
          testName: test.fullTitle(),
          testSuiteAbsolutePath,
          title,
          testStartLine
        };
        if (!isMain) {
          testInfo.isParallel = true;
        }
        testInfo.isNew = isNew;
        testInfo.isEfdRetry = isEfdRetry;
        testInfo.isAttemptToFix = isAttemptToFix;
        testInfo.isDisabled = isDisabled;
        testInfo.isQuarantined = isQuarantined;
        testInfo.isModified = isModified;
        if (isNew) {
          const testFullName = getTestFullName(test);
          if (newTests[testFullName]) {
            newTests[testFullName].push(test);
          } else {
            newTests[testFullName] = [test];
          }
        }
        if (!isAttemptToFix && isDisabled) {
          test.pending = true;
        }
        const ctx = testInfo;
        testToContext.set(test.fn, ctx);
        testStartCh.runStores(ctx, () => {
        });
      };
    }
    function getOnTestEndHandler(config) {
      return async function(test) {
        const ctx = getTestContext(test);
        const status = getTestStatus(test);
        if (test._ddShouldWaitForHitProbe || test._retriedTest?._ddShouldWaitForHitProbe) {
          await new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, BREAKPOINT_HIT_GRACE_PERIOD_MS);
          });
        }
        let hasFailedAllRetries = false;
        let attemptToFixPassed = false;
        let attemptToFixFailed = false;
        const testName = getTestFullName(test);
        if (testsStatuses.get(testName)) {
          testsStatuses.get(testName).push(status);
        } else {
          testsStatuses.set(testName, [status]);
        }
        const testStatuses = testsStatuses.get(testName);
        const isLastAttempt = testStatuses.length === config.testManagementAttemptToFixRetries + 1;
        if (test._ddIsAttemptToFix && isLastAttempt) {
          if (testStatuses.includes("fail")) {
            attemptToFixFailed = true;
          }
          if (testStatuses.every((status2) => status2 === "fail")) {
            hasFailedAllRetries = true;
          } else if (testStatuses.every((status2) => status2 === "pass")) {
            attemptToFixPassed = true;
          }
        }
        const isAttemptToFixRetry = test._ddIsAttemptToFix && testStatuses.length > 1;
        const isAtrRetry = config.isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry;
        if (ctx && !getAfterEachHooks(test).length) {
          testFinishCh.publish({
            status,
            hasBeenRetried: isMochaRetry(test),
            isLastRetry: getIsLastRetry(test),
            hasFailedAllRetries,
            attemptToFixPassed,
            attemptToFixFailed,
            isAttemptToFixRetry,
            isAtrRetry,
            ...ctx.currentStore
          });
        }
      };
    }
    function getOnHookEndHandler() {
      return function(hook) {
        const test = hook.ctx.currentTest;
        const afterEachHooks = getAfterEachHooks(hook);
        if (test && afterEachHooks.includes(hook)) {
          const isLastAfterEach = afterEachHooks.indexOf(hook) === afterEachHooks.length - 1;
          if (isLastAfterEach) {
            const status = getTestStatus(test);
            const ctx = getTestContext(test);
            if (ctx) {
              testFinishCh.publish({
                status,
                hasBeenRetried: isMochaRetry(test),
                isLastRetry: getIsLastRetry(test),
                ...ctx.currentStore
              });
            }
          }
        }
      };
    }
    function getOnFailHandler(isMain) {
      return function(testOrHook, err) {
        const testFile = testOrHook.file;
        let test = testOrHook;
        const isHook = testOrHook.type === "hook";
        if (isHook && testOrHook.ctx) {
          test = testOrHook.ctx.currentTest;
        }
        let testContext;
        if (test) {
          testContext = getTestContext(test);
        }
        if (testContext) {
          if (isHook) {
            err.message = `${testOrHook.fullTitle()}: ${err.message}`;
            testContext.err = err;
            errorCh.runStores(testContext, () => {
            });
            testFinishCh.publish({ status: "fail", hasBeenRetried: isMochaRetry(test), ...testContext.currentStore });
          } else {
            testContext.err = err;
            errorCh.runStores(testContext, () => {
            });
          }
        }
        if (isMain) {
          const testSuiteContext = testFileToSuiteCtx.get(testFile);
          if (testSuiteContext) {
            const testSuiteError = new Error(
              `"${testOrHook.parent.fullTitle()}" failed with message "${err.message}"`
            );
            testSuiteError.stack = err.stack;
            testSuiteContext.error = testSuiteError;
            testSuiteErrorCh.runStores(testSuiteContext, () => {
            });
          }
        }
      };
    }
    function getOnTestRetryHandler(config) {
      return function(test, err) {
        const ctx = getTestContext(test);
        if (ctx) {
          const isFirstAttempt = test._currentRetry === 0;
          const willBeRetried = test._currentRetry < test._retries;
          const isAtrRetry = !isFirstAttempt && config.isFlakyTestRetriesEnabled && !test._ddIsAttemptToFix && !test._ddIsEfdRetry;
          testRetryCh.publish({ isFirstAttempt, err, willBeRetried, test, isAtrRetry, ...ctx.currentStore });
        }
        const key = getTestToContextKey(test);
        testToContext.delete(key);
      };
    }
    function getOnPendingHandler() {
      return function(test) {
        const testStartLine = testToStartLine.get(test);
        const {
          file: testSuiteAbsolutePath,
          title
        } = test;
        const testInfo = {
          testName: test.fullTitle(),
          testSuiteAbsolutePath,
          title,
          testStartLine
        };
        const ctx = getTestContext(test);
        if (ctx) {
          skipCh.publish(testInfo);
        } else {
          const testCtx = testInfo;
          if (test.fn) {
            testToContext.set(test.fn, testCtx);
          } else {
            testToContext.set(test, testCtx);
          }
          skipCh.runStores(testCtx, () => {
          });
        }
      };
    }
    function getRunTestsWrapper(runTests, config) {
      return function(suite) {
        if (config.isTestManagementTestsEnabled) {
          suite.tests.forEach((test) => {
            const { isAttemptToFix, isDisabled, isQuarantined } = getTestProperties(test, config.testManagementTests);
            if (isAttemptToFix && !test.isPending()) {
              test._ddIsAttemptToFix = true;
              test._ddIsDisabled = isDisabled;
              test._ddIsQuarantined = isQuarantined;
              testsAttemptToFix.add(test);
              retryTest(
                test,
                config.testManagementAttemptToFixRetries,
                ["_ddIsAttemptToFix", isDisabled && "_ddIsDisabled", isQuarantined && "_ddIsQuarantined"]
              );
            } else if (isDisabled) {
              test._ddIsDisabled = true;
            } else if (isQuarantined) {
              testsQuarantined.add(test);
              test._ddIsQuarantined = true;
            }
          });
        }
        if (config.isImpactedTestsEnabled) {
          suite.tests.forEach((test) => {
            isModifiedCh.publish({
              modifiedFiles: config.modifiedFiles,
              file: suite.file,
              onDone: (isModified) => {
                if (isModified) {
                  test._ddIsModified = true;
                  if (!test.isPending() && !test._ddIsAttemptToFix && config.isEarlyFlakeDetectionEnabled) {
                    retryTest(
                      test,
                      config.earlyFlakeDetectionNumRetries,
                      ["_ddIsModified", "_ddIsEfdRetry"]
                    );
                  }
                }
              }
            });
          });
        }
        if (config.isKnownTestsEnabled) {
          suite.tests.forEach((test) => {
            if (!test.isPending() && isNewTest(test, config.knownTests)) {
              test._ddIsNew = true;
              if (config.isEarlyFlakeDetectionEnabled && !test._ddIsAttemptToFix && !test._ddIsModified) {
                retryTest(
                  test,
                  config.earlyFlakeDetectionNumRetries,
                  ["_ddIsNew", "_ddIsEfdRetry"]
                );
              }
            }
          });
        }
        return runTests.apply(this, arguments);
      };
    }
    module2.exports = {
      isNewTest,
      getTestProperties,
      getSuitesByTestFile,
      isMochaRetry,
      getTestFullName,
      getTestStatus,
      runnableWrapper,
      testToContext,
      originalFns,
      getTestContext,
      testToStartLine,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnTestRetryHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      testFileToSuiteCtx,
      getRunTestsWrapper,
      newTests,
      testsQuarantined,
      testsAttemptToFix,
      testsStatuses
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/stacktrace.js
var require_stacktrace = __commonJS({
  "../../packages/dd-trace/src/plugins/util/stacktrace.js"(exports2, module2) {
    "use strict";
    var { relative, sep, join } = __require("path");
    var cwd = process.cwd();
    var NODE_MODULES_PATTERN_MIDDLE = `${sep}node_modules${sep}`;
    var NODE_MODULES_PATTERN_START = `node_modules${sep}`;
    var SHOULD_FILTER_DD_TRACE_INSTRUMENTAION = __filename.endsWith(
      join(sep, "dd-trace-js", "packages", "dd-trace", "src", "plugins", "util", "stacktrace.js")
    );
    module2.exports = {
      getCallSites,
      parseUserLandFrames
    };
    function getCallSites(constructorOpt) {
      const oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      const dummy = {};
      const v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummy, constructorOpt);
      const v8StackTrace = dummy.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    }
    function parseUserLandFrames(stack, limit = Infinity) {
      let index = stack.indexOf("\n    at ");
      const frames = [];
      while (index !== -1 && frames.length !== limit) {
        const nextIndex = stack.indexOf("\n", index + 1);
        const frame = parseLine(stack, index, nextIndex === -1 ? stack.length : nextIndex);
        if (frame !== void 0) frames.push(frame);
        index = nextIndex;
      }
      return frames;
    }
    function parseLine(stack, start, end) {
      let index;
      if (stack[end - 1] === ")") {
        index = end - 2;
        const code = stack.charCodeAt(index);
        if (code < 48 || code > 57) return;
      } else {
        index = end - 1;
      }
      start += 8;
      if (stack.startsWith("new ", start)) start += 4;
      else if (stack.startsWith("async ", start)) start += 6;
      let fileName, lineNumber, columnNumber;
      const result = parseLocation(stack, start, index);
      if (result === void 0) return;
      [fileName, lineNumber, columnNumber, index] = result;
      if (isNodeModulesFrame(fileName)) return;
      if (SHOULD_FILTER_DD_TRACE_INSTRUMENTAION && isDDInstrumentationFile(fileName)) return;
      let methodName, functionName;
      if (stack[index] === "]") {
        methodName = "";
        index--;
        for (; index >= start; index--) {
          const char = stack[index];
          if (char === " " && stack.slice(index - 4, index) === " [as") {
            index -= 4;
            break;
          } else if (char === "[") {
            functionName = `${stack.slice(start, index)}[${methodName}]`;
            methodName = void 0;
            break;
          }
          methodName = char + methodName;
        }
        index--;
      }
      functionName ??= start <= index ? stack.slice(start, index + 1) : void 0;
      let typeName;
      if (functionName !== void 0 && functionName[0] !== "[") {
        const periodIndex = functionName.indexOf(".");
        if (periodIndex !== -1) {
          typeName = functionName.slice(0, periodIndex);
          functionName = functionName.slice(periodIndex + 1);
        }
      }
      return {
        lineNumber,
        columnNumber,
        fileName,
        methodName,
        functionName,
        typeName
      };
    }
    function isNodeModulesFrame(fileName) {
      if (!fileName.includes(NODE_MODULES_PATTERN_MIDDLE)) {
        return false;
      }
      const actualPath = fileName.startsWith("file:") ? fileName.slice(7) : fileName;
      const relativePath = relative(cwd, actualPath);
      return relativePath.startsWith(NODE_MODULES_PATTERN_START) || relativePath.includes(NODE_MODULES_PATTERN_MIDDLE);
    }
    function isDDInstrumentationFile(fileName) {
      return fileName.includes(`packages${sep}datadog-instrumentations${sep}src`);
    }
    function parseLocation(stack, start, index) {
      let columnNumber = "";
      for (; index >= start; index--) {
        const code = stack.charCodeAt(index);
        if (code === 41) {
          continue;
        }
        if (code < 48 || code > 57) break;
        columnNumber = stack[index] + columnNumber;
      }
      index--;
      let lineNumber = "";
      for (; index >= start; index--) {
        const code = stack.charCodeAt(index);
        if (code < 48 || code > 57) break;
        lineNumber = stack[index] + lineNumber;
      }
      index--;
      let nestedParenthesis = 1;
      let fileName = "";
      for (; index >= start; index--) {
        const char = stack[index];
        if (char === ")") {
          nestedParenthesis++;
        } else if (char === "(" && --nestedParenthesis === 0) {
          index -= 2;
          break;
        } else if (nestedParenthesis === 1 && char === ":" && stack.slice(index - 4, index) === "node") {
          return;
        }
        fileName = char + fileName;
      }
      if (fileName.startsWith("eval at ")) {
        const result = parseLocation(fileName, 0, fileName.lastIndexOf(",") - 2);
        if (result === void 0) return;
        [fileName, lineNumber, columnNumber] = result;
      }
      return [
        fileName,
        lineNumber,
        columnNumber,
        index
        // return the index, so the caller knows how far we got
      ];
    }
  }
});

// ../../packages/datadog-instrumentations/src/mocha/common.js
var require_common = __commonJS({
  "../../packages/datadog-instrumentations/src/mocha/common.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { getCallSites } = require_stacktrace();
    var { testToStartLine } = require_utils3();
    var parameterizedTestCh = channel("ci:mocha:test:parameterize");
    var patched = /* @__PURE__ */ new WeakSet();
    addHook({
      name: "mocha-each",
      versions: [">=2.0.1"]
    }, (mochaEach) => {
      if (patched.has(mochaEach)) return mochaEach;
      patched.add(mochaEach);
      return shimmer.wrapFunction(mochaEach, (mochaEach2) => function() {
        const [params] = arguments;
        const { it, ...rest } = mochaEach2.apply(this, arguments);
        return {
          it: function(title) {
            parameterizedTestCh.publish({ title, params });
            it.apply(this, arguments);
          },
          ...rest
        };
      });
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/suite.js"
    }, (Suite) => {
      shimmer.wrap(Suite.prototype, "addTest", (addTest) => function(test) {
        const callSites = getCallSites();
        let startLine;
        const testCallSite = callSites.find((site) => site.getFileName() === test.file);
        if (testCallSite) {
          startLine = testCallSite.getLineNumber();
          testToStartLine.set(test, startLine);
        }
        return addTest.apply(this, arguments);
      });
      return Suite;
    });
  }
});

// ../../packages/datadog-instrumentations/src/mocha/worker.js
var require_worker = __commonJS({
  "../../packages/datadog-instrumentations/src/mocha/worker.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var {
      runnableWrapper,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      getRunTestsWrapper
    } = require_utils3();
    require_common();
    var workerFinishCh = channel("ci:mocha:worker:finish");
    var config = {};
    addHook({
      name: "mocha",
      versions: [">=8.0.0"],
      file: "lib/mocha.js"
    }, (Mocha) => {
      shimmer.wrap(Mocha.prototype, "run", (run) => function() {
        if (this.options._ddIsKnownTestsEnabled) {
          config.isKnownTestsEnabled = true;
          config.isEarlyFlakeDetectionEnabled = this.options._ddIsEfdEnabled;
          config.knownTests = this.options._ddKnownTests;
          config.earlyFlakeDetectionNumRetries = this.options._ddEfdNumRetries;
          delete this.options._ddIsEfdEnabled;
          delete this.options._ddKnownTests;
          delete this.options._ddEfdNumRetries;
          delete this.options._ddIsKnownTestsEnabled;
        }
        if (this.options._ddIsImpactedTestsEnabled) {
          config.isImpactedTestsEnabled = true;
          config.modifiedFiles = this.options._ddModifiedFiles;
          delete this.options._ddIsImpactedTestsEnabled;
          delete this.options._ddModifiedFiles;
        }
        if (this.options._ddIsTestManagementTestsEnabled) {
          config.isTestManagementTestsEnabled = true;
          config.testManagementTests = this.options._ddTestManagementTests;
          delete this.options._ddIsTestManagementTestsEnabled;
          delete this.options._ddTestManagementTests;
        }
        return run.apply(this, arguments);
      });
      return Mocha;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runner.js"
    }, function(Runner) {
      shimmer.wrap(Runner.prototype, "runTests", (runTests) => getRunTestsWrapper(runTests, config));
      shimmer.wrap(Runner.prototype, "run", (run) => function() {
        if (!workerFinishCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        this.on("end", () => {
          workerFinishCh.publish();
        });
        this.on("test", getOnTestHandler(false));
        this.on("test end", getOnTestEndHandler(config));
        this.on("hook end", getOnHookEndHandler());
        this.on("fail", getOnFailHandler(false));
        this.on("pending", getOnPendingHandler());
        return run.apply(this, arguments);
      });
      return Runner;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runnable.js"
    }, runnableWrapper);
  }
});

// ../../packages/datadog-instrumentations/src/mocha/main.js
var require_main = __commonJS({
  "../../packages/datadog-instrumentations/src/mocha/main.js"() {
    "use strict";
    var { createCoverageMap } = require_istanbul_lib_coverage();
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { isMarkedAsUnskippable } = require_util4();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      getTestSuitePath,
      MOCHA_WORKER_TRACE_PAYLOAD_CODE,
      fromCoverageMapToCoverage,
      getCoveredFilenamesFromCoverage,
      mergeCoverage,
      resetCoverage,
      getIsFaultyEarlyFlakeDetection
    } = require_test();
    var {
      isNewTest,
      getTestProperties,
      getSuitesByTestFile,
      runnableWrapper,
      getOnTestHandler,
      getOnTestEndHandler,
      getOnTestRetryHandler,
      getOnHookEndHandler,
      getOnFailHandler,
      getOnPendingHandler,
      testFileToSuiteCtx,
      newTests,
      testsQuarantined,
      getTestFullName,
      getRunTestsWrapper,
      testsAttemptToFix,
      testsStatuses
    } = require_utils3();
    require_common();
    var patched = /* @__PURE__ */ new WeakSet();
    var unskippableSuites = [];
    var suitesToSkip = [];
    var isSuitesSkipped = false;
    var skippedSuites = [];
    var itrCorrelationId = "";
    var isForcedToRun = false;
    var config = {};
    var originalCoverageMap = createCoverageMap();
    var untestedCoverage;
    var testFinishCh = channel("ci:mocha:test:finish");
    var testSuiteStartCh = channel("ci:mocha:test-suite:start");
    var testSuiteFinishCh = channel("ci:mocha:test-suite:finish");
    var testSuiteErrorCh = channel("ci:mocha:test-suite:error");
    var testSuiteCodeCoverageCh = channel("ci:mocha:test-suite:code-coverage");
    var libraryConfigurationCh = channel("ci:mocha:library-configuration");
    var knownTestsCh = channel("ci:mocha:known-tests");
    var skippableSuitesCh = channel("ci:mocha:test-suite:skippable");
    var mochaGlobalRunCh = channel("ci:mocha:global:run");
    var testManagementTestsCh = channel("ci:mocha:test-management-tests");
    var modifiedFilesCh = channel("ci:mocha:modified-files");
    var workerReportTraceCh = channel("ci:mocha:worker-report:trace");
    var testSessionStartCh = channel("ci:mocha:session:start");
    var testSessionFinishCh = channel("ci:mocha:session:finish");
    var itrSkippedSuitesCh = channel("ci:mocha:itr:skipped-suites");
    var getCodeCoverageCh = channel("ci:nyc:get-coverage");
    function isTestFailed(test) {
      if (test.isFailed) {
        return test.isFailed();
      }
      if (test.isPending) {
        return !test.isPending() && test.state === "failed";
      }
      return false;
    }
    function getFilteredSuites(originalSuites) {
      return originalSuites.reduce((acc, suite) => {
        const testPath = getTestSuitePath(suite.file, process.cwd());
        const shouldSkip = suitesToSkip.includes(testPath);
        const isUnskippable = unskippableSuites.includes(suite.file);
        if (shouldSkip && !isUnskippable) {
          acc.skippedSuites.add(testPath);
        } else {
          acc.suitesToRun.push(suite);
        }
        return acc;
      }, { suitesToRun: [], skippedSuites: /* @__PURE__ */ new Set() });
    }
    function getOnStartHandler(isParallel, frameworkVersion) {
      return function() {
        const processArgv = process.argv.slice(2).join(" ");
        const command = `mocha ${processArgv}`;
        testSessionStartCh.publish({ command, frameworkVersion });
        if (!isParallel && skippedSuites.length) {
          itrSkippedSuitesCh.publish({ skippedSuites, frameworkVersion });
        }
      };
    }
    function getOnEndHandler(isParallel) {
      return function() {
        let status = "pass";
        let error;
        if (this.stats) {
          status = this.stats.failures === 0 ? "pass" : "fail";
          if (this.stats.tests === 0) {
            status = "skip";
          }
        } else if (this.failures !== 0) {
          status = "fail";
        }
        if (config.isEarlyFlakeDetectionEnabled) {
          for (const tests of Object.values(newTests)) {
            const failingNewTests = tests.filter((test) => isTestFailed(test));
            const areAllNewTestsFailing = failingNewTests.length === tests.length;
            if (failingNewTests.length && !areAllNewTestsFailing) {
              this.stats.failures -= failingNewTests.length;
              this.failures -= failingNewTests.length;
            }
          }
        }
        if (config.isTestManagementTestsEnabled) {
          let numFailedQuarantinedTests = 0;
          let numFailedRetriedQuarantinedOrDisabledTests = 0;
          for (const test of testsAttemptToFix) {
            const testName = getTestFullName(test);
            const testProperties = getTestProperties(test, config.testManagementTests);
            if (isTestFailed(test) && (testProperties.isQuarantined || testProperties.isDisabled)) {
              const numFailedTests = testsStatuses.get(testName).filter((status2) => status2 === "fail").length;
              numFailedRetriedQuarantinedOrDisabledTests += numFailedTests;
            }
          }
          for (const test of testsQuarantined) {
            if (isTestFailed(test)) {
              numFailedQuarantinedTests++;
            }
          }
          this.stats.failures -= numFailedQuarantinedTests + numFailedRetriedQuarantinedOrDisabledTests;
          this.failures -= numFailedQuarantinedTests + numFailedRetriedQuarantinedOrDisabledTests;
        }
        if (status === "fail") {
          error = new Error(`Failed tests: ${this.failures}.`);
        }
        testFileToSuiteCtx.clear();
        let testCodeCoverageLinesTotal;
        if (global.__coverage__) {
          try {
            if (untestedCoverage) {
              originalCoverageMap.merge(fromCoverageMapToCoverage(untestedCoverage));
            }
            testCodeCoverageLinesTotal = originalCoverageMap.getCoverageSummary().lines.pct;
          } catch {
          }
          global.__coverage__ = fromCoverageMapToCoverage(originalCoverageMap);
        }
        testSessionFinishCh.publish({
          status,
          isSuitesSkipped,
          testCodeCoverageLinesTotal,
          numSkippedSuites: skippedSuites.length,
          hasForcedToRunSuites: isForcedToRun,
          hasUnskippableSuites: !!unskippableSuites.length,
          error,
          isEarlyFlakeDetectionEnabled: config.isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty: config.isEarlyFlakeDetectionFaulty,
          isTestManagementEnabled: config.isTestManagementTestsEnabled,
          isParallel
        });
      };
    }
    function getExecutionConfiguration(runner, isParallel, frameworkVersion, onFinishRequest) {
      const ctx = {
        isParallel,
        frameworkVersion
      };
      const onReceivedSkippableSuites = ({ err, skippableSuites, itrCorrelationId: responseItrCorrelationId }) => {
        if (err) {
          suitesToSkip = [];
        } else {
          suitesToSkip = skippableSuites;
          itrCorrelationId = responseItrCorrelationId;
        }
        const filteredSuites = getFilteredSuites(runner.suite.suites);
        const { suitesToRun } = filteredSuites;
        isSuitesSkipped = suitesToRun.length !== runner.suite.suites.length;
        log.debug(
          () => `${suitesToRun.length} out of ${runner.suite.suites.length} suites are going to run.`
        );
        runner.suite.suites = suitesToRun;
        skippedSuites = [...filteredSuites.skippedSuites];
        mochaGlobalRunCh.runStores(ctx, () => {
          onFinishRequest();
        });
      };
      const onReceivedImpactedTests = ({ err, modifiedFiles: receivedModifiedFiles }) => {
        if (err) {
          config.modifiedFiles = [];
          config.isImpactedTestsEnabled = false;
        } else {
          config.modifiedFiles = receivedModifiedFiles;
        }
        if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites;
          skippableSuitesCh.runStores(ctx, () => {
          });
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest();
          });
        }
      };
      const onReceivedTestManagementTests = ({ err, testManagementTests: receivedTestManagementTests }) => {
        if (err) {
          config.testManagementTests = {};
          config.isTestManagementTestsEnabled = false;
          config.testManagementAttemptToFixRetries = 0;
        } else {
          config.testManagementTests = receivedTestManagementTests;
        }
        if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests;
          modifiedFilesCh.runStores(ctx, () => {
          });
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites;
          skippableSuitesCh.runStores(ctx, () => {
          });
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest();
          });
        }
      };
      const onReceivedKnownTests = ({ err, knownTests }) => {
        if (err) {
          config.knownTests = [];
          config.isEarlyFlakeDetectionEnabled = false;
          config.isKnownTestsEnabled = false;
        } else {
          config.knownTests = knownTests;
        }
        if (config.isTestManagementTestsEnabled) {
          ctx.onDone = onReceivedTestManagementTests;
          testManagementTestsCh.runStores(ctx, () => {
          });
        }
        if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests;
          modifiedFilesCh.runStores(ctx, () => {
          });
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites;
          skippableSuitesCh.runStores(ctx, () => {
          });
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest();
          });
        }
      };
      const onReceivedConfiguration = ({ err, libraryConfig }) => {
        if (err || !skippableSuitesCh.hasSubscribers || !knownTestsCh.hasSubscribers) {
          return mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest();
          });
        }
        config.isEarlyFlakeDetectionEnabled = libraryConfig.isEarlyFlakeDetectionEnabled;
        config.earlyFlakeDetectionNumRetries = libraryConfig.earlyFlakeDetectionNumRetries;
        config.earlyFlakeDetectionFaultyThreshold = libraryConfig.earlyFlakeDetectionFaultyThreshold;
        config.isKnownTestsEnabled = libraryConfig.isKnownTestsEnabled;
        config.isTestManagementTestsEnabled = libraryConfig.isTestManagementEnabled;
        config.testManagementAttemptToFixRetries = libraryConfig.testManagementAttemptToFixRetries;
        config.isImpactedTestsEnabled = libraryConfig.isImpactedTestsEnabled;
        config.isSuitesSkippingEnabled = !isParallel && libraryConfig.isSuitesSkippingEnabled;
        config.isFlakyTestRetriesEnabled = !isParallel && libraryConfig.isFlakyTestRetriesEnabled;
        config.flakyTestRetriesCount = !isParallel && libraryConfig.flakyTestRetriesCount;
        if (config.isKnownTestsEnabled) {
          ctx.onDone = onReceivedKnownTests;
          knownTestsCh.runStores(ctx, () => {
          });
        } else if (config.isTestManagementTestsEnabled) {
          ctx.onDone = onReceivedTestManagementTests;
          testManagementTestsCh.runStores(ctx, () => {
          });
        } else if (config.isImpactedTestsEnabled) {
          ctx.onDone = onReceivedImpactedTests;
          modifiedFilesCh.runStores(ctx, () => {
          });
        } else if (config.isSuitesSkippingEnabled) {
          ctx.onDone = onReceivedSkippableSuites;
          skippableSuitesCh.runStores(ctx, () => {
          });
        } else {
          mochaGlobalRunCh.runStores(ctx, () => {
            onFinishRequest();
          });
        }
      };
      ctx.onDone = onReceivedConfiguration;
      libraryConfigurationCh.runStores(ctx, () => {
      });
    }
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/mocha.js"
    }, (Mocha, frameworkVersion) => {
      shimmer.wrap(Mocha.prototype, "run", (run) => function() {
        if (!testFinishCh.hasSubscribers || getEnvironmentVariable("MOCHA_WORKER_ID") || this.options.parallel) {
          return run.apply(this, arguments);
        }
        this.options.delay = true;
        const runner = run.apply(this, arguments);
        this.files.forEach((path) => {
          const isUnskippable = isMarkedAsUnskippable({ path });
          if (isUnskippable) {
            unskippableSuites.push(path);
          }
        });
        getExecutionConfiguration(runner, false, frameworkVersion, () => {
          if (config.isKnownTestsEnabled) {
            const testSuites = this.files.map((file) => getTestSuitePath(file, process.cwd()));
            const isFaulty = getIsFaultyEarlyFlakeDetection(
              testSuites,
              config.knownTests?.mocha || {},
              config.earlyFlakeDetectionFaultyThreshold
            );
            if (isFaulty) {
              config.isEarlyFlakeDetectionEnabled = false;
              config.isEarlyFlakeDetectionFaulty = true;
              config.isKnownTestsEnabled = false;
            }
          }
          if (getCodeCoverageCh.hasSubscribers) {
            getCodeCoverageCh.publish({
              onDone: (receivedCodeCoverage) => {
                untestedCoverage = receivedCodeCoverage;
                global.run();
              }
            });
          } else {
            global.run();
          }
        });
        return runner;
      });
      return Mocha;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/cli/run-helpers.js"
    }, (run) => {
      shimmer.wrap(run, "runMocha", (runMocha) => function() {
        if (!testFinishCh.hasSubscribers) {
          return runMocha.apply(this, arguments);
        }
        const mocha = arguments[0];
        if (!mocha.options.parallel) {
          mocha.options.delay = true;
        }
        return runMocha.apply(this, arguments);
      });
      return run;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runner.js"
    }, function(Runner, frameworkVersion) {
      if (patched.has(Runner)) return Runner;
      patched.add(Runner);
      shimmer.wrap(Runner.prototype, "runTests", (runTests) => getRunTestsWrapper(runTests, config));
      shimmer.wrap(Runner.prototype, "run", (run) => function() {
        if (!testFinishCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        const { suitesByTestFile, numSuitesByTestFile } = getSuitesByTestFile(this.suite);
        this.once("start", getOnStartHandler(false, frameworkVersion));
        this.once("end", getOnEndHandler(false));
        this.on("test", getOnTestHandler(true));
        this.on("test end", getOnTestEndHandler(config));
        this.on("retry", getOnTestRetryHandler(config));
        this.on("hook end", getOnHookEndHandler());
        this.on("fail", getOnFailHandler(true));
        this.on("pending", getOnPendingHandler());
        this.on("suite", function(suite) {
          if (suite.root || !suite.tests.length) {
            return;
          }
          let ctx = testFileToSuiteCtx.get(suite.file);
          if (!ctx) {
            const isUnskippable = unskippableSuites.includes(suite.file);
            isForcedToRun = isUnskippable && suitesToSkip.includes(getTestSuitePath(suite.file, process.cwd()));
            ctx = {
              testSuiteAbsolutePath: suite.file,
              isUnskippable,
              isForcedToRun,
              itrCorrelationId
            };
            testFileToSuiteCtx.set(suite.file, ctx);
            testSuiteStartCh.runStores(ctx, () => {
            });
          }
        });
        this.on("suite end", function(suite) {
          if (suite.root) {
            return;
          }
          const suitesInTestFile = suitesByTestFile[suite.file];
          const isLastSuite = --numSuitesByTestFile[suite.file] === 0;
          if (!isLastSuite) {
            return;
          }
          let status = "pass";
          if (suitesInTestFile.every((suite2) => suite2.pending)) {
            status = "skip";
          } else {
            suitesInTestFile.forEach((suite2) => {
              suite2.eachTest((test) => {
                if (test.state === "failed" || test.timedOut) {
                  status = "fail";
                }
              });
            });
          }
          if (global.__coverage__) {
            const coverageFiles = getCoveredFilenamesFromCoverage(global.__coverage__);
            testSuiteCodeCoverageCh.publish({
              coverageFiles,
              suiteFile: suite.file
            });
            mergeCoverage(global.__coverage__, originalCoverageMap);
            resetCoverage(global.__coverage__);
          }
          const ctx = testFileToSuiteCtx.get(suite.file);
          if (ctx) {
            testSuiteFinishCh.publish({ status, ...ctx.currentStore }, () => {
            });
          } else {
            log.warn("No ctx found for suite", suite.file);
          }
        });
        return run.apply(this, arguments);
      });
      return Runner;
    });
    addHook({
      name: "mocha",
      versions: [">=5.2.0"],
      file: "lib/runnable.js"
    }, (runnablePackage) => runnableWrapper(runnablePackage, config));
    function onMessage(message) {
      if (Array.isArray(message)) {
        const [messageCode, payload] = message;
        if (messageCode === MOCHA_WORKER_TRACE_PAYLOAD_CODE) {
          workerReportTraceCh.publish(payload);
        }
      }
    }
    addHook({
      name: "workerpool",
      // mocha@8.0.0 added parallel support and uses workerpool for it
      // The version they use is 6.0.0:
      // https://github.com/mochajs/mocha/blob/612fa31228c695f16173ac675f40ccdf26b4cfb5/package.json#L75
      versions: [">=6.0.0"],
      file: "src/WorkerHandler.js"
    }, (workerHandlerPackage) => {
      shimmer.wrap(workerHandlerPackage.prototype, "exec", (exec) => function(_2, path) {
        if (!testFinishCh.hasSubscribers) {
          return exec.apply(this, arguments);
        }
        if (!path?.length) {
          return exec.apply(this, arguments);
        }
        const [testSuiteAbsolutePath] = path;
        const testSuiteContext = {};
        this.worker.on("message", onMessage);
        testSuiteContext.testSuiteAbsolutePath = testSuiteAbsolutePath;
        testSuiteStartCh.runStores(testSuiteContext, () => {
        });
        try {
          const promise = exec.apply(this, arguments);
          promise.then(
            (result) => {
              const status = result.failureCount === 0 ? "pass" : "fail";
              testSuiteFinishCh.publish({ status, ...testSuiteContext.currentStore }, () => {
              });
              this.worker.off("message", onMessage);
            },
            (err) => {
              testSuiteContext.error = err;
              testSuiteErrorCh.runStores(testSuiteContext, () => {
              });
              testSuiteFinishCh.publish({ status: "fail", ...testSuiteContext.currentStore }, () => {
              });
              this.worker.off("message", onMessage);
            }
          );
          return promise;
        } catch (err) {
          testSuiteContext.error = err;
          testSuiteErrorCh.runStores(testSuiteContext, () => {
          });
          testSuiteFinishCh.publish({ status: "fail", ...testSuiteContext.currentStore }, () => {
          });
          this.worker.off("message", onMessage);
          throw err;
        }
      });
      return workerHandlerPackage;
    });
    addHook({
      name: "mocha",
      versions: [">=8.0.0"],
      file: "lib/nodejs/parallel-buffered-runner.js"
    }, (ParallelBufferedRunner, frameworkVersion) => {
      shimmer.wrap(ParallelBufferedRunner.prototype, "run", (run) => function(cb, { files }) {
        if (!testFinishCh.hasSubscribers) {
          return run.apply(this, arguments);
        }
        this.once("start", getOnStartHandler(true, frameworkVersion));
        this.once("end", getOnEndHandler(true));
        getExecutionConfiguration(this, true, frameworkVersion, () => {
          if (config.isKnownTestsEnabled) {
            const testSuites = files.map((file) => getTestSuitePath(file, process.cwd()));
            const isFaulty = getIsFaultyEarlyFlakeDetection(
              testSuites,
              config.knownTests?.mocha || {},
              config.earlyFlakeDetectionFaultyThreshold
            );
            if (isFaulty) {
              config.isKnownTestsEnabled = false;
              config.isEarlyFlakeDetectionEnabled = false;
              config.isEarlyFlakeDetectionFaulty = true;
            }
          }
          run.apply(this, arguments);
        });
        return this;
      });
      return ParallelBufferedRunner;
    });
    addHook({
      name: "mocha",
      versions: [">=8.0.0"],
      file: "lib/nodejs/buffered-worker-pool.js"
    }, (BufferedWorkerPoolPackage) => {
      const { BufferedWorkerPool } = BufferedWorkerPoolPackage;
      shimmer.wrap(BufferedWorkerPool.prototype, "run", (run) => async function(testSuiteAbsolutePath, workerArgs) {
        if (!testFinishCh.hasSubscribers || !config.isKnownTestsEnabled && !config.isTestManagementTestsEnabled && !config.isImpactedTestsEnabled) {
          return run.apply(this, arguments);
        }
        const testPath = getTestSuitePath(testSuiteAbsolutePath, process.cwd());
        const newWorkerArgs = { ...workerArgs };
        if (config.isKnownTestsEnabled) {
          if (config.knownTests?.mocha) {
            const testSuiteKnownTests = config.knownTests.mocha[testPath] || [];
            newWorkerArgs._ddEfdNumRetries = config.earlyFlakeDetectionNumRetries;
            newWorkerArgs._ddIsEfdEnabled = config.isEarlyFlakeDetectionEnabled;
            newWorkerArgs._ddIsKnownTestsEnabled = true;
            newWorkerArgs._ddKnownTests = {
              mocha: {
                [testPath]: testSuiteKnownTests
              }
            };
          } else {
            config.isEarlyFlakeDetectionEnabled = false;
            config.isKnownTestsEnabled = false;
            newWorkerArgs._ddIsKnownTestsEnabled = false;
            newWorkerArgs._ddIsEfdEnabled = false;
            newWorkerArgs._ddKnownTests = {};
          }
        }
        if (config.isTestManagementTestsEnabled) {
          const testSuiteTestManagementTests = config.testManagementTests?.mocha?.suites?.[testPath] || {};
          newWorkerArgs._ddIsTestManagementTestsEnabled = true;
          newWorkerArgs._ddTestManagementTests = {
            mocha: {
              suites: {
                [testPath]: testSuiteTestManagementTests
              }
            }
          };
        }
        if (config.isImpactedTestsEnabled) {
          newWorkerArgs._ddIsImpactedTestsEnabled = true;
          newWorkerArgs._ddModifiedFiles = config.modifiedFiles || {};
        }
        const testFileResult = await run.apply(
          this,
          [
            testSuiteAbsolutePath,
            newWorkerArgs
          ]
        );
        const tests = testFileResult.events.filter((event) => event.eventName === "test end").map((event) => event.data);
        for (const test of tests) {
          if (config.isKnownTestsEnabled && isNewTest(test, config.knownTests)) {
            const testFullName = getTestFullName(test);
            const tests2 = newTests[testFullName];
            if (tests2) {
              tests2.push(test);
            } else {
              newTests[testFullName] = [test];
            }
          }
          if (config.isTestManagementTestsEnabled && getTestProperties(test, config.testManagementTests).isQuarantined) {
            testsQuarantined.add(test);
          }
        }
        return testFileResult;
      });
      return BufferedWorkerPoolPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/mocha.js
var require_mocha = __commonJS({
  "../../packages/datadog-instrumentations/src/mocha.js"() {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    if (getEnvironmentVariable("MOCHA_WORKER_ID")) {
      require_worker();
    } else {
      require_main();
    }
  }
});

// ../../packages/datadog-instrumentations/src/moleculer/client.js
var require_client4 = __commonJS({
  "../../packages/datadog-instrumentations/src/moleculer/client.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:moleculer:call:start");
    var finishChannel = channel("apm:moleculer:call:finish");
    var errorChannel = channel("apm:moleculer:call:error");
    function wrapCall(call) {
      return function(actionName, params, opts) {
        opts = arguments[2] = opts || {};
        opts.meta = opts.meta || {};
        arguments.length = Math.max(3, arguments.length);
        const ctx = { actionName, params, opts };
        return startChannel.runStores(ctx, () => {
          const promise = call.apply(this, arguments);
          const broker = this;
          ctx.promiseCtx = promise.ctx;
          ctx.broker = broker;
          promise.then(
            (result) => {
              finishChannel.publish(ctx);
            },
            (error) => {
              ctx.error = error;
              errorChannel.publish(ctx);
              finishChannel.publish(ctx);
            }
          );
          return promise;
        });
      };
    }
    addHook({ name: "moleculer", versions: [">=0.14"] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, "call", wrapCall);
      return moleculer;
    });
  }
});

// ../../packages/datadog-instrumentations/src/moleculer/server.js
var require_server4 = __commonJS({
  "../../packages/datadog-instrumentations/src/moleculer/server.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:moleculer:action:start");
    var finishChannel = channel("apm:moleculer:action:finish");
    var errorChannel = channel("apm:moleculer:action:error");
    function wrapRegisterMiddlewares(registerMiddlewares) {
      return function(userMiddlewares) {
        if (this.middlewares && this.middlewares.add) {
          this.middlewares.add(createMiddleware());
        }
        return registerMiddlewares.apply(this, arguments);
      };
    }
    function createMiddleware() {
      return {
        name: "Datadog",
        localAction(next, action) {
          const broker = this;
          return shimmer.wrapFunction(next, (next2) => function datadogMiddleware(middlewareCtx) {
            const ctx = { action, middlewareCtx, broker };
            return startChannel.runStores(ctx, () => {
              try {
                return next2(middlewareCtx).then(
                  (result) => {
                    finishChannel.publish(ctx);
                    return result;
                  },
                  (error) => {
                    ctx.error = error;
                    errorChannel.publish(ctx);
                    finishChannel.publish(ctx);
                    throw error;
                  }
                );
              } catch (e) {
                ctx.error = e;
                errorChannel.publish(ctx);
                finishChannel.publish(ctx);
              }
            });
          });
        }
      };
    }
    addHook({ name: "moleculer", versions: [">=0.14"] }, (moleculer) => {
      shimmer.wrap(moleculer.ServiceBroker.prototype, "registerMiddlewares", wrapRegisterMiddlewares);
      return moleculer;
    });
  }
});

// ../../packages/datadog-instrumentations/src/moleculer.js
var require_moleculer = __commonJS({
  "../../packages/datadog-instrumentations/src/moleculer.js"() {
    "use strict";
    require_client4();
    require_server4();
  }
});

// ../../packages/datadog-instrumentations/src/mongodb-core.js
var require_mongodb_core = __commonJS({
  "../../packages/datadog-instrumentations/src/mongodb-core.js"() {
    "use strict";
    var {
      channel,
      addHook,
      AsyncResource
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:mongodb:query:start");
    var finishCh = channel("apm:mongodb:query:finish");
    var errorCh = channel("apm:mongodb:query:error");
    addHook({ name: "mongodb-core", versions: ["2 - 3.1.9"] }, (Server2) => {
      const serverProto = Server2.Server.prototype;
      shimmer.wrap(serverProto, "command", (command) => wrapCommand(command, "command"));
      shimmer.wrap(serverProto, "insert", (insert) => wrapCommand(insert, "insert", "insert"));
      shimmer.wrap(serverProto, "update", (update) => wrapCommand(update, "update", "update"));
      shimmer.wrap(serverProto, "remove", (remove) => wrapCommand(remove, "remove", "remove"));
      const cursorProto = Server2.Cursor.prototype;
      shimmer.wrap(cursorProto, "_getmore", (_getmore) => wrapCursor(_getmore, "getMore", "getMore"));
      shimmer.wrap(cursorProto, "_find", (_find) => wrapQuery(_find, "_find"));
      shimmer.wrap(cursorProto, "kill", (kill) => wrapCursor(kill, "killCursors", "killCursors"));
      return Server2;
    });
    addHook({ name: "mongodb", versions: [">=4 <4.6.0"], file: "lib/cmap/connection.js" }, (Connection) => {
      const proto = Connection.Connection.prototype;
      shimmer.wrap(proto, "command", (command) => wrapConnectionCommand(command, "command"));
      shimmer.wrap(proto, "query", (query) => wrapConnectionCommand(query, "query"));
      return Connection;
    });
    addHook({ name: "mongodb", versions: [">=4.6.0 <6.4.0"], file: "lib/cmap/connection.js" }, (Connection) => {
      const proto = Connection.Connection.prototype;
      shimmer.wrap(proto, "command", (command) => wrapConnectionCommand(command, "command"));
      return Connection;
    });
    addHook({ name: "mongodb", versions: [">=6.4.0"], file: "lib/cmap/connection.js" }, (Connection) => {
      const proto = Connection.Connection.prototype;
      shimmer.wrap(proto, "command", (command) => wrapConnectionCommand(command, "command", void 0, instrumentPromise));
      return Connection;
    });
    addHook({ name: "mongodb", versions: [">=3.3 <4"], file: "lib/core/wireprotocol/index.js" }, (wp) => wrapWp(wp));
    addHook({ name: "mongodb-core", versions: [">=3.2"], file: "lib/wireprotocol/index.js" }, (wp) => wrapWp(wp));
    addHook({ name: "mongodb-core", versions: ["~3.1.10"], file: "lib/wireprotocol/3_2_support.js" }, (WireProtocol) => {
      shimmer.wrap(WireProtocol.prototype, "command", (command) => wrapUnifiedCommand(command, "command"));
      return WireProtocol;
    });
    addHook({ name: "mongodb-core", versions: ["~3.1.10"], file: "lib/wireprotocol/2_6_support.js" }, (WireProtocol) => {
      shimmer.wrap(WireProtocol.prototype, "command", (command) => wrapUnifiedCommand(command, "command"));
      return WireProtocol;
    });
    addHook({ name: "mongodb", versions: [">=3.5.4 <4.11.0"], file: "lib/utils.js" }, (util) => {
      shimmer.wrap(util, "maybePromise", (maybePromise) => function(parent, callback, fn) {
        const asyncResource = new AsyncResource("bound-anonymous-fn");
        const callbackIndex = arguments.length - 2;
        callback = arguments[callbackIndex];
        if (typeof callback === "function") {
          arguments[callbackIndex] = asyncResource.bind(callback);
        }
        return maybePromise.apply(this, arguments);
      });
      return util;
    });
    function wrapWp(wp) {
      shimmer.wrap(wp, "command", (command) => wrapUnifiedCommand(command, "command"));
      shimmer.wrap(wp, "insert", (insert) => wrapUnifiedCommand(insert, "insert", "insert"));
      shimmer.wrap(wp, "update", (update) => wrapUnifiedCommand(update, "update", "update"));
      shimmer.wrap(wp, "remove", (remove) => wrapUnifiedCommand(remove, "remove", "remove"));
      shimmer.wrap(wp, "query", (query) => wrapUnifiedCommand(query, "query"));
      shimmer.wrap(wp, "getMore", (getMore) => wrapUnifiedCommand(getMore, "getMore", "getMore"));
      shimmer.wrap(wp, "killCursors", (killCursors) => wrapUnifiedCommand(killCursors, "killCursors", "killCursors"));
      return wp;
    }
    function wrapUnifiedCommand(command, operation, name) {
      const wrapped = function(server2, ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        return instrument(operation, command, this, arguments, server2, ns, ops, { name });
      };
      return wrapped;
    }
    function wrapConnectionCommand(command, operation, name, instrumentFn = instrument) {
      const wrapped = function(ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        const hostParts = typeof this.address === "string" ? this.address.split(":") : "";
        const options = hostParts.length === 2 ? { host: hostParts[0], port: hostParts[1] } : {};
        const topology = { s: { options } };
        ns = `${ns.db}.${ns.collection}`;
        return instrumentFn(operation, command, this, arguments, topology, ns, ops, { name });
      };
      return wrapped;
    }
    function wrapQuery(query, operation, name) {
      const wrapped = function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const pool = this.server.s.pool;
        const ns = this.ns;
        const ops = this.cmd;
        return instrument(operation, query, this, arguments, pool, ns, ops);
      };
      return wrapped;
    }
    function wrapCursor(cursor, operation, name) {
      const wrapped = function() {
        if (!startCh.hasSubscribers) {
          return cursor.apply(this, arguments);
        }
        const pool = this.server.s.pool;
        const ns = this.ns;
        return instrument(operation, cursor, this, arguments, pool, ns, {}, { name });
      };
      return wrapped;
    }
    function wrapCommand(command, operation, name) {
      const wrapped = function(ns, ops) {
        if (!startCh.hasSubscribers) {
          return command.apply(this, arguments);
        }
        return instrument(operation, command, this, arguments, this, ns, ops, { name });
      };
      return wrapped;
    }
    function instrument(operation, command, instance, args, server2, ns, ops, options = {}) {
      const name = options.name || ops && Object.keys(ops)[0];
      const index = args.length - 1;
      const callback = args[index];
      if (typeof callback !== "function") return command.apply(instance, args);
      const serverInfo = server2 && server2.s && server2.s.options;
      const ctx = {
        ns,
        ops,
        options: serverInfo,
        name
      };
      return startCh.runStores(ctx, () => {
        args[index] = shimmer.wrapFunction(callback, (callback2) => function(err, res) {
          if (err) {
            ctx.error = err;
            errorCh.publish(ctx);
          }
          return finishCh.runStores(ctx, callback2, this, ...arguments);
        });
        try {
          return command.apply(instance, args);
        } catch (err) {
          ctx.error = err;
          errorCh.publish(ctx);
          throw err;
        }
      });
    }
    function instrumentPromise(operation, command, instance, args, server2, ns, ops, options = {}) {
      const name = options.name || ops && Object.keys(ops)[0];
      const serverInfo = server2 && server2.s && server2.s.options;
      const ctx = {
        ns,
        ops,
        options: serverInfo,
        name
      };
      return startCh.runStores(ctx, () => {
        const promise = command.apply(instance, args);
        promise.then(function(res) {
          ctx.result = res;
          finishCh.publish(ctx);
        }, function(err) {
          ctx.error = err;
          errorCh.publish(ctx);
          finishCh.publish(ctx);
        });
        return promise;
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/mongodb.js
var require_mongodb = __commonJS({
  "../../packages/datadog-instrumentations/src/mongodb.js"() {
    "use strict";
    require_mongodb_core();
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var collectionMethodsWithFilter = [
      "count",
      "countDocuments",
      "deleteMany",
      "deleteOne",
      "find",
      "findOneAndDelete",
      "findOneAndReplace",
      "replaceOne"
    ];
    var collectionMethodsWithTwoFilters = [
      "findOneAndUpdate",
      "updateMany",
      "updateOne"
    ];
    var startCh = channel("datadog:mongodb:collection:filter:start");
    addHook({ name: "mongodb", versions: [">=3.3 <5", "5", ">=6"] }, (mongodb) => {
      [...collectionMethodsWithFilter, ...collectionMethodsWithTwoFilters].forEach((methodName) => {
        if (!(methodName in mongodb.Collection.prototype)) return;
        const useTwoArguments = collectionMethodsWithTwoFilters.includes(methodName);
        shimmer.wrap(mongodb.Collection.prototype, methodName, (method) => {
          return function() {
            if (!startCh.hasSubscribers) {
              return method.apply(this, arguments);
            }
            const ctx = {
              filters: [arguments[0]],
              methodName
            };
            if (useTwoArguments) {
              ctx.filters.push(arguments[1]);
            }
            return startCh.runStores(ctx, () => {
              return method.apply(this, arguments);
            });
          };
        });
      });
      return mongodb;
    });
  }
});

// ../../packages/datadog-instrumentations/src/mongoose.js
var require_mongoose = __commonJS({
  "../../packages/datadog-instrumentations/src/mongoose.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("datadog:mongoose:model:filter:start");
    var finishCh = channel("datadog:mongoose:model:filter:finish");
    var execStartCh = channel("apm:mongoose:exec:start");
    var execFinishCh = channel("apm:mongoose:exec:finish");
    function wrapAddQueue(addQueue) {
      const ctx = {};
      return execStartCh.runStores(ctx, () => {
        return function addQueueWithTrace(name) {
          return execFinishCh.runStores(ctx, () => {
            return addQueue.apply(this, arguments);
          });
        };
      });
    }
    addHook({
      name: "mongoose",
      versions: [">=4.6.4 <5", "5", "6", ">=7"],
      file: "lib/index.js"
    }, (mongoose) => {
      if (mongoose.Promise && mongoose.Promise !== global.Promise) {
        shimmer.wrap(mongoose.Promise.prototype, "then", wrapThen);
      }
      shimmer.wrap(mongoose.Collection.prototype, "addQueue", wrapAddQueue);
      return mongoose;
    });
    var collectionMethodsWithFilter = [
      "count",
      "countDocuments",
      "deleteMany",
      "deleteOne",
      "find",
      "findOne",
      "findOneAndDelete",
      "findOneAndReplace",
      "replaceOne",
      "remove"
    ];
    var collectionMethodsWithTwoFilters = [
      "findOneAndUpdate",
      "updateMany",
      "updateOne"
    ];
    addHook({
      name: "mongoose",
      versions: [">=4.6.4 <5", "5", "6", ">=7"],
      file: "lib/model.js"
    }, (Model) => {
      [...collectionMethodsWithFilter, ...collectionMethodsWithTwoFilters].forEach((methodName) => {
        const useTwoArguments = collectionMethodsWithTwoFilters.includes(methodName);
        if (!(methodName in Model)) return;
        shimmer.wrap(Model, methodName, (method) => {
          return function wrappedModelMethod() {
            if (!startCh.hasSubscribers) {
              return method.apply(this, arguments);
            }
            const filters = [arguments[0]];
            if (useTwoArguments) {
              filters.push(arguments[1]);
            }
            let callbackWrapped = false;
            const wrapCallbackIfExist = (args, ctx2) => {
              const lastArgumentIndex = args.length - 1;
              if (typeof args[lastArgumentIndex] === "function") {
                shimmer.wrap(args, lastArgumentIndex, (originalCb) => {
                  return function() {
                    finishCh.publish(ctx2);
                    return originalCb.apply(this, arguments);
                  };
                });
                callbackWrapped = true;
              }
            };
            const ctx = {
              filters,
              methodName
            };
            return startCh.runStores(ctx, () => {
              wrapCallbackIfExist(arguments, ctx);
              const res = method.apply(this, arguments);
              if (!callbackWrapped) {
                shimmer.wrap(res, "exec", (originalExec) => {
                  return function wrappedExec() {
                    if (!callbackWrapped) {
                      wrapCallbackIfExist(arguments, ctx);
                    }
                    const execResult = originalExec.apply(this, arguments);
                    if (callbackWrapped || typeof execResult?.then !== "function") {
                      return execResult;
                    }
                    shimmer.wrap(execResult, "then", (originalThen) => {
                      return function wrappedThen() {
                        const resolve = arguments[0];
                        const reject = arguments[1];
                        arguments[0] = shimmer.wrapFunction(resolve, (resolve2) => function wrappedResolve() {
                          finishCh.publish(ctx);
                          if (resolve2) {
                            return resolve2.apply(this, arguments);
                          }
                        });
                        arguments[1] = shimmer.wrapFunction(reject, (reject2) => function wrappedReject() {
                          finishCh.publish(ctx);
                          if (reject2) {
                            return reject2.apply(this, arguments);
                          }
                        });
                        return originalThen.apply(this, arguments);
                      };
                    });
                    return execResult;
                  };
                });
              }
              return res;
            });
          };
        });
      });
      return Model;
    });
    var sanitizeFilterFinishCh = channel("datadog:mongoose:sanitize-filter:finish");
    addHook({
      name: "mongoose",
      versions: ["6", ">=7"],
      file: "lib/helpers/query/sanitizeFilter.js"
    }, (sanitizeFilter) => {
      return shimmer.wrapFunction(sanitizeFilter, (sanitizeFilter2) => function wrappedSanitizeFilter() {
        const sanitizedObject = sanitizeFilter2.apply(this, arguments);
        if (sanitizeFilterFinishCh.hasSubscribers) {
          sanitizeFilterFinishCh.publish({
            sanitizedObject
          });
        }
        return sanitizedObject;
      });
    });
  }
});

// ../../packages/datadog-instrumentations/src/mquery.js
var require_mquery = __commonJS({
  "../../packages/datadog-instrumentations/src/mquery.js"() {
    "use strict";
    var dc = require_dc_polyfill();
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var prepareCh = channel("datadog:mquery:filter:prepare");
    var tracingCh = dc.tracingChannel("datadog:mquery:filter");
    var methods = [
      "find",
      "findOne",
      "findOneAndRemove",
      "findOneAndDelete",
      "count",
      "distinct",
      "where"
    ];
    var methodsOptionalArgs = ["findOneAndUpdate"];
    function getFilters(args, methodName) {
      const [arg0, arg1] = args;
      const filters = arg0 !== null && typeof arg0 === "object" ? [arg0] : [];
      if (arg1 !== null && typeof arg1 === "object" && methodsOptionalArgs.includes(methodName)) {
        filters.push(arg1);
      }
      return filters;
    }
    addHook({
      name: "mquery",
      versions: [">=5.0.0"]
    }, (Query) => {
      [...methods, ...methodsOptionalArgs].forEach((methodName) => {
        if (!(methodName in Query.prototype)) return;
        shimmer.wrap(Query.prototype, methodName, (method) => {
          return function() {
            if (prepareCh.hasSubscribers) {
              const filters = getFilters(arguments, methodName);
              if (filters?.length) {
                prepareCh.publish({ filters });
              }
            }
            return method.apply(this, arguments);
          };
        });
      });
      shimmer.wrap(Query.prototype, "exec", (originalExec) => {
        return function wrappedExec() {
          return tracingCh.tracePromise(originalExec, {}, this, arguments);
        };
      });
      return Query;
    });
  }
});

// ../../packages/datadog-instrumentations/src/multer.js
var require_multer = __commonJS({
  "../../packages/datadog-instrumentations/src/multer.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook, AsyncResource } = require_instrument();
    var multerReadCh = channel("datadog:multer:read:finish");
    function publishRequestBodyAndNext(req, res, next) {
      return shimmer.wrapFunction(next, (next2) => function() {
        if (multerReadCh.hasSubscribers && req) {
          const abortController = new AbortController();
          const body = req.body;
          multerReadCh.publish({ req, res, body, abortController });
          if (abortController.signal.aborted) return;
        }
        return next2.apply(this, arguments);
      });
    }
    addHook({
      name: "multer",
      file: "lib/make-middleware.js",
      versions: ["^1.4.4-lts.1"]
    }, (makeMiddleware) => {
      return shimmer.wrapFunction(makeMiddleware, (makeMiddleware2) => function() {
        const middleware = makeMiddleware2.apply(this, arguments);
        return shimmer.wrapFunction(middleware, (middleware2) => function wrapMulterMiddleware(req, res, next) {
          const nextResource = new AsyncResource("bound-anonymous-fn");
          arguments[2] = nextResource.bind(publishRequestBodyAndNext(req, res, next));
          return middleware2.apply(this, arguments);
        });
      });
    });
  }
});

// ../../packages/datadog-instrumentations/src/mysql.js
var require_mysql = __commonJS({
  "../../packages/datadog-instrumentations/src/mysql.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "mysql", file: "lib/Connection.js", versions: [">=2"] }, (Connection) => {
      const startCh = channel("apm:mysql:query:start");
      const finishCh = channel("apm:mysql:query:finish");
      const errorCh = channel("apm:mysql:query:error");
      shimmer.wrap(Connection.prototype, "query", (query) => function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const sql = arguments[0].sql || arguments[0];
        const conf = this.config;
        const ctx = { sql, conf };
        return startCh.runStores(ctx, () => {
          if (arguments[0].sql) {
            arguments[0].sql = ctx.sql;
          } else {
            arguments[0] = ctx.sql;
          }
          try {
            const res = query.apply(this, arguments);
            if (res._callback) {
              const cb = res._callback;
              res._callback = shimmer.wrapFunction(cb, (cb2) => function(error, result) {
                if (error) {
                  ctx.error = error;
                  errorCh.publish(ctx);
                }
                ctx.result = result;
                return finishCh.runStores(ctx, cb2, this, error, result);
              });
            } else {
              res.on("end", () => finishCh.publish(ctx));
            }
            return res;
          } catch (err) {
            err.stack;
            ctx.error = err;
            errorCh.publish(ctx);
            throw err;
          }
        });
      });
      return Connection;
    });
    addHook({ name: "mysql", file: "lib/Pool.js", versions: [">=2"] }, (Pool) => {
      const connectionStartCh = channel("apm:mysql:connection:start");
      const connectionFinishCh = channel("apm:mysql:connection:finish");
      const startPoolQueryCh = channel("datadog:mysql:pool:query:start");
      const finishPoolQueryCh = channel("datadog:mysql:pool:query:finish");
      shimmer.wrap(Pool.prototype, "getConnection", (getConnection) => function(cb) {
        arguments[0] = function() {
          return connectionFinishCh.runStores(ctx, cb, this, ...arguments);
        };
        const ctx = {};
        connectionStartCh.publish(ctx);
        return getConnection.apply(this, arguments);
      });
      shimmer.wrap(Pool.prototype, "query", (query) => function() {
        if (!startPoolQueryCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const sql = arguments[0].sql || arguments[0];
        const ctx = { sql };
        const finish = () => finishPoolQueryCh.publish(ctx);
        return startPoolQueryCh.runStores(ctx, () => {
          const cb = arguments[arguments.length - 1];
          if (typeof cb === "function") {
            arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function() {
              return finishPoolQueryCh.runStores(ctx, cb2, this, ...arguments);
            });
          }
          const retval = query.apply(this, arguments);
          if (retval && retval.then) {
            retval.then(finish).catch(finish);
          }
          return retval;
        });
      });
      return Pool;
    });
  }
});

// ../../packages/datadog-instrumentations/src/mysql2.js
var require_mysql2 = __commonJS({
  "../../packages/datadog-instrumentations/src/mysql2.js"() {
    "use strict";
    var { errorMonitor } = __require("node:events");
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var satisfies = require_semifies();
    function wrapConnection(Connection, version) {
      const startCh = channel("apm:mysql2:query:start");
      const finishCh = channel("apm:mysql2:query:finish");
      const errorCh = channel("apm:mysql2:query:error");
      const startOuterQueryCh = channel("datadog:mysql2:outerquery:start");
      const commandAddCh = channel("apm:mysql2:command:add");
      const commandStartCh = channel("apm:mysql2:command:start");
      const commandFinishCh = channel("apm:mysql2:command:finish");
      const shouldEmitEndAfterQueryAbort = satisfies(version, ">=1.3.3");
      shimmer.wrap(Connection.prototype, "addCommand", (addCommand) => function(cmd) {
        if (!startCh.hasSubscribers) return addCommand.apply(this, arguments);
        const name = cmd && cmd.constructor && cmd.constructor.name;
        const isCommand = typeof cmd.execute === "function";
        const isQuery = isCommand && (name === "Execute" || name === "Query");
        const ctx = {};
        cmd.execute = isQuery ? wrapExecute(cmd, cmd.execute, ctx, this.config) : bindExecute(cmd.execute, ctx);
        return commandAddCh.runStores(ctx, addCommand, this, ...arguments);
      });
      shimmer.wrap(Connection.prototype, "query", (query) => function(sql, values, cb) {
        if (!startOuterQueryCh.hasSubscribers) return query.apply(this, arguments);
        if (sql !== null && typeof sql === "object") sql = sql.sql;
        if (!sql) return query.apply(this, arguments);
        const abortController = new AbortController();
        startOuterQueryCh.publish({ sql, abortController });
        if (abortController.signal.aborted) {
          const addCommand = this.addCommand;
          this.addCommand = function(cmd) {
            return cmd;
          };
          let queryCommand;
          try {
            queryCommand = query.apply(this, arguments);
          } finally {
            this.addCommand = addCommand;
          }
          cb = queryCommand.onResult;
          process.nextTick(() => {
            if (cb) {
              cb(abortController.signal.reason);
            } else {
              queryCommand.emit("error", abortController.signal.reason);
            }
            if (shouldEmitEndAfterQueryAbort) {
              queryCommand.emit("end");
            }
          });
          return queryCommand;
        }
        return query.apply(this, arguments);
      });
      shimmer.wrap(Connection.prototype, "execute", (execute) => function(sql, values, cb) {
        if (!startOuterQueryCh.hasSubscribers) return execute.apply(this, arguments);
        if (sql !== null && typeof sql === "object") sql = sql.sql;
        if (!sql) return execute.apply(this, arguments);
        const abortController = new AbortController();
        startOuterQueryCh.publish({ sql, abortController });
        if (abortController.signal.aborted) {
          const addCommand = this.addCommand;
          this.addCommand = function(cmd) {
            return cmd;
          };
          let result;
          try {
            result = execute.apply(this, arguments);
          } finally {
            this.addCommand = addCommand;
          }
          result?.onResult(abortController.signal.reason);
          return result;
        }
        return execute.apply(this, arguments);
      });
      return Connection;
      function bindExecute(execute, ctx) {
        return shimmer.wrapFunction(execute, (execute2) => function executeWithTrace(packet, connection) {
          const onResult = this.onResult;
          if (onResult) {
            this.onResult = function() {
              return commandFinishCh.runStores(ctx, onResult, this, ...arguments);
            };
          }
          return commandStartCh.runStores(ctx, execute2, this, ...arguments);
        });
      }
      function wrapExecute(cmd, execute, ctx, config) {
        return shimmer.wrapFunction(execute, (execute2) => function executeWithTrace(packet, connection) {
          ctx.sql = cmd.statement ? cmd.statement.query : cmd.sql;
          ctx.conf = config;
          return startCh.runStores(ctx, () => {
            if (cmd.statement) {
              cmd.statement.query = ctx.sql;
            } else {
              cmd.sql = ctx.sql;
            }
            if (this.onResult) {
              const onResult = this.onResult;
              this.onResult = shimmer.wrapFunction(onResult, (onResult2) => function(error) {
                if (error) {
                  ctx.error = error;
                  errorCh.publish(ctx);
                }
                finishCh.runStores(ctx, onResult2, this, ...arguments);
              });
            } else {
              this.on(errorMonitor, (error) => {
                ctx.error = error;
                errorCh.publish(ctx);
              });
              this.on("end", () => finishCh.publish(ctx));
            }
            this.execute = execute2;
            try {
              return execute2.apply(this, arguments);
            } catch (err) {
              ctx.error = err;
              errorCh.publish(ctx);
            }
          });
        }, cmd);
      }
    }
    function wrapPool(Pool, version) {
      const startOuterQueryCh = channel("datadog:mysql2:outerquery:start");
      const shouldEmitEndAfterQueryAbort = satisfies(version, ">=1.3.3");
      shimmer.wrap(Pool.prototype, "query", (query) => function(sql, values, cb) {
        if (!startOuterQueryCh.hasSubscribers) return query.apply(this, arguments);
        if (sql !== null && typeof sql === "object") sql = sql.sql;
        if (!sql) return query.apply(this, arguments);
        const abortController = new AbortController();
        startOuterQueryCh.publish({ sql, abortController });
        if (abortController.signal.aborted) {
          const getConnection = this.getConnection;
          this.getConnection = function() {
          };
          let queryCommand;
          try {
            queryCommand = query.apply(this, arguments);
          } finally {
            this.getConnection = getConnection;
          }
          process.nextTick(() => {
            if (queryCommand.onResult) {
              queryCommand.onResult(abortController.signal.reason);
            } else {
              queryCommand.emit("error", abortController.signal.reason);
            }
            if (shouldEmitEndAfterQueryAbort) {
              queryCommand.emit("end");
            }
          });
          return queryCommand;
        }
        return query.apply(this, arguments);
      });
      shimmer.wrap(Pool.prototype, "execute", (execute) => function(sql, values, cb) {
        if (!startOuterQueryCh.hasSubscribers) return execute.apply(this, arguments);
        if (sql !== null && typeof sql === "object") sql = sql.sql;
        if (!sql) return execute.apply(this, arguments);
        const abortController = new AbortController();
        startOuterQueryCh.publish({ sql, abortController });
        if (abortController.signal.aborted) {
          if (typeof values === "function") {
            cb = values;
          }
          process.nextTick(() => {
            cb(abortController.signal.reason);
          });
          return;
        }
        return execute.apply(this, arguments);
      });
      return Pool;
    }
    function wrapPoolCluster(PoolCluster) {
      const startOuterQueryCh = channel("datadog:mysql2:outerquery:start");
      const wrappedPoolNamespaces = /* @__PURE__ */ new WeakSet();
      shimmer.wrap(PoolCluster.prototype, "of", (of) => function() {
        const poolNamespace = of.apply(this, arguments);
        if (startOuterQueryCh.hasSubscribers && !wrappedPoolNamespaces.has(poolNamespace)) {
          shimmer.wrap(poolNamespace, "query", (query) => function(sql, values, cb) {
            if (sql !== null && typeof sql === "object") sql = sql.sql;
            if (!sql) return query.apply(this, arguments);
            const abortController = new AbortController();
            startOuterQueryCh.publish({ sql, abortController });
            if (abortController.signal.aborted) {
              const getConnection = this.getConnection;
              this.getConnection = function() {
              };
              let queryCommand;
              try {
                queryCommand = query.apply(this, arguments);
              } finally {
                this.getConnection = getConnection;
              }
              process.nextTick(() => {
                if (queryCommand.onResult) {
                  queryCommand.onResult(abortController.signal.reason);
                } else {
                  queryCommand.emit("error", abortController.signal.reason);
                }
                queryCommand.emit("end");
              });
              return queryCommand;
            }
            return query.apply(this, arguments);
          });
          shimmer.wrap(poolNamespace, "execute", (execute) => function(sql, values, cb) {
            if (sql !== null && typeof sql === "object") sql = sql.sql;
            if (!sql) return execute.apply(this, arguments);
            const abortController = new AbortController();
            startOuterQueryCh.publish({ sql, abortController });
            if (abortController.signal.aborted) {
              if (typeof values === "function") {
                cb = values;
              }
              process.nextTick(() => {
                cb(abortController.signal.reason);
              });
              return;
            }
            return execute.apply(this, arguments);
          });
          wrappedPoolNamespaces.add(poolNamespace);
        }
        return poolNamespace;
      });
      return PoolCluster;
    }
    addHook({ name: "mysql2", file: "lib/base/connection.js", versions: [">=3.11.5"] }, wrapConnection);
    addHook({ name: "mysql2", file: "lib/connection.js", versions: ["1 - 3.11.4"] }, wrapConnection);
    addHook({ name: "mysql2", file: "lib/pool.js", versions: ["1 - 3.11.4"] }, wrapPool);
    addHook({ name: "mysql2", file: "lib/pool_cluster.js", versions: ["2.3.0 - 3.11.4"] }, wrapPoolCluster);
  }
});

// ../../packages/datadog-instrumentations/src/net.js
var require_net = __commonJS({
  "../../packages/datadog-instrumentations/src/net.js"() {
    "use strict";
    var { errorMonitor } = __require("events");
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startICPCh = channel("apm:net:ipc:start");
    var finishICPCh = channel("apm:net:ipc:finish");
    var errorICPCh = channel("apm:net:ipc:error");
    var startTCPCh = channel("apm:net:tcp:start");
    var finishTCPCh = channel("apm:net:tcp:finish");
    var errorTCPCh = channel("apm:net:tcp:error");
    var readyCh = channel("apm:net:tcp:ready");
    var connectionCh = channel("apm:net:tcp:connection");
    var names = ["net", "node:net"];
    addHook({ name: names }, (net, version, name) => {
      if (name === "net") {
        __require("dns");
      } else {
        __require("node:dns");
      }
      shimmer.wrap(net.Socket.prototype, "connect", (connect) => function() {
        if (!startICPCh.hasSubscribers || !startTCPCh.hasSubscribers) {
          return connect.apply(this, arguments);
        }
        const options = getOptions(arguments);
        const lastIndex = arguments.length - 1;
        const callback = arguments[lastIndex];
        if (!options) return connect.apply(this, arguments);
        const protocol = options.path ? "ipc" : "tcp";
        const startCh = protocol === "ipc" ? startICPCh : startTCPCh;
        const finishCh = protocol === "ipc" ? finishICPCh : finishTCPCh;
        const errorCh = protocol === "ipc" ? errorICPCh : errorTCPCh;
        const ctx = { options };
        if (typeof callback === "function") {
          arguments[lastIndex] = function(...args) {
            return finishCh.runStores(ctx, callback, this, ...args);
          };
        }
        return startCh.runStores(ctx, () => {
          setupListeners(this, protocol, ctx, finishCh, errorCh);
          const emit = this.emit;
          this.emit = shimmer.wrapFunction(emit, (emit2) => function(eventName) {
            switch (eventName) {
              case "ready":
              case "connect":
                return readyCh.runStores(ctx, () => {
                  return emit2.apply(this, arguments);
                });
              default:
                return emit2.apply(this, arguments);
            }
          });
          try {
            return connect.apply(this, arguments);
          } catch (err) {
            errorCh.publish(err);
            throw err;
          }
        });
      });
      return net;
    });
    function getOptions(args) {
      if (!args[0]) return;
      switch (typeof args[0]) {
        case "object":
          if (Array.isArray(args[0])) return getOptions(args[0]);
          return args[0];
        case "string":
          if (Number.isNaN(Number.parseFloat(args[0]))) {
            return {
              path: args[0]
            };
          }
        case "number":
          return {
            port: args[0],
            host: typeof args[1] === "string" ? args[1] : "localhost"
          };
      }
    }
    function setupListeners(socket, protocol, ctx, finishCh, errorCh) {
      const events = ["connect", errorMonitor, "close", "timeout"];
      const wrapListener = function(error) {
        if (error) {
          ctx.error = error;
          errorCh.publish(ctx);
        }
        finishCh.runStores(ctx, () => {
        });
      };
      const localListener = function() {
        ctx.socket = socket;
        connectionCh.publish(ctx);
      };
      const cleanupListener = function() {
        socket.removeListener("connect", localListener);
        events.forEach((event) => {
          socket.removeListener(event, wrapListener);
          socket.removeListener(event, cleanupListener);
        });
      };
      if (protocol === "tcp") {
        socket.once("connect", localListener);
      }
      events.forEach((event) => {
        socket.once(event, wrapListener);
        socket.once(event, cleanupListener);
      });
    }
  }
});

// ../../packages/datadog-instrumentations/src/next.js
var require_next = __commonJS({
  "../../packages/datadog-instrumentations/src/next.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startChannel = channel("apm:next:request:start");
    var finishChannel = channel("apm:next:request:finish");
    var errorChannel = channel("apm:next:request:error");
    var pageLoadChannel = channel("apm:next:page:load");
    var bodyParsedChannel = channel("apm:next:body-parsed");
    var queryParsedChannel = channel("apm:next:query-parsed");
    var requests = /* @__PURE__ */ new WeakSet();
    var nodeNextRequestsToNextRequests = /* @__PURE__ */ new WeakMap();
    var MIDDLEWARE_HEADER = "x-middleware-invoke";
    var NEXT_REQUEST_META = Symbol.for("NextInternalRequestMeta");
    var META_IS_MIDDLEWARE = "middlewareInvoke";
    var encounteredMiddleware = /* @__PURE__ */ new WeakSet();
    function wrapHandleRequest(handleRequest) {
      return function(req, res, pathname, query) {
        return instrument(req, res, () => handleRequest.apply(this, arguments));
      };
    }
    function wrapHandleApiRequest(handleApiRequest) {
      return function(req, res, pathname, query) {
        return instrument(req, res, () => {
          const promise = handleApiRequest.apply(this, arguments);
          return promise.then((handled) => {
            if (!handled) return handled;
            return this.hasPage(pathname).then((pageFound) => {
              const pageData = pageFound ? { page: pathname } : getPageFromPath(pathname, this.dynamicRoutes);
              pageLoadChannel.publish(pageData);
              return handled;
            });
          });
        });
      };
    }
    function wrapHandleApiRequestWithMatch(handleApiRequest) {
      return function(req, res, query, match) {
        return instrument(req, res, () => {
          const page = match !== null && typeof match === "object" && match.definition !== null && typeof match.definition === "object" ? match.definition.pathname : void 0;
          pageLoadChannel.publish({ page });
          return handleApiRequest.apply(this, arguments);
        });
      };
    }
    function wrapRenderToHTML(renderToHTML) {
      return function(req, res, pathname, query, parsedUrl) {
        return instrument(req, res, () => renderToHTML.apply(this, arguments));
      };
    }
    function wrapRenderErrorToHTML(renderErrorToHTML) {
      return function(err, req, res, pathname, query) {
        return instrument(req, res, () => renderErrorToHTML.apply(this, arguments), err);
      };
    }
    function wrapRenderToResponse(renderToResponse) {
      return function(ctx) {
        return instrument(ctx.req, ctx.res, () => renderToResponse.apply(this, arguments));
      };
    }
    function wrapRenderErrorToResponse(renderErrorToResponse) {
      return function(ctx, err) {
        return instrument(ctx.req, ctx.res, () => renderErrorToResponse.apply(this, arguments), err);
      };
    }
    function wrapFindPageComponents(findPageComponents) {
      return function(pathname, query) {
        const result = findPageComponents.apply(this, arguments);
        if (result) {
          pageLoadChannel.publish(getPagePath(pathname));
        }
        return result;
      };
    }
    function getPagePath(maybePage) {
      if (typeof maybePage !== "object") return { page: maybePage };
      const isAppPath = maybePage.isAppPath;
      const page = maybePage.pathname || maybePage.page;
      return { page, isAppPath };
    }
    function getPageFromPath(page, dynamicRoutes = []) {
      for (const dynamicRoute of dynamicRoutes) {
        if (dynamicRoute.page.startsWith("/api") && dynamicRoute.match(page)) {
          return getPagePath(dynamicRoute.page);
        }
      }
      return getPagePath(page);
    }
    function getRequestMeta(req, key) {
      const meta = req[NEXT_REQUEST_META] || {};
      return typeof key === "string" ? meta[key] : meta;
    }
    function instrument(req, res, handler, error) {
      req = req.originalRequest || req;
      res = res.originalResponse || res;
      const isMiddleware = req.headers[MIDDLEWARE_HEADER] || getRequestMeta(req, META_IS_MIDDLEWARE);
      if (isMiddleware && !encounteredMiddleware.has(req) || requests.has(req)) {
        encounteredMiddleware.add(req);
        if (error) {
          errorChannel.publish({ error });
        }
        return handler();
      }
      requests.add(req);
      const ctx = { req, res };
      if (queryParsedChannel.hasSubscribers && req.url) {
        const { searchParams } = new URL(req.url, "http://dummy");
        const query = {};
        for (const key of searchParams.keys()) {
          if (!query[key]) {
            query[key] = searchParams.getAll(key);
          }
        }
        queryParsedChannel.publish({ query });
      }
      return startChannel.runStores(ctx, () => {
        try {
          const promise = handler(ctx);
          promise.then(
            (result) => finish(ctx, result),
            (err) => finish(ctx, null, err)
          );
          return promise;
        } catch (e) {
          finish(ctx, null, e);
          throw e;
        }
      });
    }
    function wrapServeStatic(serveStatic) {
      return function(req, res, path) {
        return instrument(req, res, () => {
          if (pageLoadChannel.hasSubscribers && path) {
            pageLoadChannel.publish({ page: path, isStatic: true });
          }
          return serveStatic.apply(this, arguments);
        });
      };
    }
    function finish(ctx, result, err) {
      if (err) {
        ctx.error = err;
        errorChannel.publish(ctx);
      }
      const maybeNextRequest = nodeNextRequestsToNextRequests.get(ctx.req);
      if (maybeNextRequest) {
        ctx.nextRequest = maybeNextRequest;
      }
      finishChannel.publish(ctx);
    }
    addHook({
      name: "next",
      versions: [">=13.3.0"],
      file: "dist/server/web/spec-extension/adapters/next-request.js"
    }, (NextRequestAdapter) => {
      shimmer.wrap(NextRequestAdapter.NextRequestAdapter, "fromNodeNextRequest", (fromNodeNextRequest) => {
        return function(nodeNextRequest) {
          const nextRequest = fromNodeNextRequest.apply(this, arguments);
          nodeNextRequestsToNextRequests.set(nodeNextRequest.originalRequest, nextRequest);
          return nextRequest;
        };
      });
      return NextRequestAdapter;
    });
    addHook({
      name: "next",
      versions: [">=11.1"],
      file: "dist/server/serve-static.js"
    }, (serveStatic) => shimmer.wrap(serveStatic, "serveStatic", wrapServeStatic, { replaceGetter: true }));
    addHook({
      name: "next",
      versions: [">=10.2 <11.1"],
      file: "dist/next-server/server/serve-static.js"
    }, (serveStatic) => shimmer.wrap(serveStatic, "serveStatic", wrapServeStatic, { replaceGetter: true }));
    addHook({ name: "next", versions: [">=11.1"], file: "dist/server/next-server.js" }, (nextServer) => {
      const Server2 = nextServer.default;
      shimmer.wrap(Server2.prototype, "handleRequest", wrapHandleRequest);
      shimmer.wrap(Server2.prototype, "renderToResponse", wrapRenderToResponse);
      shimmer.wrap(Server2.prototype, "renderErrorToResponse", wrapRenderErrorToResponse);
      shimmer.wrap(Server2.prototype, "findPageComponents", wrapFindPageComponents);
      return nextServer;
    });
    addHook({ name: "next", versions: [">=13.2"], file: "dist/server/next-server.js" }, (nextServer) => {
      const Server2 = nextServer.default;
      shimmer.wrap(Server2.prototype, "handleApiRequest", wrapHandleApiRequestWithMatch);
      return nextServer;
    });
    addHook({
      name: "next",
      versions: [">=11.1 <13.2"],
      file: "dist/server/next-server.js"
    }, (nextServer) => {
      const Server2 = nextServer.default;
      shimmer.wrap(Server2.prototype, "handleApiRequest", wrapHandleApiRequest);
      return nextServer;
    });
    addHook({
      name: "next",
      versions: [">=10.2 <11.1"],
      file: "dist/next-server/server/next-server.js"
    }, (nextServer) => {
      const Server2 = nextServer.default;
      shimmer.wrap(Server2.prototype, "handleRequest", wrapHandleRequest);
      shimmer.wrap(Server2.prototype, "handleApiRequest", wrapHandleApiRequest);
      shimmer.wrap(Server2.prototype, "renderToHTML", wrapRenderToHTML);
      shimmer.wrap(Server2.prototype, "renderErrorToHTML", wrapRenderErrorToHTML);
      shimmer.wrap(Server2.prototype, "findPageComponents", wrapFindPageComponents);
      return nextServer;
    });
    addHook({
      name: "next",
      versions: [">=13"],
      file: "dist/server/web/spec-extension/request.js"
    }, (request2) => {
      const requestProto = Object.getPrototypeOf(request2.NextRequest.prototype);
      shimmer.massWrap(requestProto, ["text", "json"], function(originalMethod) {
        return async function wrappedJson() {
          const body = await originalMethod.apply(this, arguments);
          bodyParsedChannel.publish({ body });
          return body;
        };
      });
      shimmer.wrap(requestProto, "formData", function(originalFormData) {
        return async function wrappedFormData() {
          const body = await originalFormData.apply(this, arguments);
          let normalizedBody = body;
          if (typeof body.entries === "function") {
            normalizedBody = Object.fromEntries(body.entries());
          }
          bodyParsedChannel.publish({ body: normalizedBody });
          return body;
        };
      });
      return request2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/node-serialize.js
var require_node_serialize = __commonJS({
  "../../packages/datadog-instrumentations/src/node-serialize.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var nodeUnserializeCh = channel("datadog:node-serialize:unserialize:start");
    function wrapUnserialize(serialize) {
      return function wrappedUnserialize(obj) {
        if (nodeUnserializeCh.hasSubscribers) {
          nodeUnserializeCh.publish({ obj });
        }
        return serialize.apply(this, arguments);
      };
    }
    addHook({ name: "node-serialize", versions: ["0.0.4"] }, (serialize) => {
      shimmer.wrap(serialize, "unserialize", wrapUnserialize);
      return serialize;
    });
  }
});

// ../../packages/datadog-instrumentations/src/url.js
var require_url3 = __commonJS({
  "../../packages/datadog-instrumentations/src/url.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var names = ["url", "node:url"];
    var parseFinishedChannel = channel("datadog:url:parse:finish");
    var urlGetterChannel = channel("datadog:url:getter:finish");
    var instrumentedGetters = ["host", "origin", "hostname"];
    addHook({ name: names }, function(url) {
      shimmer.wrap(url, "parse", (parse) => {
        return function wrappedParse(input) {
          const parsedValue = parse.apply(this, arguments);
          if (!parseFinishedChannel.hasSubscribers) return parsedValue;
          parseFinishedChannel.publish({
            input,
            parsed: parsedValue,
            isURL: false
          });
          return parsedValue;
        };
      });
      const URLPrototype = url.URL.prototype.constructor.prototype;
      instrumentedGetters.forEach((property) => {
        shimmer.wrap(URLPrototype, property, function(originalGet) {
          return function get3() {
            const result = originalGet.call(this);
            if (!urlGetterChannel.hasSubscribers) return result;
            const context2 = { urlObject: this, result, property };
            urlGetterChannel.publish(context2);
            return context2.result;
          };
        });
      });
      shimmer.wrap(url, "URL", (URL2) => {
        return class extends URL2 {
          constructor(input, base) {
            super(...arguments);
            if (!parseFinishedChannel.hasSubscribers) return;
            parseFinishedChannel.publish({
              input,
              base,
              parsed: this,
              isURL: true
            });
          }
          static [Symbol.hasInstance](instance) {
            return instance instanceof URL2;
          }
        };
      });
      if (url.URL.parse) {
        shimmer.wrap(url.URL, "parse", (parse) => {
          return function wrappedParse(input, base) {
            const parsedValue = parse.apply(this, arguments);
            if (!parseFinishedChannel.hasSubscribers) return parsedValue;
            parseFinishedChannel.publish({
              input,
              base,
              parsed: parsedValue,
              isURL: true
            });
            return parsedValue;
          };
        });
      }
    });
  }
});

// ../../packages/datadog-instrumentations/src/vm.js
var require_vm = __commonJS({
  "../../packages/datadog-instrumentations/src/vm.js"() {
    "use strict";
    var { channel, addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var names = ["vm", "node:vm"];
    var runScriptStartChannel = channel("datadog:vm:run-script:start");
    var sourceTextModuleStartChannel = channel("datadog:vm:source-text-module:start");
    addHook({ name: names }, function(vm) {
      vm.Script = class extends vm.Script {
        constructor(code) {
          super(...arguments);
          if (runScriptStartChannel.hasSubscribers && code) {
            runScriptStartChannel.publish({ code });
          }
        }
      };
      if (vm.SourceTextModule && typeof vm.SourceTextModule === "function") {
        vm.SourceTextModule = class extends vm.SourceTextModule {
          constructor(code) {
            super(...arguments);
            if (sourceTextModuleStartChannel.hasSubscribers && code) {
              sourceTextModuleStartChannel.publish({ code });
            }
          }
        };
      }
      shimmer.wrap(vm, "runInContext", wrapVMMethod);
      shimmer.wrap(vm, "runInNewContext", wrapVMMethod);
      shimmer.wrap(vm, "runInThisContext", wrapVMMethod);
      shimmer.wrap(vm, "compileFunction", wrapVMMethod);
      return vm;
    });
    function wrapVMMethod(original) {
      return function wrappedVMMethod(code) {
        if (runScriptStartChannel.hasSubscribers && code) {
          runScriptStartChannel.publish({ code });
        }
        return original.apply(this, arguments);
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/nyc.js
var require_nyc = __commonJS({
  "../../packages/datadog-instrumentations/src/nyc.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { getEnvironmentVariable } = require_config_helper();
    var codeCoverageWrapCh = channel("ci:nyc:wrap");
    addHook({
      name: "nyc",
      versions: [">=17"]
    }, (nycPackage) => {
      shimmer.wrap(nycPackage.prototype, "wrap", (wrap) => function() {
        try {
          if (JSON.parse(getEnvironmentVariable("NYC_CONFIG")).all) {
            codeCoverageWrapCh.publish(this);
          }
        } catch {
        }
        return wrap.apply(this, arguments);
      });
      return nycPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/oracledb.js
var require_oracledb = __commonJS({
  "../../packages/datadog-instrumentations/src/oracledb.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var connectionAttributes = /* @__PURE__ */ new WeakMap();
    var poolAttributes = /* @__PURE__ */ new WeakMap();
    var startChannel = channel("apm:oracledb:query:start");
    var errorChannel = channel("apm:oracledb:query:error");
    var finishChannel = channel("apm:oracledb:query:finish");
    function finish(ctx) {
      if (ctx.error) {
        errorChannel.publish(ctx);
      }
      finishChannel.publish(ctx);
    }
    addHook({ name: "oracledb", versions: [">=5"], file: "lib/oracledb.js" }, (oracledb) => {
      shimmer.wrap(oracledb.Connection.prototype, "execute", (execute) => {
        return function wrappedExecute(dbQuery, ...args) {
          if (!startChannel.hasSubscribers) {
            return execute.apply(this, arguments);
          }
          if (arguments.length && typeof arguments[arguments.length - 1] === "function") {
            const cb = arguments[arguments.length - 1];
            arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function wrappedCb(err, result) {
              if (err) {
                ctx.error = err;
                errorChannel.publish(ctx);
              }
              return finishChannel.runStores(ctx, () => {
                return cb2.apply(this, arguments);
              });
            });
          }
          let hostname;
          let port;
          let dbInstance;
          try {
            if (this.thin) {
              const details = this._impl ?? this;
              dbInstance = this.serviceName ?? details.serviceName;
              hostname = this.hostName ?? details.nscon?.ntAdapter?.hostName;
              const p = this.port ?? details.nscon?.ntAdapter?.port;
              if (p != null) port = String(p);
            } else {
              dbInstance = this.serviceName;
            }
          } catch {
          }
          const connAttrs = connectionAttributes.get(this);
          const ctx = {
            dbInstance,
            port,
            hostname,
            query: dbQuery,
            connAttrs
          };
          return startChannel.runStores(ctx, () => {
            try {
              let result = execute.apply(this, arguments);
              if (typeof result?.then === "function") {
                result = result.then(
                  (x) => {
                    finish(ctx);
                    return x;
                  },
                  (e) => {
                    ctx.error = e;
                    finish(ctx);
                    throw e;
                  }
                );
              }
              return result;
            } catch (err) {
              ctx.error = err;
              finish(ctx);
              throw err;
            }
          });
        };
      });
      shimmer.wrap(oracledb, "getConnection", (getConnection) => {
        return function wrappedGetConnection(connAttrs, callback) {
          if (callback) {
            arguments[1] = shimmer.wrapFunction(callback, (callback2) => (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, connAttrs);
              }
              callback2(err, connection);
            });
            getConnection.apply(this, arguments);
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, connAttrs);
              return connection;
            });
          }
        };
      });
      shimmer.wrap(oracledb, "createPool", (createPool) => {
        return function wrappedCreatePool(poolAttrs, callback) {
          if (callback) {
            arguments[1] = shimmer.wrapFunction(callback, (callback2) => (err, pool) => {
              if (pool) {
                poolAttributes.set(pool, poolAttrs);
              }
              callback2(err, pool);
            });
            createPool.apply(this, arguments);
          } else {
            return createPool.apply(this, arguments).then((pool) => {
              poolAttributes.set(pool, poolAttrs);
              return pool;
            });
          }
        };
      });
      shimmer.wrap(oracledb.Pool.prototype, "getConnection", (getConnection) => {
        return function wrappedGetConnection() {
          let callback;
          if (typeof arguments[arguments.length - 1] === "function") {
            callback = arguments[arguments.length - 1];
          }
          if (callback) {
            arguments[arguments.length - 1] = shimmer.wrapFunction(callback, (callback2) => (err, connection) => {
              if (connection) {
                connectionAttributes.set(connection, poolAttributes.get(this));
              }
              callback2(err, connection);
            });
            getConnection.apply(this, arguments);
          } else {
            return getConnection.apply(this, arguments).then((connection) => {
              connectionAttributes.set(connection, poolAttributes.get(this));
              return connection;
            });
          }
        };
      });
      return oracledb;
    });
  }
});

// ../../packages/datadog-instrumentations/src/openai.js
var require_openai = __commonJS({
  "../../packages/datadog-instrumentations/src/openai.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var dc = require_dc_polyfill();
    var ch = dc.tracingChannel("apm:openai:request");
    var onStreamedChunkCh = dc.channel("apm:openai:request:chunk");
    var V4_PACKAGE_SHIMS = [
      {
        file: "resources/chat/completions",
        targetClass: "Completions",
        baseResource: "chat.completions",
        methods: ["create"],
        streamedResponse: true
      },
      {
        file: "resources/completions",
        targetClass: "Completions",
        baseResource: "completions",
        methods: ["create"],
        streamedResponse: true
      },
      {
        file: "resources/embeddings",
        targetClass: "Embeddings",
        baseResource: "embeddings",
        methods: ["create"]
      },
      {
        file: "resources/files",
        targetClass: "Files",
        baseResource: "files",
        methods: ["create", "list", "retrieve"]
      },
      {
        file: "resources/files",
        targetClass: "Files",
        baseResource: "files",
        methods: ["del"],
        versions: [">=4.0.0 <5.0.0"]
      },
      {
        file: "resources/files",
        targetClass: "Files",
        baseResource: "files",
        methods: ["delete"],
        versions: [">=5"]
      },
      {
        file: "resources/files",
        targetClass: "Files",
        baseResource: "files",
        methods: ["retrieveContent"],
        versions: [">=4.0.0 <4.17.1"]
      },
      {
        file: "resources/files",
        targetClass: "Files",
        baseResource: "files",
        methods: ["content"],
        // replaced `retrieveContent` in v4.17.1
        versions: [">=4.17.1"]
      },
      {
        file: "resources/images",
        targetClass: "Images",
        baseResource: "images",
        methods: ["createVariation", "edit", "generate"]
      },
      {
        file: "resources/fine-tuning/jobs/jobs",
        targetClass: "Jobs",
        baseResource: "fine_tuning.jobs",
        methods: ["cancel", "create", "list", "listEvents", "retrieve"],
        versions: [">=4.34.0"]
        // file location changed in 4.34.0
      },
      {
        file: "resources/fine-tuning/jobs",
        targetClass: "Jobs",
        baseResource: "fine_tuning.jobs",
        methods: ["cancel", "create", "list", "listEvents", "retrieve"],
        versions: [">=4.1.0 <4.34.0"]
      },
      {
        file: "resources/fine-tunes",
        // deprecated after 4.1.0
        targetClass: "FineTunes",
        baseResource: "fine-tune",
        methods: ["cancel", "create", "list", "listEvents", "retrieve"],
        versions: [">=4.0.0 <4.1.0"]
      },
      {
        file: "resources/models",
        targetClass: "Models",
        baseResource: "models",
        methods: ["list", "retrieve"]
      },
      {
        file: "resources/models",
        targetClass: "Models",
        baseResource: "models",
        methods: ["del"],
        versions: [">=4 <5"]
      },
      {
        file: "resources/models",
        targetClass: "Models",
        baseResource: "models",
        methods: ["delete"],
        versions: [">=5"]
      },
      {
        file: "resources/moderations",
        targetClass: "Moderations",
        baseResource: "moderations",
        methods: ["create"]
      },
      {
        file: "resources/audio/transcriptions",
        targetClass: "Transcriptions",
        baseResource: "audio.transcriptions",
        methods: ["create"]
      },
      {
        file: "resources/audio/translations",
        targetClass: "Translations",
        baseResource: "audio.translations",
        methods: ["create"]
      },
      {
        file: "resources/chat/completions/completions",
        targetClass: "Completions",
        baseResource: "chat.completions",
        methods: ["create"],
        streamedResponse: true,
        versions: [">=4.85.0"]
      }
    ];
    addHook({ name: "openai", file: "dist/api.js", versions: [">=3.0.0 <4"] }, (exports3) => {
      const methodNames = Object.getOwnPropertyNames(exports3.OpenAIApi.prototype);
      methodNames.shift();
      for (const methodName of methodNames) {
        shimmer.wrap(exports3.OpenAIApi.prototype, methodName, (fn) => function() {
          if (!ch.start.hasSubscribers) {
            return fn.apply(this, arguments);
          }
          const ctx = {
            methodName,
            args: arguments,
            basePath: this.basePath
          };
          return ch.tracePromise(fn, ctx, this, ...arguments);
        });
      }
      return exports3;
    });
    function wrapStreamIterator(response, options, ctx) {
      return function(itr) {
        return function() {
          const iterator = itr.apply(this, arguments);
          shimmer.wrap(iterator, "next", (next) => function() {
            return next.apply(this, arguments).then((res) => {
              const { done, value: chunk } = res;
              onStreamedChunkCh.publish({ ctx, chunk, done });
              if (done) {
                finish(ctx, {
                  headers: response.headers,
                  request: {
                    path: response.url,
                    method: options.method
                  }
                });
              }
              return res;
            }).catch((err) => {
              finish(ctx, void 0, err);
              throw err;
            });
          });
          return iterator;
        };
      };
    }
    var extensions = [".js", ".mjs"];
    for (const extension of extensions) {
      for (const shim of V4_PACKAGE_SHIMS) {
        const { file, targetClass, baseResource, methods, versions, streamedResponse } = shim;
        addHook({ name: "openai", file: file + extension, versions: versions || [">=4"] }, (exports3) => {
          const targetPrototype = exports3[targetClass].prototype;
          for (const methodName of methods) {
            shimmer.wrap(targetPrototype, methodName, (methodFn) => function() {
              if (!ch.start.hasSubscribers) {
                return methodFn.apply(this, arguments);
              }
              const stream = streamedResponse && getOption(arguments, "stream", false);
              const client = this._client || this.client;
              const ctx = {
                methodName: `${baseResource}.${methodName}`,
                args: arguments,
                basePath: client.baseURL
              };
              return ch.start.runStores(ctx, () => {
                const apiProm = methodFn.apply(this, arguments);
                if (baseResource === "chat.completions" && typeof apiProm._thenUnwrap === "function") {
                  shimmer.wrap(apiProm, "_thenUnwrap", (origApiPromThenUnwrap) => function() {
                    const unwrappedPromise = origApiPromThenUnwrap.apply(this, arguments);
                    shimmer.wrap(unwrappedPromise, "parse", (origApiPromParse) => function() {
                      const parsedPromise = origApiPromParse.apply(this, arguments).then((body) => Promise.all([this.responsePromise, body]));
                      return handleUnwrappedAPIPromise(parsedPromise, ctx, stream);
                    });
                    return unwrappedPromise;
                  });
                }
                shimmer.wrap(apiProm, "parse", (origApiPromParse) => function() {
                  const parsedPromise = origApiPromParse.apply(this, arguments).then((body) => Promise.all([this.responsePromise, body]));
                  return handleUnwrappedAPIPromise(parsedPromise, ctx, stream);
                });
                ch.end.publish(ctx);
                return apiProm;
              });
            });
          }
          return exports3;
        });
      }
    }
    function handleUnwrappedAPIPromise(apiProm, ctx, stream) {
      return apiProm.then(([{ response, options }, body]) => {
        if (stream) {
          if (body.iterator) {
            shimmer.wrap(body, "iterator", wrapStreamIterator(response, options, ctx));
          } else {
            shimmer.wrap(
              body.response.body,
              Symbol.asyncIterator,
              wrapStreamIterator(response, options, ctx)
            );
          }
        } else {
          finish(ctx, {
            headers: response.headers,
            data: body,
            request: {
              path: response.url,
              method: options.method
            }
          });
        }
        return body;
      }).catch((error) => {
        finish(ctx, void 0, error);
        throw error;
      });
    }
    function finish(ctx, response, error) {
      if (error) {
        ctx.error = error;
        ch.error.publish(ctx);
      }
      ctx.result ??= {};
      Object.assign(ctx.result, response);
      ch.asyncEnd.publish(ctx);
    }
    function getOption(args, option, defaultValue) {
      return args[0]?.[option] || defaultValue;
    }
  }
});

// ../../packages/datadog-instrumentations/src/passport.js
var require_passport = __commonJS({
  "../../packages/datadog-instrumentations/src/passport.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var onPassportDeserializeUserChannel = channel("datadog:passport:deserializeUser:finish");
    function wrapDone(done) {
      return function wrappedDone(err, user) {
        if (!err && user) {
          const abortController = new AbortController();
          onPassportDeserializeUserChannel.publish({ user, abortController });
          if (abortController.signal.aborted) return;
        }
        return done.apply(this, arguments);
      };
    }
    function wrapDeserializeUser(deserializeUser) {
      return function wrappedDeserializeUser(fn, req, done) {
        if (typeof fn === "function") return deserializeUser.apply(this, arguments);
        if (typeof req === "function") {
          done = req;
          arguments[1] = wrapDone(done);
        } else {
          arguments[2] = wrapDone(done);
        }
        return deserializeUser.apply(this, arguments);
      };
    }
    addHook({
      name: "passport",
      file: "lib/authenticator.js",
      versions: [">=0.3.0"]
    }, (Authenticator) => {
      shimmer.wrap(Authenticator.prototype, "deserializeUser", wrapDeserializeUser);
      return Authenticator;
    });
  }
});

// ../../packages/datadog-instrumentations/src/passport-utils.js
var require_passport_utils = __commonJS({
  "../../packages/datadog-instrumentations/src/passport-utils.js"(exports2, module2) {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel } = require_instrument();
    var passportVerifyChannel = channel("datadog:passport:verify:finish");
    function wrapVerifiedAndPublish(framework, username, verified) {
      return shimmer.wrapFunction(verified, function wrapVerified(verified2) {
        return function wrappedVerified(err, user) {
          if (!err) {
            const abortController = new AbortController();
            passportVerifyChannel.publish({ framework, login: username, user, success: !!user, abortController });
            if (abortController.signal.aborted) return;
          }
          return verified2.apply(this, arguments);
        };
      });
    }
    function wrapVerify(verify) {
      return function wrappedVerify(req, username, password, verified) {
        if (passportVerifyChannel.hasSubscribers) {
          const framework = `passport-${this.name}`;
          if (this._passReqToCallback) {
            arguments[3] = wrapVerifiedAndPublish(framework, arguments[1], arguments[3]);
          } else {
            arguments[2] = wrapVerifiedAndPublish(framework, arguments[0], arguments[2]);
          }
        }
        return verify.apply(this, arguments);
      };
    }
    function wrapStrategy(Strategy) {
      return function wrappedStrategy() {
        if (typeof arguments[0] === "function") {
          arguments[0] = wrapVerify(arguments[0]);
        } else {
          arguments[1] = wrapVerify(arguments[1]);
        }
        return Strategy.apply(this, arguments);
      };
    }
    function strategyHook(Strategy) {
      return shimmer.wrapFunction(Strategy, wrapStrategy);
    }
    module2.exports = {
      strategyHook
    };
  }
});

// ../../packages/datadog-instrumentations/src/passport-http.js
var require_passport_http = __commonJS({
  "../../packages/datadog-instrumentations/src/passport-http.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { strategyHook } = require_passport_utils();
    addHook({
      name: "passport-http",
      file: "lib/passport-http/strategies/basic.js",
      versions: [">=0.3.0"]
    }, strategyHook);
  }
});

// ../../packages/datadog-instrumentations/src/passport-local.js
var require_passport_local = __commonJS({
  "../../packages/datadog-instrumentations/src/passport-local.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { strategyHook } = require_passport_utils();
    addHook({
      name: "passport-local",
      file: "lib/strategy.js",
      versions: [">=1.0.0"]
    }, strategyHook);
  }
});

// ../../packages/datadog-instrumentations/src/pg.js
var require_pg = __commonJS({
  "../../packages/datadog-instrumentations/src/pg.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var startCh = channel("apm:pg:query:start");
    var finishCh = channel("apm:pg:query:finish");
    var errorCh = channel("apm:pg:query:error");
    var startPoolQueryCh = channel("datadog:pg:pool:query:start");
    var finishPoolQueryCh = channel("datadog:pg:pool:query:finish");
    var { errorMonitor } = __require("node:events");
    addHook({ name: "pg", versions: [">=8.0.3"], file: "lib/native/client.js" }, (Client) => {
      shimmer.wrap(Client.prototype, "query", (query) => wrapQuery(query));
      return Client;
    });
    addHook({ name: "pg", versions: [">=8.0.3"], file: "lib/client.js" }, (Client) => {
      shimmer.wrap(Client.prototype, "query", (query) => wrapQuery(query));
      return Client;
    });
    addHook({ name: "pg", versions: [">=8.0.3"] }, (pg) => {
      shimmer.wrap(pg.Pool.prototype, "query", (query) => wrapPoolQuery(query));
      return pg;
    });
    function wrapQuery(query) {
      return function() {
        if (!startCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const processId = this.processID;
        const pgQuery = arguments[0] !== null && typeof arguments[0] === "object" ? arguments[0] : { text: arguments[0] };
        const textPropObj = pgQuery.cursor ?? pgQuery;
        const textProp = Object.getOwnPropertyDescriptor(textPropObj, "text");
        const stream = typeof textPropObj.read === "function";
        let originalText;
        if (!textProp || textProp.configurable) {
          originalText = textPropObj.text;
          Object.defineProperty(textPropObj, "text", {
            get() {
              return this?.__ddInjectableQuery || originalText;
            }
          });
        }
        const abortController = new AbortController();
        const ctx = {
          params: this.connectionParameters,
          query: textPropObj,
          originalText,
          processId,
          abortController,
          stream
        };
        const finish2 = (error, res) => {
          if (error) {
            ctx.error = error;
            errorCh.publish(ctx);
          }
          ctx.result = res?.rows;
          return finishCh.publish(ctx);
        };
        return startCh.runStores(ctx, () => {
          if (abortController.signal.aborted) {
            const error = abortController.signal.reason || new Error("Aborted");
            const reusingQuery = typeof pgQuery.submit === "function";
            const callback = arguments[arguments.length - 1];
            finish2(error);
            if (reusingQuery) {
              if (!pgQuery.callback && typeof callback === "function") {
                pgQuery.callback = callback;
              }
              if (pgQuery.callback) {
                pgQuery.callback(error);
              } else {
                process.nextTick(() => {
                  pgQuery.emit("error", error);
                });
              }
              return pgQuery;
            }
            if (typeof callback === "function") {
              callback(error);
              return;
            }
            return Promise.reject(error);
          }
          arguments[0] = pgQuery;
          const retval = query.apply(this, arguments);
          const queryQueue = this.queryQueue || this._queryQueue;
          const activeQuery = this.activeQuery || this._activeQuery;
          const newQuery = queryQueue.at(-1) || activeQuery;
          if (!newQuery) {
            return retval;
          }
          if (newQuery.callback) {
            const originalCallback = newQuery.callback;
            newQuery.callback = function(err, ...args) {
              finish2(err, ...args);
              return finishCh.runStores(ctx, originalCallback, this, err, ...args);
            };
          } else if (newQuery.once) {
            newQuery.once(errorMonitor, finish2).once("end", (res) => finish2(null, res));
          } else {
            newQuery.then((res) => finish2(null, res), finish2);
          }
          try {
            return retval;
          } catch (error) {
            ctx.error = error;
            errorCh.publish(ctx);
          }
        });
      };
    }
    var finish = (ctx) => {
      finishPoolQueryCh.publish(ctx);
    };
    function wrapPoolQuery(query) {
      return function() {
        if (!startPoolQueryCh.hasSubscribers) {
          return query.apply(this, arguments);
        }
        const pgQuery = arguments[0] !== null && typeof arguments[0] === "object" ? arguments[0] : { text: arguments[0] };
        const abortController = new AbortController();
        const ctx = { query: pgQuery, abortController };
        return startPoolQueryCh.runStores(ctx, () => {
          const cb = arguments[arguments.length - 1];
          if (abortController.signal.aborted) {
            const error = abortController.signal.reason || new Error("Aborted");
            finish(ctx);
            if (typeof cb === "function") {
              cb(error);
              return;
            }
            return Promise.reject(error);
          }
          if (typeof cb === "function") {
            arguments[arguments.length - 1] = shimmer.wrapFunction(cb, (cb2) => function() {
              finish(ctx);
              return cb2.apply(this, arguments);
            });
          }
          const retval = query.apply(this, arguments);
          if (retval?.then) {
            retval.then(() => {
              finish(ctx);
            }).catch(() => {
              finish(ctx);
            });
          }
          return retval;
        });
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/pino.js
var require_pino = __commonJS({
  "../../packages/datadog-instrumentations/src/pino.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    function wrapPino(symbol, wrapper, pino) {
      return function pinoWithTrace() {
        const instance = pino.apply(this, arguments);
        Object.defineProperty(instance, symbol, {
          configurable: true,
          enumerable: true,
          writable: true,
          value: wrapper(instance[symbol])
        });
        return instance;
      };
    }
    function wrapAsJson(asJson) {
      const ch = channel("apm:pino:log");
      return function asJsonWithTrace(obj, msg, num, time) {
        obj = arguments[0] = obj || {};
        const payload = { message: obj };
        ch.publish(payload);
        arguments[0] = payload.message;
        return asJson.apply(this, arguments);
      };
    }
    function wrapMixin(mixin) {
      const ch = channel("apm:pino:log");
      return function mixinWithTrace() {
        let obj = {};
        if (mixin) {
          obj = mixin.apply(this, arguments);
        }
        const payload = { message: obj };
        ch.publish(payload);
        return payload.message;
      };
    }
    function wrapPrettifyObject(prettifyObject) {
      const ch = channel("apm:pino:log");
      return function prettifyObjectWithTrace(input) {
        const payload = { message: input.input };
        ch.publish(payload);
        input.input = payload.message;
        return prettifyObject.apply(this, arguments);
      };
    }
    function wrapPrettyFactory(prettyFactory) {
      const ch = channel("apm:pino:log");
      return function prettyFactoryWithTrace() {
        const pretty = prettyFactory.apply(this, arguments);
        return function prettyWithTrace(obj) {
          const payload = { message: obj };
          ch.publish(payload);
          arguments[0] = payload.message;
          return pretty.apply(this, arguments);
        };
      };
    }
    addHook({ name: "pino", versions: ["2 - 3", "4"], patchDefault: true }, (pino) => {
      const asJsonSym = pino.symbols && pino.symbols.asJsonSym || "asJson";
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(asJsonSym, wrapAsJson, pino2));
      return wrapped;
    });
    addHook({ name: "pino", versions: [">=5 <5.14.0"], patchDefault: true }, (pino) => {
      const asJsonSym = (pino.default || pino)?.symbols.asJsonSym || "asJson";
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(asJsonSym, wrapAsJson, pino2));
      return wrapped;
    });
    addHook({ name: "pino", versions: [">=5.14.0 <6.8.0"] }, (pino) => {
      const mixinSym = (pino.default || pino).symbols.mixinSym;
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(mixinSym, wrapMixin, pino2.default || pino2));
      return wrapped;
    });
    addHook({ name: "pino", versions: [">=6.8.0"], patchDefault: false }, (pino, _1, _2, isIitm) => {
      const mixinSym = pino.symbols.mixinSym;
      const wrapped = shimmer.wrapFunction(pino, (pino2) => wrapPino(mixinSym, wrapMixin, pino2));
      wrapped.pino = wrapped;
      wrapped.default = wrapped;
      return wrapped;
    });
    addHook({ name: "pino-pretty", file: "lib/utils.js", versions: [">=3"] }, (utils) => {
      shimmer.wrap(utils, "prettifyObject", wrapPrettifyObject);
      return utils;
    });
    addHook({ name: "pino-pretty", versions: ["1 - 2"] }, (prettyFactory) => {
      return shimmer.wrapFunction(prettyFactory, wrapPrettyFactory);
    });
  }
});

// ../../packages/datadog-instrumentations/src/promise-js.js
var require_promise_js = __commonJS({
  "../../packages/datadog-instrumentations/src/promise-js.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "promise-js",
      versions: [">=0.0.3"]
    }, (Promise2) => {
      if (Promise2 !== global.Promise) {
        shimmer.wrap(Promise2.prototype, "then", wrapThen);
      }
      return Promise2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/promise.js
var require_promise3 = __commonJS({
  "../../packages/datadog-instrumentations/src/promise.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "promise",
      file: "lib/core.js",
      versions: [">=7"]
    }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "then", wrapThen);
      return Promise2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/protobufjs.js
var require_protobufjs = __commonJS({
  "../../packages/datadog-instrumentations/src/protobufjs.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook } = require_instrument();
    var dc = require_dc_polyfill();
    var serializeChannel = dc.channel("apm:protobufjs:serialize-start");
    var deserializeChannel = dc.channel("apm:protobufjs:deserialize-end");
    function wrapSerialization(messageClass) {
      if (messageClass?.encode) {
        shimmer.wrap(messageClass, "encode", (original) => function() {
          if (!serializeChannel.hasSubscribers) {
            return original.apply(this, arguments);
          }
          serializeChannel.publish({ messageClass: this });
          return original.apply(this, arguments);
        });
      }
    }
    function wrapDeserialization(messageClass) {
      if (messageClass?.decode) {
        shimmer.wrap(messageClass, "decode", (original) => function() {
          if (!deserializeChannel.hasSubscribers) {
            return original.apply(this, arguments);
          }
          const result = original.apply(this, arguments);
          deserializeChannel.publish({ messageClass: result });
          return result;
        });
      }
    }
    function wrapSetup(messageClass) {
      if (messageClass?.setup) {
        shimmer.wrap(messageClass, "setup", (original) => function() {
          const result = original.apply(this, arguments);
          wrapSerialization(messageClass);
          wrapDeserialization(messageClass);
          return result;
        });
      }
    }
    function wrapProtobufClasses(root) {
      if (!root) {
        return;
      }
      if (root.decode) {
        wrapSetup(root);
      }
      if (root.nestedArray) {
        for (const subRoot of root.nestedArray) {
          wrapProtobufClasses(subRoot);
        }
      }
    }
    function wrapReflection(protobuf) {
      const reflectionMethods = [
        {
          target: protobuf.Root,
          name: "fromJSON"
        },
        {
          target: protobuf.Type.prototype,
          name: "fromObject"
        }
      ];
      reflectionMethods.forEach((method) => {
        shimmer.wrap(method.target, method.name, (original) => function() {
          const result = original.apply(this, arguments);
          if (result.nested) {
            for (const type in result.nested) {
              wrapSetup(result.nested[type]);
            }
          }
          if (result.$type) {
            wrapSetup(result.$type);
          }
          return result;
        });
      });
    }
    function isPromise(obj) {
      return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
    }
    addHook({
      name: "protobufjs",
      versions: [">=6.8.0"]
    }, (protobuf) => {
      shimmer.wrap(protobuf.Root.prototype, "load", (original) => function() {
        const result = original.apply(this, arguments);
        if (isPromise(result)) {
          return result.then((root) => {
            wrapProtobufClasses(root);
            return root;
          });
        }
        wrapProtobufClasses(result);
        return result;
      });
      shimmer.wrap(protobuf.Root.prototype, "loadSync", (original) => function() {
        const root = original.apply(this, arguments);
        wrapProtobufClasses(root);
        return root;
      });
      shimmer.wrap(protobuf, "Type", (Original) => function() {
        const typeInstance = new Original(...arguments);
        wrapSetup(typeInstance);
        return typeInstance;
      });
      wrapReflection(protobuf);
      return protobuf;
    });
  }
});

// ../../packages/datadog-instrumentations/src/pug.js
var require_pug = __commonJS({
  "../../packages/datadog-instrumentations/src/pug.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel, addHook } = require_instrument();
    var pugCompileCh = channel("datadog:pug:compile:start");
    function wrapCompile(compile) {
      return function wrappedCompile(source) {
        if (pugCompileCh.hasSubscribers) {
          pugCompileCh.publish({ source });
        }
        return compile.apply(this, arguments);
      };
    }
    addHook({ name: "pug", versions: [">=2.0.4"] }, (compiler) => {
      shimmer.wrap(compiler, "compile", wrapCompile);
      shimmer.wrap(compiler, "compileClientWithDependenciesTracked", wrapCompile);
      return compiler;
    });
  }
});

// ../../packages/datadog-instrumentations/src/q.js
var require_q = __commonJS({
  "../../packages/datadog-instrumentations/src/q.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "q",
      versions: ["1"]
    }, (Q) => {
      shimmer.wrap(Q.makePromise.prototype, "then", wrapThen);
      return Q;
    });
    addHook({
      name: "q",
      versions: [">=2"]
    }, (Q) => {
      shimmer.wrap(Q.Promise.prototype, "then", wrapThen);
      return Q;
    });
  }
});

// ../../packages/datadog-instrumentations/src/restify.js
var require_restify = __commonJS({
  "../../packages/datadog-instrumentations/src/restify.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { addHook, channel } = require_instrument();
    var handlers = ["use", "pre"];
    var methods = ["del", "get", "head", "opts", "post", "put", "patch"];
    var handleChannel = channel("apm:restify:request:handle");
    var errorChannel = channel("apm:restify:middleware:error");
    var enterChannel = channel("apm:restify:middleware:enter");
    var exitChannel = channel("apm:restify:middleware:exit");
    var finishChannel = channel("apm:restify:middleware:finish");
    var nextChannel = channel("apm:restify:middleware:next");
    function wrapSetupRequest(setupRequest) {
      return function(req, res) {
        handleChannel.publish({ req, res });
        return setupRequest.apply(this, arguments);
      };
    }
    function wrapMethod(method) {
      return function(path, ...middlewares) {
        const wrappedMiddlewares = middlewares.map(wrapFn);
        return method.apply(this, [path, ...wrappedMiddlewares]);
      };
    }
    function wrapHandler(method) {
      return function(...middlewares) {
        return method.apply(this, middlewares.map(wrapFn));
      };
    }
    function wrapFn(fn) {
      if (Array.isArray(fn)) return fn.map(wrapFn);
      return shimmer.wrapFunction(fn, (fn2) => function(req, res, next) {
        if (typeof next === "function") {
          arguments[2] = wrapNext(req, next);
        }
        const route = req.route && req.route.path;
        enterChannel.publish({ req, route });
        try {
          const result = fn2.apply(this, arguments);
          if (typeof result?.then === "function") {
            return result.then(function(result2) {
              nextChannel.publish({ req });
              finishChannel.publish({ req });
              return result2;
            }).catch(function(error) {
              errorChannel.publish({ req, error });
              nextChannel.publish({ req });
              finishChannel.publish({ req });
              throw error;
            });
          }
          return result;
        } catch (error) {
          errorChannel.publish({ req, error });
          nextChannel.publish({ req });
          finishChannel.publish({ req });
          throw error;
        } finally {
          exitChannel.publish({ req });
        }
      });
    }
    function wrapNext(req, next) {
      return shimmer.wrapFunction(next, (next2) => function() {
        nextChannel.publish({ req });
        finishChannel.publish({ req });
        next2.apply(this, arguments);
      });
    }
    addHook({ name: "restify", versions: [">=3"], file: "lib/server.js" }, (Server2) => {
      shimmer.wrap(Server2.prototype, "_setupRequest", wrapSetupRequest);
      shimmer.massWrap(Server2.prototype, handlers, wrapHandler);
      shimmer.massWrap(Server2.prototype, methods, wrapMethod);
      return Server2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/rhea.js
var require_rhea = __commonJS({
  "../../packages/datadog-instrumentations/src/rhea.js"(exports2, module2) {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var circularBufferConstructor = Symbol("circularBufferConstructor");
    var inFlightDeliveries = Symbol("inFlightDeliveries");
    var patched = /* @__PURE__ */ new WeakSet();
    var startSendCh = channel("apm:rhea:send:start");
    var encodeSendCh = channel("apm:rhea:send:encode");
    var errorSendCh = channel("apm:rhea:send:error");
    var finishSendCh = channel("apm:rhea:send:finish");
    var startReceiveCh = channel("apm:rhea:receive:start");
    var dispatchReceiveCh = channel("apm:rhea:receive:dispatch");
    var errorReceiveCh = channel("apm:rhea:receive:error");
    var finishReceiveCh = channel("apm:rhea:receive:finish");
    var contexts = /* @__PURE__ */ new WeakMap();
    addHook({ name: "rhea", versions: [">=1"] }, (rhea) => {
      shimmer.wrap(rhea.message, "encode", (encode) => function(msg) {
        encodeSendCh.publish(msg);
        return encode.apply(this, arguments);
      });
      return rhea;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/link.js" }, (obj) => {
      const Sender = obj.Sender;
      const Receiver = obj.Receiver;
      shimmer.wrap(Sender.prototype, "send", (send) => function(msg, tag, format) {
        if (!canTrace(this)) {
          return send.apply(this, arguments);
        }
        const { host, port } = getHostAndPort(this.connection);
        const targetAddress = this.options && this.options.target && this.options.target.address ? this.options.target.address : void 0;
        const ctx = { targetAddress, host, port, msg, connection: this.connection };
        return startSendCh.runStores(ctx, () => {
          const delivery = send.apply(this, arguments);
          contexts.set(delivery, ctx);
          addToInFlightDeliveries(this.connection, delivery);
          try {
            return delivery;
          } catch (err) {
            ctx.error = err;
            errorSendCh.publish(ctx);
            throw err;
          }
        });
      });
      shimmer.wrap(Receiver.prototype, "dispatch", (dispatch) => function(eventName, msgObj) {
        if (!canTrace(this)) {
          return dispatch.apply(this, arguments);
        }
        if (eventName === "message" && msgObj) {
          const ctx = { msgObj, connection: this.connection };
          return startReceiveCh.runStores(ctx, () => {
            if (msgObj.delivery) {
              contexts.set(msgObj.delivery, ctx);
              msgObj.delivery.update = wrapDeliveryUpdate(msgObj.delivery, msgObj.delivery.update);
              addToInFlightDeliveries(this.connection, msgObj.delivery);
            }
            try {
              return dispatch.apply(this, arguments);
            } catch (err) {
              ctx.error = err;
              errorReceiveCh.publish(ctx);
              throw err;
            }
          });
        }
        return dispatch.apply(this, arguments);
      });
      return obj;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/connection.js" }, (Connection) => {
      shimmer.wrap(Connection.prototype, "dispatch", (dispatch) => function(eventName, obj) {
        if (eventName === "disconnected") {
          const error = obj.error || this.saved_error;
          if (this[inFlightDeliveries]) {
            this[inFlightDeliveries].forEach((delivery) => {
              const ctx = contexts.get(delivery);
              if (!ctx) return;
              ctx.error = error;
              errorReceiveCh.publish(ctx);
              exports2.beforeFinish(delivery, null);
              finishReceiveCh.publish(ctx);
            });
          }
        }
        return dispatch.apply(this, arguments);
      });
      return Connection;
    });
    addHook({ name: "rhea", versions: [">=1"], file: "lib/session.js" }, (Session) => {
      patchCircularBuffer(Session.prototype, Session);
      return Session;
    });
    function canTrace(link) {
      return link.connection && link.session && link.session.outgoing;
    }
    function getHostAndPort(connection) {
      let host;
      let port;
      if (connection && connection.options) {
        host = connection.options.host;
        port = connection.options.port;
      }
      return { host, port };
    }
    function wrapDeliveryUpdate(obj, update) {
      const ctx = contexts.get(obj);
      if (obj && ctx) {
        const cb = update;
        return shimmer.wrapFunction(cb, (cb2) => function wrappedUpdate(settled, stateData) {
          ctx.state = getStateFromData(stateData);
          dispatchReceiveCh.runStores(ctx, () => {
            return cb2.apply(this, arguments);
          });
        });
      }
      return function wrappedUpdate(settled, stateData) {
        return update.apply(this, arguments);
      };
    }
    function patchCircularBuffer(proto, Session) {
      Object.defineProperty(proto, "outgoing", {
        configurable: true,
        // eslint-disable-next-line getter-return
        get() {
        },
        set(outgoing) {
          delete proto.outgoing;
          this.outgoing = outgoing;
          if (outgoing) {
            let CircularBuffer;
            if (outgoing.deliveries) {
              CircularBuffer = outgoing.deliveries.constructor;
            }
            if (CircularBuffer && !patched.has(CircularBuffer.prototype)) {
              shimmer.wrap(CircularBuffer.prototype, "pop_if", (popIf) => function(fn) {
                arguments[0] = shimmer.wrapFunction(fn, (fn2) => function(entry) {
                  const ctx = contexts.get(entry);
                  if (!ctx) return fn2(entry);
                  const shouldPop = fn2(entry);
                  if (shouldPop) {
                    const remoteState = entry.remote_state;
                    const state = remoteState && remoteState.constructor ? entry.remote_state.constructor.composite_type : void 0;
                    ctx.state = state;
                    exports2.beforeFinish(entry, state);
                    finishSendCh.publish(ctx);
                  }
                  return shouldPop;
                });
                return popIf.apply(this, arguments);
              });
              patched.add(CircularBuffer.prototype);
              const Session2 = proto.constructor;
              if (Session2) {
                Session2[circularBufferConstructor] = CircularBuffer;
              }
            }
          }
        }
      });
    }
    function addToInFlightDeliveries(connection, delivery) {
      let deliveries = connection[inFlightDeliveries];
      if (!deliveries) {
        deliveries = /* @__PURE__ */ new Set();
        connection[inFlightDeliveries] = deliveries;
      }
      deliveries.add(delivery);
    }
    function beforeFinish(delivery, state) {
      const ctx = contexts.get(delivery);
      if (ctx) {
        if (state) {
          ctx.state = state;
          dispatchReceiveCh.publish(ctx);
        }
        if (ctx.connection && ctx.connection[inFlightDeliveries]) {
          ctx.connection[inFlightDeliveries].delete(delivery);
        }
      }
    }
    function getStateFromData(stateData) {
      if (stateData && stateData.descriptor && stateData.descriptor) {
        switch (stateData.descriptor.value) {
          case 36:
            return "accepted";
          case 37:
            return "rejected";
          case 38:
            return "released";
          case 39:
            return "modified";
        }
      }
    }
    module2.exports.inFlightDeliveries = inFlightDeliveries;
    module2.exports.beforeFinish = beforeFinish;
    module2.exports.contexts = contexts;
  }
});

// ../../packages/datadog-instrumentations/src/selenium.js
var require_selenium = __commonJS({
  "../../packages/datadog-instrumentations/src/selenium.js"() {
    "use strict";
    var { addHook, channel } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var ciSeleniumDriverGetStartCh = channel("ci:selenium:driver:get");
    var RUM_STOP_SESSION_SCRIPT = `
if (window.DD_RUM && window.DD_RUM.stopSession) {
  window.DD_RUM.stopSession();
  return true;
} else {
  return false;
}
`;
    var IS_RUM_ACTIVE_SCRIPT = "return !!window.DD_RUM";
    var DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS = 500;
    var DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME = "datadog-ci-visibility-test-execution-id";
    addHook({
      name: "selenium-webdriver",
      versions: [">=4.11.0"]
    }, (seleniumPackage, seleniumVersion) => {
      shimmer.wrap(seleniumPackage.WebDriver.prototype, "get", (get3) => async function() {
        if (!ciSeleniumDriverGetStartCh.hasSubscribers) {
          return get3.apply(this, arguments);
        }
        let traceId;
        const setTraceId = (inputTraceId) => {
          traceId = inputTraceId;
        };
        const getResult = await get3.apply(this, arguments);
        const isRumActive = await this.executeScript(IS_RUM_ACTIVE_SCRIPT);
        const capabilities = await this.getCapabilities();
        ciSeleniumDriverGetStartCh.publish({
          setTraceId,
          seleniumVersion,
          browserName: capabilities.getBrowserName(),
          browserVersion: capabilities.getBrowserVersion(),
          isRumActive
        });
        if (traceId && isRumActive) {
          await this.manage().addCookie({
            name: DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME,
            value: traceId
          });
        }
        return getResult;
      });
      shimmer.wrap(seleniumPackage.WebDriver.prototype, "quit", (quit) => async function() {
        if (!ciSeleniumDriverGetStartCh.hasSubscribers) {
          return quit.apply(this, arguments);
        }
        const isRumActive = await this.executeScript(RUM_STOP_SESSION_SCRIPT);
        if (isRumActive) {
          await new Promise((resolve) => {
            setTimeout(() => {
              resolve();
            }, DD_CIVISIBILITY_RUM_FLUSH_WAIT_MILLIS);
          });
          await this.manage().deleteCookie(DD_CIVISIBILITY_TEST_EXECUTION_ID_COOKIE_NAME);
        }
        return quit.apply(this, arguments);
      });
      return seleniumPackage;
    });
  }
});

// ../../packages/datadog-instrumentations/src/sequelize.js
var require_sequelize = __commonJS({
  "../../packages/datadog-instrumentations/src/sequelize.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "sequelize", versions: [">=4"], file: ["lib/sequelize.js"] }, (Sequelize) => {
      const startCh = channel("datadog:sequelize:query:start");
      const finishCh = channel("datadog:sequelize:query:finish");
      shimmer.wrap(Sequelize.prototype, "query", (query) => {
        return function(sql, options) {
          if (!startCh.hasSubscribers) {
            return query.apply(this, arguments);
          }
          let dialect;
          if (this.options && this.options.dialect) {
            dialect = this.options.dialect;
          } else if (this.dialect && this.dialect.name) {
            dialect = this.dialect.name;
          }
          function onFinish(result) {
            const type = options?.type || "RAW";
            if (type === "RAW" && result?.length > 1) {
              result = result[0];
            }
            finishCh.runStores({ result }, () => {
            });
          }
          return startCh.runStores({ sql, dialect }, () => {
            const promise = query.apply(this, arguments);
            promise.then(onFinish, () => {
              onFinish();
            });
            return promise;
          });
        };
      });
      return Sequelize;
    });
  }
});

// ../../packages/datadog-instrumentations/src/sharedb.js
var require_sharedb = __commonJS({
  "../../packages/datadog-instrumentations/src/sharedb.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var READABLE_ACTION_NAMES = {
      hs: "handshake",
      qf: "query-fetch",
      qs: "query-subscribe",
      qu: "query-unsubscribe",
      bf: "bulk-fetch",
      bs: "bulk-subscribe",
      bu: "bulk-unsubscribe",
      f: "fetch",
      s: "subscribe",
      u: "unsubscribe",
      op: "op",
      nf: "snapshot-fetch",
      nt: "snapshot-fetch-by-ts",
      p: "presence-broadcast",
      pr: "presence-request",
      ps: "presence-subscribe",
      pu: "presence-unsubscribe"
    };
    addHook({ name: "sharedb", versions: [">=1"], file: "lib/agent.js" }, (Agent2) => {
      const startCh = channel("apm:sharedb:request:start");
      const finishCh = channel("apm:sharedb:request:finish");
      const errorCh = channel("apm:sharedb:request:error");
      shimmer.wrap(Agent2.prototype, "_handleMessage", (origHandleMessageFn) => function(request2, callback) {
        const action = request2.a;
        const actionName = getReadableActionName(action);
        const ctx = { actionName, request: request2 };
        return startCh.runStores(ctx, () => {
          arguments[1] = shimmer.wrapFunction(callback, (callback2) => function(error, res) {
            if (error) {
              ctx.error = error;
              errorCh.publish(error);
            }
            ctx.res = res;
            return finishCh.runStores(ctx, callback2, this, ...arguments);
          });
          try {
            return origHandleMessageFn.apply(this, arguments);
          } catch (error) {
            ctx.error = error;
            errorCh.publish(ctx);
            throw error;
          }
        });
      });
      return Agent2;
    });
    function getReadableActionName(action) {
      const actionName = READABLE_ACTION_NAMES[action];
      if (actionName === void 0) {
        return action;
      }
      return actionName;
    }
  }
});

// ../../packages/datadog-instrumentations/src/tedious.js
var require_tedious = __commonJS({
  "../../packages/datadog-instrumentations/src/tedious.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    addHook({ name: "tedious", versions: [">=1.0.0"] }, (tedious) => {
      const startCh = channel("apm:tedious:request:start");
      const finishCh = channel("apm:tedious:request:finish");
      const errorCh = channel("apm:tedious:request:error");
      shimmer.wrap(tedious.Connection.prototype, "makeRequest", (makeRequest) => function(request2) {
        if (!startCh.hasSubscribers) {
          return makeRequest.apply(this, arguments);
        }
        const [queryOrProcedure, queryParent, queryField] = getQueryOrProcedure(request2);
        if (!queryOrProcedure) {
          return makeRequest.apply(this, arguments);
        }
        const connectionConfig = this.config;
        const ctx = { queryOrProcedure, connectionConfig };
        return startCh.runStores(ctx, () => {
          queryParent[queryField] = ctx.sql;
          const cb = request2.callback;
          request2.callback = function(error, ...args) {
            if (error) {
              ctx.error = error;
              errorCh.publish(ctx);
            }
            return finishCh.runStores(ctx, cb, this, error, ...args);
          };
          try {
            return makeRequest.apply(this, arguments);
          } catch (error) {
            ctx.error = error;
            errorCh.publish(ctx);
            throw error;
          }
        });
      });
      return tedious;
    });
    function getQueryOrProcedure(request2) {
      if (!request2.parameters) return [null];
      if (request2.parametersByName.statement) {
        return [request2.parametersByName.statement.value, request2.parametersByName.statement, "value"];
      } else if (request2.parametersByName.stmt) {
        return [request2.parametersByName.stmt.value, request2.parametersByName.stmt, "value"];
      }
      return [request2.sqlTextOrProcedure, request2, "sqlTextOrProcedure"];
    }
  }
});

// ../../packages/datadog-instrumentations/src/helpers/fetch.js
var require_fetch = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/fetch.js"(exports2) {
    "use strict";
    exports2.createWrapFetch = function createWrapFetch(Request, ch, onLoad) {
      return function wrapFetch(fetch2) {
        if (typeof fetch2 !== "function") return fetch2;
        return function(input, init) {
          if (onLoad) {
            onLoad();
            onLoad = void 0;
          }
          if (!ch.start.hasSubscribers) return fetch2.apply(this, arguments);
          if (input instanceof Request) {
            const ctx2 = { req: input };
            return ch.tracePromise(() => fetch2.call(this, input, init), ctx2);
          }
          const req = new Request(input, init);
          const ctx = { req };
          return ch.tracePromise(() => fetch2.call(this, req), ctx);
        };
      };
    };
  }
});

// ../../packages/datadog-instrumentations/src/undici.js
var require_undici = __commonJS({
  "../../packages/datadog-instrumentations/src/undici.js"() {
    "use strict";
    var {
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var ch = tracingChannel("apm:undici:fetch");
    var { createWrapFetch } = require_fetch();
    addHook({
      name: "undici",
      versions: ["^4.4.1", "5", ">=6.0.0"]
    }, (undici) => {
      return shimmer.wrap(undici, "fetch", createWrapFetch(undici.Request, ch));
    });
  }
});

// ../../packages/datadog-instrumentations/src/when.js
var require_when = __commonJS({
  "../../packages/datadog-instrumentations/src/when.js"() {
    "use strict";
    var { addHook } = require_instrument();
    var { wrapThen } = require_promise2();
    var shimmer = require_datadog_shimmer();
    addHook({
      name: "when",
      file: "lib/Promise.js",
      versions: [">=3"]
    }, (Promise2) => {
      shimmer.wrap(Promise2.prototype, "then", wrapThen);
      return Promise2;
    });
  }
});

// ../../packages/datadog-instrumentations/src/winston.js
var require_winston = __commonJS({
  "../../packages/datadog-instrumentations/src/winston.js"() {
    "use strict";
    var {
      channel,
      addHook
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var patched = /* @__PURE__ */ new WeakSet();
    var configureCh = channel("ci:log-submission:winston:configure");
    var addTransport = channel("ci:log-submission:winston:add-transport");
    addHook({ name: "winston", file: "lib/winston/transports/index.js", versions: [">=3"] }, (transportsPackage) => {
      if (configureCh.hasSubscribers) {
        configureCh.publish(transportsPackage.Http);
      }
      return transportsPackage;
    });
    addHook({ name: "winston", file: "lib/winston/logger.js", versions: [">=3"] }, (Logger) => {
      const logCh = channel("apm:winston:log");
      shimmer.wrap(Logger.prototype, "write", (write) => {
        return function wrappedWrite(chunk, enc, cb) {
          if (logCh.hasSubscribers) {
            const payload = { message: chunk };
            logCh.publish(payload);
            arguments[0] = payload.message;
          }
          return write.apply(this, arguments);
        };
      });
      shimmer.wrap(Logger.prototype, "configure", (configure) => function() {
        const configureResponse = configure.apply(this, arguments);
        if (addTransport.hasSubscribers) {
          addTransport.publish(this);
        }
        return configureResponse;
      });
      return Logger;
    });
    addHook({ name: "winston", file: "lib/winston/logger.js", versions: ["1", "2"] }, (logger) => {
      const logCh = channel("apm:winston:log");
      if (logger.Logger.prototype.configure) {
        shimmer.wrap(logger.Logger.prototype, "configure", (configure) => wrapMethod(configure, logCh));
      }
      shimmer.wrap(logger.Logger.prototype, "add", (configure) => wrapMethod(configure, logCh));
      return logger;
    });
    function wrapMethod(method, logCh) {
      return function methodWithTrace() {
        const result = method.apply(this, arguments);
        if (logCh.hasSubscribers) {
          for (const name in this.transports) {
            const transport = this.transports[name];
            if (patched.has(transport) || typeof transport.log !== "function") continue;
            shimmer.wrap(transport, "log", (log) => function wrappedLog(level, msg, meta, callback) {
              const payload = { message: meta || {} };
              logCh.publish(payload);
              arguments[2] = payload.message;
              log.apply(this, arguments);
            });
            patched.add(transport);
          }
        }
        return result;
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/ws.js
var require_ws = __commonJS({
  "../../packages/datadog-instrumentations/src/ws.js"() {
    "use strict";
    var {
      addHook,
      channel
    } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var tracingChannel = require_dc_polyfill().tracingChannel;
    var serverCh = tracingChannel("ws:server:connect");
    var producerCh = tracingChannel("ws:send");
    var receiverCh = tracingChannel("ws:receive");
    var closeCh = tracingChannel("ws:close");
    var emitCh = channel("tracing:ws:server:connect:emit");
    function wrapHandleUpgrade(handleUpgrade) {
      return function() {
        const [req, socket, , cb] = arguments;
        if (!serverCh.start.hasSubscribers || typeof cb !== "function") {
          return handleUpgrade.apply(this, arguments);
        }
        const ctx = { req, socket };
        arguments[3] = function() {
          return serverCh.asyncStart.runStores(ctx, () => {
            try {
              return cb.apply(this, arguments);
            } finally {
              serverCh.asyncEnd.publish(ctx);
            }
          }, this, ...arguments);
        };
        return serverCh.traceSync(handleUpgrade, ctx, this, ...arguments);
      };
    }
    function wrapSend(send) {
      return function wrappedSend(...args) {
        if (!producerCh.start.hasSubscribers) return send.apply(this, arguments);
        const [data, options, cb] = arguments;
        const ctx = { data, socket: this._sender?._socket };
        return typeof cb === "function" ? producerCh.traceCallback(send, void 0, ctx, this, data, options, cb) : producerCh.traceSync(send, ctx, this, data, options, cb);
      };
    }
    function createWrapEmit(emit) {
      return function(title, headers, req) {
        if (!serverCh.start.hasSubscribers || title !== "headers") return emit.apply(this, arguments);
        const ctx = { req };
        ctx.req.resStatus = headers[0].split(" ")[1];
        emitCh.runStores(ctx, () => {
          try {
            return emit.apply(this, arguments);
          } finally {
            emitCh.publish(ctx);
          }
        });
      };
    }
    function createWrappedHandler(handler) {
      return function wrappedMessageHandler(data, binary) {
        const byteLength = dataLength(data);
        const ctx = { data, binary, socket: this._sender?._socket, byteLength };
        return receiverCh.traceSync(handler, ctx, this, data, binary);
      };
    }
    function wrapListener(originalOn) {
      return function(eventName, handler) {
        if (eventName === "message") {
          return originalOn.call(this, eventName, createWrappedHandler(handler));
        }
        return originalOn.apply(this, arguments);
      };
    }
    function wrapClose(close) {
      return function(code, data) {
        const isPeerClose = this._closeFrameReceived === true && this._closeFrameSent === false;
        const ctx = { code, data, socket: this._sender?._socket, isPeerClose };
        return closeCh.traceSync(close, ctx, this, ...arguments);
      };
    }
    addHook({
      name: "ws",
      file: "lib/websocket-server.js",
      versions: [">=8.0.0"]
    }, (ws) => {
      shimmer.wrap(ws.prototype, "handleUpgrade", wrapHandleUpgrade);
      shimmer.wrap(ws.prototype, "emit", createWrapEmit);
      return ws;
    });
    addHook({
      name: "ws",
      file: "lib/websocket.js",
      versions: [">=8.0.0"]
    }, (ws) => {
      shimmer.wrap(ws.prototype, "send", wrapSend);
      shimmer.wrap(ws.prototype, "on", wrapListener);
      shimmer.wrap(ws.prototype, "close", wrapClose);
      return ws;
    });
    function detectType(data) {
      if (typeof Blob !== "undefined" && data instanceof Blob) return "Blob";
      if (typeof Buffer !== "undefined" && Buffer.isBuffer(data)) return "Buffer";
      if (typeof data === "string") return "string";
      return "Unknown";
    }
    function dataLength(data) {
      const type = detectType(data);
      if (type === "Blob") return data.size;
      if (type === "Buffer") return data.length;
      if (type === "string") return Buffer.byteLength(data);
      return 0;
    }
  }
});

// ../../packages/datadog-instrumentations/src/helpers/hooks.js
var require_hooks = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/hooks.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "@anthropic-ai/sdk": { esmFirst: true, fn: () => require_anthropic() },
      "@apollo/server": () => require_apollo_server(),
      "@apollo/gateway": () => require_apollo(),
      "apollo-server-core": () => require_apollo_server_core(),
      "@aws-sdk/smithy-client": () => require_aws_sdk(),
      "@azure/event-hubs": () => require_azure_event_hubs(),
      "@azure/functions": () => require_azure_functions(),
      "@azure/service-bus": () => require_azure_service_bus(),
      "@cucumber/cucumber": () => require_cucumber(),
      "@playwright/test": () => require_playwright(),
      "@elastic/elasticsearch": () => require_elasticsearch(),
      "@elastic/transport": () => require_elasticsearch(),
      "@google-cloud/pubsub": () => require_google_cloud_pubsub(),
      "@google-cloud/vertexai": () => require_google_cloud_vertexai(),
      "@graphql-tools/executor": () => require_graphql(),
      "@grpc/grpc-js": () => require_grpc(),
      "@hapi/hapi": () => require_hapi(),
      "@happy-dom/jest-environment": () => require_jest(),
      "@jest/core": () => require_jest(),
      "@jest/reporters": () => require_jest(),
      "@jest/test-sequencer": () => require_jest(),
      "@jest/transform": () => require_jest(),
      "@koa/router": () => require_koa(),
      "@langchain/core": { esmFirst: true, fn: () => require_langchain() },
      "@node-redis/client": () => require_redis(),
      "@opensearch-project/opensearch": () => require_opensearch(),
      "@opentelemetry/sdk-trace-node": () => require_otel_sdk_trace(),
      "@prisma/client": () => require_prisma(),
      "@redis/client": () => require_redis(),
      "@smithy/smithy-client": () => require_aws_sdk(),
      "@vitest/runner": { esmFirst: true, fn: () => require_vitest() },
      aerospike: () => require_aerospike(),
      ai: () => require_ai(),
      amqp10: () => require_amqp10(),
      amqplib: () => require_amqplib(),
      avsc: () => require_avsc(),
      "aws-sdk": () => require_aws_sdk(),
      bluebird: () => require_bluebird(),
      "body-parser": () => require_body_parser(),
      bunyan: () => require_bunyan(),
      "cassandra-driver": () => require_cassandra_driver(),
      child_process: () => require_child_process(),
      connect: () => require_connect(),
      cookie: () => require_cookie(),
      "cookie-parser": () => require_cookie_parser(),
      couchbase: () => require_couchbase(),
      crypto: () => require_crypto(),
      cypress: () => require_cypress(),
      "dd-trace-api": () => require_dd_trace_api(),
      dns: () => require_dns(),
      elasticsearch: () => require_elasticsearch(),
      express: () => require_express(),
      "express-mongo-sanitize": () => require_express_mongo_sanitize(),
      "express-session": () => require_express_session(),
      fastify: () => require_fastify(),
      "find-my-way": () => require_find_my_way(),
      fs: { serverless: false, fn: () => require_fs() },
      "generic-pool": () => require_generic_pool(),
      graphql: () => require_graphql(),
      grpc: () => require_grpc(),
      handlebars: () => require_handlebars(),
      hapi: () => require_hapi(),
      hono: { esmFirst: true, fn: () => require_hono() },
      http: () => require_http2(),
      http2: () => require_http22(),
      https: () => require_http2(),
      ioredis: () => require_ioredis(),
      iovalkey: () => require_iovalkey(),
      "jest-circus": () => require_jest(),
      "jest-config": () => require_jest(),
      "jest-environment-node": () => require_jest(),
      "jest-environment-jsdom": () => require_jest(),
      "jest-runtime": () => require_jest(),
      "jest-worker": () => require_jest(),
      knex: () => require_knex(),
      koa: () => require_koa(),
      "koa-router": () => require_koa(),
      "@confluentinc/kafka-javascript": () => require_confluentinc_kafka_javascript(),
      kafkajs: () => require_kafkajs(),
      langchain: () => require_langchain(),
      ldapjs: () => require_ldapjs(),
      "limitd-client": () => require_limitd_client(),
      lodash: () => require_lodash(),
      mariadb: () => require_mariadb(),
      memcached: () => require_memcached(),
      "microgateway-core": () => require_microgateway_core(),
      mocha: () => require_mocha(),
      "mocha-each": () => require_mocha(),
      moleculer: () => require_moleculer(),
      mongodb: () => require_mongodb(),
      "mongodb-core": () => require_mongodb_core(),
      mongoose: () => require_mongoose(),
      mquery: () => require_mquery(),
      multer: () => require_multer(),
      mysql: () => require_mysql(),
      mysql2: () => require_mysql2(),
      net: () => require_net(),
      next: () => require_next(),
      "node-serialize": () => require_node_serialize(),
      "node:child_process": () => require_child_process(),
      "node:crypto": () => require_crypto(),
      "node:dns": () => require_dns(),
      "node:http": () => require_http2(),
      "node:http2": () => require_http22(),
      "node:https": () => require_http2(),
      "node:net": () => require_net(),
      "node:url": () => require_url3(),
      "node:vm": () => require_vm(),
      nyc: () => require_nyc(),
      oracledb: () => require_oracledb(),
      openai: { esmFirst: true, fn: () => require_openai() },
      passport: () => require_passport(),
      "passport-http": () => require_passport_http(),
      "passport-local": () => require_passport_local(),
      pg: () => require_pg(),
      pino: () => require_pino(),
      "pino-pretty": () => require_pino(),
      playwright: () => require_playwright(),
      "playwright-core": () => require_playwright(),
      "promise-js": () => require_promise_js(),
      promise: () => require_promise3(),
      protobufjs: () => require_protobufjs(),
      pug: () => require_pug(),
      q: () => require_q(),
      redis: () => require_redis(),
      restify: () => require_restify(),
      rhea: () => require_rhea(),
      router: () => require_router(),
      "selenium-webdriver": () => require_selenium(),
      sequelize: () => require_sequelize(),
      sharedb: () => require_sharedb(),
      tedious: () => require_tedious(),
      tinypool: { esmFirst: true, fn: () => require_vitest() },
      undici: () => require_undici(),
      url: () => require_url3(),
      vitest: { esmFirst: true, fn: () => require_vitest() },
      vm: () => require_vm(),
      when: () => require_when(),
      winston: () => require_winston(),
      workerpool: () => require_mocha(),
      ws: () => require_ws()
    };
  }
});

// ../../packages/datadog-instrumentations/src/helpers/check-require-cache.js
var require_check_require_cache = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/check-require-cache.js"(exports2, module2) {
    "use strict";
    var warnings = [];
    var potentialConflicts = /* @__PURE__ */ new Set([
      "@appsignal/javascript",
      "@appsignal/nodejs",
      "@dynatrace/oneagent",
      "@instana/aws-fargate",
      "@instana/aws-lambda",
      "@instana/azure-container-services",
      "@instana/collector",
      "@instana/google-cloud-run",
      "@sentry/node",
      "appoptics-apm",
      "atatus-nodejs",
      "elastic-apm-node",
      "newrelic",
      "stackify-node-apm",
      "sqreen"
    ]);
    var extractPackageAndModulePath = require_extract_package_and_module_path();
    module2.exports.checkForRequiredModules = function() {
      const packages = require_hooks();
      const naughties = /* @__PURE__ */ new Set();
      let didWarn = false;
      for (const pathToModule of Object.keys(__require.cache)) {
        const { pkg } = extractPackageAndModulePath(pathToModule);
        if (naughties.has(pkg)) continue;
        if (!(pkg in packages)) continue;
        warnings.push(() => `Warning: Package '${pkg}' was loaded before dd-trace! This may break instrumentation.`);
        naughties.add(pkg);
        didWarn = true;
      }
      if (didWarn) warnings.push("Warning: Please ensure dd-trace is loaded before other modules.");
    };
    module2.exports.checkForPotentialConflicts = function() {
      const naughties = /* @__PURE__ */ new Set();
      let didWarn = false;
      for (const pathToModule of Object.keys(__require.cache)) {
        const { pkg } = extractPackageAndModulePath(pathToModule);
        if (naughties.has(pkg)) continue;
        if (!potentialConflicts.has(pkg)) continue;
        warnings.push(() => `Warning: Package '${pkg}' may cause conflicts with dd-trace.`);
        naughties.add(pkg);
        didWarn = true;
      }
      if (didWarn) warnings.push("Warning: Packages were loaded that may conflict with dd-trace.");
    };
    module2.exports.flushStartupLogs = function(log) {
      while (warnings.length) {
        log.warn(warnings.shift());
      }
    };
  }
});

// ../../node_modules/@datadog/libdatadog/load.js
var require_load = __commonJS({
  "../../node_modules/@datadog/libdatadog/load.js"(exports2, module2) {
    "use strict";
    var { existsSync, readdirSync } = __require("fs");
    var os = __require("os");
    var path = __require("path");
    var PLATFORM = os.platform();
    var ARCH = process.arch;
    var LIBC = PLATFORM === "linux" ? existsSync("/etc/alpine-release") ? "musl" : "glibc" : "";
    var ABI = process.versions.modules;
    var inWebpack = typeof __webpack_require__ === "function";
    var runtimeRequire = inWebpack ? __non_webpack_require__ : __require;
    function maybeLoad(name) {
      try {
        return load(name);
      } catch (e) {
      }
    }
    function load(name) {
      const filename = find(name);
      const filenameWASM = findWASM(name);
      if (filename) {
        return runtimeRequire(filename);
      } else if (filenameWASM) {
        return runtimeRequire(filenameWASM);
      }
      throw new Error(`Could not find a ${name} binary for ${PLATFORM}${LIBC}-${ARCH} nor a ${name} WASM module.`);
    }
    function findWASM(name) {
      const root = __dirname;
      const prebuilds = path.join(root, "prebuilds");
      const folders = readdirSync(prebuilds);
      if (folders.find((f) => f === name)) {
        return path.join(prebuilds, name, `${name.replaceAll("-", "_")}.js`);
      }
    }
    function find(name, binary = false) {
      const root = __dirname;
      const filename = binary ? name : `${name}.node`;
      const build = `${root}/build/Release/${filename}`;
      if (existsSync(build)) return build;
      const folder = findFolder(root);
      if (!folder) return;
      const prebuildFolder = path.join(root, "prebuilds", folder);
      const file = findFile(prebuildFolder, name, binary);
      if (!file) return;
      return path.join(prebuildFolder, file);
    }
    function findFolder(root) {
      try {
        const prebuilds = path.join(root, "prebuilds");
        const folders = readdirSync(prebuilds);
        return folders.find((f) => f === `${PLATFORM}${LIBC}-${ARCH}`) || folders.find((f) => f === `${PLATFORM}-${ARCH}`);
      } catch (e) {
        return null;
      }
    }
    function findFile(root, name, binary = false) {
      const files = readdirSync(root);
      if (binary) return files.find((f) => f === name);
      return files.find((f) => f === `${name}-${ABI}.node`) || files.find((f) => f === `${name}-napi.node`) || files.find((f) => f === `${name}.node`);
    }
    module2.exports = { find, load, maybeLoad };
  }
});

// ../../node_modules/@datadog/libdatadog/index.js
var require_libdatadog = __commonJS({
  "../../node_modules/@datadog/libdatadog/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_load();
  }
});

// ../../packages/dd-trace/src/tracer_metadata.js
var require_tracer_metadata = __commonJS({
  "../../packages/dd-trace/src/tracer_metadata.js"(exports2, module2) {
    "use strict";
    var libdatadog = require_libdatadog();
    var tracerVersion = require_version2().VERSION;
    function storeConfig(config) {
      const processDiscovery = libdatadog.maybeLoad("process-discovery");
      if (processDiscovery === void 0) {
        return;
      }
      const metadata = new processDiscovery.TracerMetadata(
        config.tags["runtime-id"],
        tracerVersion,
        config.hostname,
        config.service || null,
        config.env || null,
        config.version || null
      );
      return processDiscovery.storeMetadata(metadata);
    }
    module2.exports = storeConfig;
  }
});

// ../../packages/dd-trace/src/tracer.js
var require_tracer4 = __commonJS({
  "../../packages/dd-trace/src/tracer.js"(exports2, module2) {
    "use strict";
    var Tracer = require_tracer3();
    var tags = require_tags();
    var Scope = require_scope2();
    var { isError } = require_util();
    var { setStartupLogConfig } = require_startup_log();
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants3();
    var { DataStreamsCheckpointer, DataStreamsManager, DataStreamsProcessor } = require_datastreams();
    var { flushStartupLogs } = require_check_require_cache();
    var log = require_writer();
    var SPAN_TYPE = tags.SPAN_TYPE;
    var RESOURCE_NAME = tags.RESOURCE_NAME;
    var SERVICE_NAME = tags.SERVICE_NAME;
    var MEASURED = tags.MEASURED;
    var DatadogTracer = class extends Tracer {
      constructor(config, prioritySampler) {
        super(config, prioritySampler);
        this._dataStreamsProcessor = new DataStreamsProcessor(config);
        this._dataStreamsManager = new DataStreamsManager(this._dataStreamsProcessor);
        this.dataStreamsCheckpointer = new DataStreamsCheckpointer(this);
        this._scope = new Scope();
        setStartupLogConfig(config);
        flushStartupLogs(log);
        if (!config._isInServerlessEnvironment()) {
          const storeConfig = require_tracer_metadata();
          const metadata = storeConfig(config);
          if (metadata === void 0) {
            log.warn("Could not store tracer configuration for service discovery");
          }
          this._inmem_cfg = metadata;
        }
      }
      configure(config) {
        const { env, sampler } = config;
        this._prioritySampler.configure(env, sampler, config);
      }
      // todo[piochelepiotr] These two methods are not related to the tracer, but to data streams monitoring.
      // They should be moved outside of the tracer in the future.
      setCheckpoint(edgeTags, span, payloadSize = 0) {
        return this._dataStreamsManager.setCheckpoint(edgeTags, span, payloadSize);
      }
      decodeDataStreamsContext(carrier) {
        return this._dataStreamsManager.decodeDataStreamsContext(carrier);
      }
      setOffset(offsetData) {
        return this._dataStreamsProcessor.setOffset(offsetData);
      }
      trace(name, options, fn) {
        options = { childOf: this.scope().active(), ...options };
        const span = this.startSpan(name, options);
        addTags(span, options);
        try {
          if (fn.length > 1) {
            return this.scope().activate(span, () => fn(span, (err) => {
              addError(span, err);
              span.finish();
            }));
          }
          const result = this.scope().activate(span, () => fn(span));
          if (result && typeof result.then === "function") {
            return result.then(
              (value) => {
                span.finish();
                return value;
              },
              (err) => {
                addError(span, err);
                span.finish();
                throw err;
              }
            );
          }
          span.finish();
          return result;
        } catch (e) {
          addError(span, e);
          span.finish();
          throw e;
        }
      }
      wrap(name, options, fn) {
        const tracer2 = this;
        return function() {
          let optionsObj = options;
          if (typeof optionsObj === "function" && typeof fn === "function") {
            optionsObj = optionsObj.apply(this, arguments);
          }
          const lastArgId = arguments.length - 1;
          const cb = arguments[lastArgId];
          if (typeof cb === "function") {
            const scopeBoundCb = tracer2.scope().bind(cb);
            return tracer2.trace(name, optionsObj, (span, done) => {
              arguments[lastArgId] = function(err) {
                done(err);
                return scopeBoundCb.apply(this, arguments);
              };
              return fn.apply(this, arguments);
            });
          }
          return tracer2.trace(name, optionsObj, () => fn.apply(this, arguments));
        };
      }
      setUrl(url) {
        this._exporter.setUrl(url);
        this._dataStreamsProcessor.setUrl(url);
      }
      scope() {
        return this._scope;
      }
      getRumData() {
        if (!this._enableGetRumData) {
          return "";
        }
        const span = this.scope().active().context();
        const traceId = span.toTraceId();
        const traceTime = Date.now();
        return `<meta name="dd-trace-id" content="${traceId}" /><meta name="dd-trace-time" content="${traceTime}" />`;
      }
    };
    function addError(span, error) {
      if (isError(error)) {
        span.addTags({
          [ERROR_TYPE]: error.name,
          [ERROR_MESSAGE]: error.message,
          [ERROR_STACK]: error.stack
        });
      }
    }
    function addTags(span, options) {
      const tags2 = {};
      if (options.type) tags2[SPAN_TYPE] = options.type;
      if (options.service) tags2[SERVICE_NAME] = options.service;
      if (options.resource) tags2[RESOURCE_NAME] = options.resource;
      tags2[MEASURED] = options.measured;
      span.addTags(tags2);
    }
    module2.exports = DatadogTracer;
  }
});

// ../../node_modules/crypto-randomuuid/validators.js
var require_validators2 = __commonJS({
  "../../node_modules/crypto-randomuuid/validators.js"(exports2, module2) {
    "use strict";
    var assert = __require("assert");
    var util = __require("util");
    var kTypes = [
      "string",
      "function",
      "number",
      "object",
      // Accept 'Function' and 'Object' as alternative to the lower cased version.
      "Function",
      "Object",
      "boolean",
      "bigint",
      "symbol"
    ];
    var ERR_OPERATION_FAILED = class extends TypeError {
      constructor(message) {
        super(`Operation failed: ${message}`);
        this.code = this.constructor.name;
        Object.defineProperties(this, {
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
    var ERR_INVALID_ARG_TYPE = class extends TypeError {
      constructor(name, expected, actual) {
        super();
        assert(typeof name === "string", "'name' must be a string");
        if (!Array.isArray(expected)) {
          expected = [expected];
        }
        let msg = "The ";
        if (name.endsWith(" argument")) {
          msg += `${name} `;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          msg += `"${name}" ${type} `;
        }
        msg += "must be ";
        const types = [];
        const instances = [];
        const other = [];
        for (const value of expected) {
          assert(
            typeof value === "string",
            "All expected entries have to be of type string"
          );
          if (kTypes.includes(value)) {
            types.push(value.toLowerCase());
          } else if (classRegExp.test(value)) {
            instances.push(value);
          } else {
            assert(
              value !== "object",
              'The value "object" should be written as "Object"'
            );
            other.push(value);
          }
        }
        if (instances.length > 0) {
          const pos = types.indexOf("object");
          if (pos !== -1) {
            types.splice(pos, 1);
            instances.push("Object");
          }
        }
        if (types.length > 0) {
          if (types.length > 2) {
            const last = types.pop();
            msg += `one of type ${types.join(", ")}, or ${last}`;
          } else if (types.length === 2) {
            msg += `one of type ${types[0]} or ${types[1]}`;
          } else {
            msg += `of type ${types[0]}`;
          }
          if (instances.length > 0 || other.length > 0)
            msg += " or ";
        }
        if (instances.length > 0) {
          if (instances.length > 2) {
            const last = instances.pop();
            msg += `an instance of ${instances.join(", ")}, or ${last}`;
          } else {
            msg += `an instance of ${instances[0]}`;
            if (instances.length === 2) {
              msg += ` or ${instances[1]}`;
            }
          }
          if (other.length > 0)
            msg += " or ";
        }
        if (other.length > 0) {
          if (other.length > 2) {
            const last = other.pop();
            msg += `one of ${other.join(", ")}, or ${last}`;
          } else if (other.length === 2) {
            msg += `one of ${other[0]} or ${other[1]}`;
          } else {
            if (other[0].toLowerCase() !== other[0])
              msg += "an ";
            msg += `${other[0]}`;
          }
        }
        if (actual == null) {
          msg += `. Received ${actual}`;
        } else if (typeof actual === "function" && actual.name) {
          msg += `. Received function ${actual.name}`;
        } else if (typeof actual === "object") {
          if (actual.constructor && actual.constructor.name) {
            msg += `. Received an instance of ${actual.constructor.name}`;
          } else {
            const inspected = util.inspect(actual, { depth: -1 });
            msg += `. Received ${inspected}`;
          }
        } else {
          let inspected = util.inspect(actual, { colors: false });
          if (inspected.length > 25) {
            inspected = `${inspected.slice(0, 25)}...`;
          }
          msg += `. Received type ${typeof actual} (${inspected})`;
        }
        this.code = this.constructor.name;
        Object.defineProperties(this, {
          message: {
            value: msg,
            enumerable: false,
            writable: true,
            configurable: true
          },
          toString: {
            value() {
              return `${this.name} [${this.code}]: ${this.message}`;
            },
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
    function validateBoolean(value, name) {
      if (typeof value !== "boolean")
        throw new ERR_INVALID_ARG_TYPE(name, "boolean", value);
    }
    function validateObject(value, name, {
      nullable = false,
      allowArray = false,
      allowFunction = false
    } = {}) {
      if (!nullable && value === null || !allowArray && Array.isArray(value) || typeof value !== "object" && (!allowFunction || typeof value !== "function")) {
        throw new ERR_INVALID_ARG_TYPE(name, "Object", value);
      }
    }
    module2.exports = {
      validateBoolean,
      validateObject,
      codes: {
        ERR_OPERATION_FAILED
      }
    };
  }
});

// ../../node_modules/crypto-randomuuid/polyfill.js
var require_polyfill = __commonJS({
  "../../node_modules/crypto-randomuuid/polyfill.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var {
      validateBoolean,
      validateObject,
      codes: {
        ERR_OPERATION_FAILED
      }
    } = require_validators2();
    var { randomFillSync } = crypto;
    function secureBuffer(size) {
      const buf = Buffer.alloc(size);
      return randomFillSync(buf);
    }
    var kBatchSize = 128;
    var uuidData;
    var uuidNotBuffered;
    var uuidBatch = 0;
    var hexBytesCache;
    function getHexBytes() {
      if (hexBytesCache === void 0) {
        hexBytesCache = new Array(256);
        for (let i = 0; i < hexBytesCache.length; i++) {
          const hex = i.toString(16);
          hexBytesCache[i] = hex.padStart(2, "0");
        }
      }
      return hexBytesCache;
    }
    function serializeUUID(buf, offset = 0) {
      const kHexBytes = getHexBytes();
      return kHexBytes[buf[offset]] + kHexBytes[buf[offset + 1]] + kHexBytes[buf[offset + 2]] + kHexBytes[buf[offset + 3]] + "-" + kHexBytes[buf[offset + 4]] + kHexBytes[buf[offset + 5]] + "-" + kHexBytes[buf[offset + 6] & 15 | 64] + kHexBytes[buf[offset + 7]] + "-" + kHexBytes[buf[offset + 8] & 63 | 128] + kHexBytes[buf[offset + 9]] + "-" + kHexBytes[buf[offset + 10]] + kHexBytes[buf[offset + 11]] + kHexBytes[buf[offset + 12]] + kHexBytes[buf[offset + 13]] + kHexBytes[buf[offset + 14]] + kHexBytes[buf[offset + 15]];
    }
    function getBufferedUUID() {
      if (!uuidData) uuidData = secureBuffer(16 * kBatchSize);
      if (uuidData === void 0)
        throw new ERR_OPERATION_FAILED("Out of memory");
      if (uuidBatch === 0) randomFillSync(uuidData);
      uuidBatch = (uuidBatch + 1) % kBatchSize;
      return serializeUUID(uuidData, uuidBatch * 16);
    }
    function getUnbufferedUUID() {
      if (!uuidNotBuffered) uuidNotBuffered = secureBuffer(16 * kBatchSize);
      if (uuidNotBuffered === void 0)
        throw new ERR_OPERATION_FAILED("Out of memory");
      randomFillSync(uuidNotBuffered);
      return serializeUUID(uuidNotBuffered);
    }
    function randomUUID(options) {
      if (options !== void 0)
        validateObject(options, "options");
      const {
        disableEntropyCache = false
      } = options || {};
      validateBoolean(disableEntropyCache, "options.disableEntropyCache");
      return disableEntropyCache ? getUnbufferedUUID() : getBufferedUUID();
    }
    module2.exports = randomUUID;
  }
});

// ../../node_modules/crypto-randomuuid/index.js
var require_crypto_randomuuid = __commonJS({
  "../../node_modules/crypto-randomuuid/index.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    module2.exports = typeof crypto.randomUUID === "function" ? crypto.randomUUID : require_polyfill();
  }
});

// ../../packages/datadog-core/src/utils/src/set.js
var require_set2 = __commonJS({
  "../../packages/datadog-core/src/utils/src/set.js"(exports2, module2) {
    "use strict";
    module2.exports = function set2(object, path, value) {
      let index = -1;
      while (true) {
        const nextIndex = path.indexOf(".", index + 1);
        if (nextIndex === -1) {
          if (index === -1) {
            object[path] = value;
          } else {
            object[path.slice(index + 1)] = value;
          }
          return;
        }
        object = object[path.slice(index + 1, nextIndex)] ??= {};
        index = nextIndex;
      }
    };
  }
});

// ../../packages/dd-trace/src/git_properties.js
var require_git_properties = __commonJS({
  "../../packages/dd-trace/src/git_properties.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var path = __require("path");
    var gitPropertiesCommitSHARegex = /git\.commit\.sha=([a-f\d]{40})/;
    var gitPropertiesRepositoryUrlRegex = /git\.repository_url=([\w\d:@/.-]+)/;
    var repositoryUrlRegex = /^([\w\d:@/.-]+)$/;
    var remoteOriginRegex = /^\[remote\s+"origin"\]/i;
    var gitHeadRefRegex = /ref:\s+(refs\/[A-Za-z0-9._/-]+)/;
    var commitSHARegex = /^[0-9a-f]{40}$/;
    function removeUserSensitiveInfo(repositoryUrl) {
      try {
        const parsedUrl = new URL(repositoryUrl);
        if (parsedUrl.username || parsedUrl.password) {
          return `${parsedUrl.origin}${parsedUrl.pathname}`;
        }
        return repositoryUrl;
      } catch {
        return repositoryUrl;
      }
    }
    function getGitMetadataFromGitProperties(gitPropertiesString) {
      if (!gitPropertiesString) {
        return {};
      }
      const commitSHAMatch = gitPropertiesString.match(gitPropertiesCommitSHARegex);
      const repositoryUrlMatch = gitPropertiesString.match(gitPropertiesRepositoryUrlRegex);
      const repositoryUrl = repositoryUrlMatch ? repositoryUrlMatch[1] : void 0;
      return {
        commitSHA: commitSHAMatch ? commitSHAMatch[1] : void 0,
        repositoryUrl: removeUserSensitiveInfo(repositoryUrl)
      };
    }
    function getRemoteOriginURL(gitConfigContent) {
      if (!gitConfigContent) {
        return;
      }
      const lines = gitConfigContent.split("\n");
      let index = 0;
      for (; index < lines.length; index++) {
        const line = lines[index];
        if (line[0] !== "[") continue;
        if (remoteOriginRegex.test(line)) break;
      }
      index++;
      for (; index < lines.length; index++) {
        const line = lines[index];
        if (line[0] === "[") return;
        const splitAt = line.indexOf("=");
        if (splitAt === -1) continue;
        const key = line.slice(0, splitAt).trim().toLowerCase();
        if (key !== "url") continue;
        const repositoryUrlValue = line.slice(splitAt + 1).trim();
        const repositoryUrlMatch = repositoryUrlValue.match(repositoryUrlRegex);
        if (!repositoryUrlMatch) continue;
        return removeUserSensitiveInfo(repositoryUrlMatch[0]);
      }
    }
    function getGitHeadRef(gitHeadContent) {
      if (!gitHeadContent) {
        return;
      }
      const gitRefMatch = gitHeadContent.match(gitHeadRefRegex);
      return gitRefMatch?.[1];
    }
    function resolveGitHeadSHA(DD_GIT_FOLDER_PATH) {
      const gitHeadPath = path.join(DD_GIT_FOLDER_PATH, "HEAD");
      try {
        const gitHeadContent = fs.readFileSync(gitHeadPath, "utf8");
        if (!gitHeadContent) {
          return;
        }
        const headContent = gitHeadContent.trim();
        if (commitSHARegex.test(headContent)) {
          return headContent;
        }
        const gitHeadRef = getGitHeadRef(headContent);
        if (!gitHeadRef) {
          return;
        }
        const gitHeadRefPath = path.join(DD_GIT_FOLDER_PATH, gitHeadRef);
        const gitHeadRefContent = fs.readFileSync(gitHeadRefPath, "utf8");
        if (gitHeadRefContent) {
          const headRefContent = gitHeadRefContent.trim();
          if (commitSHARegex.test(headRefContent)) {
            return headRefContent;
          }
        }
      } catch {
      }
    }
    module2.exports = {
      getGitMetadataFromGitProperties,
      removeUserSensitiveInfo,
      getGitHeadRef,
      getRemoteOriginURL,
      resolveGitHeadSHA
    };
  }
});

// ../../node_modules/module-details-from-path/index.js
var require_module_details_from_path = __commonJS({
  "../../node_modules/module-details-from-path/index.js"(exports2, module2) {
    "use strict";
    var sep = __require("path").sep;
    module2.exports = function(file) {
      var segments = file.split(sep);
      var index = segments.lastIndexOf("node_modules");
      if (index === -1) return;
      if (!segments[index + 1]) return;
      var scoped = segments[index + 1][0] === "@";
      var name = scoped ? segments[index + 1] + "/" + segments[index + 2] : segments[index + 1];
      var offset = scoped ? 3 : 2;
      var basedir = "";
      var lastBaseDirSegmentIndex = index + offset - 1;
      for (var i = 0; i <= lastBaseDirSegmentIndex; i++) {
        if (i === lastBaseDirSegmentIndex) {
          basedir += segments[i];
        } else {
          basedir += segments[i] + sep;
        }
      }
      var path = "";
      var lastSegmentIndex = segments.length - 1;
      for (var i2 = index + offset; i2 <= lastSegmentIndex; i2++) {
        if (i2 === lastSegmentIndex) {
          path += segments[i2];
        } else {
          path += segments[i2] + sep;
        }
      }
      return {
        name,
        basedir,
        path
      };
    };
  }
});

// ../../packages/dd-trace/src/require-package-json.js
var require_require_package_json = __commonJS({
  "../../packages/dd-trace/src/require-package-json.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    function requirePackageJson(name, module3) {
      if (path.isAbsolute(name)) {
        const candidate = path.join(name, "package.json");
        return JSON.parse(fs.readFileSync(candidate, "utf8"));
      }
      for (const modulePath of module3.paths) {
        const candidate = path.join(modulePath, name, "package.json");
        try {
          return JSON.parse(fs.readFileSync(candidate, "utf8"));
        } catch {
          continue;
        }
      }
      throw new Error(`could not find ${name}/package.json`);
    }
    module2.exports = requirePackageJson;
  }
});

// ../../packages/dd-trace/src/telemetry/dependencies.js
var require_dependencies = __commonJS({
  "../../packages/dd-trace/src/telemetry/dependencies.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var parse = require_module_details_from_path();
    var requirePackageJson = require_require_package_json();
    var { sendData } = require_send_data();
    var dc = require_dc_polyfill();
    var { fileURLToPath } = __require("url");
    var { isTrue } = require_util();
    var savedDependenciesToSend = /* @__PURE__ */ new Set();
    var detectedDependencyKeys = /* @__PURE__ */ new Set();
    var detectedDependencyVersions = /* @__PURE__ */ new Set();
    var FILE_URI_START = "file://";
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var config;
    var application;
    var host;
    var initialLoad;
    var isFirstModule = true;
    var getRetryData;
    var updateRetryData;
    function waitAndSend(config2, application2, host2) {
      setImmediate(() => {
        if (savedDependenciesToSend.size === 0) {
          return;
        }
        const dependencies = [];
        let send = 0;
        for (const dependency of savedDependenciesToSend) {
          const [name, version, initialLoadModule] = dependency.split(" ");
          const sendModule = isTrue(initialLoadModule) || config2.telemetry?.dependencyCollection;
          savedDependenciesToSend.delete(dependency);
          if (sendModule) {
            dependencies.push({ name, version });
            send++;
            if (send === 2e3) {
              break;
            }
          }
        }
        let payload = { dependencies };
        let reqType = "app-dependencies-loaded";
        const retryData = getRetryData();
        if (retryData) {
          payload = [{
            request_type: "app-dependencies-loaded",
            payload
          }, {
            request_type: retryData.reqType,
            payload: retryData.payload
          }];
          reqType = "message-batch";
        } else if (!dependencies.length) {
          return;
        }
        sendData(config2, application2, host2, reqType, payload, updateRetryData);
        if (savedDependenciesToSend.size > 0) {
          waitAndSend(config2, application2, host2);
        }
      }).unref();
    }
    function loadAllTheLoadedModules() {
      if (__require.cache) {
        const filenames = Object.keys(__require.cache);
        filenames.forEach((filename) => {
          onModuleLoad({ filename });
        });
      }
    }
    function onModuleLoad(data) {
      if (isFirstModule) {
        isFirstModule = false;
        loadAllTheLoadedModules();
      }
      if (data) {
        let filename = data.filename;
        if (filename?.startsWith(FILE_URI_START)) {
          try {
            filename = fileURLToPath(filename);
          } catch {
          }
        }
        const parseResult = filename && parse(filename);
        const request2 = data.request || parseResult?.name;
        const dependencyKey = parseResult?.basedir ?? request2;
        if (filename && request2 && isDependency(request2) && !detectedDependencyKeys.has(dependencyKey)) {
          detectedDependencyKeys.add(dependencyKey);
          if (parseResult) {
            const { name, basedir } = parseResult;
            if (basedir) {
              try {
                const { version } = requirePackageJson(basedir, module2);
                const dependencyAndVersion = `${name} ${version}`;
                if (!detectedDependencyVersions.has(dependencyAndVersion)) {
                  savedDependenciesToSend.add(`${dependencyAndVersion} ${initialLoad}`);
                  detectedDependencyVersions.add(dependencyAndVersion);
                  waitAndSend(config, application, host);
                }
              } catch {
              }
            }
          }
        }
      }
    }
    function start(_config = {}, _application, _host, getRetryDataFunction, updateRetryDatafunction) {
      config = _config;
      application = _application;
      host = _host;
      initialLoad = true;
      getRetryData = getRetryDataFunction;
      updateRetryData = updateRetryDatafunction;
      moduleLoadStartChannel.subscribe(onModuleLoad);
      queueMicrotask(() => {
        initialLoad = false;
      });
    }
    function isDependency(request2) {
      const isDependencyWithSlash = isDependencyWithSeparator(request2, "/");
      if (isDependencyWithSlash && process.platform === "win32") {
        return isDependencyWithSeparator(request2, path.sep);
      }
      return isDependencyWithSlash;
    }
    function isDependencyWithSeparator(request2, sep) {
      return request2.indexOf(`..${sep}`) !== 0 && request2.indexOf(`.${sep}`) !== 0 && request2.indexOf(sep) !== 0 && request2.indexOf(`:${sep}`) !== 1;
    }
    function stop() {
      config = null;
      application = null;
      host = null;
      detectedDependencyKeys.clear();
      savedDependenciesToSend.clear();
      detectedDependencyVersions.clear();
      if (moduleLoadStartChannel.hasSubscribers) {
        moduleLoadStartChannel.unsubscribe(onModuleLoad);
      }
    }
    module2.exports = { start, stop };
  }
});

// ../../packages/dd-trace/src/telemetry/endpoints.js
var require_endpoints = __commonJS({
  "../../packages/dd-trace/src/telemetry/endpoints.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var { sendData } = require_send_data();
    var fastifyRouteCh = dc.channel("apm:fastify:route:added");
    var expressRouteCh = dc.channel("apm:express:route:added");
    var routerRouteCh = dc.channel("apm:router:route:added");
    var config;
    var application;
    var host;
    var getRetryData;
    var updateRetryData;
    var pendingEndpoints = /* @__PURE__ */ new Map();
    var wildcardEndpoints = /* @__PURE__ */ new Set();
    var flushScheduled = false;
    var isFirstPayload = true;
    function endpointKey(method, path) {
      return `${method.toUpperCase()} ${path}`;
    }
    function scheduleFlush() {
      if (flushScheduled) return;
      flushScheduled = true;
      setImmediate(flushAndSend).unref();
    }
    function recordEndpoint(method, path) {
      const key = endpointKey(method, path);
      if (pendingEndpoints.has(key)) return;
      pendingEndpoints.set(key, { method: method.toUpperCase(), path });
      scheduleFlush();
    }
    function onFastifyRoute(routeData) {
      const routeOptions = routeData?.routeOptions;
      if (!routeOptions?.path) return;
      const methods = Array.isArray(routeOptions.method) ? routeOptions.method : [routeOptions.method];
      for (const method of methods) {
        recordEndpoint(method, routeOptions.path);
      }
    }
    function onExpressRoute({ method, path }) {
      if (!method || !path) return;
      if (wildcardEndpoints.has(path)) return;
      recordEndpoint(method, path);
      if (method === "*") {
        wildcardEndpoints.add(path);
        return;
      }
      if (method.toUpperCase() === "GET") {
        recordEndpoint("HEAD", path);
      }
    }
    function buildEndpointObjects(endpoints) {
      return endpoints.map(({ method, path }) => {
        return {
          type: "REST",
          method,
          path,
          operation_name: "http.request",
          resource_name: endpointKey(method, path)
        };
      });
    }
    function flushAndSend() {
      flushScheduled = false;
      if (pendingEndpoints.size === 0) return;
      const batchEndpoints = [];
      for (const [key, endpoint] of pendingEndpoints) {
        batchEndpoints.push(endpoint);
        pendingEndpoints.delete(key);
        if (batchEndpoints.length >= config.appsec?.apiSecurity?.endpointCollectionMessageLimit) break;
      }
      const payloadObj = {
        is_first: isFirstPayload,
        endpoints: buildEndpointObjects(batchEndpoints)
      };
      let reqType = "app-endpoints";
      let payload = payloadObj;
      const retryData = getRetryData();
      if (retryData) {
        payload = [
          { request_type: "app-endpoints", payload: payloadObj },
          { request_type: retryData.reqType, payload: retryData.payload }
        ];
        reqType = "message-batch";
      }
      sendData(config, application, host, reqType, payload, updateRetryData);
      if (isFirstPayload) {
        isFirstPayload = false;
      }
      if (pendingEndpoints.size) scheduleFlush();
    }
    function start(_config = {}, _application, _host, getRetryDataFunction, updateRetryDataFunction) {
      if (!_config?.appsec?.apiSecurity?.endpointCollectionEnabled) return;
      config = _config;
      application = _application;
      host = _host;
      getRetryData = getRetryDataFunction;
      updateRetryData = updateRetryDataFunction;
      fastifyRouteCh.subscribe(onFastifyRoute);
      expressRouteCh.subscribe(onExpressRoute);
      routerRouteCh.subscribe(onExpressRoute);
    }
    function stop() {
      fastifyRouteCh.unsubscribe(onFastifyRoute);
      expressRouteCh.unsubscribe(onExpressRoute);
      routerRouteCh.unsubscribe(onExpressRoute);
      pendingEndpoints.clear();
      flushScheduled = false;
      config = application = host = getRetryData = updateRetryData = null;
    }
    module2.exports = {
      start,
      stop
    };
  }
});

// ../../packages/dd-trace/src/telemetry/logs/log-collector.js
var require_log_collector = __commonJS({
  "../../packages/dd-trace/src/telemetry/logs/log-collector.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { ddBasePath } = require_util();
    var logs = /* @__PURE__ */ new Map();
    var maxEntries = 1e4;
    var overflowedCount = 0;
    function hashCode(hashSource) {
      let hash = 0;
      const size = hashSource.length;
      for (let offset = 0; offset < size; offset++) {
        hash = (hash * 31 | 0) + hashSource.charCodeAt(offset) | 0;
      }
      return hash;
    }
    function createHash(logEntry) {
      const prime = 31;
      let result = logEntry.level ? hashCode(logEntry.level) : 0;
      result = (prime * result | 0) + (logEntry.message ? hashCode(logEntry.message) : 0) | 0;
      result = (prime * result | 0) + (logEntry.stack_trace ? hashCode(logEntry.stack_trace) : 0) | 0;
      return result;
    }
    function isValid(logEntry) {
      return logEntry?.level && logEntry.message;
    }
    var EOL = "\n";
    var STACK_FRAME_LINE_REGEX = /^\s*at\s/gm;
    function sanitize(logEntry) {
      const stack = logEntry.stack_trace;
      if (!stack) return logEntry;
      let stackLines = stack.split(EOL);
      const firstIndex = stackLines.findIndex((l) => l.match(STACK_FRAME_LINE_REGEX));
      stackLines = stackLines.filter((line, index) => index >= firstIndex && line.includes(ddBasePath)).map((line) => line.replace(ddBasePath, ""));
      if (logEntry.errorType && stackLines.length) {
        stackLines = [`${logEntry.errorType}: redacted`, ...stackLines];
      }
      delete logEntry.errorType;
      logEntry.stack_trace = stackLines.join(EOL);
      if (logEntry.stack_trace === "" && (!logEntry.message || logEntry.message === "Generic Error")) {
        return null;
      }
      return logEntry;
    }
    var logCollector = {
      add(logEntry) {
        try {
          if (!isValid(logEntry)) return false;
          if (logs.size >= maxEntries) {
            overflowedCount++;
            return false;
          }
          logEntry = sanitize(logEntry);
          if (!logEntry) {
            return false;
          }
          const hash = createHash(logEntry);
          if (logs.has(hash)) {
            logs.get(hash).count++;
          } else {
            logs.set(hash, logEntry);
            return true;
          }
        } catch (e) {
          log.error("Unable to add log to logCollector: %s", e.message);
        }
        return false;
      },
      // Used for testing
      hasEntry(logEntry) {
        return logs.has(createHash(logEntry));
      },
      drain() {
        if (logs.size === 0) return;
        const drained = [...logs.values()];
        if (overflowedCount > 0) {
          drained.push({
            message: `Omitted ${overflowedCount} entries due to overflowing`,
            level: "ERROR"
          });
        }
        this.reset();
        return drained;
      },
      reset(max) {
        logs.clear();
        overflowedCount = 0;
        if (max) {
          maxEntries = max;
        }
      }
    };
    logCollector.reset();
    module2.exports = logCollector;
  }
});

// ../../packages/dd-trace/src/telemetry/logs/index.js
var require_logs = __commonJS({
  "../../packages/dd-trace/src/telemetry/logs/index.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var logCollector = require_log_collector();
    var { sendData } = require_send_data();
    var telemetryLog = dc.channel("datadog:telemetry:log");
    var errorLog = dc.channel("datadog:log:error");
    var enabled = false;
    function isLevelEnabled(level) {
      return isValidLevel(level);
    }
    function isValidLevel(level) {
      switch (level) {
        case "ERROR":
        case "WARN":
          return true;
        default:
          return false;
      }
    }
    function onLog(log) {
      if (isLevelEnabled(log?.level?.toUpperCase())) {
        logCollector.add(log);
      }
    }
    function onErrorLog(msg) {
      const { message, cause, sendViaTelemetry } = msg;
      if (!sendViaTelemetry || !message && !cause) return;
      const telLog = {
        level: "ERROR",
        count: 1,
        // existing log.error(err) without message will be reported as 'Generic Error'
        message: message ?? "Generic Error"
      };
      if (cause) {
        telLog.stack_trace = cause.stack;
        telLog.errorType = cause.constructor.name;
      }
      onLog(telLog);
    }
    function start(config) {
      if (!config.telemetry.logCollection || enabled) return;
      enabled = true;
      telemetryLog.subscribe(onLog);
      errorLog.subscribe(onErrorLog);
    }
    function stop() {
      enabled = false;
      if (telemetryLog.hasSubscribers) {
        telemetryLog.unsubscribe(onLog);
      }
      errorLog.unsubscribe(onErrorLog);
    }
    function send(config, application, host) {
      if (!enabled) return;
      const logs = logCollector.drain();
      if (logs) {
        sendData(config, application, host, "logs", { logs });
      }
    }
    module2.exports = {
      start,
      stop,
      send
    };
  }
});

// ../../packages/dd-trace/src/telemetry/telemetry.js
var require_telemetry2 = __commonJS({
  "../../packages/dd-trace/src/telemetry/telemetry.js"(exports2, module2) {
    "use strict";
    var tracerVersion = require_package().version;
    var dc = require_dc_polyfill();
    var os = __require("os");
    var dependencies = require_dependencies();
    var endpoints = require_endpoints();
    var { sendData } = require_send_data();
    var { errors } = require_startup_log();
    var { manager: metricsManager } = require_metrics();
    var telemetryLogger = require_logs();
    var logger = require_log2();
    var telemetryStartChannel = dc.channel("datadog:telemetry:start");
    var telemetryStopChannel = dc.channel("datadog:telemetry:stop");
    var telemetryAppClosingChannel = dc.channel("datadog:telemetry:app-closing");
    var config;
    var pluginManager;
    var application;
    var host;
    var heartbeatTimeout;
    var heartbeatInterval;
    var extendedInterval;
    var integrations;
    var configWithOrigin = /* @__PURE__ */ new Map();
    var retryData = null;
    var extendedHeartbeatPayload = {};
    var sentIntegrations = /* @__PURE__ */ new Set();
    var seqId = 0;
    function getRetryData() {
      return retryData;
    }
    function updateRetryData(error, retryObj) {
      if (error) {
        if (retryObj.reqType === "message-batch") {
          const payload = retryObj.payload[0].payload;
          const reqType = retryObj.payload[0].request_type;
          retryData = { payload, reqType };
          const failedPayload = retryObj.payload[1].payload;
          const failedReqType = retryObj.payload[1].request_type;
          if (failedReqType === "app-integrations-change") {
            if (extendedHeartbeatPayload.integrations) {
              extendedHeartbeatPayload.integrations.push(failedPayload);
            } else {
              extendedHeartbeatPayload.integrations = [failedPayload];
            }
          }
          if (failedReqType === "app-dependencies-loaded") {
            if (extendedHeartbeatPayload.dependencies) {
              extendedHeartbeatPayload.dependencies.push(failedPayload);
            } else {
              extendedHeartbeatPayload.dependencies = [failedPayload];
            }
          }
        } else {
          retryData = retryObj;
        }
      } else {
        retryData = null;
      }
    }
    function getIntegrations() {
      const newIntegrations = [];
      for (const pluginName in pluginManager._pluginsByName) {
        if (sentIntegrations.has(pluginName)) {
          continue;
        }
        newIntegrations.push({
          name: pluginName,
          enabled: pluginManager._pluginsByName[pluginName]._enabled,
          auto_enabled: true
        });
        sentIntegrations.add(pluginName);
      }
      return newIntegrations;
    }
    function getProducts(config2) {
      const products = {
        appsec: {
          enabled: config2.appsec.enabled
        },
        profiler: {
          version: tracerVersion,
          enabled: profilingEnabledToBoolean(config2.profiling.enabled)
        }
      };
      if (errors.profilingError) {
        products.profiler.error = errors.profilingError;
        errors.profilingError = {};
      }
      return products;
    }
    function getInstallSignature(config2) {
      const { installSignature: sig } = config2;
      if (sig && (sig.id || sig.time || sig.type)) {
        return {
          install_id: sig.id,
          install_time: sig.time,
          install_type: sig.type
        };
      }
    }
    function appStarted(config2) {
      const app = {
        products: getProducts(config2),
        configuration: [...configWithOrigin.values()]
      };
      const installSignature = getInstallSignature(config2);
      if (installSignature) {
        app.install_signature = installSignature;
      }
      return app;
    }
    function appClosing() {
      if (!config?.telemetry?.enabled) {
        return;
      }
      telemetryAppClosingChannel.publish();
      const { reqType, payload } = createPayload("app-closing");
      sendData(config, application, host, reqType, payload);
      metricsManager.send(config, application, host);
      telemetryLogger.send(config, application, host);
    }
    function onBeforeExit() {
      process.removeListener("beforeExit", onBeforeExit);
      appClosing();
    }
    function createAppObject(config2) {
      return {
        service_name: config2.service,
        env: config2.env,
        service_version: config2.version,
        tracer_version: tracerVersion,
        language_name: "nodejs",
        language_version: process.versions.node
      };
    }
    function createHostObject() {
      const osName = os.type();
      if (osName === "Linux" || osName === "Darwin") {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          kernel_version: os.version(),
          kernel_release: os.release(),
          kernel_name: osName
        };
      }
      if (osName === "Windows_NT") {
        return {
          hostname: os.hostname(),
          os: osName,
          architecture: os.arch(),
          os_version: os.version()
        };
      }
      return {
        hostname: os.hostname(),
        // TODO is this enough?
        os: osName
      };
    }
    function getTelemetryData() {
      return { config, application, host, heartbeatInterval };
    }
    function createBatchPayload(payload) {
      const batchPayload = payload.map((item) => {
        return {
          request_type: item.reqType,
          payload: item.payload
        };
      });
      return batchPayload;
    }
    function createPayload(currReqType, currPayload = {}) {
      if (getRetryData()) {
        const payload = { reqType: currReqType, payload: currPayload };
        const batchPayload = createBatchPayload([payload, retryData]);
        return { reqType: "message-batch", payload: batchPayload };
      }
      return { reqType: currReqType, payload: currPayload };
    }
    function heartbeat(config2, application2, host2) {
      heartbeatTimeout = setTimeout(() => {
        metricsManager.send(config2, application2, host2);
        telemetryLogger.send(config2, application2, host2);
        const { reqType, payload } = createPayload("app-heartbeat");
        sendData(config2, application2, host2, reqType, payload, updateRetryData);
        heartbeat(config2, application2, host2);
      }, heartbeatInterval).unref();
      return heartbeatTimeout;
    }
    function extendedHeartbeat(config2) {
      extendedInterval = setInterval(() => {
        const appPayload = appStarted(config2);
        const payload = {
          ...appPayload,
          ...extendedHeartbeatPayload
        };
        sendData(config2, application, host, "app-extended-heartbeat", payload);
        Object.keys(extendedHeartbeatPayload).forEach((key) => delete extendedHeartbeatPayload[key]);
      }, 1e3 * 60 * 60 * 24).unref();
      return extendedInterval;
    }
    function start(aConfig, thePluginManager) {
      if (!aConfig.telemetry.enabled) {
        if (aConfig.sca?.enabled) {
          logger.warn("DD_APPSEC_SCA_ENABLED requires enabling telemetry to work.");
        }
        return;
      }
      config = aConfig;
      pluginManager = thePluginManager;
      application = createAppObject(config);
      host = createHostObject();
      heartbeatInterval = config.telemetry.heartbeatInterval;
      integrations = getIntegrations();
      dependencies.start(config, application, host, getRetryData, updateRetryData);
      telemetryLogger.start(config);
      endpoints.start(config, application, host, getRetryData, updateRetryData);
      sendData(config, application, host, "app-started", appStarted(config));
      if (integrations.length > 0) {
        sendData(
          config,
          application,
          host,
          "app-integrations-change",
          { integrations },
          updateRetryData
        );
      }
      heartbeat(config, application, host);
      extendedHeartbeat(config);
      process.on("beforeExit", onBeforeExit);
      telemetryStartChannel.publish(getTelemetryData());
    }
    function stop() {
      if (!config) {
        return;
      }
      clearInterval(extendedInterval);
      clearTimeout(heartbeatTimeout);
      process.removeListener("beforeExit", onBeforeExit);
      telemetryStopChannel.publish(getTelemetryData());
      endpoints.stop();
      config = void 0;
    }
    function updateIntegrations() {
      if (!config?.telemetry.enabled) {
        return;
      }
      const integrations2 = getIntegrations();
      if (integrations2.length === 0) {
        return;
      }
      const { reqType, payload } = createPayload("app-integrations-change", { integrations: integrations2 });
      sendData(config, application, host, reqType, payload, updateRetryData);
    }
    function formatMapForTelemetry(map) {
      return map ? Object.entries(map).map(([key, value]) => `${key}:${value}`).join(",") : "";
    }
    var nameMapping = {
      sampleRate: "DD_TRACE_SAMPLE_RATE",
      logInjection: "DD_LOG_INJECTION",
      headerTags: "DD_TRACE_HEADER_TAGS",
      tags: "DD_TAGS",
      "sampler.rules": "DD_TRACE_SAMPLING_RULES",
      traceEnabled: "DD_TRACE_ENABLED",
      url: "DD_TRACE_AGENT_URL",
      "sampler.rateLimit": "DD_TRACE_RATE_LIMIT",
      queryStringObfuscation: "DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP",
      version: "DD_VERSION",
      env: "DD_ENV",
      service: "DD_SERVICE",
      clientIpHeader: "DD_TRACE_CLIENT_IP_HEADER",
      "grpc.client.error.statuses": "DD_GRPC_CLIENT_ERROR_STATUSES",
      "grpc.server.error.statuses": "DD_GRPC_SERVER_ERROR_STATUSES",
      traceId128BitLoggingEnabled: "DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED",
      instrumentationSource: "instrumentation_source",
      injectionEnabled: "ssi_injection_enabled",
      injectForce: "ssi_forced_injection_enabled",
      "runtimeMetrics.enabled": "runtimeMetrics",
      otelLogsEnabled: "DD_LOGS_OTEL_ENABLED",
      otelUrl: "OTEL_EXPORTER_OTLP_ENDPOINT",
      otelEndpoint: "OTEL_EXPORTER_OTLP_ENDPOINT",
      otelHeaders: "OTEL_EXPORTER_OTLP_HEADERS",
      otelProtocol: "OTEL_EXPORTER_OTLP_PROTOCOL",
      otelTimeout: "OTEL_EXPORTER_OTLP_TIMEOUT",
      otelLogsHeaders: "OTEL_EXPORTER_OTLP_LOGS_HEADERS",
      otelLogsProtocol: "OTEL_EXPORTER_OTLP_LOGS_PROTOCOL",
      otelLogsTimeout: "OTEL_EXPORTER_OTLP_LOGS_TIMEOUT",
      otelLogsUrl: "OTEL_EXPORTER_OTLP_LOGS_ENDPOINT",
      otelLogsBatchTimeout: "OTEL_BSP_SCHEDULE_DELAY",
      otelLogsMaxExportBatchSize: "OTEL_BSP_MAX_EXPORT_BATCH_SIZE"
    };
    var namesNeedFormatting = /* @__PURE__ */ new Set(["DD_TAGS", "peerServiceMapping", "serviceMapping"]);
    function updateConfig(changes, config2) {
      if (!config2.telemetry.enabled) return;
      if (changes.length === 0) return;
      logger.trace(changes);
      const application2 = createAppObject(config2);
      const host2 = createHostObject();
      const changed = configWithOrigin.size > 0;
      for (const change of changes) {
        const name = nameMapping[change.name] || change.name;
        const { origin, value } = change;
        const entry = { name, value, origin, seq_id: seqId++ };
        if (namesNeedFormatting.has(entry.name)) {
          entry.value = formatMapForTelemetry(entry.value);
        } else if (entry.name === "url") {
          if (entry.value) {
            entry.value = entry.value.toString();
          }
        } else if (entry.name === "DD_TRACE_SAMPLING_RULES") {
          entry.value = JSON.stringify(entry.value);
        } else if (Array.isArray(entry.value)) {
          entry.value = value.join(",");
        }
        configWithOrigin.set(`${name}|${origin}`, entry);
      }
      if (changed) {
        const { reqType, payload } = createPayload("app-client-configuration-change", {
          configuration: [...configWithOrigin.values()]
        });
        sendData(config2, application2, host2, reqType, payload, updateRetryData);
      }
    }
    function profilingEnabledToBoolean(profilingEnabled) {
      if (typeof profilingEnabled === "boolean") {
        return profilingEnabled;
      }
      return profilingEnabled === "true" || profilingEnabled === "auto";
    }
    module2.exports = {
      start,
      stop,
      updateIntegrations,
      updateConfig,
      appClosing
    };
  }
});

// ../../packages/dd-trace/src/telemetry/index.js
var require_telemetry3 = __commonJS({
  "../../packages/dd-trace/src/telemetry/index.js"(exports2, module2) {
    "use strict";
    var telemetry;
    module2.exports = {
      start(config, ...args) {
        telemetry ??= require_telemetry2();
        telemetry.start(config, ...args);
      },
      stop() {
        telemetry?.stop();
      },
      // This might be called before `start` so we have to trigger loading the
      // underlying module here as well.
      updateConfig(changes, config, ...args) {
        telemetry ??= require_telemetry2();
        telemetry.updateConfig(changes, config, ...args);
      },
      updateIntegrations() {
        telemetry?.updateIntegrations();
      },
      appClosing() {
        telemetry?.appClosing();
      }
    };
  }
});

// ../../packages/dd-trace/src/serverless.js
var require_serverless = __commonJS({
  "../../packages/dd-trace/src/serverless.js"(exports2, module2) {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    function getIsGCPFunction() {
      const isDeprecatedGCPFunction = getEnvironmentVariable("FUNCTION_NAME") !== void 0 && getEnvironmentVariable("GCP_PROJECT") !== void 0;
      const isNewerGCPFunction = getEnvironmentVariable("K_SERVICE") !== void 0 && getEnvironmentVariable("FUNCTION_TARGET") !== void 0;
      return isDeprecatedGCPFunction || isNewerGCPFunction;
    }
    function getIsAzureFunction() {
      const isAzureFunction = getEnvironmentVariable("FUNCTIONS_EXTENSION_VERSION") !== void 0 && getEnvironmentVariable("FUNCTIONS_WORKER_RUNTIME") !== void 0;
      return isAzureFunction;
    }
    function isInServerlessEnvironment() {
      const inAWSLambda = getEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") !== void 0;
      const isGCPFunction = getIsGCPFunction();
      const isAzureFunction = getIsAzureFunction();
      return inAWSLambda || isGCPFunction || isAzureFunction;
    }
    module2.exports = {
      getIsGCPFunction,
      getIsAzureFunction,
      isInServerlessEnvironment
    };
  }
});

// ../../packages/dd-trace/src/payload-tagging/config/aws.json
var require_aws = __commonJS({
  "../../packages/dd-trace/src/payload-tagging/config/aws.json"(exports2, module2) {
    module2.exports = {
      sns: {
        request: [
          "$.Attributes.KmsMasterKeyId",
          "$.Attributes.PlatformCredential",
          "$.Attributes.PlatformPrincipal",
          "$.Attributes.Token",
          "$.AWSAccountId",
          "$.Endpoint",
          "$.OneTimePassword",
          "$.phoneNumber",
          "$.PhoneNumber",
          "$.Token"
        ],
        response: [
          "$.Attributes.KmsMasterKeyId",
          "$.Attributes.Token",
          "$.Endpoints.*.Token",
          "$.PhoneNumber",
          "$.PlatformApplication.*.PlatformCredential",
          "$.PlatformApplication.*.PlatformPrincipal",
          "$.Subscriptions.*.Endpoint",
          "$.PhoneNumbers[*].PhoneNumber",
          "$.phoneNumbers[*]"
        ],
        expand: [
          "$.MessageAttributes.*.StringValue"
        ]
      },
      eventbridge: {
        request: [
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters[*].Value",
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters[*].Value",
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.HeaderParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.QueryStringParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.BodyParameters[*].Value",
          "$.Targets[*].RedshiftDataParameters.Sql",
          "$.Targets[*].RedshiftDataParameters.Sqls",
          "$.Targets[*].AppSyncParameters.GraphQLOperation",
          "$.AuthParameters.BasicAuthParameters.Password",
          "$.AuthParameters.OAuthParameters.ClientParameters.ClientSecret",
          "$.AuthParameters.ApiKeyAuthParameters.ApiKeyValue"
        ],
        response: [
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.HeaderParameters[*].Value",
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.QueryStringParameters[*].Value",
          "$.AuthParameters.OAuthParameters.OAuthHttpParameters.BodyParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.HeaderParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.QueryStringParameters[*].Value",
          "$.AuthParameters.InvocationHttpParameters.BodyParameters[*].Value",
          "$.Targets[*].RedshiftDataParameters.Sql",
          "$.Targets[*].RedshiftDataParameters.Sqls",
          "$.Targets[*].AppSyncParameters.GraphQLOperation"
        ],
        expand: []
      },
      s3: {
        request: [
          "$.SSEKMSKeyId",
          "$.SSEKMSEncryptionContext",
          "$.ServerSideEncryptionConfiguration.Rules[*].ApplyServerSideEncryptionByDefault.KMSMasterKeyID",
          "$.InventoryConfiguration.Destination.S3BucketDestination.Encryption.SSEKMS.KeyId",
          "$.SSECustomerKey",
          "$.CopySourceSSECustomerKey",
          "$.RestoreRequest.OutputLocation.S3.Encryption.KMSKeyId"
        ],
        response: [
          "$.SSEKMSKeyId",
          "$.SSEKMSEncryptionContext",
          "$.ServerSideEncryptionConfiguration.Rules[*].ApplyServerSideEncryptionByDefault.KMSMasterKeyID",
          "$.InventoryConfiguration.Destination.S3BucketDestination.Encryption.SSEKMS.KeyId",
          "$.Credentials.SecretAccessKey",
          "$.Credentials.SessionToken",
          "$.InventoryConfigurationList[*].Destination.S3BucketDestination.Encryption.SSEKMS.KeyId"
        ],
        expand: []
      },
      sqs: {
        request: [],
        response: [],
        expand: []
      },
      kinesis: {
        request: [],
        response: [],
        expand: []
      },
      dynamodb: {
        request: [],
        response: [],
        expand: []
      }
    };
  }
});

// ../../packages/dd-trace/src/payload-tagging/config/index.js
var require_config = __commonJS({
  "../../packages/dd-trace/src/payload-tagging/config/index.js"(exports2, module2) {
    "use strict";
    var aws = require_aws();
    var sdks = { aws };
    function getSDKRules(sdk, requestInput, responseInput) {
      const sdkServiceRules = {};
      for (const [service, serviceRules] of Object.entries(sdk)) {
        sdkServiceRules[service] = {
          // Make a copy. Otherwise calling the function multiple times would append
          // the rules to the same object.
          request: [...serviceRules.request, ...requestInput],
          response: [...serviceRules.response, ...responseInput],
          expand: serviceRules.expand
        };
      }
      return sdkServiceRules;
    }
    function appendRules(requestInput = [], responseInput = []) {
      const sdkRules = {};
      for (const [name, sdk] of Object.entries(sdks)) {
        sdkRules[name] = getSDKRules(sdk, requestInput, responseInput);
      }
      return sdkRules;
    }
    module2.exports = { appendRules };
  }
});

// ../../packages/dd-trace/src/config_stable.js
var require_config_stable = __commonJS({
  "../../packages/dd-trace/src/config_stable.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var fs = __require("fs");
    var { getEnvironmentVariable } = require_config_helper();
    var StableConfig = class {
      constructor() {
        this.warnings = [];
        this.localEntries = {};
        this.fleetEntries = {};
        this.wasm_loaded = false;
        const { localConfigPath, fleetConfigPath } = this._getStableConfigPaths();
        if (!fs.existsSync(localConfigPath) && !fs.existsSync(fleetConfigPath)) {
          return;
        }
        const localConfig = this._readConfigFromPath(localConfigPath);
        const fleetConfig = this._readConfigFromPath(fleetConfigPath);
        if (!localConfig && !fleetConfig) {
          return;
        }
        let libdatadog;
        try {
          libdatadog = require_libdatadog();
          this.wasm_loaded = true;
        } catch {
          this.warnings.push("Can't load libdatadog library");
          return;
        }
        const libconfig = libdatadog.maybeLoad("library_config");
        if (libconfig === void 0) {
          this.warnings.push("Can't load library_config library");
          return;
        }
        try {
          const configurator = new libconfig.JsConfigurator();
          configurator.set_envp(Object.entries(process.env).map(([key, value]) => `${key}=${value}`));
          configurator.set_args(process.argv);
          configurator.get_configuration(localConfig.toString(), fleetConfig.toString()).forEach((entry) => {
            if (entry.source === "local_stable_config") {
              this.localEntries[entry.name] = entry.value;
            } else if (entry.source === "fleet_stable_config") {
              this.fleetEntries[entry.name] = entry.value;
            }
          });
        } catch (e) {
          this.warnings.push(`Error parsing configuration from file: ${e.message}`);
        }
      }
      _readConfigFromPath(path) {
        try {
          return fs.readFileSync(path, "utf8");
        } catch (err) {
          if (err.code !== "ENOENT") {
            this.warnings.push(`Error reading config file at ${path}. ${err.code}: ${err.message}`);
          }
          return "";
        }
      }
      _getStableConfigPaths() {
        let localConfigPath = "";
        let fleetConfigPath = "";
        switch (os.type().toLowerCase()) {
          case "linux":
            localConfigPath = "/etc/datadog-agent/application_monitoring.yaml";
            fleetConfigPath = "/etc/datadog-agent/managed/datadog-agent/stable/application_monitoring.yaml";
            break;
          case "darwin":
            localConfigPath = "/opt/datadog-agent/etc/application_monitoring.yaml";
            fleetConfigPath = "/opt/datadog-agent/etc/managed/datadog-agent/stable/application_monitoring.yaml";
            break;
          case "win32":
            localConfigPath = String.raw`C:\ProgramData\Datadog\application_monitoring.yaml`;
            fleetConfigPath = String.raw`C:\ProgramData\Datadog\managed\datadog-agent\stable\application_monitoring.yaml`;
            break;
          default:
            break;
        }
        if (getEnvironmentVariable("DD_TEST_LOCAL_CONFIG_PATH") !== void 0) {
          localConfigPath = getEnvironmentVariable("DD_TEST_LOCAL_CONFIG_PATH");
        }
        if (getEnvironmentVariable("DD_TEST_FLEET_CONFIG_PATH") !== void 0) {
          fleetConfigPath = getEnvironmentVariable("DD_TEST_FLEET_CONFIG_PATH");
        }
        return { localConfigPath, fleetConfigPath };
      }
    };
    module2.exports = StableConfig;
  }
});

// ../../packages/dd-trace/src/config.js
var require_config2 = __commonJS({
  "../../packages/dd-trace/src/config.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var os = __require("os");
    var uuid = require_crypto_randomuuid();
    var { URL: URL2 } = __require("url");
    var log = require_log2();
    var tagger = require_tagger();
    var set2 = require_set2();
    var { isTrue, isFalse, normalizeProfilingEnabledValue } = require_util();
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2();
    var { getGitMetadataFromGitProperties, removeUserSensitiveInfo, getRemoteOriginURL, resolveGitHeadSHA } = require_git_properties();
    var { updateConfig } = require_telemetry3();
    var telemetryMetrics = require_metrics();
    var { isInServerlessEnvironment, getIsGCPFunction, getIsAzureFunction } = require_serverless();
    var { ORIGIN_KEY } = require_constants3();
    var { appendRules } = require_config();
    var { getEnvironmentVariable: getEnv, getEnvironmentVariables } = require_config_helper();
    var defaults = require_config_defaults();
    var path = __require("path");
    var tracerMetrics = telemetryMetrics.manager.namespace("tracers");
    var changeTracker = {};
    var telemetryCounters = {
      "otel.env.hiding": {},
      "otel.env.invalid": {}
    };
    function getCounter(event, ddVar, otelVar) {
      const counters = telemetryCounters[event];
      const tags = [];
      const ddVarPrefix = "config_datadog:";
      const otelVarPrefix = "config_opentelemetry:";
      if (ddVar) {
        ddVar = ddVarPrefix + ddVar.toLowerCase();
        tags.push(ddVar);
      }
      if (otelVar) {
        otelVar = otelVarPrefix + otelVar.toLowerCase();
        tags.push(otelVar);
      }
      if (!(otelVar in counters)) counters[otelVar] = {};
      const counter = tracerMetrics.count(event, tags);
      counters[otelVar][ddVar] = counter;
      return counter;
    }
    var otelDdEnvMapping = {
      OTEL_LOG_LEVEL: "DD_TRACE_LOG_LEVEL",
      OTEL_PROPAGATORS: "DD_TRACE_PROPAGATION_STYLE",
      OTEL_SERVICE_NAME: "DD_SERVICE",
      OTEL_TRACES_SAMPLER: "DD_TRACE_SAMPLE_RATE",
      OTEL_TRACES_SAMPLER_ARG: "DD_TRACE_SAMPLE_RATE",
      OTEL_TRACES_EXPORTER: "DD_TRACE_ENABLED",
      OTEL_METRICS_EXPORTER: "DD_RUNTIME_METRICS_ENABLED",
      OTEL_RESOURCE_ATTRIBUTES: "DD_TAGS",
      OTEL_SDK_DISABLED: "DD_TRACE_OTEL_ENABLED",
      OTEL_LOGS_EXPORTER: void 0
    };
    var VALID_PROPAGATION_STYLES = /* @__PURE__ */ new Set(["datadog", "tracecontext", "b3", "b3 single header", "none"]);
    var VALID_PROPAGATION_BEHAVIOR_EXTRACT = /* @__PURE__ */ new Set(["continue", "restart", "ignore"]);
    var VALID_LOG_LEVELS = /* @__PURE__ */ new Set(["debug", "info", "warn", "error"]);
    var DEFAULT_OTLP_PORT = 4318;
    function getFromOtelSamplerMap(otelTracesSampler, otelTracesSamplerArg) {
      const OTEL_TRACES_SAMPLER_MAPPING = {
        always_on: "1.0",
        always_off: "0.0",
        traceidratio: otelTracesSamplerArg,
        parentbased_always_on: "1.0",
        parentbased_always_off: "0.0",
        parentbased_traceidratio: otelTracesSamplerArg
      };
      return OTEL_TRACES_SAMPLER_MAPPING[otelTracesSampler];
    }
    function validateOtelPropagators(propagators) {
      if (!getEnv("PROPAGATION_STYLE_EXTRACT") && !getEnv("PROPAGATION_STYLE_INJECT") && !getEnv("DD_TRACE_PROPAGATION_STYLE") && getEnv("OTEL_PROPAGATORS")) {
        for (const style in propagators) {
          if (!VALID_PROPAGATION_STYLES.has(style)) {
            log.warn("unexpected value for OTEL_PROPAGATORS environment variable");
            getCounter("otel.env.invalid", "DD_TRACE_PROPAGATION_STYLE", "OTEL_PROPAGATORS").inc();
          }
        }
      }
    }
    function isInvalidOtelEnvironmentVariable(envVar, value) {
      if (value === void 0) return false;
      switch (envVar) {
        case "OTEL_LOG_LEVEL":
          return !VALID_LOG_LEVELS.has(value);
        case "OTEL_PROPAGATORS":
        case "OTEL_RESOURCE_ATTRIBUTES":
        case "OTEL_SERVICE_NAME":
          return typeof value !== "string";
        case "OTEL_TRACES_SAMPLER":
          return getFromOtelSamplerMap(value, getEnv("OTEL_TRACES_SAMPLER_ARG")) === void 0;
        case "OTEL_TRACES_SAMPLER_ARG":
          return Number.isNaN(Number.parseFloat(value));
        case "OTEL_SDK_DISABLED":
          return value.toLowerCase() !== "true" && value.toLowerCase() !== "false";
        case "OTEL_TRACES_EXPORTER":
        case "OTEL_METRICS_EXPORTER":
        case "OTEL_LOGS_EXPORTER":
          return value.toLowerCase() !== "none";
        default:
          return true;
      }
    }
    function checkIfBothOtelAndDdEnvVarSet() {
      for (const [otelEnvVar, ddEnvVar] of Object.entries(otelDdEnvMapping)) {
        const otelValue = getEnv(otelEnvVar);
        if (ddEnvVar && getEnv(ddEnvVar) && otelValue) {
          log.warn("both %s and %s environment variables are set", ddEnvVar, otelEnvVar);
          getCounter("otel.env.hiding", ddEnvVar, otelEnvVar).inc();
        }
        if (isInvalidOtelEnvironmentVariable(otelEnvVar, otelValue)) {
          log.warn("unexpected value %s for %s environment variable", otelValue, otelEnvVar);
          getCounter("otel.env.invalid", ddEnvVar, otelEnvVar).inc();
        }
      }
    }
    var runtimeId = uuid();
    function maybeFile(filepath) {
      if (!filepath) return;
      try {
        return fs.readFileSync(filepath, "utf8");
      } catch (e) {
        log.error("Error reading file %s", filepath, e);
      }
    }
    function maybeJsonFile(filepath) {
      const file = maybeFile(filepath);
      if (!file) return;
      try {
        return JSON.parse(file);
      } catch (e) {
        log.error("Error parsing JSON file %s", filepath, e);
      }
    }
    function safeJsonParse(input) {
      try {
        return JSON.parse(input);
      } catch {
      }
    }
    var namingVersions = /* @__PURE__ */ new Set(["v0", "v1"]);
    var defaultNamingVersion = "v0";
    function validateNamingVersion(versionString) {
      if (!versionString) {
        return defaultNamingVersion;
      }
      if (!namingVersions.has(versionString)) {
        log.warn("Unexpected input for config.spanAttributeSchema, picked default", defaultNamingVersion);
        return defaultNamingVersion;
      }
      return versionString;
    }
    function splitJSONPathRules(input) {
      if (!input) return;
      if (Array.isArray(input)) return input;
      if (input === "all") return [];
      return input.split(",");
    }
    function remapify(input, mappings) {
      if (!input) return;
      const output = {};
      for (const [key, value] of Object.entries(input)) {
        output[key in mappings ? mappings[key] : key] = value;
      }
      return output;
    }
    function propagationStyle(key, option) {
      if (option !== null && typeof option === "object" && !Array.isArray(option)) {
        option = option[key];
      }
      if (Array.isArray(option)) return option.map((v) => v.toLowerCase());
      if (option !== void 0) {
        log.warn("Unexpected input for config.tracePropagationStyle");
      }
      const envKey = `DD_TRACE_PROPAGATION_STYLE_${key.toUpperCase()}`;
      const envVar = getEnv(envKey) ?? getEnv("DD_TRACE_PROPAGATION_STYLE") ?? getEnv("OTEL_PROPAGATORS");
      if (envVar !== void 0) {
        return envVar.split(",").filter((v) => v !== "").map((v) => v.trim().toLowerCase());
      }
    }
    function reformatSpanSamplingRules(rules) {
      if (!rules) return rules;
      return rules.map((rule) => {
        return remapify(rule, {
          sample_rate: "sampleRate",
          max_per_second: "maxPerSecond"
        });
      });
    }
    var Config = class {
      /**
       * parsed DD_TAGS, usable as a standalone tag set across products
       * @type {Record<string, string> | undefined}
       */
      #parsedDdTags = {};
      #envUnprocessed = {};
      #optsUnprocessed = {};
      #remoteUnprocessed = {};
      #env = {};
      #options = {};
      #remote = {};
      #defaults = {};
      #optionsArg = {};
      #localStableConfig = {};
      #fleetStableConfig = {};
      #calculated = {};
      #getSourcesInOrder() {
        return [
          { container: this.#remote, origin: "remote_config", unprocessed: this.#remoteUnprocessed },
          { container: this.#options, origin: "code", unprocessed: this.#optsUnprocessed },
          { container: this.#fleetStableConfig, origin: "fleet_stable_config" },
          { container: this.#env, origin: "env_var", unprocessed: this.#envUnprocessed },
          { container: this.#localStableConfig, origin: "local_stable_config" },
          { container: this.#calculated, origin: "calculated" },
          { container: this.#defaults, origin: "default" }
        ];
      }
      constructor(options = {}) {
        if (!isInServerlessEnvironment()) {
          const StableConfig = require_config_stable();
          this.stableConfig = new StableConfig();
        }
        const envs = getEnvironmentVariables();
        options = {
          ...options,
          appsec: options.appsec == null ? options.experimental?.appsec : options.appsec,
          iast: options.iast == null ? options.experimental?.iast : options.iast
        };
        const logConfig = log.getConfig();
        this.debug = log.isEnabled(
          this.stableConfig?.fleetEntries?.DD_TRACE_DEBUG,
          this.stableConfig?.localEntries?.DD_TRACE_DEBUG
        );
        this.logger = options.logger ?? logConfig.logger;
        this.logLevel = log.getLogLevel(
          options.logLevel,
          this.stableConfig?.fleetEntries?.DD_TRACE_LOG_LEVEL,
          this.stableConfig?.localEntries?.DD_TRACE_LOG_LEVEL
        );
        log.use(this.logger);
        log.toggle(this.debug, this.logLevel);
        for (const warning of this.stableConfig?.warnings ?? []) {
          log.warn(warning);
        }
        checkIfBothOtelAndDdEnvVarSet();
        const {
          DD_API_KEY,
          DD_APP_KEY,
          DD_INSTRUMENTATION_INSTALL_ID = null,
          DD_INSTRUMENTATION_INSTALL_TIME = null,
          DD_INSTRUMENTATION_INSTALL_TYPE = null,
          DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH,
          DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING,
          DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING,
          DD_TRACE_PROPAGATION_STYLE_EXTRACT,
          DD_TRACE_PROPAGATION_STYLE_INJECT,
          DD_TRACE_PROPAGATION_STYLE
        } = envs;
        if (DD_TRACE_PROPAGATION_STYLE && (DD_TRACE_PROPAGATION_STYLE_INJECT || DD_TRACE_PROPAGATION_STYLE_EXTRACT)) {
          log.warn(
            // eslint-disable-next-line @stylistic/max-len
            "Use either the DD_TRACE_PROPAGATION_STYLE environment variable or separate DD_TRACE_PROPAGATION_STYLE_INJECT and DD_TRACE_PROPAGATION_STYLE_EXTRACT environment variables"
          );
        }
        const PROPAGATION_STYLE_INJECT = propagationStyle(
          "inject",
          options.tracePropagationStyle
        );
        validateOtelPropagators(PROPAGATION_STYLE_INJECT);
        if (typeof options.appsec === "boolean") {
          options.appsec = {
            enabled: options.appsec
          };
        }
        if (typeof options.runtimeMetrics === "boolean") {
          options.runtimeMetrics = {
            enabled: options.runtimeMetrics
          };
        }
        const cloudPayloadTaggingRequestRules = splitJSONPathRules(
          DD_TRACE_CLOUD_REQUEST_PAYLOAD_TAGGING ?? options.cloudPayloadTagging?.request ?? ""
        );
        const cloudPayloadTaggingResponseRules = splitJSONPathRules(
          DD_TRACE_CLOUD_RESPONSE_PAYLOAD_TAGGING ?? options.cloudPayloadTagging?.response ?? ""
        );
        const cloudPayloadTaggingMaxDepth = maybeInt(
          DD_TRACE_CLOUD_PAYLOAD_TAGGING_MAX_DEPTH ?? options.cloudPayloadTagging?.maxDepth
        ) ?? 10;
        this.apiKey = DD_API_KEY;
        this.appKey = DD_APP_KEY;
        this.installSignature = {
          id: DD_INSTRUMENTATION_INSTALL_ID,
          time: DD_INSTRUMENTATION_INSTALL_TIME,
          type: DD_INSTRUMENTATION_INSTALL_TYPE
        };
        this.cloudPayloadTagging = {
          requestsEnabled: !!cloudPayloadTaggingRequestRules,
          responsesEnabled: !!cloudPayloadTaggingResponseRules,
          maxDepth: cloudPayloadTaggingMaxDepth,
          rules: appendRules(cloudPayloadTaggingRequestRules, cloudPayloadTaggingResponseRules)
        };
        this.#defaults = defaults;
        this.#applyStableConfig(this.stableConfig?.localEntries ?? {}, this.#localStableConfig);
        this.#applyEnvironment(envs);
        this.#applyStableConfig(this.stableConfig?.fleetEntries ?? {}, this.#fleetStableConfig);
        this.#applyOptions(options);
        this.#applyCalculated();
        this.#applyRemote({});
        this.#merge();
        tagger.add(this.tags, {
          service: this.service,
          env: this.env,
          version: this.version,
          "runtime-id": runtimeId
        });
        if (this.isCiVisibility) {
          tagger.add(this.tags, {
            [ORIGIN_KEY]: "ciapp-test"
          });
        }
        if (this.gitMetadataEnabled) {
          this.#loadGitMetadata(envs);
        }
      }
      get parsedDdTags() {
        return this.#parsedDdTags;
      }
      // Supports only a subset of options for now.
      configure(options, remote) {
        if (remote) {
          this.#applyRemote(options);
        } else {
          this.#applyOptions(options);
        }
        this.#applyCalculated();
        this.#merge();
      }
      #getDefaultPropagationStyle(options) {
        const DD_TRACE_B3_ENABLED = options.experimental?.b3 ?? getEnv("DD_TRACE_EXPERIMENTAL_B3_ENABLED");
        const defaultPropagationStyle = ["datadog", "tracecontext"];
        if (isTrue(DD_TRACE_B3_ENABLED)) {
          defaultPropagationStyle.push("b3", "b3 single header");
        }
        return defaultPropagationStyle;
      }
      _isInServerlessEnvironment() {
        return isInServerlessEnvironment();
      }
      #applyStableConfig(config, obj) {
        const {
          DD_APPSEC_ENABLED,
          DD_APPSEC_SCA_ENABLED,
          DD_DATA_STREAMS_ENABLED,
          DD_DYNAMIC_INSTRUMENTATION_ENABLED,
          DD_ENV,
          DD_IAST_ENABLED,
          DD_LOGS_INJECTION,
          DD_PROFILING_ENABLED,
          DD_RUNTIME_METRICS_ENABLED,
          DD_SERVICE,
          DD_VERSION
        } = config;
        this.#setBoolean(obj, "appsec.enabled", DD_APPSEC_ENABLED);
        this.#setBoolean(obj, "appsec.sca.enabled", DD_APPSEC_SCA_ENABLED);
        this.#setBoolean(obj, "dsmEnabled", DD_DATA_STREAMS_ENABLED);
        this.#setBoolean(obj, "dynamicInstrumentation.enabled", DD_DYNAMIC_INSTRUMENTATION_ENABLED);
        this.#setString(obj, "env", DD_ENV);
        this.#setBoolean(obj, "iast.enabled", DD_IAST_ENABLED);
        this.#setBoolean(obj, "logInjection", DD_LOGS_INJECTION);
        const profilingEnabled = normalizeProfilingEnabledValue(DD_PROFILING_ENABLED);
        this.#setString(obj, "profiling.enabled", profilingEnabled);
        this.#setBoolean(obj, "runtimeMetrics.enabled", DD_RUNTIME_METRICS_ENABLED);
        this.#setString(obj, "service", DD_SERVICE);
        this.#setString(obj, "version", DD_VERSION);
      }
      #applyEnvironment(envs) {
        const {
          AWS_LAMBDA_FUNCTION_NAME,
          DD_AGENT_HOST,
          DD_AI_GUARD_ENABLED,
          DD_AI_GUARD_ENDPOINT,
          DD_AI_GUARD_MAX_CONTENT_SIZE,
          DD_AI_GUARD_MAX_MESSAGES_LENGTH,
          DD_AI_GUARD_TIMEOUT,
          DD_API_SECURITY_ENABLED,
          DD_API_SECURITY_SAMPLE_DELAY,
          DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED,
          DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT,
          DD_APM_TRACING_ENABLED,
          DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE,
          DD_APPSEC_COLLECT_ALL_HEADERS,
          DD_APPSEC_ENABLED,
          DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON,
          DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED,
          DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML,
          DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON,
          DD_APPSEC_MAX_COLLECTED_HEADERS,
          DD_APPSEC_MAX_STACK_TRACES,
          DD_APPSEC_MAX_STACK_TRACE_DEPTH,
          DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP,
          DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP,
          DD_APPSEC_RULES,
          DD_APPSEC_SCA_ENABLED,
          DD_APPSEC_STACK_TRACE_ENABLED,
          DD_APPSEC_RASP_ENABLED,
          DD_APPSEC_RASP_COLLECT_REQUEST_BODY,
          DD_APPSEC_TRACE_RATE_LIMIT,
          DD_APPSEC_WAF_TIMEOUT,
          DD_CRASHTRACKING_ENABLED,
          DD_CODE_ORIGIN_FOR_SPANS_ENABLED,
          DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED,
          DD_DATA_STREAMS_ENABLED,
          DD_DBM_PROPAGATION_MODE,
          DD_DOGSTATSD_HOST,
          DD_DOGSTATSD_PORT,
          DD_DYNAMIC_INSTRUMENTATION_ENABLED,
          DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE,
          DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS,
          DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS,
          DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS,
          DD_ENV,
          DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED,
          DD_PROFILING_ENABLED,
          DD_GRPC_CLIENT_ERROR_STATUSES,
          DD_GRPC_SERVER_ERROR_STATUSES,
          JEST_WORKER_ID,
          DD_HEAP_SNAPSHOT_COUNT,
          DD_HEAP_SNAPSHOT_DESTINATION,
          DD_HEAP_SNAPSHOT_INTERVAL,
          DD_IAST_DB_ROWS_TO_TAINT,
          DD_IAST_DEDUPLICATION_ENABLED,
          DD_IAST_ENABLED,
          DD_IAST_MAX_CONCURRENT_REQUESTS,
          DD_IAST_MAX_CONTEXT_OPERATIONS,
          DD_IAST_REDACTION_ENABLED,
          DD_IAST_REDACTION_NAME_PATTERN,
          DD_IAST_REDACTION_VALUE_PATTERN,
          DD_IAST_REQUEST_SAMPLING,
          DD_IAST_SECURITY_CONTROLS_CONFIGURATION,
          DD_IAST_TELEMETRY_VERBOSITY,
          DD_IAST_STACK_TRACE_ENABLED,
          DD_INJECTION_ENABLED,
          DD_INJECT_FORCE,
          DD_INSTRUMENTATION_TELEMETRY_ENABLED,
          DD_INSTRUMENTATION_CONFIG_ID,
          DD_LOGS_INJECTION,
          DD_LOGS_OTEL_ENABLED,
          DD_LANGCHAIN_SPAN_CHAR_LIMIT,
          DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE,
          DD_LLMOBS_AGENTLESS_ENABLED,
          DD_LLMOBS_ENABLED,
          DD_LLMOBS_ML_APP,
          DD_OPENAI_LOGS_ENABLED,
          DD_OPENAI_SPAN_CHAR_LIMIT,
          DD_PROFILING_EXPORTERS,
          DD_PROFILING_SOURCE_MAP,
          DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD,
          DD_REMOTE_CONFIGURATION_ENABLED,
          DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS,
          DD_RUNTIME_METRICS_ENABLED,
          DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED,
          DD_RUNTIME_METRICS_GC_ENABLED,
          DD_SERVICE,
          DD_SERVICE_MAPPING,
          DD_SITE,
          DD_SPAN_SAMPLING_RULES,
          DD_SPAN_SAMPLING_RULES_FILE,
          DD_TAGS,
          DD_TELEMETRY_DEBUG,
          DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED,
          DD_TELEMETRY_HEARTBEAT_INTERVAL,
          DD_TELEMETRY_LOG_COLLECTION_ENABLED,
          DD_TELEMETRY_METRICS_ENABLED,
          DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED,
          DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED,
          DD_TRACE_AGENT_PORT,
          DD_TRACE_AGENT_PROTOCOL_VERSION,
          DD_TRACE_AWS_ADD_SPAN_POINTERS,
          DD_TRACE_BAGGAGE_MAX_BYTES,
          DD_TRACE_BAGGAGE_MAX_ITEMS,
          DD_TRACE_BAGGAGE_TAG_KEYS,
          DD_TRACE_CLIENT_IP_ENABLED,
          DD_TRACE_CLIENT_IP_HEADER,
          DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS,
          DD_TRACE_ENABLED,
          DD_TRACE_EXPERIMENTAL_EXPORTER,
          DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED,
          DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED,
          DD_TRACE_GIT_METADATA_ENABLED,
          DD_TRACE_GLOBAL_TAGS,
          DD_TRACE_GRAPHQL_ERROR_EXTENSIONS,
          DD_TRACE_HEADER_TAGS,
          DD_TRACE_LEGACY_BAGGAGE_ENABLED,
          DD_TRACE_MEMCACHED_COMMAND_ENABLED,
          DD_TRACE_MIDDLEWARE_TRACING_ENABLED,
          DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP,
          DD_TRACE_PARTIAL_FLUSH_MIN_SPANS,
          DD_TRACE_FLUSH_INTERVAL,
          DD_TRACE_PEER_SERVICE_MAPPING,
          DD_TRACE_PROPAGATION_EXTRACT_FIRST,
          DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT,
          DD_TRACE_PROPAGATION_STYLE,
          DD_TRACE_PROPAGATION_STYLE_INJECT,
          DD_TRACE_PROPAGATION_STYLE_EXTRACT,
          DD_TRACE_RATE_LIMIT,
          DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED,
          DD_TRACE_REPORT_HOSTNAME,
          DD_TRACE_SAMPLE_RATE,
          DD_TRACE_SAMPLING_RULES,
          DD_TRACE_SCOPE,
          DD_TRACE_SPAN_ATTRIBUTE_SCHEMA,
          DD_TRACE_SPAN_LEAK_DEBUG,
          DD_TRACE_STARTUP_LOGS,
          DD_TRACE_TAGS,
          DD_TRACE_WEBSOCKET_MESSAGES_ENABLED,
          DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING,
          DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES,
          DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH,
          DD_TRACING_ENABLED,
          DD_VERSION,
          DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE,
          DD_VERTEXAI_SPAN_CHAR_LIMIT,
          DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED,
          DD_TRACE_NATIVE_SPAN_EVENTS,
          OTEL_METRICS_EXPORTER,
          OTEL_PROPAGATORS,
          OTEL_RESOURCE_ATTRIBUTES,
          OTEL_SERVICE_NAME,
          OTEL_TRACES_SAMPLER,
          OTEL_TRACES_SAMPLER_ARG,
          DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED,
          OTEL_EXPORTER_OTLP_LOGS_ENDPOINT,
          OTEL_EXPORTER_OTLP_LOGS_HEADERS,
          OTEL_EXPORTER_OTLP_LOGS_PROTOCOL,
          OTEL_EXPORTER_OTLP_LOGS_TIMEOUT,
          OTEL_EXPORTER_OTLP_PROTOCOL,
          OTEL_EXPORTER_OTLP_ENDPOINT,
          OTEL_EXPORTER_OTLP_HEADERS,
          OTEL_EXPORTER_OTLP_TIMEOUT,
          OTEL_BSP_SCHEDULE_DELAY,
          OTEL_BSP_MAX_EXPORT_BATCH_SIZE
        } = envs;
        const tags = {};
        const env = this.#env;
        tagger.add(this.#parsedDdTags, parseSpaceSeparatedTags(DD_TAGS));
        tagger.add(tags, parseSpaceSeparatedTags(handleOtel(OTEL_RESOURCE_ATTRIBUTES)));
        tagger.add(tags, this.#parsedDdTags);
        tagger.add(tags, DD_TRACE_TAGS);
        tagger.add(tags, DD_TRACE_GLOBAL_TAGS);
        this.#setBoolean(env, "otelLogsEnabled", isTrue(DD_LOGS_OTEL_ENABLED));
        if (OTEL_EXPORTER_OTLP_ENDPOINT) {
          this.#setString(env, "otelUrl", OTEL_EXPORTER_OTLP_ENDPOINT);
        }
        if (OTEL_EXPORTER_OTLP_ENDPOINT || OTEL_EXPORTER_OTLP_LOGS_ENDPOINT) {
          this.#setString(env, "otelLogsUrl", OTEL_EXPORTER_OTLP_LOGS_ENDPOINT || env.otelUrl);
        }
        this.#setString(env, "otelHeaders", OTEL_EXPORTER_OTLP_HEADERS);
        this.#setString(env, "otelLogsHeaders", OTEL_EXPORTER_OTLP_LOGS_HEADERS || env.otelHeaders);
        this.#setString(env, "otelProtocol", OTEL_EXPORTER_OTLP_PROTOCOL);
        this.#setString(env, "otelLogsProtocol", OTEL_EXPORTER_OTLP_LOGS_PROTOCOL || env.otelProtocol);
        env.otelTimeout = maybeInt(OTEL_EXPORTER_OTLP_TIMEOUT);
        env.otelLogsTimeout = maybeInt(OTEL_EXPORTER_OTLP_LOGS_TIMEOUT) || env.otelTimeout;
        env.otelLogsBatchTimeout = maybeInt(OTEL_BSP_SCHEDULE_DELAY);
        env.otelLogsMaxExportBatchSize = maybeInt(OTEL_BSP_MAX_EXPORT_BATCH_SIZE);
        this.#setBoolean(
          env,
          "apmTracingEnabled",
          DD_APM_TRACING_ENABLED ?? (DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED && isFalse(DD_EXPERIMENTAL_APPSEC_STANDALONE_ENABLED))
        );
        this.#setBoolean(env, "appsec.apiSecurity.enabled", DD_API_SECURITY_ENABLED && isTrue(DD_API_SECURITY_ENABLED));
        env["appsec.apiSecurity.sampleDelay"] = maybeFloat(DD_API_SECURITY_SAMPLE_DELAY);
        this.#setBoolean(
          env,
          "appsec.apiSecurity.endpointCollectionEnabled",
          DD_API_SECURITY_ENDPOINT_COLLECTION_ENABLED
        );
        env["appsec.apiSecurity.endpointCollectionMessageLimit"] = maybeInt(DD_API_SECURITY_ENDPOINT_COLLECTION_MESSAGE_LIMIT);
        env["appsec.blockedTemplateGraphql"] = maybeFile(DD_APPSEC_GRAPHQL_BLOCKED_TEMPLATE_JSON);
        env["appsec.blockedTemplateHtml"] = maybeFile(DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML);
        this.#envUnprocessed["appsec.blockedTemplateHtml"] = DD_APPSEC_HTTP_BLOCKED_TEMPLATE_HTML;
        env["appsec.blockedTemplateJson"] = maybeFile(DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON);
        this.#envUnprocessed["appsec.blockedTemplateJson"] = DD_APPSEC_HTTP_BLOCKED_TEMPLATE_JSON;
        this.#setBoolean(env, "appsec.enabled", DD_APPSEC_ENABLED);
        this.#setString(env, "appsec.eventTracking.mode", DD_APPSEC_AUTO_USER_INSTRUMENTATION_MODE);
        this.#setBoolean(env, "appsec.extendedHeadersCollection.enabled", DD_APPSEC_COLLECT_ALL_HEADERS);
        this.#setBoolean(
          env,
          "appsec.extendedHeadersCollection.redaction",
          DD_APPSEC_HEADER_COLLECTION_REDACTION_ENABLED
        );
        env["appsec.extendedHeadersCollection.maxHeaders"] = maybeInt(DD_APPSEC_MAX_COLLECTED_HEADERS);
        this.#envUnprocessed["appsec.extendedHeadersCollection.maxHeaders"] = DD_APPSEC_MAX_COLLECTED_HEADERS;
        this.#setString(env, "appsec.obfuscatorKeyRegex", DD_APPSEC_OBFUSCATION_PARAMETER_KEY_REGEXP);
        this.#setString(env, "appsec.obfuscatorValueRegex", DD_APPSEC_OBFUSCATION_PARAMETER_VALUE_REGEXP);
        this.#setBoolean(env, "appsec.rasp.enabled", DD_APPSEC_RASP_ENABLED);
        this.#setBoolean(env, "appsec.rasp.bodyCollection", DD_APPSEC_RASP_COLLECT_REQUEST_BODY);
        env["appsec.rateLimit"] = maybeInt(DD_APPSEC_TRACE_RATE_LIMIT);
        this.#envUnprocessed["appsec.rateLimit"] = DD_APPSEC_TRACE_RATE_LIMIT;
        this.#setString(env, "appsec.rules", DD_APPSEC_RULES);
        this.#setBoolean(env, "appsec.sca.enabled", DD_APPSEC_SCA_ENABLED);
        this.#setBoolean(env, "appsec.stackTrace.enabled", DD_APPSEC_STACK_TRACE_ENABLED);
        env["appsec.stackTrace.maxDepth"] = maybeInt(DD_APPSEC_MAX_STACK_TRACE_DEPTH);
        this.#envUnprocessed["appsec.stackTrace.maxDepth"] = DD_APPSEC_MAX_STACK_TRACE_DEPTH;
        env["appsec.stackTrace.maxStackTraces"] = maybeInt(DD_APPSEC_MAX_STACK_TRACES);
        this.#envUnprocessed["appsec.stackTrace.maxStackTraces"] = DD_APPSEC_MAX_STACK_TRACES;
        env["appsec.wafTimeout"] = maybeInt(DD_APPSEC_WAF_TIMEOUT);
        this.#envUnprocessed["appsec.wafTimeout"] = DD_APPSEC_WAF_TIMEOUT;
        env.baggageMaxBytes = DD_TRACE_BAGGAGE_MAX_BYTES;
        env.baggageMaxItems = DD_TRACE_BAGGAGE_MAX_ITEMS;
        env.baggageTagKeys = DD_TRACE_BAGGAGE_TAG_KEYS;
        this.#setBoolean(env, "clientIpEnabled", DD_TRACE_CLIENT_IP_ENABLED);
        this.#setString(env, "clientIpHeader", DD_TRACE_CLIENT_IP_HEADER?.toLowerCase());
        this.#setBoolean(env, "crashtracking.enabled", DD_CRASHTRACKING_ENABLED ?? !this._isInServerlessEnvironment());
        this.#setBoolean(env, "codeOriginForSpans.enabled", DD_CODE_ORIGIN_FOR_SPANS_ENABLED);
        this.#setBoolean(
          env,
          "codeOriginForSpans.experimental.exit_spans.enabled",
          DD_CODE_ORIGIN_FOR_SPANS_EXPERIMENTAL_EXIT_SPANS_ENABLED
        );
        this.#setString(env, "dbmPropagationMode", DD_DBM_PROPAGATION_MODE);
        this.#setString(env, "dogstatsd.hostname", DD_DOGSTATSD_HOST);
        this.#setString(env, "dogstatsd.port", DD_DOGSTATSD_PORT);
        this.#setBoolean(env, "dsmEnabled", DD_DATA_STREAMS_ENABLED);
        this.#setBoolean(env, "dynamicInstrumentation.enabled", DD_DYNAMIC_INSTRUMENTATION_ENABLED);
        this.#setString(env, "dynamicInstrumentation.probeFile", DD_DYNAMIC_INSTRUMENTATION_PROBE_FILE);
        this.#setArray(env, "dynamicInstrumentation.redactedIdentifiers", DD_DYNAMIC_INSTRUMENTATION_REDACTED_IDENTIFIERS);
        this.#setArray(
          env,
          "dynamicInstrumentation.redactionExcludedIdentifiers",
          DD_DYNAMIC_INSTRUMENTATION_REDACTION_EXCLUDED_IDENTIFIERS
        );
        env["dynamicInstrumentation.uploadIntervalSeconds"] = maybeFloat(DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS);
        this.#envUnprocessed["dynamicInstrumentation.uploadInterval"] = DD_DYNAMIC_INSTRUMENTATION_UPLOAD_INTERVAL_SECONDS;
        this.#setString(env, "env", DD_ENV || tags.env);
        this.#setBoolean(env, "experimental.flaggingProvider.enabled", DD_EXPERIMENTAL_FLAGGING_PROVIDER_ENABLED);
        this.#setBoolean(env, "traceEnabled", DD_TRACE_ENABLED);
        this.#setBoolean(env, "experimental.aiguard.enabled", DD_AI_GUARD_ENABLED);
        this.#setString(env, "experimental.aiguard.endpoint", DD_AI_GUARD_ENDPOINT);
        env["experimental.aiguard.maxContentSize"] = maybeInt(DD_AI_GUARD_MAX_CONTENT_SIZE);
        this.#envUnprocessed["experimental.aiguard.maxContentSize"] = DD_AI_GUARD_MAX_CONTENT_SIZE;
        env["experimental.aiguard.maxMessagesLength"] = maybeInt(DD_AI_GUARD_MAX_MESSAGES_LENGTH);
        this.#envUnprocessed["experimental.aiguard.maxMessagesLength"] = DD_AI_GUARD_MAX_MESSAGES_LENGTH;
        env["experimental.aiguard.timeout"] = maybeInt(DD_AI_GUARD_TIMEOUT);
        this.#envUnprocessed["experimental.aiguard.timeout"] = DD_AI_GUARD_TIMEOUT;
        this.#setBoolean(env, "experimental.enableGetRumData", DD_TRACE_EXPERIMENTAL_GET_RUM_DATA_ENABLED);
        this.#setString(env, "experimental.exporter", DD_TRACE_EXPERIMENTAL_EXPORTER);
        env.flushInterval = AWS_LAMBDA_FUNCTION_NAME ? 0 : maybeInt(DD_TRACE_FLUSH_INTERVAL);
        env.flushMinSpans = maybeInt(DD_TRACE_PARTIAL_FLUSH_MIN_SPANS);
        this.#envUnprocessed.flushMinSpans = DD_TRACE_PARTIAL_FLUSH_MIN_SPANS;
        this.#setBoolean(env, "gitMetadataEnabled", DD_TRACE_GIT_METADATA_ENABLED);
        this.#setIntegerRangeSet(env, "grpc.client.error.statuses", DD_GRPC_CLIENT_ERROR_STATUSES);
        this.#setIntegerRangeSet(env, "grpc.server.error.statuses", DD_GRPC_SERVER_ERROR_STATUSES);
        this.#setArray(env, "headerTags", DD_TRACE_HEADER_TAGS);
        env["heapSnapshot.count"] = maybeInt(DD_HEAP_SNAPSHOT_COUNT);
        this.#setString(env, "heapSnapshot.destination", DD_HEAP_SNAPSHOT_DESTINATION);
        env["heapSnapshot.interval"] = maybeInt(DD_HEAP_SNAPSHOT_INTERVAL);
        this.#setString(env, "hostname", DD_AGENT_HOST);
        env["iast.dbRowsToTaint"] = maybeInt(DD_IAST_DB_ROWS_TO_TAINT);
        this.#setBoolean(env, "iast.deduplicationEnabled", DD_IAST_DEDUPLICATION_ENABLED);
        this.#setBoolean(env, "iast.enabled", DD_IAST_ENABLED);
        env["iast.maxConcurrentRequests"] = maybeInt(DD_IAST_MAX_CONCURRENT_REQUESTS);
        this.#envUnprocessed["iast.maxConcurrentRequests"] = DD_IAST_MAX_CONCURRENT_REQUESTS;
        env["iast.maxContextOperations"] = maybeInt(DD_IAST_MAX_CONTEXT_OPERATIONS);
        this.#envUnprocessed["iast.maxContextOperations"] = DD_IAST_MAX_CONTEXT_OPERATIONS;
        this.#setBoolean(env, "iast.redactionEnabled", DD_IAST_REDACTION_ENABLED && !isFalse(DD_IAST_REDACTION_ENABLED));
        this.#setString(env, "iast.redactionNamePattern", DD_IAST_REDACTION_NAME_PATTERN);
        this.#setString(env, "iast.redactionValuePattern", DD_IAST_REDACTION_VALUE_PATTERN);
        const iastRequestSampling = maybeInt(DD_IAST_REQUEST_SAMPLING);
        if (iastRequestSampling !== void 0 && iastRequestSampling > -1 && iastRequestSampling < 101) {
          env["iast.requestSampling"] = iastRequestSampling;
        }
        this.#envUnprocessed["iast.requestSampling"] = DD_IAST_REQUEST_SAMPLING;
        this.#setString(env, "iast.securityControlsConfiguration", DD_IAST_SECURITY_CONTROLS_CONFIGURATION);
        this.#setString(env, "iast.telemetryVerbosity", DD_IAST_TELEMETRY_VERBOSITY);
        this.#setBoolean(env, "iast.stackTrace.enabled", DD_IAST_STACK_TRACE_ENABLED);
        this.#setArray(env, "injectionEnabled", DD_INJECTION_ENABLED);
        this.#setString(env, "instrumentationSource", DD_INJECTION_ENABLED ? "ssi" : "manual");
        this.#setBoolean(env, "injectForce", DD_INJECT_FORCE);
        this.#setBoolean(env, "isAzureFunction", getIsAzureFunction());
        this.#setBoolean(env, "isGCPFunction", getIsGCPFunction());
        env["langchain.spanCharLimit"] = maybeInt(DD_LANGCHAIN_SPAN_CHAR_LIMIT);
        env["langchain.spanPromptCompletionSampleRate"] = maybeFloat(DD_LANGCHAIN_SPAN_PROMPT_COMPLETION_SAMPLE_RATE);
        this.#setBoolean(env, "legacyBaggageEnabled", DD_TRACE_LEGACY_BAGGAGE_ENABLED);
        this.#setBoolean(env, "llmobs.agentlessEnabled", DD_LLMOBS_AGENTLESS_ENABLED);
        this.#setBoolean(env, "llmobs.enabled", DD_LLMOBS_ENABLED);
        this.#setString(env, "llmobs.mlApp", DD_LLMOBS_ML_APP);
        this.#setBoolean(env, "logInjection", DD_LOGS_INJECTION);
        this.#setBoolean(env, "memcachedCommandEnabled", DD_TRACE_MEMCACHED_COMMAND_ENABLED);
        this.#setBoolean(env, "middlewareTracingEnabled", DD_TRACE_MIDDLEWARE_TRACING_ENABLED);
        this.#setBoolean(env, "openAiLogsEnabled", DD_OPENAI_LOGS_ENABLED);
        env["openai.spanCharLimit"] = maybeInt(DD_OPENAI_SPAN_CHAR_LIMIT);
        this.#envUnprocessed.openaiSpanCharLimit = DD_OPENAI_SPAN_CHAR_LIMIT;
        if (DD_TRACE_PEER_SERVICE_MAPPING) {
          env.peerServiceMapping = Object.fromEntries(
            DD_TRACE_PEER_SERVICE_MAPPING.split(",").map((x) => x.trim().split(":"))
          );
          this.#envUnprocessed.peerServiceMapping = DD_TRACE_PEER_SERVICE_MAPPING;
        }
        this.#setString(env, "port", DD_TRACE_AGENT_PORT);
        const profilingEnabled = normalizeProfilingEnabledValue(
          DD_PROFILING_ENABLED ?? (this._isInServerlessEnvironment() ? "false" : void 0)
        );
        this.#setString(env, "profiling.enabled", profilingEnabled);
        this.#setString(env, "profiling.exporters", DD_PROFILING_EXPORTERS);
        this.#setBoolean(env, "profiling.sourceMap", DD_PROFILING_SOURCE_MAP && !isFalse(DD_PROFILING_SOURCE_MAP));
        if (DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD) {
          env["profiling.longLivedThreshold"] = Number(DD_INTERNAL_PROFILING_LONG_LIVED_THRESHOLD);
        }
        this.#setString(env, "protocolVersion", DD_TRACE_AGENT_PROTOCOL_VERSION);
        this.#setString(env, "queryStringObfuscation", DD_TRACE_OBFUSCATION_QUERY_STRING_REGEXP);
        this.#setBoolean(env, "remoteConfig.enabled", DD_REMOTE_CONFIGURATION_ENABLED ?? !this._isInServerlessEnvironment());
        env["remoteConfig.pollInterval"] = maybeFloat(DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS);
        this.#envUnprocessed["remoteConfig.pollInterval"] = DD_REMOTE_CONFIG_POLL_INTERVAL_SECONDS;
        this.#setBoolean(env, "reportHostname", DD_TRACE_REPORT_HOSTNAME);
        const otelSetRuntimeMetrics = String(OTEL_METRICS_EXPORTER).toLowerCase() === "none" ? false : void 0;
        this.#setBoolean(env, "runtimeMetrics.enabled", DD_RUNTIME_METRICS_ENABLED || otelSetRuntimeMetrics);
        this.#setBoolean(env, "runtimeMetrics.eventLoop", DD_RUNTIME_METRICS_EVENT_LOOP_ENABLED);
        this.#setBoolean(env, "runtimeMetrics.gc", DD_RUNTIME_METRICS_GC_ENABLED);
        this.#setBoolean(env, "runtimeMetricsRuntimeId", DD_RUNTIME_METRICS_RUNTIME_ID_ENABLED);
        this.#setArray(env, "sampler.spanSamplingRules", reformatSpanSamplingRules(
          maybeJsonFile(DD_SPAN_SAMPLING_RULES_FILE) ?? safeJsonParse(DD_SPAN_SAMPLING_RULES)
        ));
        this.#setUnit(env, "sampleRate", DD_TRACE_SAMPLE_RATE || getFromOtelSamplerMap(OTEL_TRACES_SAMPLER, OTEL_TRACES_SAMPLER_ARG));
        env["sampler.rateLimit"] = DD_TRACE_RATE_LIMIT;
        this.#setSamplingRule(env, "sampler.rules", safeJsonParse(DD_TRACE_SAMPLING_RULES));
        this.#envUnprocessed["sampler.rules"] = DD_TRACE_SAMPLING_RULES;
        this.#setString(env, "scope", DD_TRACE_SCOPE);
        this.#setString(env, "service", DD_SERVICE || tags.service || OTEL_SERVICE_NAME);
        if (DD_SERVICE_MAPPING) {
          env.serviceMapping = Object.fromEntries(
            DD_SERVICE_MAPPING.split(",").map((x) => x.trim().split(":"))
          );
        }
        this.#setString(env, "site", DD_SITE);
        if (DD_TRACE_SPAN_ATTRIBUTE_SCHEMA) {
          this.#setString(env, "spanAttributeSchema", validateNamingVersion(DD_TRACE_SPAN_ATTRIBUTE_SCHEMA));
          this.#envUnprocessed.spanAttributeSchema = DD_TRACE_SPAN_ATTRIBUTE_SCHEMA;
        }
        env.spanLeakDebug = maybeInt(DD_TRACE_SPAN_LEAK_DEBUG);
        this.#setBoolean(env, "spanRemoveIntegrationFromService", DD_TRACE_REMOVE_INTEGRATION_SERVICE_NAMES_ENABLED);
        this.#setBoolean(env, "startupLogs", DD_TRACE_STARTUP_LOGS);
        this.#setTags(env, "tags", tags);
        env.tagsHeaderMaxLength = DD_TRACE_X_DATADOG_TAGS_MAX_LENGTH;
        this.#setBoolean(env, "telemetry.enabled", DD_INSTRUMENTATION_TELEMETRY_ENABLED ?? !(this._isInServerlessEnvironment() || JEST_WORKER_ID));
        this.#setString(env, "instrumentation_config_id", DD_INSTRUMENTATION_CONFIG_ID);
        this.#setBoolean(env, "telemetry.debug", DD_TELEMETRY_DEBUG);
        this.#setBoolean(env, "telemetry.dependencyCollection", DD_TELEMETRY_DEPENDENCY_COLLECTION_ENABLED);
        env["telemetry.heartbeatInterval"] = maybeInt(Math.floor(DD_TELEMETRY_HEARTBEAT_INTERVAL * 1e3));
        this.#envUnprocessed["telemetry.heartbeatInterval"] = DD_TELEMETRY_HEARTBEAT_INTERVAL * 1e3;
        this.#setBoolean(env, "telemetry.logCollection", DD_TELEMETRY_LOG_COLLECTION_ENABLED);
        this.#setBoolean(env, "telemetry.metrics", DD_TELEMETRY_METRICS_ENABLED);
        this.#setBoolean(env, "traceId128BitGenerationEnabled", DD_TRACE_128_BIT_TRACEID_GENERATION_ENABLED);
        this.#setBoolean(env, "traceId128BitLoggingEnabled", DD_TRACE_128_BIT_TRACEID_LOGGING_ENABLED);
        this.#setBoolean(env, "tracePropagationExtractFirst", DD_TRACE_PROPAGATION_EXTRACT_FIRST);
        const stringPropagationBehaviorExtract = String(DD_TRACE_PROPAGATION_BEHAVIOR_EXTRACT);
        env.tracePropagationBehaviorExtract = VALID_PROPAGATION_BEHAVIOR_EXTRACT.has(stringPropagationBehaviorExtract) ? stringPropagationBehaviorExtract : "continue";
        this.#setBoolean(
          env,
          "tracePropagationStyle.otelPropagators",
          DD_TRACE_PROPAGATION_STYLE || DD_TRACE_PROPAGATION_STYLE_INJECT || DD_TRACE_PROPAGATION_STYLE_EXTRACT ? false : !!OTEL_PROPAGATORS
        );
        this.#setBoolean(env, "traceWebsocketMessagesEnabled", DD_TRACE_WEBSOCKET_MESSAGES_ENABLED);
        this.#setBoolean(env, "traceWebsocketMessagesInheritSampling", DD_TRACE_WEBSOCKET_MESSAGES_INHERIT_SAMPLING);
        this.#setBoolean(env, "traceWebsocketMessagesSeparateTraces", DD_TRACE_WEBSOCKET_MESSAGES_SEPARATE_TRACES);
        this.#setBoolean(env, "tracing", DD_TRACING_ENABLED);
        this.#setString(env, "version", DD_VERSION || tags.version);
        this.#setBoolean(env, "inferredProxyServicesEnabled", DD_TRACE_INFERRED_PROXY_SERVICES_ENABLED);
        this.#setBoolean(env, "trace.aws.addSpanPointers", DD_TRACE_AWS_ADD_SPAN_POINTERS);
        this.#setString(env, "trace.dynamoDb.tablePrimaryKeys", DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS);
        this.#setArray(env, "graphqlErrorExtensions", DD_TRACE_GRAPHQL_ERROR_EXTENSIONS);
        this.#setBoolean(env, "trace.nativeSpanEvents", DD_TRACE_NATIVE_SPAN_EVENTS);
        env["vertexai.spanPromptCompletionSampleRate"] = maybeFloat(DD_VERTEXAI_SPAN_PROMPT_COMPLETION_SAMPLE_RATE);
        env["vertexai.spanCharLimit"] = maybeInt(DD_VERTEXAI_SPAN_CHAR_LIMIT);
      }
      #applyOptions(options) {
        const opts = this.#options;
        const tags = {};
        options = this.#optionsArg = { ingestion: {}, ...options, ...opts };
        tagger.add(tags, options.tags);
        this.#setBoolean(
          opts,
          "apmTracingEnabled",
          options.apmTracingEnabled ?? (options.experimental?.appsec?.standalone && !options.experimental.appsec.standalone.enabled)
        );
        this.#setBoolean(opts, "appsec.apiSecurity.enabled", options.appsec?.apiSecurity?.enabled);
        this.#setBoolean(
          opts,
          "appsec.apiSecurity.endpointCollectionEnabled",
          options.appsec?.apiSecurity?.endpointCollectionEnabled
        );
        opts["appsec.apiSecurity.endpointCollectionMessageLimit"] = maybeInt(options.appsec?.apiSecurity?.endpointCollectionMessageLimit);
        opts["appsec.blockedTemplateGraphql"] = maybeFile(options.appsec?.blockedTemplateGraphql);
        opts["appsec.blockedTemplateHtml"] = maybeFile(options.appsec?.blockedTemplateHtml);
        this.#optsUnprocessed["appsec.blockedTemplateHtml"] = options.appsec?.blockedTemplateHtml;
        opts["appsec.blockedTemplateJson"] = maybeFile(options.appsec?.blockedTemplateJson);
        this.#optsUnprocessed["appsec.blockedTemplateJson"] = options.appsec?.blockedTemplateJson;
        this.#setBoolean(opts, "appsec.enabled", options.appsec?.enabled);
        this.#setString(opts, "appsec.eventTracking.mode", options.appsec?.eventTracking?.mode);
        this.#setBoolean(
          opts,
          "appsec.extendedHeadersCollection.enabled",
          options.appsec?.extendedHeadersCollection?.enabled
        );
        this.#setBoolean(
          opts,
          "appsec.extendedHeadersCollection.redaction",
          options.appsec?.extendedHeadersCollection?.redaction
        );
        opts["appsec.extendedHeadersCollection.maxHeaders"] = options.appsec?.extendedHeadersCollection?.maxHeaders;
        this.#setString(opts, "appsec.obfuscatorKeyRegex", options.appsec?.obfuscatorKeyRegex);
        this.#setString(opts, "appsec.obfuscatorValueRegex", options.appsec?.obfuscatorValueRegex);
        this.#setBoolean(opts, "appsec.rasp.enabled", options.appsec?.rasp?.enabled);
        this.#setBoolean(opts, "appsec.rasp.bodyCollection", options.appsec?.rasp?.bodyCollection);
        opts["appsec.rateLimit"] = maybeInt(options.appsec?.rateLimit);
        this.#optsUnprocessed["appsec.rateLimit"] = options.appsec?.rateLimit;
        this.#setString(opts, "appsec.rules", options.appsec?.rules);
        this.#setBoolean(opts, "appsec.stackTrace.enabled", options.appsec?.stackTrace?.enabled);
        opts["appsec.stackTrace.maxDepth"] = maybeInt(options.appsec?.stackTrace?.maxDepth);
        this.#optsUnprocessed["appsec.stackTrace.maxDepth"] = options.appsec?.stackTrace?.maxDepth;
        opts["appsec.stackTrace.maxStackTraces"] = maybeInt(options.appsec?.stackTrace?.maxStackTraces);
        this.#optsUnprocessed["appsec.stackTrace.maxStackTraces"] = options.appsec?.stackTrace?.maxStackTraces;
        opts["appsec.wafTimeout"] = maybeInt(options.appsec?.wafTimeout);
        this.#optsUnprocessed["appsec.wafTimeout"] = options.appsec?.wafTimeout;
        this.#setBoolean(opts, "clientIpEnabled", options.clientIpEnabled);
        this.#setString(opts, "clientIpHeader", options.clientIpHeader?.toLowerCase());
        opts.baggageMaxBytes = options.baggageMaxBytes;
        opts.baggageMaxItems = options.baggageMaxItems;
        opts.baggageTagKeys = options.baggageTagKeys;
        this.#setBoolean(opts, "codeOriginForSpans.enabled", options.codeOriginForSpans?.enabled);
        this.#setBoolean(
          opts,
          "codeOriginForSpans.experimental.exit_spans.enabled",
          options.codeOriginForSpans?.experimental?.exit_spans?.enabled
        );
        this.#setString(opts, "dbmPropagationMode", options.dbmPropagationMode);
        if (options.dogstatsd) {
          this.#setString(opts, "dogstatsd.hostname", options.dogstatsd.hostname);
          this.#setString(opts, "dogstatsd.port", options.dogstatsd.port);
        }
        this.#setBoolean(opts, "dsmEnabled", options.dsmEnabled);
        this.#setBoolean(opts, "dynamicInstrumentation.enabled", options.dynamicInstrumentation?.enabled);
        this.#setString(opts, "dynamicInstrumentation.probeFile", options.dynamicInstrumentation?.probeFile);
        this.#setArray(
          opts,
          "dynamicInstrumentation.redactedIdentifiers",
          options.dynamicInstrumentation?.redactedIdentifiers
        );
        this.#setArray(
          opts,
          "dynamicInstrumentation.redactionExcludedIdentifiers",
          options.dynamicInstrumentation?.redactionExcludedIdentifiers
        );
        opts["dynamicInstrumentation.uploadIntervalSeconds"] = maybeFloat(options.dynamicInstrumentation?.uploadIntervalSeconds);
        this.#optsUnprocessed["dynamicInstrumentation.uploadIntervalSeconds"] = options.dynamicInstrumentation?.uploadIntervalSeconds;
        this.#setString(opts, "env", options.env || tags.env);
        this.#setBoolean(opts, "experimental.aiguard.enabled", options.experimental?.aiguard?.enabled);
        this.#setString(opts, "experimental.aiguard.endpoint", options.experimental?.aiguard?.endpoint);
        opts["experimental.aiguard.maxMessagesLength"] = maybeInt(options.experimental?.aiguard?.maxMessagesLength);
        this.#optsUnprocessed["experimental.aiguard.maxMessagesLength"] = options.experimental?.aiguard?.maxMessagesLength;
        opts["experimental.aiguard.maxContentSize"] = maybeInt(options.experimental?.aiguard?.maxContentSize);
        this.#optsUnprocessed["experimental.aiguard.maxContentSize"] = options.experimental?.aiguard?.maxContentSize;
        opts["experimental.aiguard.timeout"] = maybeInt(options.experimental?.aiguard?.timeout);
        this.#optsUnprocessed["experimental.aiguard.timeout"] = options.experimental?.aiguard?.timeout;
        this.#setBoolean(opts, "experimental.enableGetRumData", options.experimental?.enableGetRumData);
        this.#setString(opts, "experimental.exporter", options.experimental?.exporter);
        this.#setBoolean(opts, "experimental.flaggingProvider.enabled", options.experimental?.flaggingProvider?.enabled);
        opts.flushInterval = maybeInt(options.flushInterval);
        this.#optsUnprocessed.flushInterval = options.flushInterval;
        opts.flushMinSpans = maybeInt(options.flushMinSpans);
        this.#optsUnprocessed.flushMinSpans = options.flushMinSpans;
        this.#setArray(opts, "headerTags", options.headerTags);
        this.#setString(opts, "hostname", options.hostname);
        opts["iast.dbRowsToTaint"] = maybeInt(options.iast?.dbRowsToTaint);
        this.#setBoolean(opts, "iast.deduplicationEnabled", options.iast && options.iast.deduplicationEnabled);
        this.#setBoolean(
          opts,
          "iast.enabled",
          options.iast && (options.iast === true || options.iast.enabled === true)
        );
        opts["iast.maxConcurrentRequests"] = maybeInt(options.iast?.maxConcurrentRequests);
        this.#optsUnprocessed["iast.maxConcurrentRequests"] = options.iast?.maxConcurrentRequests;
        opts["iast.maxContextOperations"] = maybeInt(options.iast?.maxContextOperations);
        this.#optsUnprocessed["iast.maxContextOperations"] = options.iast?.maxContextOperations;
        this.#setBoolean(opts, "iast.redactionEnabled", options.iast?.redactionEnabled);
        this.#setString(opts, "iast.redactionNamePattern", options.iast?.redactionNamePattern);
        this.#setString(opts, "iast.redactionValuePattern", options.iast?.redactionValuePattern);
        const iastRequestSampling = maybeInt(options.iast?.requestSampling);
        if (iastRequestSampling !== void 0 && iastRequestSampling > -1 && iastRequestSampling < 101) {
          opts["iast.requestSampling"] = iastRequestSampling;
          this.#optsUnprocessed["iast.requestSampling"] = options.iast?.requestSampling;
        }
        opts["iast.securityControlsConfiguration"] = options.iast?.securityControlsConfiguration;
        this.#setBoolean(opts, "iast.stackTrace.enabled", options.iast?.stackTrace?.enabled);
        this.#setString(opts, "iast.telemetryVerbosity", options.iast && options.iast.telemetryVerbosity);
        this.#setBoolean(opts, "isCiVisibility", options.isCiVisibility);
        this.#setBoolean(opts, "legacyBaggageEnabled", options.legacyBaggageEnabled);
        this.#setBoolean(opts, "llmobs.agentlessEnabled", options.llmobs?.agentlessEnabled);
        this.#setString(opts, "llmobs.mlApp", options.llmobs?.mlApp);
        this.#setBoolean(opts, "logInjection", options.logInjection);
        opts.lookup = options.lookup;
        this.#setBoolean(opts, "middlewareTracingEnabled", options.middlewareTracingEnabled);
        this.#setBoolean(opts, "openAiLogsEnabled", options.openAiLogsEnabled);
        opts.peerServiceMapping = options.peerServiceMapping;
        this.#setBoolean(opts, "plugins", options.plugins);
        this.#setString(opts, "port", options.port);
        const strProfiling = String(options.profiling);
        if (["true", "false", "auto"].includes(strProfiling)) {
          this.#setString(opts, "profiling.enabled", strProfiling);
        }
        this.#setString(opts, "protocolVersion", options.protocolVersion);
        if (options.remoteConfig) {
          opts["remoteConfig.pollInterval"] = maybeFloat(options.remoteConfig.pollInterval);
          this.#optsUnprocessed["remoteConfig.pollInterval"] = options.remoteConfig.pollInterval;
        }
        this.#setBoolean(opts, "reportHostname", options.reportHostname);
        this.#setBoolean(opts, "runtimeMetrics.enabled", options.runtimeMetrics?.enabled);
        this.#setBoolean(opts, "runtimeMetrics.eventLoop", options.runtimeMetrics?.eventLoop);
        this.#setBoolean(opts, "runtimeMetrics.gc", options.runtimeMetrics?.gc);
        this.#setBoolean(opts, "runtimeMetricsRuntimeId", options.runtimeMetricsRuntimeId);
        this.#setArray(opts, "sampler.spanSamplingRules", reformatSpanSamplingRules(options.spanSamplingRules));
        this.#setUnit(opts, "sampleRate", options.sampleRate ?? options.ingestion.sampleRate);
        opts["sampler.rateLimit"] = maybeInt(options.rateLimit ?? options.ingestion.rateLimit);
        this.#setSamplingRule(opts, "sampler.rules", options.samplingRules);
        this.#setString(opts, "service", options.service || tags.service);
        opts.serviceMapping = options.serviceMapping;
        this.#setString(opts, "site", options.site);
        if (options.spanAttributeSchema) {
          this.#setString(opts, "spanAttributeSchema", validateNamingVersion(options.spanAttributeSchema));
          this.#optsUnprocessed.spanAttributeSchema = options.spanAttributeSchema;
        }
        this.#setBoolean(opts, "spanRemoveIntegrationFromService", options.spanRemoveIntegrationFromService);
        this.#setBoolean(opts, "startupLogs", options.startupLogs);
        this.#setTags(opts, "tags", tags);
        this.#setBoolean(opts, "traceId128BitGenerationEnabled", options.traceId128BitGenerationEnabled);
        this.#setBoolean(opts, "traceId128BitLoggingEnabled", options.traceId128BitLoggingEnabled);
        this.#setBoolean(opts, "traceWebsocketMessagesEnabled", options.traceWebsocketMessagesEnabled);
        this.#setBoolean(opts, "traceWebsocketMessagesInheritSampling", options.traceWebsocketMessagesInheritSampling);
        this.#setBoolean(opts, "traceWebsocketMessagesSeparateTraces", options.traceWebsocketMessagesSeparateTraces);
        this.#setString(opts, "version", options.version || tags.version);
        this.#setBoolean(opts, "inferredProxyServicesEnabled", options.inferredProxyServicesEnabled);
        this.#setBoolean(opts, "graphqlErrorExtensions", options.graphqlErrorExtensions);
        this.#setBoolean(opts, "trace.nativeSpanEvents", options.trace?.nativeSpanEvents);
        const llmobsEnabledEnv = this.#env["llmobs.enabled"];
        if (llmobsEnabledEnv == null && options.llmobs) {
          this.#setBoolean(opts, "llmobs.enabled", !!options.llmobs);
        }
      }
      #isCiVisibility() {
        return this.#optionsArg.isCiVisibility ?? this.#defaults.isCiVisibility;
      }
      #isCiVisibilityItrEnabled() {
        return getEnv("DD_CIVISIBILITY_ITR_ENABLED") ?? true;
      }
      #getHostname() {
        const DD_CIVISIBILITY_AGENTLESS_URL = getEnv("DD_CIVISIBILITY_AGENTLESS_URL");
        const url = DD_CIVISIBILITY_AGENTLESS_URL ? new URL2(DD_CIVISIBILITY_AGENTLESS_URL) : getAgentUrl(this._getTraceAgentUrl(), this.#optionsArg);
        const DD_AGENT_HOST = this.#optionsArg.hostname ?? getEnv("DD_AGENT_HOST") ?? defaults.hostname;
        return DD_AGENT_HOST || url?.hostname;
      }
      #getSpanComputePeerService() {
        const DD_TRACE_SPAN_ATTRIBUTE_SCHEMA = validateNamingVersion(
          this.#optionsArg.spanAttributeSchema ?? getEnv("DD_TRACE_SPAN_ATTRIBUTE_SCHEMA")
        );
        const peerServiceSet = this.#optionsArg.hasOwnProperty("spanComputePeerService") || getEnv("DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED") !== void 0;
        const peerServiceValue = this.#optionsArg.spanComputePeerService ?? getEnv("DD_TRACE_PEER_SERVICE_DEFAULTS_ENABLED");
        const spanComputePeerService = DD_TRACE_SPAN_ATTRIBUTE_SCHEMA === "v0" ? peerServiceSet && isTrue(peerServiceValue) : peerServiceSet ? !isFalse(peerServiceValue) : true;
        return spanComputePeerService;
      }
      #isTraceStatsComputationEnabled() {
        const apmTracingEnabled = this.#options.apmTracingEnabled !== false && this.#env.apmTracingEnabled !== false;
        return apmTracingEnabled && (this.#optionsArg.stats ?? getEnv("DD_TRACE_STATS_COMPUTATION_ENABLED") ?? (getIsGCPFunction() || getIsAzureFunction()));
      }
      _getTraceAgentUrl() {
        return this.#optionsArg.url ?? getEnv("DD_TRACE_AGENT_URL") ?? null;
      }
      // handles values calculated from a mixture of options and env vars
      #applyCalculated() {
        const calc = this.#calculated;
        const DD_CIVISIBILITY_AGENTLESS_URL = getEnv("DD_CIVISIBILITY_AGENTLESS_URL");
        calc.url = DD_CIVISIBILITY_AGENTLESS_URL ? new URL2(DD_CIVISIBILITY_AGENTLESS_URL) : getAgentUrl(this._getTraceAgentUrl(), this.#optionsArg);
        if (this.#isCiVisibility()) {
          this.#setBoolean(
            calc,
            "isEarlyFlakeDetectionEnabled",
            getEnv("DD_CIVISIBILITY_EARLY_FLAKE_DETECTION_ENABLED") ?? true
          );
          this.#setBoolean(calc, "isFlakyTestRetriesEnabled", getEnv("DD_CIVISIBILITY_FLAKY_RETRY_ENABLED") ?? true);
          calc.flakyTestRetriesCount = maybeInt(getEnv("DD_CIVISIBILITY_FLAKY_RETRY_COUNT")) ?? 5;
          this.#setBoolean(calc, "isIntelligentTestRunnerEnabled", isTrue(this.#isCiVisibilityItrEnabled()));
          this.#setBoolean(calc, "isManualApiEnabled", !isFalse(getEnv("DD_CIVISIBILITY_MANUAL_API_ENABLED")));
          this.#setString(calc, "ciVisibilityTestSessionName", getEnv("DD_TEST_SESSION_NAME"));
          this.#setBoolean(
            calc,
            "ciVisAgentlessLogSubmissionEnabled",
            isTrue(getEnv("DD_AGENTLESS_LOG_SUBMISSION_ENABLED"))
          );
          this.#setBoolean(
            calc,
            "isTestDynamicInstrumentationEnabled",
            !isFalse(getEnv("DD_TEST_FAILED_TEST_REPLAY_ENABLED"))
          );
          this.#setBoolean(calc, "isServiceUserProvided", !!this.#env.service);
          this.#setBoolean(calc, "isTestManagementEnabled", !isFalse(getEnv("DD_TEST_MANAGEMENT_ENABLED")));
          calc.testManagementAttemptToFixRetries = maybeInt(getEnv("DD_TEST_MANAGEMENT_ATTEMPT_TO_FIX_RETRIES")) ?? 20;
          this.#setBoolean(
            calc,
            "isImpactedTestsEnabled",
            !isFalse(getEnv("DD_CIVISIBILITY_IMPACTED_TESTS_DETECTION_ENABLED"))
          );
        }
        if (this.#env.otelLogsEnabled) {
          this.#setBoolean(calc, "logInjection", false);
        }
        calc["dogstatsd.hostname"] = this.#getHostname();
        const agentHostname = this.#getHostname();
        calc.otelLogsUrl = `http://${agentHostname}:${DEFAULT_OTLP_PORT}`;
        calc.otelUrl = `http://${agentHostname}:${DEFAULT_OTLP_PORT}`;
        this.#setBoolean(
          calc,
          "isGitUploadEnabled",
          calc.isIntelligentTestRunnerEnabled && !isFalse(getEnv("DD_CIVISIBILITY_GIT_UPLOAD_ENABLED"))
        );
        this.#setBoolean(calc, "spanComputePeerService", this.#getSpanComputePeerService());
        this.#setBoolean(calc, "stats.enabled", this.#isTraceStatsComputationEnabled());
        const defaultPropagationStyle = this.#getDefaultPropagationStyle(this.#optionsArg);
        calc["tracePropagationStyle.inject"] = propagationStyle(
          "inject",
          this.#optionsArg.tracePropagationStyle
        );
        calc["tracePropagationStyle.extract"] = propagationStyle(
          "extract",
          this.#optionsArg.tracePropagationStyle
        );
        if (defaultPropagationStyle.length > 2) {
          calc["tracePropagationStyle.inject"] = calc["tracePropagationStyle.inject"] || defaultPropagationStyle;
          calc["tracePropagationStyle.extract"] = calc["tracePropagationStyle.extract"] || defaultPropagationStyle;
        }
      }
      #applyRemote(options) {
        const opts = this.#remote;
        const tags = {};
        const headerTags = options.tracing_header_tags ? options.tracing_header_tags.map((tag) => {
          return tag.tag_name ? `${tag.header}:${tag.tag_name}` : tag.header;
        }) : void 0;
        tagger.add(tags, options.tracing_tags);
        if (Object.keys(tags).length) tags["runtime-id"] = runtimeId;
        this.#setUnit(opts, "sampleRate", options.tracing_sampling_rate);
        this.#setBoolean(opts, "logInjection", options.log_injection_enabled);
        opts.headerTags = headerTags;
        this.#setTags(opts, "tags", tags);
        this.#setBoolean(opts, "tracing", options.tracing_enabled);
        this.#remoteUnprocessed["sampler.rules"] = options.tracing_sampling_rules;
        this.#setSamplingRule(opts, "sampler.rules", this.#reformatTags(options.tracing_sampling_rules));
      }
      #reformatTags(samplingRules) {
        for (const rule of samplingRules || []) {
          const reformattedTags = {};
          if (rule.tags) {
            for (const tag of rule.tags) {
              reformattedTags[tag.key] = tag.value_glob;
            }
            rule.tags = reformattedTags;
          }
        }
        return samplingRules;
      }
      #setBoolean(obj, name, value) {
        if (value === void 0 || value === null) {
          obj[name] = value;
        } else if (isTrue(value)) {
          obj[name] = true;
        } else if (isFalse(value)) {
          obj[name] = false;
        }
      }
      #setUnit(obj, name, value) {
        if (value === null || value === void 0) {
          obj[name] = value;
          return;
        }
        value = Number.parseFloat(value);
        if (!Number.isNaN(value)) {
          obj[name] = Math.min(Math.max(value, 0), 1);
        }
      }
      #setArray(obj, name, value) {
        if (value == null) {
          obj[name] = null;
          return;
        }
        if (typeof value === "string") {
          value = value.split(",").map((item) => {
            const [key, val] = item.split(":").map((part) => part.trim());
            return val === void 0 ? key : `${key}:${val}`;
          });
        }
        if (Array.isArray(value)) {
          obj[name] = value;
        }
      }
      #setIntegerRangeSet(obj, name, value) {
        if (value == null) {
          obj[name] = null;
          return;
        }
        value = value.split(",");
        const result = [];
        value.forEach((val) => {
          if (val.includes("-")) {
            const [start, end] = val.split("-").map(Number);
            for (let i = start; i <= end; i++) {
              result.push(i);
            }
          } else {
            result.push(Number(val));
          }
        });
        obj[name] = result;
      }
      #setSamplingRule(obj, name, value) {
        if (value == null) {
          obj[name] = null;
          return;
        }
        if (typeof value === "string") {
          value = value.split(",");
        }
        if (Array.isArray(value)) {
          value = value.map((rule) => {
            return remapify(rule, {
              sample_rate: "sampleRate"
            });
          });
          obj[name] = value;
        }
      }
      #setString(obj, name, value) {
        obj[name] = value ? String(value) : void 0;
      }
      #setTags(obj, name, value) {
        if (!value || Object.keys(value).length === 0) {
          obj[name] = null;
          return;
        }
        obj[name] = value;
      }
      #setAndTrackChange({ name, value, origin, unprocessedValue, changes }) {
        set2(this, name, value);
        if (!changeTracker[name]) {
          changeTracker[name] = {};
        }
        const originExists = origin in changeTracker[name];
        const oldValue = changeTracker[name][origin];
        if (!originExists || oldValue !== value) {
          changeTracker[name][origin] = value;
          changes.push({
            name,
            value: unprocessedValue || value,
            origin
          });
        }
      }
      // TODO: Report origin changes and errors to telemetry.
      // TODO: Deeply merge configurations.
      // TODO: Move change tracking to telemetry.
      // for telemetry reporting, `name`s in `containers` need to be keys from:
      // https://github.com/DataDog/dd-go/blob/prod/trace/apps/tracer-telemetry-intake/telemetry-payload/static/config_norm_rules.json
      #merge() {
        const changes = [];
        const sources = this.#getSourcesInOrder();
        for (const name of Object.keys(this.#defaults)) {
          for (let i = sources.length - 1; i >= 0; i--) {
            const { container, origin, unprocessed } = sources[i];
            const value = container[name];
            if (value != null || container === this.#defaults) {
              this.#setAndTrackChange({
                name,
                value,
                origin,
                unprocessedValue: unprocessed?.[name],
                changes
              });
            }
          }
        }
        this.sampler.sampleRate = this.sampleRate;
        updateConfig(changes, this);
      }
      getOrigin(name) {
        for (const { container, origin } of this.#getSourcesInOrder()) {
          const value = container[name];
          if (value != null || container === this.#defaults) {
            return origin;
          }
        }
      }
      #loadGitMetadata(envs) {
        this.repositoryUrl = removeUserSensitiveInfo(
          envs.DD_GIT_REPOSITORY_URL ?? this.tags[GIT_REPOSITORY_URL]
        );
        this.commitSHA = envs.DD_GIT_COMMIT_SHA ?? this.tags[GIT_COMMIT_SHA];
        if (!this.repositoryUrl || !this.commitSHA) {
          const DD_GIT_PROPERTIES_FILE = envs.DD_GIT_PROPERTIES_FILE ?? `${process.cwd()}/git.properties`;
          let gitPropertiesString;
          try {
            gitPropertiesString = fs.readFileSync(DD_GIT_PROPERTIES_FILE, "utf8");
          } catch (e) {
            if (envs.DD_GIT_PROPERTIES_FILE) {
              log.error("Error reading DD_GIT_PROPERTIES_FILE: %s", DD_GIT_PROPERTIES_FILE, e);
            }
          }
          if (gitPropertiesString) {
            const { commitSHA, repositoryUrl } = getGitMetadataFromGitProperties(gitPropertiesString);
            this.commitSHA = this.commitSHA || commitSHA;
            this.repositoryUrl = this.repositoryUrl || repositoryUrl;
          }
        }
        if (!this.repositoryUrl || !this.commitSHA) {
          const DD_GIT_FOLDER_PATH = envs.DD_GIT_FOLDER_PATH ?? path.join(process.cwd(), ".git");
          if (!this.repositoryUrl) {
            const gitConfigPath = path.join(DD_GIT_FOLDER_PATH, "config");
            try {
              const gitConfigContent = fs.readFileSync(gitConfigPath, "utf8");
              if (gitConfigContent) {
                this.repositoryUrl = getRemoteOriginURL(gitConfigContent);
              }
            } catch (e) {
              if (envs.DD_GIT_FOLDER_PATH) {
                log.error("Error reading git config: %s", gitConfigPath, e);
              }
            }
          }
          if (!this.commitSHA) {
            const gitHeadSha = resolveGitHeadSHA(DD_GIT_FOLDER_PATH);
            if (gitHeadSha) {
              this.commitSHA = gitHeadSha;
            }
          }
        }
      }
    };
    function handleOtel(tagString) {
      return tagString?.replace(/(^|,)deployment\.environment=/, "$1env:").replace(/(^|,)service\.name=/, "$1service:").replace(/(^|,)service\.version=/, "$1version:").replaceAll("=", ":");
    }
    function parseSpaceSeparatedTags(tagString) {
      if (tagString && !tagString.includes(",")) {
        tagString = tagString.replaceAll(/\s+/g, ",");
      }
      return tagString;
    }
    function maybeInt(number) {
      const parsed = Number.parseInt(number);
      return Number.isNaN(parsed) ? void 0 : parsed;
    }
    function maybeFloat(number) {
      const parsed = Number.parseFloat(number);
      return Number.isNaN(parsed) ? void 0 : parsed;
    }
    function getAgentUrl(url, options) {
      if (url) return new URL2(url);
      if (os.type() === "Windows_NT") return;
      if (!options.hostname && !options.port && !getEnv("DD_AGENT_HOST") && !getEnv("DD_TRACE_AGENT_PORT") && fs.existsSync("/var/run/datadog/apm.socket")) {
        return new URL2("unix:///var/run/datadog/apm.socket");
      }
    }
    module2.exports = Config;
  }
});

// ../../packages/dd-trace/src/debugger/config.js
var require_config3 = __commonJS({
  "../../packages/dd-trace/src/debugger/config.js"(exports2, module2) {
    "use strict";
    module2.exports = function getDebuggerConfig(config) {
      return {
        commitSHA: config.commitSHA,
        debug: config.debug,
        dynamicInstrumentation: config.dynamicInstrumentation,
        hostname: config.hostname,
        logLevel: config.logLevel,
        port: config.port,
        repositoryUrl: config.repositoryUrl,
        runtimeId: config.tags["runtime-id"],
        service: config.service,
        url: config.url?.toString()
      };
    };
  }
});

// ../../packages/dd-trace/src/debugger/index.js
var require_debugger = __commonJS({
  "../../packages/dd-trace/src/debugger/index.js"(exports2, module2) {
    "use strict";
    var { readFile } = __require("fs");
    var { types } = __require("util");
    var { join } = __require("path");
    var { Worker, MessageChannel: MessageChannel2, threadId: parentThreadId } = __require("worker_threads");
    var getDebuggerConfig = require_config3();
    var log = require_log2();
    var worker = null;
    var configChannel = null;
    var ackId = 0;
    var { NODE_OPTIONS, ...env } = process.env;
    module2.exports = {
      start,
      configure
    };
    function start(config, rc) {
      if (worker !== null) return;
      log.debug("[debugger] Starting Dynamic Instrumentation client...");
      const rcAckCallbacks = /* @__PURE__ */ new Map();
      const probeChannel = new MessageChannel2();
      const logChannel = new MessageChannel2();
      configChannel = new MessageChannel2();
      process[Symbol.for("datadog:node:util:types")] = types;
      readProbeFile(config.dynamicInstrumentation.probeFile, (probes) => {
        const action = "apply";
        for (const probe of probes) {
          probeChannel.port2.postMessage({ action, probe });
        }
      });
      rc.setProductHandler("LIVE_DEBUGGING", (action, probe, id, ack) => {
        rcAckCallbacks.set(++ackId, ack);
        probeChannel.port2.postMessage({ action, probe, ackId });
      });
      probeChannel.port2.on("message", ({ ackId: ackId2, error }) => {
        const ack = rcAckCallbacks.get(ackId2);
        if (ack === void 0) {
          log.error("[debugger] Received an unknown ackId: %s", ackId2);
          if (error) log.error("[debugger] Error starting Dynamic Instrumentation client", error);
          return;
        }
        ack(error);
        rcAckCallbacks.delete(ackId2);
      });
      probeChannel.port2.on("messageerror", (err) => log.error('[debugger] received "messageerror" on probe port', err));
      logChannel.port2.on("message", ({ level, args }) => {
        log[level](...args);
      });
      logChannel.port2.on("messageerror", (err) => log.error('[debugger] received "messageerror" on log port', err));
      worker = new Worker(
        join(__dirname, "devtools_client", "index.js"),
        {
          execArgv: [],
          // Avoid worker thread inheriting the `-r` command line argument
          env,
          // Avoid worker thread inheriting the `NODE_OPTIONS` environment variable (in case it contains `-r`)
          workerData: {
            config: getDebuggerConfig(config),
            parentThreadId,
            probePort: probeChannel.port1,
            logPort: logChannel.port1,
            configPort: configChannel.port1
          },
          transferList: [probeChannel.port1, logChannel.port1, configChannel.port1]
        }
      );
      worker.on("online", () => {
        log.debug("[debugger] Dynamic Instrumentation worker thread started successfully (thread id: %d)", worker.threadId);
      });
      worker.on("error", (err) => log.error("[debugger] worker thread error", err));
      worker.on("messageerror", (err) => log.error('[debugger] received "messageerror" from worker', err));
      worker.on("exit", (code) => {
        const error = new Error(`Dynamic Instrumentation worker thread exited unexpectedly with code ${code}`);
        log.error("[debugger] worker thread exited unexpectedly", error);
        rc.removeProductHandler("LIVE_DEBUGGING");
        worker.removeAllListeners();
        configChannel = null;
        for (const ackId2 of rcAckCallbacks.keys()) {
          rcAckCallbacks.get(ackId2)(error);
          rcAckCallbacks.delete(ackId2);
        }
      });
      worker.unref();
      probeChannel.port1.unref();
      probeChannel.port2.unref();
      logChannel.port1.unref();
      logChannel.port2.unref();
      configChannel.port1.unref();
      configChannel.port2.unref();
    }
    function configure(config) {
      if (configChannel === null) return;
      configChannel.port2.postMessage(getDebuggerConfig(config));
    }
    function readProbeFile(path, cb) {
      if (!path) return;
      log.debug("[debugger] Reading probe file: %s", path);
      readFile(path, "utf8", (err, data) => {
        if (err) {
          log.error("[debugger] Failed to read probe file: %s", path, err);
          return;
        }
        try {
          const parsedData = JSON.parse(data);
          log.debug("[debugger] Successfully parsed probe file: %s", path);
          cb(parsedData);
        } catch (err2) {
          log.error("[debugger] Probe file (%s) is not valid JSON", path, err2);
        }
      });
    }
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/definition.js
var require_definition = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/definition.js"(exports2, module2) {
    "use strict";
    var SchemaDefinition = class {
      constructor(schema) {
        this.schema = schema;
      }
      getOpName(type, kind, plugin, opts) {
        const item = this.schema[type][kind][plugin];
        return item.opName(opts);
      }
      getServiceName(type, kind, plugin, opts) {
        const item = this.schema[type][kind][plugin];
        return item.serviceName(opts);
      }
    };
    module2.exports = SchemaDefinition;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/util.js
var require_util5 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/util.js"(exports2, module2) {
    "use strict";
    function identityService({ tracerService }) {
      return tracerService;
    }
    function getFormattedHostString({ host, port }) {
      return [host, port].filter(Boolean).join(":");
    }
    function httpPluginClientService({ tracerService, pluginConfig, sessionDetails }) {
      if (pluginConfig.splitByDomain) {
        return getFormattedHostString(sessionDetails);
      } else if (pluginConfig.service) {
        return pluginConfig.service;
      }
      return tracerService;
    }
    function awsServiceV0({ tracerService, awsService }) {
      return `${tracerService}-aws-${awsService}`;
    }
    module2.exports = { identityService, httpPluginClientService, awsServiceV0 };
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/messaging.js
var require_messaging = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/messaging.js"(exports2, module2) {
    "use strict";
    var { identityService, awsServiceV0 } = require_util5();
    function amqpServiceName({ tracerService }) {
      return `${tracerService}-amqp`;
    }
    var messaging = {
      producer: {
        amqplib: {
          opName: () => "amqp.command",
          serviceName: amqpServiceName
        },
        amqp10: {
          opName: () => "amqp.send",
          serviceName: amqpServiceName
        },
        "azure-event-hubs": {
          opName: () => "azure.eventhubs.send",
          serviceName: ({ tracerService }) => `${tracerService}-azure-event-hubs`
        },
        "azure-service-bus": {
          opName: () => "azure.servicebus.send",
          serviceName: ({ tracerService }) => `${tracerService}-azure-service-bus`
        },
        "google-cloud-pubsub": {
          opName: () => "pubsub.request",
          serviceName: ({ tracerService }) => `${tracerService}-pubsub`
        },
        kafkajs: {
          opName: () => "kafka.produce",
          serviceName: ({ tracerService }) => `${tracerService}-kafka`
        },
        "confluentinc-kafka-javascript": {
          opName: () => "kafka.produce",
          serviceName: ({ tracerService }) => `${tracerService}-kafka`
        },
        rhea: {
          opName: () => "amqp.send",
          serviceName: ({ tracerService }) => `${tracerService}-amqp-producer`
        },
        sqs: {
          opName: () => "aws.request",
          serviceName: awsServiceV0
        },
        sns: {
          opName: () => "aws.request",
          serviceName: awsServiceV0
        }
      },
      consumer: {
        amqplib: {
          opName: () => "amqp.command",
          serviceName: amqpServiceName
        },
        amqp10: {
          opName: () => "amqp.receive",
          serviceName: amqpServiceName
        },
        "google-cloud-pubsub": {
          opName: () => "pubsub.receive",
          serviceName: identityService
        },
        kafkajs: {
          opName: () => "kafka.consume",
          serviceName: ({ tracerService }) => `${tracerService}-kafka`
        },
        "confluentinc-kafka-javascript": {
          opName: () => "kafka.consume",
          serviceName: ({ tracerService }) => `${tracerService}-kafka`
        },
        rhea: {
          opName: () => "amqp.receive",
          serviceName: identityService
        },
        sqs: {
          opName: () => "aws.request",
          serviceName: awsServiceV0
        }
      },
      client: {
        amqplib: {
          opName: () => "amqp.command",
          serviceName: amqpServiceName
        },
        "google-cloud-pubsub": {
          opName: () => "pubsub.request",
          serviceName: ({ tracerService }) => `${tracerService}-pubsub`
        }
      }
    };
    module2.exports = messaging;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/storage.js
var require_storage2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/storage.js"(exports2, module2) {
    "use strict";
    function getRedisService(pluginConfig, connectionName) {
      if (pluginConfig.splitByInstance && connectionName) {
        return pluginConfig.service ? `${pluginConfig.service}-${connectionName}` : connectionName;
      }
      return pluginConfig.service;
    }
    function fromSystem(tracerService, system) {
      return system ? `${tracerService}-${system}` : void 0;
    }
    function mysqlServiceName({ tracerService, pluginConfig, dbConfig, system }) {
      if (typeof pluginConfig.service === "function") {
        return pluginConfig.service(dbConfig);
      }
      return pluginConfig.service || fromSystem(tracerService, system);
    }
    function withSuffixFunction(suffix) {
      return ({ tracerService, pluginConfig, params }) => {
        if (typeof pluginConfig.service === "function") {
          return pluginConfig.service(params);
        }
        return pluginConfig.service || `${tracerService}-${suffix}`;
      };
    }
    var redisConfig = {
      opName: () => "redis.command",
      serviceName: ({ tracerService, pluginConfig, system, connectionName }) => {
        return getRedisService(pluginConfig, connectionName) || fromSystem(tracerService, system);
      }
    };
    var valkeyConfig = {
      opName: () => "valkey.command",
      serviceName: ({ tracerService, pluginConfig, system, connectionName }) => {
        return getRedisService(pluginConfig, connectionName) || fromSystem(tracerService, system);
      }
    };
    var storage = {
      client: {
        aerospike: {
          opName: () => "aerospike.command",
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-aerospike`
        },
        "cassandra-driver": {
          opName: () => "cassandra.query",
          serviceName: ({ tracerService, pluginConfig, system }) => pluginConfig.service || fromSystem(tracerService, system)
        },
        couchbase: {
          opName: ({ operation }) => `couchbase.${operation}`,
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-couchbase`
        },
        elasticsearch: {
          opName: () => "elasticsearch.query",
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-elasticsearch`
        },
        ioredis: redisConfig,
        iovalkey: valkeyConfig,
        mariadb: {
          opName: () => "mariadb.query",
          serviceName: mysqlServiceName
        },
        memcached: {
          opName: () => "memcached.command",
          serviceName: ({ tracerService, pluginConfig, system }) => pluginConfig.service || fromSystem(tracerService, system)
        },
        "mongodb-core": {
          opName: () => "mongodb.query",
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-mongodb`
        },
        mysql: {
          opName: () => "mysql.query",
          serviceName: mysqlServiceName
        },
        mysql2: {
          opName: () => "mysql.query",
          serviceName: mysqlServiceName
        },
        opensearch: {
          opName: () => "opensearch.query",
          serviceName: ({ tracerService, pluginConfig }) => pluginConfig.service || `${tracerService}-opensearch`
        },
        oracledb: {
          opName: () => "oracle.query",
          serviceName: withSuffixFunction("oracle")
        },
        pg: {
          opName: () => "pg.query",
          serviceName: withSuffixFunction("postgres")
        },
        prisma: {
          opName: ({ operation }) => `prisma.${operation}`,
          serviceName: withSuffixFunction("prisma")
        },
        redis: redisConfig,
        tedious: {
          opName: () => "tedious.request",
          serviceName: ({ tracerService, pluginConfig, system }) => pluginConfig.service || fromSystem(tracerService, system)
        }
      }
    };
    module2.exports = storage;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/graphql.js
var require_graphql2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/graphql.js"(exports2, module2) {
    "use strict";
    var { identityService } = require_util5();
    var graphql = {
      server: {
        graphql: {
          opName: () => "graphql.execute",
          serviceName: identityService
        }
      }
    };
    module2.exports = graphql;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/web.js
var require_web = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/web.js"(exports2, module2) {
    "use strict";
    var { identityService, httpPluginClientService, awsServiceV0 } = require_util5();
    var web = {
      client: {
        grpc: {
          opName: () => "grpc.client",
          serviceName: identityService
        },
        moleculer: {
          opName: () => "moleculer.call",
          serviceName: identityService
        },
        http: {
          opName: () => "http.request",
          serviceName: httpPluginClientService
        },
        fetch: {
          opName: () => "http.request",
          serviceName: httpPluginClientService
        },
        http2: {
          opName: () => "http.request",
          serviceName: httpPluginClientService
        },
        aws: {
          opName: () => "aws.request",
          serviceName: awsServiceV0
        },
        lambda: {
          opName: () => "aws.request",
          serviceName: awsServiceV0
        },
        undici: {
          opName: () => "undici.request",
          serviceName: httpPluginClientService
        }
      },
      server: {
        "apollo.gateway.request": {
          opName: () => "apollo.gateway.request",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.plan": {
          opName: () => "apollo.gateway.plan",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.validate": {
          opName: () => "apollo.gateway.validate",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.execute": {
          opName: () => "apollo.gateway.execute",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.fetch": {
          opName: () => "apollo.gateway.fetch",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.postprocessing": {
          opName: () => "apollo.gateway.postprocessing",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        grpc: {
          opName: () => "grpc.server",
          serviceName: identityService
        },
        moleculer: {
          opName: () => "moleculer.action",
          serviceName: identityService
        },
        http: {
          opName: () => "web.request",
          serviceName: identityService
        },
        http2: {
          opName: () => "web.request",
          serviceName: identityService
        },
        next: {
          opName: () => "next.request",
          serviceName: identityService
        }
      }
    };
    module2.exports = web;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/serverless.js
var require_serverless2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/serverless.js"(exports2, module2) {
    "use strict";
    var { identityService } = require_util5();
    var serverless = {
      server: {
        "azure-functions": {
          opName: () => "azure.functions.invoke",
          serviceName: identityService
        }
      }
    };
    module2.exports = serverless;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/websocket.js
var require_websocket = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/websocket.js"(exports2, module2) {
    "use strict";
    var websocket = {
      request: {
        ws: {
          opName: () => "web.request",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      producer: {
        ws: {
          opName: () => "websocket.send",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      consumer: {
        ws: {
          opName: () => "websocket.receive",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      close: {
        ws: {
          opName: () => "websocket.close",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      }
    };
    module2.exports = websocket;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v0/index.js
var require_v0 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v0/index.js"(exports2, module2) {
    "use strict";
    var SchemaDefinition = require_definition();
    var messaging = require_messaging();
    var storage = require_storage2();
    var graphql = require_graphql2();
    var web = require_web();
    var serverless = require_serverless2();
    var websocket = require_websocket();
    module2.exports = new SchemaDefinition({ messaging, storage, web, graphql, serverless, websocket });
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/messaging.js
var require_messaging2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/messaging.js"(exports2, module2) {
    "use strict";
    var { identityService } = require_util5();
    var amqpInbound = {
      opName: () => "amqp.process",
      serviceName: identityService
    };
    var amqpOutbound = {
      opName: () => "amqp.send",
      serviceName: identityService
    };
    var messaging = {
      producer: {
        amqplib: amqpOutbound,
        amqp10: amqpOutbound,
        "azure-service-bus": {
          opName: () => "azure.servicebus.send",
          serviceName: identityService
        },
        "azure-event-hubs": {
          opName: () => "azure.eventhubs.send",
          serviceName: identityService
        },
        "google-cloud-pubsub": {
          opName: () => "gcp.pubsub.send",
          serviceName: identityService
        },
        kafkajs: {
          opName: () => "kafka.send",
          serviceName: identityService
        },
        "confluentinc-kafka-javascript": {
          opName: () => "kafka.send",
          serviceName: identityService
        },
        rhea: amqpOutbound,
        sqs: {
          opName: () => "aws.sqs.send",
          serviceName: identityService
        },
        sns: {
          opName: () => "aws.sns.send",
          serviceName: identityService
        }
      },
      consumer: {
        amqplib: amqpInbound,
        amqp10: amqpInbound,
        "google-cloud-pubsub": {
          opName: () => "gcp.pubsub.process",
          serviceName: identityService
        },
        kafkajs: {
          opName: () => "kafka.process",
          serviceName: identityService
        },
        "confluentinc-kafka-javascript": {
          opName: () => "kafka.process",
          serviceName: identityService
        },
        rhea: amqpInbound,
        sqs: {
          opName: () => "aws.sqs.process",
          serviceName: identityService
        }
      },
      client: {
        amqplib: {
          opName: () => "amqp.command",
          serviceName: identityService
        },
        "google-cloud-pubsub": {
          opName: () => "gcp.pubsub.request",
          serviceName: identityService
        }
      }
    };
    module2.exports = messaging;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/storage.js
var require_storage3 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/storage.js"(exports2, module2) {
    "use strict";
    function configWithFallback({ tracerService, pluginConfig }) {
      return pluginConfig.service || tracerService;
    }
    var redisNaming = {
      opName: () => "redis.command",
      serviceName: configWithFallback
    };
    var mySQLNaming = {
      opName: () => "mysql.query",
      serviceName: withFunction
    };
    function withFunction({ tracerService, pluginConfig, params }) {
      if (typeof pluginConfig.service === "function") {
        const result = pluginConfig.service(params);
        return typeof result === "string" && result.length > 0 ? result : tracerService;
      }
      return configWithFallback({ tracerService, pluginConfig });
    }
    var storage = {
      client: {
        aerospike: {
          opName: () => "aerospike.command",
          serviceName: configWithFallback
        },
        "cassandra-driver": {
          opName: () => "cassandra.query",
          serviceName: configWithFallback
        },
        couchbase: {
          opName: () => "couchbase.query",
          serviceName: configWithFallback
        },
        elasticsearch: {
          opName: () => "elasticsearch.query",
          serviceName: configWithFallback
        },
        ioredis: redisNaming,
        iovalkey: {
          opName: () => "valkey.command",
          serviceName: configWithFallback
        },
        mariadb: {
          opName: () => "mariadb.query",
          serviceName: withFunction
        },
        memcached: {
          opName: () => "memcached.command",
          serviceName: configWithFallback
        },
        "mongodb-core": {
          opName: () => "mongodb.query",
          serviceName: configWithFallback
        },
        mysql: mySQLNaming,
        mysql2: mySQLNaming,
        opensearch: {
          opName: () => "opensearch.query",
          serviceName: configWithFallback
        },
        oracledb: {
          opName: () => "oracle.query",
          serviceName: withFunction
        },
        pg: {
          opName: () => "postgresql.query",
          serviceName: withFunction
        },
        prisma: {
          opName: ({ operation }) => `prisma.${operation}`,
          serviceName: configWithFallback
        },
        redis: redisNaming,
        tedious: {
          opName: () => "mssql.query",
          serviceName: configWithFallback
        }
      }
    };
    module2.exports = storage;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/graphql.js
var require_graphql3 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/graphql.js"(exports2, module2) {
    "use strict";
    var { identityService } = require_util5();
    var graphql = {
      server: {
        graphql: {
          opName: () => "graphql.server.request",
          serviceName: identityService
        }
      }
    };
    module2.exports = graphql;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/web.js
var require_web2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/web.js"(exports2, module2) {
    "use strict";
    var { identityService, httpPluginClientService } = require_util5();
    var web = {
      client: {
        grpc: {
          opName: () => "grpc.client.request",
          serviceName: identityService
        },
        moleculer: {
          opName: () => "moleculer.client.request",
          serviceName: identityService
        },
        http: {
          opName: () => "http.client.request",
          serviceName: httpPluginClientService
        },
        fetch: {
          opName: () => "http.client.request",
          serviceName: httpPluginClientService
        },
        http2: {
          opName: () => "http.client.request",
          serviceName: httpPluginClientService
        },
        aws: {
          opName: ({ awsService }) => `aws.${awsService}.request`,
          serviceName: identityService
        },
        lambda: {
          opName: () => "aws.lambda.invoke",
          serviceName: identityService
        },
        undici: {
          opName: () => "undici.request",
          serviceName: httpPluginClientService
        }
      },
      server: {
        "apollo.gateway.request": {
          opName: () => "apollo.gateway.request",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.plan": {
          opName: () => "apollo.gateway.plan",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.validate": {
          opName: () => "apollo.gateway.validate",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.execute": {
          opName: () => "apollo.gateway.execute",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.fetch": {
          opName: () => "apollo.gateway.fetch",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        "apollo.gateway.postprocessing": {
          opName: () => "apollo.gateway.postprocessing",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        },
        grpc: {
          opName: () => "grpc.server.request",
          serviceName: identityService
        },
        moleculer: {
          opName: () => "moleculer.server.request",
          serviceName: identityService
        },
        http: {
          opName: () => "http.server.request",
          serviceName: identityService
        },
        http2: {
          opName: () => "http.server.request",
          serviceName: identityService
        },
        next: {
          opName: () => "http.server.request",
          serviceName: identityService
        }
      }
    };
    module2.exports = web;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/serverless.js
var require_serverless3 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/serverless.js"(exports2, module2) {
    "use strict";
    var { identityService } = require_util5();
    var serverless = {
      server: {
        "azure-functions": {
          opName: () => "azure.functions.invoke",
          serviceName: identityService
        }
      }
    };
    module2.exports = serverless;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/websocket.js
var require_websocket2 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/websocket.js"(exports2, module2) {
    "use strict";
    var websocket = {
      request: {
        ws: {
          opName: () => "web.request",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      producer: {
        ws: {
          opName: () => "websocket.send",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      consumer: {
        ws: {
          opName: () => "websocket.receive",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      },
      close: {
        ws: {
          opName: () => "websocket.close",
          serviceName: ({ pluginConfig, tracerService }) => pluginConfig.service || tracerService
        }
      }
    };
    module2.exports = websocket;
  }
});

// ../../packages/dd-trace/src/service-naming/schemas/v1/index.js
var require_v1 = __commonJS({
  "../../packages/dd-trace/src/service-naming/schemas/v1/index.js"(exports2, module2) {
    "use strict";
    var SchemaDefinition = require_definition();
    var messaging = require_messaging2();
    var storage = require_storage3();
    var graphql = require_graphql3();
    var web = require_web2();
    var serverless = require_serverless3();
    var websocket = require_websocket2();
    module2.exports = new SchemaDefinition({ messaging, storage, web, graphql, serverless, websocket });
  }
});

// ../../packages/dd-trace/src/service-naming/index.js
var require_service_naming = __commonJS({
  "../../packages/dd-trace/src/service-naming/index.js"(exports2, module2) {
    "use strict";
    var SchemaManager = class {
      constructor() {
        this.schemas = {};
        this.configure({ spanAttributeSchema: "v0", spanRemoveIntegrationFromService: false });
      }
      get schema() {
        return this.schemas[this.version];
      }
      get version() {
        return this.config.spanAttributeSchema;
      }
      get shouldUseConsistentServiceNaming() {
        return this.config.spanRemoveIntegrationFromService && this.version === "v0";
      }
      opName(type, kind, plugin, opts) {
        return this.schema.getOpName(type, kind, plugin, opts);
      }
      serviceName(type, kind, plugin, opts) {
        const schema = this.shouldUseConsistentServiceNaming ? this.schemas.v1 : this.schema;
        return schema.getServiceName(type, kind, plugin, { ...opts, tracerService: this.config.service });
      }
      configure(config = {}) {
        const { spanAttributeSchema, spanRemoveIntegrationFromService } = config;
        if (!this.schemas.v0 && spanAttributeSchema === "v0") {
          this.schemas.v0 = require_v0();
        }
        if (!this.schemas.v1 && (spanAttributeSchema === "v1" || spanRemoveIntegrationFromService)) {
          this.schemas.v1 = require_v1();
        }
        this.config = config;
      }
    };
    module2.exports = new SchemaManager();
  }
});

// ../../packages/dd-trace/src/plugins/plugin.js
var require_plugin = __commonJS({
  "../../packages/dd-trace/src/plugins/plugin.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var logger = require_log2();
    var { storage } = require_datadog_core();
    var Subscription = class {
      constructor(event, handler) {
        this._channel = dc.channel(event);
        this._handler = (message, name) => {
          const store = storage("legacy").getStore();
          if (!store || !store.noop) {
            handler(message, name);
          }
        };
      }
      enable() {
        this._channel.subscribe(this._handler);
      }
      disable() {
        this._channel.unsubscribe(this._handler);
      }
    };
    var StoreBinding = class {
      constructor(event, transform) {
        this._channel = dc.channel(event);
        this._transform = (data) => {
          const store = storage("legacy").getStore();
          return !store || !store.noop || data && Object.hasOwn(data, "currentStore") ? transform(data) : store;
        };
      }
      enable() {
        this._channel.bindStore(storage("legacy"), this._transform);
      }
      disable() {
        this._channel.unbindStore(storage("legacy"));
      }
    };
    module2.exports = class Plugin {
      /**
       * Create a new plugin instance.
       *
       * @param {object} tracer Tracer instance or wrapper containing it under `_tracer`.
       * @param {object} tracerConfig Global tracer configuration object.
       */
      constructor(tracer2, tracerConfig) {
        this._subscriptions = [];
        this._bindings = [];
        this._enabled = false;
        this._tracer = tracer2;
        this.config = {};
        this._tracerConfig = tracerConfig;
      }
      /**
       * Normalized tracer access. Returns the underlying tracer even if wrapped.
       *
       * @returns {object}
       */
      get tracer() {
        return this._tracer?._tracer || this._tracer;
      }
      /**
       * Enter a context with the provided span bound in storage.
       *
       * @param {object} span The span to bind as current.
       * @param {object=} store Optional existing store to extend; if omitted, uses current store.
       * @returns {void}
       */
      enter(span, store) {
        store = store || storage("legacy").getStore();
        storage("legacy").enterWith({ ...store, span });
      }
      // TODO: Implement filters on resource name for all plugins.
      /** Prevents creation of spans here and for all async descendants. */
      skip() {
        storage("legacy").enterWith({ noop: true });
      }
      /**
       * Subscribe to a diagnostic channel with automatic error handling and enable/disable lifecycle.
       *
       * @param {string} channelName Diagnostic channel name.
       * @param {(...args: unknown[]) => unknown} handler Handler invoked on messages.
       * @returns {void}
       */
      addSub(channelName, handler) {
        const plugin = this;
        const wrappedHandler = function() {
          try {
            return handler.apply(this, arguments);
          } catch (e) {
            logger.error("Error in plugin handler:", e);
            logger.info("Disabling plugin: %s", plugin.id);
            plugin.configure(false);
          }
        };
        this._subscriptions.push(new Subscription(channelName, wrappedHandler));
      }
      /**
       * Bind the tracer store to a diagnostic channel with a transform function.
       *
       * @param {string} channelName Diagnostic channel name.
       * @param {(data: unknown) => object} transform Transform to compute the bound store.
       * @returns {void}
       */
      addBind(channelName, transform) {
        this._bindings.push(new StoreBinding(channelName, transform));
      }
      /**
       * Attach an error to the current active span (if any).
       *
       * @param {unknown} error Error object or sentinel value.
       * @returns {void}
       */
      addError(error) {
        const store = storage("legacy").getStore();
        if (!store || !store.span) return;
        if (!store.span._spanContext._tags.error) {
          store.span.setTag("error", error || 1);
        }
      }
      /**
       * Enable or disable the plugin and (re)apply its configuration.
       *
       * @param {boolean|object} config Either a boolean to enable/disable or a configuration object
       *                                containing at least `{ enabled: boolean }`.
       * @returns {void}
       */
      configure(config) {
        if (typeof config === "boolean") {
          config = { enabled: config };
        }
        this.config = config;
        if (config.enabled && !this._enabled) {
          this._enabled = true;
          this._subscriptions.forEach((sub) => sub.enable());
          this._bindings.forEach((sub) => sub.enable());
        } else if (!config.enabled && this._enabled) {
          this._enabled = false;
          this._subscriptions.forEach((sub) => sub.disable());
          this._bindings.forEach((sub) => sub.disable());
        }
      }
    };
  }
});

// ../../packages/dd-trace/src/plugins/composite.js
var require_composite2 = __commonJS({
  "../../packages/dd-trace/src/plugins/composite.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var CompositePlugin = class extends Plugin {
      constructor(...args) {
        super(...args);
        for (const [name, PluginClass] of Object.entries(this.constructor.plugins)) {
          this[name] = new PluginClass(...args);
        }
      }
      /**
       * @override
       */
      configure(config) {
        super.configure(config);
        for (const name in this.constructor.plugins) {
          const pluginConfig = config[name] === false ? false : { ...config, ...config[name] };
          this[name].configure(pluginConfig);
        }
      }
    };
    module2.exports = CompositePlugin;
  }
});

// ../../packages/dd-trace/src/analytics_sampler.js
var require_analytics_sampler = __commonJS({
  "../../packages/dd-trace/src/analytics_sampler.js"(exports2, module2) {
    "use strict";
    var { MEASURED } = require_tags();
    module2.exports = {
      sample(span, measured, measuredByDefault) {
        if (measured !== null && typeof measured === "object") {
          this.sample(span, measured[span.context()._name], measuredByDefault);
        } else if (measured !== void 0) {
          span.setTag(MEASURED, !!measured);
        } else if (measuredByDefault) {
          span.setTag(MEASURED, true);
        }
      }
    };
  }
});

// ../../packages/dd-trace/src/plugins/tracing.js
var require_tracing = __commonJS({
  "../../packages/dd-trace/src/plugins/tracing.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants3();
    var TracingPlugin = class extends Plugin {
      constructor(...args) {
        super(...args);
        this.component = this.constructor.component || this.constructor.id;
        this.operation = this.constructor.operation;
        this.addTraceSubs();
      }
      get activeSpan() {
        const store = storage("legacy").getStore();
        return store && store.span;
      }
      serviceName(opts = {}) {
        const {
          type = this.constructor.type,
          id = this.constructor.id,
          kind = this.constructor.kind
        } = opts;
        return this._tracer._nomenclature.serviceName(type, kind, id, opts);
      }
      operationName(opts = {}) {
        const {
          type = this.constructor.type,
          id = this.constructor.id,
          kind = this.constructor.kind
        } = opts;
        return this._tracer._nomenclature.opName(type, kind, id, opts);
      }
      configure(config) {
        return super.configure({
          ...config,
          hooks: {
            [this.operation]: () => {
            },
            ...config.hooks
          }
        });
      }
      start() {
      }
      // implemented by individual plugins
      finish(ctx) {
        const span = ctx?.currentStore?.span || this.activeSpan;
        span?.finish();
      }
      error(ctxOrError) {
        if (ctxOrError?.currentStore) {
          ctxOrError.currentStore?.span.setTag("error", ctxOrError?.error);
          return;
        }
        this.addError(ctxOrError);
      }
      addTraceSubs() {
        const events = ["start", "end", "asyncStart", "asyncEnd", "error", "finish"];
        for (const event of events) {
          const bindName = `bind${event.charAt(0).toUpperCase()}${event.slice(1)}`;
          if (this[event]) {
            this.addTraceSub(event, (message) => {
              this[event](message);
            });
          }
          if (this[bindName]) {
            this.addTraceBind(event, (message) => this[bindName](message));
          }
        }
      }
      addTraceSub(eventName, handler) {
        const prefix = this.constructor.prefix || `apm:${this.component}:${this.operation}`;
        this.addSub(`${prefix}:${eventName}`, handler);
      }
      addTraceBind(eventName, transform) {
        const prefix = this.constructor.prefix || `apm:${this.component}:${this.operation}`;
        this.addBind(`${prefix}:${eventName}`, transform);
      }
      addError(error, span = this.activeSpan) {
        if (span && !span._spanContext._tags.error) {
          error = error && error.error || error;
          span.setTag("error", error || 1);
        }
      }
      startSpan(name, options = {}, enterOrCtx = true) {
        let {
          component = this.component,
          childOf,
          integrationName,
          kind,
          meta,
          metrics: metrics2,
          service,
          startTime,
          resource,
          type
        } = options;
        const tracer2 = options.tracer || this.tracer;
        const config = options.config || this.config;
        const store = storage("legacy").getStore();
        if (store && childOf === void 0) {
          childOf = store.span;
        }
        const span = tracer2.startSpan(name, {
          startTime,
          childOf,
          tags: {
            [COMPONENT]: component,
            "service.name": service || meta?.service || tracer2._service,
            "resource.name": resource,
            "span.kind": kind,
            "span.type": type,
            ...meta,
            ...metrics2
          },
          integrationName: integrationName || component,
          links: childOf?._links
        });
        analyticsSampler.sample(span, config.measured);
        if (enterOrCtx === true) {
          storage("legacy").enterWith({ ...store, span });
        } else if (enterOrCtx) {
          enterOrCtx.parentStore = store;
          enterOrCtx.currentStore = { ...store, span };
        }
        return span;
      }
    };
    module2.exports = TracingPlugin;
  }
});

// ../../packages/datadog-plugin-anthropic/src/tracing.js
var require_tracing2 = __commonJS({
  "../../packages/datadog-plugin-anthropic/src/tracing.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var AnthropicTracingPlugin = class extends TracingPlugin {
      static id = "anthropic";
      static operation = "request";
      static system = "anthropic";
      static prefix = "tracing:apm:anthropic:request";
      bindStart(ctx) {
        const { resource, options } = ctx;
        this.startSpan("anthropic.request", {
          meta: {
            "resource.name": `Messages.${resource}`,
            "anthropic.request.model": options.model
          }
        }, ctx);
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span;
        span?.finish();
      }
    };
    module2.exports = AnthropicTracingPlugin;
  }
});

// ../../packages/dd-trace/src/llmobs/storage.js
var require_storage4 = __commonJS({
  "../../packages/dd-trace/src/llmobs/storage.js"(exports2, module2) {
    "use strict";
    var { storage: createStorage } = require_datadog_core();
    var storage = createStorage("llmobs");
    module2.exports = { storage };
  }
});

// ../../packages/dd-trace/src/llmobs/constants/tags.js
var require_tags3 = __commonJS({
  "../../packages/dd-trace/src/llmobs/constants/tags.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      SPAN_KINDS: ["llm", "agent", "workflow", "task", "tool", "embedding", "retrieval"],
      SPAN_KIND: "_ml_obs.meta.span.kind",
      SESSION_ID: "_ml_obs.session_id",
      DECORATOR: "_ml_obs.decorator",
      INTEGRATION: "_ml_obs.integration",
      METADATA: "_ml_obs.meta.metadata",
      METRICS: "_ml_obs.metrics",
      ML_APP: "_ml_obs.meta.ml_app",
      PROPAGATED_PARENT_ID_KEY: "_dd.p.llmobs_parent_id",
      PROPAGATED_ML_APP_KEY: "_dd.p.llmobs_ml_app",
      PARENT_ID_KEY: "_ml_obs.llmobs_parent_id",
      TAGS: "_ml_obs.tags",
      NAME: "_ml_obs.name",
      TRACE_ID: "_ml_obs.trace_id",
      PROPAGATED_TRACE_ID_KEY: "_dd.p.llmobs_trace_id",
      ROOT_PARENT_ID: "undefined",
      MODEL_NAME: "_ml_obs.meta.model_name",
      MODEL_PROVIDER: "_ml_obs.meta.model_provider",
      INPUT_DOCUMENTS: "_ml_obs.meta.input.documents",
      INPUT_MESSAGES: "_ml_obs.meta.input.messages",
      INPUT_VALUE: "_ml_obs.meta.input.value",
      OUTPUT_DOCUMENTS: "_ml_obs.meta.output.documents",
      OUTPUT_MESSAGES: "_ml_obs.meta.output.messages",
      OUTPUT_VALUE: "_ml_obs.meta.output.value",
      INPUT_TOKENS_METRIC_KEY: "input_tokens",
      OUTPUT_TOKENS_METRIC_KEY: "output_tokens",
      TOTAL_TOKENS_METRIC_KEY: "total_tokens",
      CACHE_READ_INPUT_TOKENS_METRIC_KEY: "cache_read_input_tokens",
      CACHE_WRITE_INPUT_TOKENS_METRIC_KEY: "cache_write_input_tokens",
      DROPPED_IO_COLLECTION_ERROR: "dropped_io"
    };
  }
});

// ../../packages/dd-trace/src/llmobs/tagger.js
var require_tagger2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/tagger.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var {
      MODEL_NAME,
      MODEL_PROVIDER,
      SESSION_ID,
      ML_APP,
      SPAN_KIND,
      INPUT_VALUE,
      OUTPUT_DOCUMENTS,
      INPUT_DOCUMENTS,
      OUTPUT_VALUE,
      METADATA,
      METRICS,
      PARENT_ID_KEY,
      INPUT_MESSAGES,
      OUTPUT_MESSAGES,
      TAGS,
      NAME,
      PROPAGATED_PARENT_ID_KEY,
      ROOT_PARENT_ID,
      CACHE_READ_INPUT_TOKENS_METRIC_KEY,
      CACHE_WRITE_INPUT_TOKENS_METRIC_KEY,
      INPUT_TOKENS_METRIC_KEY,
      OUTPUT_TOKENS_METRIC_KEY,
      TOTAL_TOKENS_METRIC_KEY,
      INTEGRATION,
      DECORATOR,
      PROPAGATED_ML_APP_KEY
    } = require_tags3();
    var { storage } = require_storage4();
    var registry = /* @__PURE__ */ new WeakMap();
    var LLMObsTagger = class {
      constructor(config, softFail = false) {
        this._config = config;
        this.softFail = softFail;
      }
      static get tagMap() {
        return registry;
      }
      static getSpanKind(span) {
        return registry.get(span)?.[SPAN_KIND];
      }
      registerLLMObsSpan(span, {
        modelName,
        modelProvider,
        sessionId,
        mlApp,
        parent,
        kind,
        name,
        integration,
        _decorator
      } = {}) {
        if (!this._config.llmobs.enabled) return;
        if (!kind) return;
        const spanMlApp = mlApp || registry.get(parent)?.[ML_APP] || span.context()._trace.tags[PROPAGATED_ML_APP_KEY] || this._config.llmobs.mlApp || this._config.service;
        if (!spanMlApp) {
          throw new Error(
            "[LLMObs] Cannot start an LLMObs span without an mlApp configured.Ensure this configuration is set before running your application."
          );
        }
        this._register(span);
        this._setTag(span, ML_APP, spanMlApp);
        if (name) this._setTag(span, NAME, name);
        this._setTag(span, SPAN_KIND, kind);
        if (modelName) this._setTag(span, MODEL_NAME, modelName);
        if (modelProvider) this._setTag(span, MODEL_PROVIDER, modelProvider);
        sessionId = sessionId || registry.get(parent)?.[SESSION_ID];
        if (sessionId) this._setTag(span, SESSION_ID, sessionId);
        if (integration) this._setTag(span, INTEGRATION, integration);
        if (_decorator) this._setTag(span, DECORATOR, _decorator);
        const parentId = parent?.context().toSpanId() ?? span.context()._trace.tags[PROPAGATED_PARENT_ID_KEY] ?? ROOT_PARENT_ID;
        this._setTag(span, PARENT_ID_KEY, parentId);
        const annotationContext = storage.getStore()?.annotationContext;
        const tags = annotationContext?.tags;
        if (tags) this.tagSpanTags(span, tags);
        const annotationContextName = annotationContext?.name;
        if (annotationContextName) this._setTag(span, NAME, annotationContextName);
      }
      // TODO: similarly for the following `tag` methods,
      // how can we transition from a span weakmap to core API functionality
      tagLLMIO(span, inputData, outputData) {
        this.#tagMessages(span, inputData, INPUT_MESSAGES);
        this.#tagMessages(span, outputData, OUTPUT_MESSAGES);
      }
      tagEmbeddingIO(span, inputData, outputData) {
        this.#tagDocuments(span, inputData, INPUT_DOCUMENTS);
        this.#tagText(span, outputData, OUTPUT_VALUE);
      }
      tagRetrievalIO(span, inputData, outputData) {
        this.#tagText(span, inputData, INPUT_VALUE);
        this.#tagDocuments(span, outputData, OUTPUT_DOCUMENTS);
      }
      tagTextIO(span, inputData, outputData) {
        this.#tagText(span, inputData, INPUT_VALUE);
        this.#tagText(span, outputData, OUTPUT_VALUE);
      }
      tagMetadata(span, metadata) {
        const existingMetadata = registry.get(span)?.[METADATA];
        if (existingMetadata) {
          Object.assign(existingMetadata, metadata);
        } else {
          this._setTag(span, METADATA, metadata);
        }
      }
      tagMetrics(span, metrics2) {
        const filterdMetrics = {};
        for (const [key, value] of Object.entries(metrics2)) {
          let processedKey = key;
          switch (key) {
            case "inputTokens":
              processedKey = INPUT_TOKENS_METRIC_KEY;
              break;
            case "outputTokens":
              processedKey = OUTPUT_TOKENS_METRIC_KEY;
              break;
            case "totalTokens":
              processedKey = TOTAL_TOKENS_METRIC_KEY;
              break;
            case "cacheReadTokens":
              processedKey = CACHE_READ_INPUT_TOKENS_METRIC_KEY;
              break;
            case "cacheWriteTokens":
              processedKey = CACHE_WRITE_INPUT_TOKENS_METRIC_KEY;
              break;
          }
          if (typeof value === "number") {
            filterdMetrics[processedKey] = value;
          } else {
            this.#handleFailure(`Value for metric '${key}' must be a number, instead got ${value}`, "invalid_metrics");
          }
        }
        const existingMetrics = registry.get(span)?.[METRICS];
        if (existingMetrics) {
          Object.assign(existingMetrics, filterdMetrics);
        } else {
          this._setTag(span, METRICS, filterdMetrics);
        }
      }
      tagSpanTags(span, tags) {
        const currentTags = registry.get(span)?.[TAGS];
        if (currentTags) {
          Object.assign(currentTags, tags);
        } else {
          this._setTag(span, TAGS, tags);
        }
      }
      changeKind(span, newKind) {
        this._setTag(span, SPAN_KIND, newKind);
      }
      #tagText(span, data, key) {
        if (data) {
          if (typeof data === "string") {
            this._setTag(span, key, data);
          } else {
            try {
              this._setTag(span, key, JSON.stringify(data));
            } catch {
              const type = key === INPUT_VALUE ? "input" : "output";
              this.#handleFailure(`Failed to parse ${type} value, must be JSON serializable.`, "invalid_io_text");
            }
          }
        }
      }
      #tagDocuments(span, data, key) {
        if (!data) {
          return;
        }
        if (!Array.isArray(data)) {
          data = [data];
        }
        const documents = [];
        for (const document of data) {
          if (typeof document === "string") {
            documents.push({ text: document });
            continue;
          }
          if (document == null || typeof document !== "object") {
            this.#handleFailure("Documents must be a string, object, or list of objects.", "invalid_embedding_io");
            continue;
          }
          const { text, name, id, score } = document;
          const valid = typeof text === "string";
          if (!valid) {
            this.#handleFailure("Document text must be a string.", "invalid_embedding_io");
          }
          const documentObj = { text };
          const condition1 = this.#tagConditionalString(name, "Document name", documentObj, "name");
          const condition2 = this.#tagConditionalString(id, "Document ID", documentObj, "id");
          const condition3 = this.#tagConditionalNumber(score, "Document score", documentObj, "score");
          if (valid && condition1 && condition2 && condition3) {
            documents.push(documentObj);
          }
        }
        if (documents.length) {
          this._setTag(span, key, documents);
        }
      }
      #filterToolCalls(toolCalls) {
        if (!Array.isArray(toolCalls)) {
          toolCalls = [toolCalls];
        }
        const filteredToolCalls = [];
        for (const toolCall of toolCalls) {
          if (typeof toolCall !== "object") {
            this.#handleFailure("Tool call must be an object.", "invalid_io_messages");
            continue;
          }
          const { name, arguments: args, toolId, type } = toolCall;
          const toolCallObj = {};
          const condition1 = this.#tagConditionalString(name, "Tool name", toolCallObj, "name");
          const condition2 = this.#tagConditionalObject(args, "Tool arguments", toolCallObj, "arguments");
          const condition3 = this.#tagConditionalString(toolId, "Tool ID", toolCallObj, "tool_id");
          const condition4 = this.#tagConditionalString(type, "Tool type", toolCallObj, "type");
          if (condition1 && condition2 && condition3 && condition4) {
            filteredToolCalls.push(toolCallObj);
          }
        }
        return filteredToolCalls;
      }
      #filterToolResults(toolResults) {
        if (!Array.isArray(toolResults)) {
          toolResults = [toolResults];
        }
        const filteredToolResults = [];
        for (const toolResult of toolResults) {
          if (typeof toolResult !== "object") {
            this.#handleFailure("Tool result must be an object.", "invalid_io_messages");
            continue;
          }
          const { result, toolId, type } = toolResult;
          const toolResultObj = {};
          const condition1 = this.#tagConditionalString(result, "Tool result", toolResultObj, "result");
          const condition2 = this.#tagConditionalString(toolId, "Tool ID", toolResultObj, "tool_id");
          const condition3 = this.#tagConditionalString(type, "Tool type", toolResultObj, "type");
          if (condition1 && condition2 && condition3) {
            filteredToolResults.push(toolResultObj);
          }
        }
        return filteredToolResults;
      }
      #tagMessages(span, data, key) {
        if (!data) {
          return;
        }
        if (!Array.isArray(data)) {
          data = [data];
        }
        const messages = [];
        for (const message of data) {
          if (typeof message === "string") {
            messages.push({ content: message });
            continue;
          }
          if (message == null || typeof message !== "object") {
            this.#handleFailure("Messages must be a string, object, or list of objects", "invalid_io_messages");
            continue;
          }
          const { content = "", role } = message;
          const toolCalls = message.toolCalls;
          const toolResults = message.toolResults;
          const toolId = message.toolId;
          const messageObj = { content };
          const valid = typeof content === "string";
          if (!valid) {
            this.#handleFailure("Message content must be a string.", "invalid_io_messages");
          }
          let condition = this.#tagConditionalString(role, "Message role", messageObj, "role");
          if (toolCalls) {
            const filteredToolCalls = this.#filterToolCalls(toolCalls);
            if (filteredToolCalls.length) {
              messageObj.tool_calls = filteredToolCalls;
            }
          }
          if (toolResults) {
            const filteredToolResults = this.#filterToolResults(toolResults);
            if (filteredToolResults.length) {
              messageObj.tool_results = filteredToolResults;
            }
          }
          if (toolId) {
            if (role === "tool") {
              condition = this.#tagConditionalString(toolId, "Tool ID", messageObj, "tool_id");
            } else {
              log.warn(`Tool ID for tool message not associated with a "tool" role, instead got "${role}"`);
            }
          }
          if (valid && condition) {
            messages.push(messageObj);
          }
        }
        if (messages.length) {
          this._setTag(span, key, messages);
        }
      }
      #tagConditionalString(data, type, carrier, key) {
        if (!data) return true;
        if (typeof data !== "string") {
          this.#handleFailure(`"${type}" must be a string.`);
          return false;
        }
        carrier[key] = data;
        return true;
      }
      #tagConditionalNumber(data, type, carrier, key) {
        if (!data) return true;
        if (typeof data !== "number") {
          this.#handleFailure(`"${type}" must be a number.`);
          return false;
        }
        carrier[key] = data;
        return true;
      }
      #tagConditionalObject(data, type, carrier, key) {
        if (!data) return true;
        if (typeof data !== "object") {
          this.#handleFailure(`"${type}" must be an object.`);
          return false;
        }
        carrier[key] = data;
        return true;
      }
      // any public-facing LLMObs APIs using this tagger should not soft fail
      // auto-instrumentation should soft fail
      #handleFailure(msg, errorTag) {
        if (this.softFail) {
          log.warn(msg);
        } else {
          const err = new Error(msg);
          if (errorTag) {
            Object.defineProperty(err, "ddErrorTag", { get() {
              return errorTag;
            } });
          }
          throw err;
        }
      }
      _register(span) {
        if (!this._config.llmobs.enabled) return;
        if (registry.has(span)) {
          this.#handleFailure(`LLMObs Span "${span._name}" already registered.`);
          return;
        }
        registry.set(span, {});
      }
      _setTag(span, key, value) {
        if (!this._config.llmobs.enabled) return;
        if (!registry.has(span)) {
          this.#handleFailure(`Span "${span._name}" must be an LLMObs generated span.`);
          return;
        }
        const tagsCarrier = registry.get(span);
        tagsCarrier[key] = value;
      }
    };
    module2.exports = LLMObsTagger;
  }
});

// ../../packages/dd-trace/src/llmobs/telemetry.js
var require_telemetry4 = __commonJS({
  "../../packages/dd-trace/src/llmobs/telemetry.js"(exports2, module2) {
    "use strict";
    var {
      SPAN_KIND,
      MODEL_PROVIDER,
      PARENT_ID_KEY,
      SESSION_ID,
      ROOT_PARENT_ID,
      INTEGRATION,
      DECORATOR
    } = require_tags3();
    var ERROR_TYPE = require_constants3();
    var telemetryMetrics = require_metrics();
    var LLMObsTagger = require_tagger2();
    var llmobsMetrics = telemetryMetrics.manager.namespace("mlobs");
    function extractIntegrationFromTags(tags) {
      if (!Array.isArray(tags)) return null;
      const integrationTag = tags.find((tag) => tag.startsWith("integration:"));
      if (!integrationTag) return null;
      return integrationTag.split(":")[1] || null;
    }
    function extractTagsFromSpanEvent(event) {
      const spanKind = event.meta?.["span.kind"] || "";
      const integration = extractIntegrationFromTags(event.tags);
      const error = event.status === "error";
      const autoinstrumented = integration != null;
      return {
        span_kind: spanKind,
        autoinstrumented: Number(autoinstrumented),
        error: error ? 1 : 0,
        integration: integration || "N/A"
      };
    }
    function incrementLLMObsSpanStartCount(tags, value = 1) {
      llmobsMetrics.count("span.start", tags).inc(value);
    }
    function incrementLLMObsSpanFinishedCount(span, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span);
      const spanTags = span.context()._tags;
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID;
      const hasSessionId = mlObsTags[SESSION_ID] != null;
      const integration = mlObsTags[INTEGRATION];
      const autoInstrumented = integration != null;
      const decorator = !!mlObsTags[DECORATOR];
      const spanKind = mlObsTags[SPAN_KIND];
      const modelProvider = mlObsTags[MODEL_PROVIDER];
      const error = spanTags.error || spanTags[ERROR_TYPE];
      const tags = {
        autoinstrumented: Number(autoInstrumented),
        has_session_id: Number(hasSessionId),
        is_root_span: Number(isRootSpan),
        span_kind: spanKind,
        integration: integration || "N/A",
        error: error ? 1 : 0
      };
      if (!autoInstrumented) {
        tags.decorator = Number(decorator);
      }
      if (modelProvider) {
        tags.model_provider = modelProvider;
      }
      llmobsMetrics.count("span.finished", tags).inc(value);
    }
    function recordLLMObsEnabled(startTime, config, value = 1) {
      const initTimeMs = performance.now() - startTime;
      const autoEnabled = !!config._env?.["llmobs.enabled"];
      const tags = {
        error: 0,
        agentless: Number(config.llmobs.agentlessEnabled),
        site: config.site,
        auto: Number(autoEnabled),
        ml_app: config.llmobs.mlApp
      };
      llmobsMetrics.count("product_enabled", tags).inc(value);
      llmobsMetrics.distribution("init_time", tags).track(initTimeMs);
    }
    function recordLLMObsRawSpanSize(event, rawEventSize) {
      const tags = extractTagsFromSpanEvent(event);
      llmobsMetrics.distribution("span.raw_size", tags).track(rawEventSize);
    }
    function recordLLMObsSpanSize(event, eventSize, shouldTruncate) {
      const tags = extractTagsFromSpanEvent(event);
      tags.truncated = Number(shouldTruncate);
      llmobsMetrics.distribution("span.size", tags).track(eventSize);
    }
    function recordDroppedPayload(numEvents, eventType, error) {
      if (eventType !== "span" && eventType !== "evaluation_metric") return;
      const metricName = eventType === "span" ? "dropped_span_event" : "dropped_eval_event";
      const tags = { error };
      llmobsMetrics.count(metricName, tags).inc(numEvents);
    }
    function recordLLMObsAnnotate(span, err, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span) || {};
      const spanKind = mlObsTags[SPAN_KIND] || "N/A";
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID;
      const tags = {
        error: Number(!!err),
        span_kind: spanKind,
        is_root_span: Number(isRootSpan)
      };
      if (err) tags.error_type = err;
      llmobsMetrics.count("annotations", tags).inc(value);
    }
    function recordUserFlush(err, value = 1) {
      const tags = { error: Number(!!err) };
      if (err) tags.error_type = err;
      llmobsMetrics.count("user_flush", tags).inc(value);
    }
    function recordExportSpan(span, err, value = 1) {
      const mlObsTags = LLMObsTagger.tagMap.get(span) || {};
      const spanKind = mlObsTags[SPAN_KIND] || "N/A";
      const isRootSpan = mlObsTags[PARENT_ID_KEY] === ROOT_PARENT_ID;
      const tags = {
        error: Number(!!err),
        span_kind: spanKind,
        is_root_span: Number(isRootSpan)
      };
      if (err) tags.error_type = err;
      llmobsMetrics.count("spans_exported", tags).inc(value);
    }
    function recordSubmitEvaluation(options, err, value = 1) {
      const tags = {
        error: Number(!!err),
        custom_joining_key: 0
      };
      const metricType = options?.metricType?.toLowerCase();
      if (metricType !== "categorical" && metricType !== "score") tags.metric_type = "other";
      if (err) tags.error_type = err;
      llmobsMetrics.count("evals_submitted", tags).inc(value);
    }
    function recordLLMObsUserProcessorCalled(error, value = 1) {
      const tags = { error: error ? 1 : 0 };
      llmobsMetrics.count("user_processor_called", tags).inc(value);
    }
    module2.exports = {
      recordLLMObsEnabled,
      incrementLLMObsSpanStartCount,
      incrementLLMObsSpanFinishedCount,
      recordLLMObsRawSpanSize,
      recordLLMObsSpanSize,
      recordDroppedPayload,
      recordLLMObsAnnotate,
      recordUserFlush,
      recordExportSpan,
      recordSubmitEvaluation,
      recordLLMObsUserProcessorCalled
    };
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/base.js
var require_base = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/base.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { storage: llmobsStorage } = require_storage4();
    var telemetry = require_telemetry4();
    var TracingPlugin = require_tracing();
    var LLMObsTagger = require_tagger2();
    var LLMObsPlugin = class extends TracingPlugin {
      constructor(...args) {
        super(...args);
        this._tagger = new LLMObsTagger(this._tracerConfig, true);
      }
      setLLMObsTags(ctx) {
        throw new Error("setLLMObsTags must be implemented by the subclass");
      }
      getLLMObsSpanRegisterOptions(ctx) {
        throw new Error("getLLMObsSPanRegisterOptions must be implemented by the subclass");
      }
      start(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled;
        if (!enabled) return;
        const parentStore = llmobsStorage.getStore();
        const apmStore = ctx.currentStore;
        const span = apmStore?.span;
        const registerOptions = this.getLLMObsSpanRegisterOptions(ctx);
        if (registerOptions) {
          telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: true, integration: this.constructor.integration });
          ctx.llmobs = {};
          llmobsStorage.enterWith({ ...parentStore, span });
          ctx.llmobs.parent = parentStore;
          this._tagger.registerLLMObsSpan(span, {
            parent: parentStore?.span,
            integration: this.constructor.integration,
            ...registerOptions
          });
        }
      }
      end(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled;
        if (!enabled) return;
        const apmStore = ctx.currentStore;
        const span = apmStore?.span;
        if (!LLMObsTagger.tagMap.has(span)) return;
        const parentStore = ctx.llmobs.parent;
        llmobsStorage.enterWith(parentStore);
      }
      asyncEnd(ctx) {
        const enabled = this._tracerConfig.llmobs.enabled;
        if (!enabled) return;
        const apmStore = ctx.currentStore;
        const span = apmStore?.span;
        if (!span) {
          log.debug(
            "Tried to start an LLMObs span for %s without an active APM span. Not starting LLMObs span.",
            this.constructor.name
          );
          return;
        }
        this.setLLMObsTags(ctx);
      }
      configure(config) {
        const llmobsEnabled = this._tracerConfig.llmobs.enabled;
        if (llmobsEnabled === false) {
          config = typeof config === "boolean" ? false : { ...config, enabled: false };
        }
        super.configure(config);
      }
    };
    module2.exports = LLMObsPlugin;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/anthropic.js
var require_anthropic2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/anthropic.js"(exports2, module2) {
    "use strict";
    var LLMObsPlugin = require_base();
    var ALLOWED_METADATA_KEYS = /* @__PURE__ */ new Set([
      "max_tokens",
      "stop_sequences",
      "temperature",
      "top_k",
      "top_p"
    ]);
    var AnthropicLLMObsPlugin = class extends LLMObsPlugin {
      static integration = "anthropic";
      // used for llmobs telemetry
      static id = "anthropic";
      static prefix = "tracing:apm:anthropic:request";
      constructor() {
        super(...arguments);
        this.addSub("apm:anthropic:request:chunk", ({ ctx, chunk, done }) => {
          ctx.chunks ??= [];
          const chunks = ctx.chunks;
          if (chunk) chunks.push(chunk);
          if (!done) return;
          const response = { content: [] };
          for (const chunk2 of chunks) {
            switch (chunk2.type) {
              case "message_start": {
                const { message } = chunk2;
                if (!message) continue;
                const { role, usage } = message;
                if (role) response.role = role;
                if (usage) response.usage = usage;
                break;
              }
              case "content_block_start": {
                const contentBlock = chunk2.content_block;
                if (!contentBlock) continue;
                const { type } = contentBlock;
                if (type === "text") {
                  response.content.push({ type, text: contentBlock.text });
                } else if (type === "tool_use") {
                  response.content.push({ type, name: contentBlock.name, input: "", id: contentBlock.id });
                }
                break;
              }
              case "content_block_delta": {
                const { delta } = chunk2;
                if (!delta) continue;
                const { text } = delta;
                if (text) response.content[response.content.length - 1].text += text;
                const partialJson = delta.partial_json;
                if (partialJson && delta.type === "input_json_delta") {
                  response.content[response.content.length - 1].input += partialJson;
                }
                break;
              }
              case "content_block_stop": {
                const type = response.content[response.content.length - 1].type;
                if (type === "tool_use") {
                  const input = response.content[response.content.length - 1].input ?? "{}";
                  response.content[response.content.length - 1].input = JSON.parse(input);
                }
                break;
              }
              case "message_delta": {
                const { delta } = chunk2;
                const finishReason = delta?.stop_reason;
                if (finishReason) response.finish_reason = finishReason;
                const { usage } = chunk2;
                if (usage) {
                  const responseUsage = response.usage ?? (response.usage = { input_tokens: 0, output_tokens: 0 });
                  responseUsage.output_tokens = usage.output_tokens;
                  const cacheCreationTokens = usage.cache_creation_input_tokens;
                  const cacheReadTokens = usage.cache_read_input_tokens;
                  if (cacheCreationTokens) responseUsage.cache_creation_input_tokens = cacheCreationTokens;
                  if (cacheReadTokens) responseUsage.cache_read_input_tokens = cacheReadTokens;
                }
                break;
              }
              case "error": {
                const { error } = chunk2;
                if (!error) continue;
                response.error = {};
                if (error.type) response.error.type = error.type;
                if (error.message) response.error.message = error.message;
                break;
              }
            }
            ctx.result = response;
          }
        });
      }
      getLLMObsSpanRegisterOptions(ctx) {
        const { options } = ctx;
        const { model } = options;
        return {
          kind: "llm",
          modelName: model,
          modelProvider: "anthropic"
        };
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span;
        if (!span) return;
        const { options, result } = ctx;
        this.#tagAnthropicInputMessages(span, options);
        this.#tagAnthropicOutputMessages(span, result);
        this.#tagAnthropicMetadata(span, options);
        this.#tagAnthropicUsage(span, result);
      }
      #tagAnthropicInputMessages(span, options) {
        const { system, messages } = options;
        const inputMessages = [];
        if (system) {
          messages.unshift({ content: system, role: "system" });
        }
        for (const message of messages) {
          const { content, role } = message;
          if (typeof content === "string") {
            inputMessages.push({ content, role });
            continue;
          }
          for (const block of content) {
            if (block.type === "text") {
              inputMessages.push({ content: block.text, role });
            } else if (block.type === "image") {
              inputMessages.push({ content: "([IMAGE DETECTED])", role });
            } else if (block.type === "tool_use") {
              const { text, name, id, type } = block;
              let input = block.input;
              if (typeof input === "string") {
                input = JSON.parse(input);
              }
              const toolCall = {
                name,
                arguments: input,
                toolId: id,
                type
              };
              inputMessages.push({ content: text ?? "", role, toolCalls: [toolCall] });
            } else if (block.type === "tool_result") {
              const { content: content2 } = block;
              const formattedContent = this.#formatAnthropicToolResultContent(content2);
              const toolResult = {
                result: formattedContent,
                toolId: block.tool_use_id,
                type: "tool_result"
              };
              inputMessages.push({ content: "", role, toolResults: [toolResult] });
            } else {
              inputMessages.push({ content: JSON.stringify(block), role });
            }
          }
        }
        this._tagger.tagLLMIO(span, inputMessages);
      }
      #tagAnthropicOutputMessages(span, result) {
        if (!result) return;
        const { content, role } = result;
        if (typeof content === "string") {
          this._tagger.tagLLMIO(span, null, [{ content, role }]);
          return;
        }
        const outputMessages = [];
        for (const block of content) {
          const { text } = block;
          if (typeof text === "string") {
            outputMessages.push({ content: text, role });
          } else if (block.type === "tool_use") {
            let input = block.input;
            if (typeof input === "string") {
              input = JSON.parse(input);
            }
            const toolCall = {
              name: block.name,
              arguments: input,
              toolId: block.id,
              type: block.type
            };
            outputMessages.push({ content: text ?? "", role, toolCalls: [toolCall] });
          }
        }
        this._tagger.tagLLMIO(span, null, outputMessages);
      }
      #tagAnthropicMetadata(span, options) {
        const metadata = {};
        for (const [key, value] of Object.entries(options)) {
          if (ALLOWED_METADATA_KEYS.has(key)) {
            metadata[key] = value;
          }
        }
        this._tagger.tagMetadata(span, metadata);
      }
      #tagAnthropicUsage(span, result) {
        if (!result) return;
        const { usage } = result;
        if (!usage) return;
        const inputTokens = usage.input_tokens;
        const outputTokens = usage.output_tokens;
        const cacheWriteTokens = usage.cache_creation_input_tokens;
        const cacheReadTokens = usage.cache_read_input_tokens;
        const metrics2 = {};
        metrics2.inputTokens = (inputTokens ?? 0) + (cacheWriteTokens ?? 0) + (cacheReadTokens ?? 0);
        if (outputTokens) metrics2.outputTokens = outputTokens;
        const totalTokens = metrics2.inputTokens + (outputTokens ?? 0);
        if (totalTokens) metrics2.totalTokens = totalTokens;
        if (cacheWriteTokens != null) metrics2.cacheWriteTokens = cacheWriteTokens;
        if (cacheReadTokens != null) metrics2.cacheReadTokens = cacheReadTokens;
        this._tagger.tagMetrics(span, metrics2);
      }
      // maybe can make into a util file
      #formatAnthropicToolResultContent(content) {
        if (typeof content === "string") {
          return content;
        } else if (Array.isArray(content)) {
          const formattedContent = [];
          for (const toolResultBlock of content) {
            if (toolResultBlock.text) {
              formattedContent.push(toolResultBlock.text);
            } else if (toolResultBlock.type === "image") {
              formattedContent.push("([IMAGE DETECTED])");
            }
          }
          return formattedContent.join(",");
        }
        return JSON.stringify(content);
      }
    };
    module2.exports = AnthropicLLMObsPlugin;
  }
});

// ../../packages/datadog-plugin-anthropic/src/index.js
var require_src2 = __commonJS({
  "../../packages/datadog-plugin-anthropic/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var AnthropicTracingPlugin = require_tracing2();
    var AnthropicLLMObsPlugin = require_anthropic2();
    var AnthropicPlugin = class extends CompositePlugin {
      static id = "anthropic";
      static get plugins() {
        return {
          llmobs: AnthropicLLMObsPlugin,
          tracing: AnthropicTracingPlugin
        };
      }
    };
    module2.exports = AnthropicPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/apollo.js
var require_apollo2 = __commonJS({
  "../../packages/dd-trace/src/plugins/apollo.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var { storage } = require_datadog_core();
    var ApolloBasePlugin = class extends TracingPlugin {
      static id = "apollo.gateway";
      static type = "web";
      static kind = "server";
      bindStart(ctx) {
        const store = storage("legacy").getStore();
        const childOf = store ? store.span : null;
        const span = this.startSpan(this.getOperationName(), {
          childOf,
          service: this.getServiceName(),
          type: this.constructor.type,
          kind: this.constructor.kind,
          meta: {}
        }, false);
        ctx.parentStore = store;
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
      end(ctx) {
        if (!ctx.hasOwnProperty("result") && !ctx.hasOwnProperty("error")) return;
        ctx?.currentStore?.span?.finish();
      }
      asyncStart(ctx) {
        ctx?.currentStore?.span.finish();
        return ctx.parentStore;
      }
      getServiceName() {
        return this.serviceName({
          id: `${this.constructor.id}.${this.constructor.operation}`,
          pluginConfig: this.config
        });
      }
      getOperationName() {
        return this.operationName({
          id: `${this.constructor.id}.${this.constructor.operation}`
        });
      }
    };
    module2.exports = ApolloBasePlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/execute.js
var require_execute = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/execute.js"(exports2, module2) {
    "use strict";
    var ApolloBasePlugin = require_apollo2();
    var ApolloGatewayExecutePlugin = class extends ApolloBasePlugin {
      static operation = "execute";
      static prefix = "tracing:apm:apollo:gateway:execute";
    };
    module2.exports = ApolloGatewayExecutePlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/postprocessing.js
var require_postprocessing = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/postprocessing.js"(exports2, module2) {
    "use strict";
    var ApolloBasePlugin = require_apollo2();
    var ApolloGatewayPostProcessingPlugin = class extends ApolloBasePlugin {
      static operation = "postprocessing";
      static prefix = "tracing:apm:apollo:gateway:postprocessing";
    };
    module2.exports = ApolloGatewayPostProcessingPlugin;
  }
});

// ../../node_modules/lodash.sortby/index.js
var require_lodash2 = __commonJS({
  "../../node_modules/lodash.sortby/index.js"(exports2, module2) {
    var LARGE_ARRAY_SIZE = 200;
    var FUNC_ERROR_TEXT = "Expected a function";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var UNORDERED_COMPARE_FLAG = 1;
    var PARTIAL_COMPARE_FLAG = 2;
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp = /^\w*$/;
    var reLeadingDot = /^\./;
    var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reEscapeChar = /\\(\\)?/g;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = (function() {
      try {
        return freeProcess && freeProcess.binding("util");
      } catch (e) {
      }
    })();
    var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? void 0 : object[key];
      };
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set2) {
      var index = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    })();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function SetCache(values) {
      var index = -1, length = values ? values.length : 0;
      this.__data__ = new MapCache();
      while (++index < length) {
        this.add(values[index]);
      }
    }
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }
    function setCacheHas(value) {
      return this.__data__.has(value);
    }
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    var baseEach = createBaseEach(baseForOwn);
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1, length = array.length;
      predicate || (predicate = isFlattenable);
      result || (result = []);
      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }
    var baseFor = createBaseFor();
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }
    function baseGet(object, path) {
      path = isKey(path, object) ? [path] : castPath(path);
      var index = 0, length = path.length;
      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return index && index == length ? object : void 0;
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }
    function baseIsEqual(value, other, customizer, bitmask, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
    }
    function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
      var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
      if (!objIsArr) {
        objTag = getTag(object);
        objTag = objTag == argsTag ? objectTag : objTag;
      }
      if (!othIsArr) {
        othTag = getTag(other);
        othTag = othTag == argsTag ? objectTag : othTag;
      }
      var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack());
        return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
      }
      if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack());
          return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack());
      return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
    }
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length, length = index, noCustomizer = !customizer;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0], objValue = object[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseIsTypedArray(value) {
      return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
    }
    function baseIteratee(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == "object") {
        return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
      }
      return property(value);
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function baseMap(collection, iteratee) {
      var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
      baseEach(collection, function(value, key, collection2) {
        result[++index] = iteratee(value, key, collection2);
      });
      return result;
    }
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get3(object, path);
        return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
      };
    }
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(baseIteratee));
      var result = baseMap(collection, function(value, key, collection2) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { "criteria": criteria, "index": ++index, "value": value };
      });
      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function castPath(value) {
      return isArray(value) ? value : stringToPath(value);
    }
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
        var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
          return 1;
        }
        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }
    function compareMultiple(object, other, orders) {
      var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == "desc" ? -1 : 1);
        }
      }
      return object.index - other.index;
    }
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index-- : ++index < length) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }
    function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
      stack.set(array, other);
      stack.set(other, array);
      while (++index < arrLength) {
        var arrValue = array[index], othValue = other[index];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome(other, function(othValue2, othIndex) {
            if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
              return seen.add(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array);
      stack["delete"](other);
      return result;
    }
    function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
      switch (tag) {
        case dataViewTag:
          if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;
        case arrayBufferTag:
          if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
            return false;
          }
          return true;
        case boolTag:
        case dateTag:
        case numberTag:
          return eq(+object, +other);
        case errorTag:
          return object.name == other.name && object.message == other.message;
        case regexpTag:
        case stringTag:
          return object == other + "";
        case mapTag:
          var convert = mapToArray;
        case setTag:
          var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
          convert || (convert = setToArray);
          if (object.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= UNORDERED_COMPARE_FLAG;
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
          stack["delete"](object);
          return result;
        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }
    function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
      var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);
      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object);
      stack["delete"](other);
      return result;
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getMatchData(object) {
      var result = keys(object), length = result.length;
      while (length--) {
        var key = result[length], value = object[key];
        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function hasPath(object, path, hasFunc) {
      path = isKey(path, object) ? [path] : castPath(path);
      var result, index = -1, length = path.length;
      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result) {
        return result;
      }
      var length = object ? object.length : 0;
      return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
    }
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
      };
    }
    var stringToPath = memoize(function(string) {
      string = toString2(string);
      var result = [];
      if (reLeadingDot.test(string)) {
        result.push("");
      }
      string.replace(rePropName, function(match, number, quote, string2) {
        result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
      });
      return result;
    });
    function toKey(value) {
      if (typeof value == "string" || isSymbol(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });
    function memoize(func, resolver) {
      if (typeof func != "function" || resolver && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result);
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache)();
      return memoized;
    }
    memoize.Cache = MapCache;
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
    function toString2(value) {
      return value == null ? "" : baseToString(value);
    }
    function get3(object, path, defaultValue) {
      var result = object == null ? void 0 : baseGet(object, path);
      return result === void 0 ? defaultValue : result;
    }
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function identity(value) {
      return value;
    }
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }
    module2.exports = sortBy;
  }
});

// ../../packages/datadog-plugin-graphql/src/tools/transforms.js
var require_transforms = __commonJS({
  "../../packages/datadog-plugin-graphql/src/tools/transforms.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var visitor_1 = __require("graphql/language/visitor");
    var printer_1 = __require("graphql/language/printer");
    var utilities_1 = __require("graphql/utilities");
    var lodash_sortby_1 = __importDefault(require_lodash2());
    function hideLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
          return Object.assign({}, node, { value: "", block: false });
        },
        ListValue(node) {
          return Object.assign({}, node, { values: [] });
        },
        ObjectValue(node) {
          return Object.assign({}, node, { fields: [] });
        }
      });
    }
    exports2.hideLiterals = hideLiterals;
    function hideStringAndNumericLiterals(ast) {
      return visitor_1.visit(ast, {
        IntValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        FloatValue(node) {
          return Object.assign({}, node, { value: "0" });
        },
        StringValue(node) {
          return Object.assign({}, node, { value: "", block: false });
        }
      });
    }
    exports2.hideStringAndNumericLiterals = hideStringAndNumericLiterals;
    function dropUnusedDefinitions(ast, operationName) {
      const separated = utilities_1.separateOperations(ast)[operationName];
      if (!separated) {
        return ast;
      }
      return separated;
    }
    exports2.dropUnusedDefinitions = dropUnusedDefinitions;
    function sorted(items) {
      if (items) {
        return lodash_sortby_1.default.apply(null, arguments);
      }
      return void 0;
    }
    function sortAST(ast) {
      return visitor_1.visit(ast, {
        OperationDefinition(node) {
          return Object.assign({}, node, { variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        SelectionSet(node) {
          return Object.assign({}, node, { selections: lodash_sortby_1.default(node.selections, "kind", "name.value") });
        },
        Field(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        },
        FragmentSpread(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        InlineFragment(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value") });
        },
        FragmentDefinition(node) {
          return Object.assign({}, node, { directives: sorted(node.directives, "name.value"), variableDefinitions: sorted(node.variableDefinitions, "variable.name.value") });
        },
        Directive(node) {
          return Object.assign({}, node, { arguments: sorted(node.arguments, "name.value") });
        }
      });
    }
    exports2.sortAST = sortAST;
    function removeAliases(ast) {
      return visitor_1.visit(ast, {
        Field(node) {
          return Object.assign({}, node, { alias: void 0 });
        }
      });
    }
    exports2.removeAliases = removeAliases;
    function printWithReducedWhitespace(ast) {
      const sanitizedAST = visitor_1.visit(ast, {
        StringValue(node) {
          return Object.assign({}, node, { value: Buffer.from(node.value, "utf8").toString("hex"), block: false });
        }
      });
      const withWhitespace = printer_1.print(sanitizedAST);
      const minimizedButStillHex = withWhitespace.replace(/\s+/g, " ").replace(/([^_a-zA-Z0-9]) /g, (_2, c) => c).replace(/ ([^_a-zA-Z0-9])/g, (_2, c) => c);
      return minimizedButStillHex.replace(/"([a-f0-9]+)"/g, (_2, hex) => JSON.stringify(Buffer.from(hex, "hex").toString("utf8")));
    }
    exports2.printWithReducedWhitespace = printWithReducedWhitespace;
  }
});

// ../../packages/datadog-plugin-graphql/src/tools/signature.js
var require_signature = __commonJS({
  "../../packages/datadog-plugin-graphql/src/tools/signature.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var transforms_1 = require_transforms();
    function defaultEngineReportingSignature(ast, operationName) {
      return transforms_1.printWithReducedWhitespace(transforms_1.sortAST(transforms_1.removeAliases(transforms_1.hideLiterals(transforms_1.dropUnusedDefinitions(ast, operationName)))));
    }
    exports2.defaultEngineReportingSignature = defaultEngineReportingSignature;
  }
});

// ../../packages/datadog-plugin-graphql/src/tools/index.js
var require_tools = __commonJS({
  "../../packages/datadog-plugin-graphql/src/tools/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var signature_1 = require_signature();
    exports2.defaultEngineReportingSignature = signature_1.defaultEngineReportingSignature;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/request.js
var require_request2 = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/request.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var ApolloBasePlugin = require_apollo2();
    var tools;
    var OPERATION_DEFINITION = "OperationDefinition";
    var FRAGMENT_DEFINITION = "FragmentDefinition";
    var ApolloGatewayRequestPlugin = class extends ApolloBasePlugin {
      static operation = "request";
      static prefix = "tracing:apm:apollo:gateway:request";
      bindStart(ctx) {
        const store = storage("legacy").getStore();
        const childOf = store ? store.span : null;
        const spanData = {
          childOf,
          service: this.serviceName(
            { id: `${this.constructor.id}.${this.constructor.operation}`, pluginConfig: this.config }
          ),
          type: this.constructor.type,
          kind: this.constructor.kind,
          meta: {}
        };
        const { requestContext, gateway } = ctx;
        if (requestContext?.operationName) {
          spanData.meta["graphql.operation.name"] = requestContext.operationName;
        }
        if ((this.config.source || gateway?.config?.telemetry?.includeDocument) && requestContext?.source) {
          spanData.meta["graphql.source"] = requestContext.source;
        }
        const operationContext = buildOperationContext(gateway.schema, requestContext.document, requestContext.request.operationName);
        if (operationContext?.operation?.operation) {
          const document = requestContext?.document;
          const type = operationContext?.operation?.operation;
          const name = operationContext?.operation?.name && operationContext?.operation?.name?.value;
          spanData.resource = getSignature(document, name, type, this?.config?.signature);
          spanData.meta["graphql.operation.type"] = type;
        }
        const span = this.startSpan(
          this.operationName({ id: `${this.constructor.id}.${this.constructor.operation}` }),
          spanData,
          false
        );
        ctx.parentStore = store;
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
      asyncStart(ctx) {
        const errors = ctx?.result?.errors;
        if (Array.isArray(errors) && errors.at(-1)?.stack && errors.at(-1).message) {
          ctx.currentStore.span.setTag("error", errors.at(-1));
        }
        ctx.currentStore.span.finish();
        return ctx.parentStore;
      }
    };
    function buildOperationContext(schema, operationDocument, operationName) {
      let operation;
      let operationCount = 0;
      const fragments = /* @__PURE__ */ Object.create(null);
      try {
        operationDocument.definitions.forEach((definition) => {
          switch (definition.kind) {
            case OPERATION_DEFINITION:
              operationCount++;
              if (!operationName && operationCount > 1) {
                return;
              }
              if (!operationName || definition.name && definition.name.value === operationName) {
                operation = definition;
              }
              break;
            case FRAGMENT_DEFINITION:
              fragments[definition.name.value] = definition;
              break;
          }
        });
      } catch {
      }
      return {
        schema,
        operation,
        fragments
      };
    }
    function getSignature(document, operationName, operationType, calculate) {
      if (calculate !== false && tools !== false) {
        try {
          try {
            tools = tools || require_tools();
          } catch (e) {
            tools = false;
            throw e;
          }
          return tools.defaultEngineReportingSignature(document, operationName);
        } catch {
        }
      }
      return [operationType, operationName].filter(Boolean).join(" ");
    }
    module2.exports = ApolloGatewayRequestPlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/plan.js
var require_plan = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/plan.js"(exports2, module2) {
    "use strict";
    var ApolloBasePlugin = require_apollo2();
    var ApolloGatewayPlanPlugin = class extends ApolloBasePlugin {
      static operation = "plan";
      static prefix = "tracing:apm:apollo:gateway:plan";
    };
    module2.exports = ApolloGatewayPlanPlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/validate.js
var require_validate = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/validate.js"(exports2, module2) {
    "use strict";
    var ApolloBasePlugin = require_apollo2();
    var ApolloGatewayValidatePlugin = class extends ApolloBasePlugin {
      static operation = "validate";
      static prefix = "tracing:apm:apollo:gateway:validate";
      end(ctx) {
        const result = ctx.result;
        const span = ctx.currentStore?.span;
        if (!span) return;
        if (Array.isArray(result) && result.at(-1)?.stack && result.at(-1).message) {
          span.setTag("error", result.at(-1));
        }
        span.finish();
      }
    };
    module2.exports = ApolloGatewayValidatePlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/fetch.js
var require_fetch2 = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/fetch.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var ApolloBasePlugin = require_apollo2();
    var ApolloGatewayFetchPlugin = class extends ApolloBasePlugin {
      static operation = "fetch";
      static prefix = "tracing:apm:apollo:gateway:fetch";
      bindStart(ctx) {
        const store = storage("legacy").getStore();
        const childOf = store ? store.span : null;
        const spanData = {
          childOf,
          service: this.getServiceName(),
          type: this.constructor.type,
          meta: {}
        };
        const serviceName = ctx?.attributes?.service;
        if (serviceName) {
          spanData.meta.serviceName = serviceName;
        }
        const span = this.startSpan(this.getOperationName(), spanData, false);
        ctx.parentStore = store;
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
    };
    module2.exports = ApolloGatewayFetchPlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/gateway/index.js
var require_gateway = __commonJS({
  "../../packages/datadog-plugin-apollo/src/gateway/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var CompositePlugin = require_composite2();
    var ApolloGatewayExecutePlugin = require_execute();
    var ApolloGatewayPostProcessingPlugin = require_postprocessing();
    var ApolloGatewayRequestPlugin = require_request2();
    var ApolloGatewayPlanPlugin = require_plan();
    var ApolloGatewayValidatePlugin = require_validate();
    var ApolloGatewayFetchPlugin = require_fetch2();
    var ApolloGatewayPlugin = class extends CompositePlugin {
      static id = "gateway";
      static get plugins() {
        return {
          execute: ApolloGatewayExecutePlugin,
          postprocessing: ApolloGatewayPostProcessingPlugin,
          request: ApolloGatewayRequestPlugin,
          plan: ApolloGatewayPlanPlugin,
          fetch: ApolloGatewayFetchPlugin,
          validate: ApolloGatewayValidatePlugin
        };
      }
      constructor(...args) {
        super(...args);
        this.addSub("apm:apollo:gateway:general:error", (ctx) => {
          const store = storage("legacy").getStore();
          const span = store?.span;
          if (!span) return;
          span.setTag("error", ctx.error);
        });
      }
    };
    module2.exports = ApolloGatewayPlugin;
  }
});

// ../../packages/datadog-plugin-apollo/src/index.js
var require_src3 = __commonJS({
  "../../packages/datadog-plugin-apollo/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var ApolloGatewayPlugin = require_gateway();
    var ApolloPlugin = class extends CompositePlugin {
      static id = "apollo";
      static get plugins() {
        return {
          gateway: ApolloGatewayPlugin
        };
      }
    };
    module2.exports = ApolloPlugin;
  }
});

// ../../packages/datadog-code-origin/index.js
var require_datadog_code_origin = __commonJS({
  "../../packages/datadog-code-origin/index.js"(exports2, module2) {
    "use strict";
    var { parseUserLandFrames } = require_stacktrace();
    var ENTRY_SPAN_STACK_FRAMES_LIMIT = 1;
    var EXIT_SPAN_STACK_FRAMES_LIMIT = Number(process.env._DD_CODE_ORIGIN_FOR_SPANS_EXIT_SPAN_MAX_USER_FRAMES) || 8;
    module2.exports = {
      entryTags,
      exitTags
    };
    function entryTags(topOfStackFunc) {
      return tag("entry", topOfStackFunc, ENTRY_SPAN_STACK_FRAMES_LIMIT);
    }
    function exitTags(topOfStackFunc) {
      return tag("exit", topOfStackFunc, EXIT_SPAN_STACK_FRAMES_LIMIT);
    }
    function tag(type, topOfStackFunc, limit) {
      const originalLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      const dummy = {};
      Error.captureStackTrace(dummy, topOfStackFunc);
      const frames = parseUserLandFrames(dummy.stack, limit);
      Error.stackTraceLimit = originalLimit;
      const tags = {
        "_dd.code_origin.type": type
      };
      for (let i = 0; i < frames.length; i++) {
        const frame = frames[i];
        tags[`_dd.code_origin.frames.${i}.file`] = frame.fileName;
        tags[`_dd.code_origin.frames.${i}.line`] = frame.lineNumber;
        tags[`_dd.code_origin.frames.${i}.column`] = frame.columnNumber;
        if (frame.methodName || frame.functionName) {
          tags[`_dd.code_origin.frames.${i}.method`] = frame.methodName || frame.functionName;
        }
        if (frame.typeName) {
          tags[`_dd.code_origin.frames.${i}.type`] = frame.typeName;
        }
      }
      return tags;
    }
  }
});

// ../../packages/dd-trace/src/plugins/outbound.js
var require_outbound = __commonJS({
  "../../packages/dd-trace/src/plugins/outbound.js"(exports2, module2) {
    "use strict";
    var {
      CLIENT_PORT_KEY,
      PEER_SERVICE_KEY,
      PEER_SERVICE_SOURCE_KEY,
      PEER_SERVICE_REMAP_KEY
    } = require_constants3();
    var TracingPlugin = require_tracing();
    var { exitTags } = require_datadog_code_origin();
    var { storage } = require_datadog_core();
    var COMMON_PEER_SVC_SOURCE_TAGS = [
      "net.peer.name",
      "out.host"
    ];
    var OutboundPlugin = class extends TracingPlugin {
      static peerServicePrecursors = [];
      constructor(...args) {
        super(...args);
        this.addTraceSub("connect", (ctx) => {
          this.connect(ctx);
        });
      }
      bindFinish(ctx) {
        return ctx.parentStore;
      }
      startSpan(...args) {
        const span = super.startSpan(...args);
        if (this._tracerConfig.codeOriginForSpans.enabled && this._tracerConfig.codeOriginForSpans.experimental.exit_spans.enabled) {
          span.addTags(exitTags(this.startSpan));
        }
        return span;
      }
      getPeerService(tags) {
        if (tags[PEER_SERVICE_KEY] !== void 0) {
          return {
            [PEER_SERVICE_KEY]: tags[PEER_SERVICE_KEY],
            [PEER_SERVICE_SOURCE_KEY]: PEER_SERVICE_KEY
          };
        }
        const sourceTags = [
          ...this.constructor.peerServicePrecursors,
          ...COMMON_PEER_SVC_SOURCE_TAGS
        ];
        for (const sourceTag of sourceTags) {
          if (tags[sourceTag]) {
            return {
              [PEER_SERVICE_KEY]: tags[sourceTag],
              [PEER_SERVICE_SOURCE_KEY]: sourceTag
            };
          }
        }
      }
      getPeerServiceRemap(peerData) {
        const peerService = peerData[PEER_SERVICE_KEY];
        const mappedService = this._tracerConfig.peerServiceMapping?.[peerService];
        if (peerService && mappedService) {
          return {
            ...peerData,
            [PEER_SERVICE_KEY]: mappedService,
            [PEER_SERVICE_REMAP_KEY]: peerService
          };
        }
        return peerData;
      }
      finish(ctx) {
        const span = ctx?.currentStore?.span || this.activeSpan;
        this.tagPeerService(span);
        if (this._tracerConfig?._isInServerlessEnvironment()) {
          const peerHostname = storage("peerServerless").getStore()?.peerHostname;
          if (peerHostname) span.setTag("peer.service", peerHostname);
        }
        super.finish(...arguments);
      }
      tagPeerService(span) {
        if (this._tracerConfig.spanComputePeerService) {
          const peerData = this.getPeerService(span.context()._tags);
          if (peerData !== void 0) {
            span.addTags(this.getPeerServiceRemap(peerData));
          }
        }
      }
      connect(ctx) {
        this.addHost(ctx);
      }
      addHost(ctx) {
        const { hostname, port } = ctx;
        const span = ctx?.currentStore?.span || this.activeSpan;
        if (!span) return;
        span.addTags({
          "out.host": hostname,
          [CLIENT_PORT_KEY]: port
        });
      }
    };
    module2.exports = OutboundPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/client.js
var require_client5 = __commonJS({
  "../../packages/dd-trace/src/plugins/client.js"(exports2, module2) {
    "use strict";
    var OutboundPlugin = require_outbound();
    var ClientPlugin = class extends OutboundPlugin {
      static operation = "request";
      static kind = "client";
      static type = "web";
      // overridden by storage and other client type plugins
    };
    module2.exports = ClientPlugin;
  }
});

// ../../node_modules/rfdc/index.js
var require_rfdc = __commonJS({
  "../../node_modules/rfdc/index.js"(exports2, module2) {
    "use strict";
    module2.exports = rfdc;
    function copyBuffer(cur) {
      if (cur instanceof Buffer) {
        return Buffer.from(cur);
      }
      return new cur.constructor(cur.buffer.slice(), cur.byteOffset, cur.length);
    }
    function rfdc(opts) {
      opts = opts || {};
      if (opts.circles) return rfdcCircles(opts);
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            a2[k] = fn(cur);
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = clone(cur);
          }
        }
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            o2[k] = cloneProto(cur);
          }
        }
        return o2;
      }
    }
    function rfdcCircles(opts) {
      const refs = [];
      const refsNew = [];
      const constructorHandlers = /* @__PURE__ */ new Map();
      constructorHandlers.set(Date, (o) => new Date(o));
      constructorHandlers.set(Map, (o, fn) => new Map(cloneArray(Array.from(o), fn)));
      constructorHandlers.set(Set, (o, fn) => new Set(cloneArray(Array.from(o), fn)));
      if (opts.constructorHandlers) {
        for (const handler2 of opts.constructorHandlers) {
          constructorHandlers.set(handler2[0], handler2[1]);
        }
      }
      let handler = null;
      return opts.proto ? cloneProto : clone;
      function cloneArray(a, fn) {
        const keys = Object.keys(a);
        const a2 = new Array(keys.length);
        for (let i = 0; i < keys.length; i++) {
          const k = keys[i];
          const cur = a[k];
          if (typeof cur !== "object" || cur === null) {
            a2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            a2[k] = handler(cur, fn);
          } else if (ArrayBuffer.isView(cur)) {
            a2[k] = copyBuffer(cur);
          } else {
            const index = refs.indexOf(cur);
            if (index !== -1) {
              a2[k] = refsNew[index];
            } else {
              a2[k] = fn(cur);
            }
          }
        }
        return a2;
      }
      function clone(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, clone);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, clone);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          if (Object.hasOwnProperty.call(o, k) === false) continue;
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, clone);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = clone(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
      function cloneProto(o) {
        if (typeof o !== "object" || o === null) return o;
        if (Array.isArray(o)) return cloneArray(o, cloneProto);
        if (o.constructor !== Object && (handler = constructorHandlers.get(o.constructor))) {
          return handler(o, cloneProto);
        }
        const o2 = {};
        refs.push(o);
        refsNew.push(o2);
        for (const k in o) {
          const cur = o[k];
          if (typeof cur !== "object" || cur === null) {
            o2[k] = cur;
          } else if (cur.constructor !== Object && (handler = constructorHandlers.get(cur.constructor))) {
            o2[k] = handler(cur, cloneProto);
          } else if (ArrayBuffer.isView(cur)) {
            o2[k] = copyBuffer(cur);
          } else {
            const i = refs.indexOf(cur);
            if (i !== -1) {
              o2[k] = refsNew[i];
            } else {
              o2[k] = cloneProto(cur);
            }
          }
        }
        refs.pop();
        refsNew.pop();
        return o2;
      }
    }
  }
});

// ../../node_modules/jsonpath-plus/dist/index-node-cjs.cjs
var require_index_node_cjs = __commonJS({
  "../../node_modules/jsonpath-plus/dist/index-node-cjs.cjs"(exports2) {
    "use strict";
    var vm = __require("vm");
    var Hooks = class {
      /**
       * @callback HookCallback
       * @this {*|Jsep} this
       * @param {Jsep} env
       * @returns: void
       */
      /**
       * Adds the given callback to the list of callbacks for the given hook.
       *
       * The callback will be invoked when the hook it is registered for is run.
       *
       * One callback function can be registered to multiple hooks and the same hook multiple times.
       *
       * @param {string|object} name The name of the hook, or an object of callbacks keyed by name
       * @param {HookCallback|boolean} callback The callback function which is given environment variables.
       * @param {?boolean} [first=false] Will add the hook to the top of the list (defaults to the bottom)
       * @public
       */
      add(name, callback, first) {
        if (typeof arguments[0] != "string") {
          for (let name2 in arguments[0]) {
            this.add(name2, arguments[0][name2], arguments[1]);
          }
        } else {
          (Array.isArray(name) ? name : [name]).forEach(function(name2) {
            this[name2] = this[name2] || [];
            if (callback) {
              this[name2][first ? "unshift" : "push"](callback);
            }
          }, this);
        }
      }
      /**
       * Runs a hook invoking all registered callbacks with the given environment variables.
       *
       * Callbacks will be invoked synchronously and in the order in which they were registered.
       *
       * @param {string} name The name of the hook.
       * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
       * @public
       */
      run(name, env) {
        this[name] = this[name] || [];
        this[name].forEach(function(callback) {
          callback.call(env && env.context ? env.context : env, env);
        });
      }
    };
    var Plugins = class {
      constructor(jsep2) {
        this.jsep = jsep2;
        this.registered = {};
      }
      /**
       * @callback PluginSetup
       * @this {Jsep} jsep
       * @returns: void
       */
      /**
       * Adds the given plugin(s) to the registry
       *
       * @param {object} plugins
       * @param {string} plugins.name The name of the plugin
       * @param {PluginSetup} plugins.init The init function
       * @public
       */
      register(...plugins) {
        plugins.forEach((plugin2) => {
          if (typeof plugin2 !== "object" || !plugin2.name || !plugin2.init) {
            throw new Error("Invalid JSEP plugin format");
          }
          if (this.registered[plugin2.name]) {
            return;
          }
          plugin2.init(this.jsep);
          this.registered[plugin2.name] = plugin2;
        });
      }
    };
    var Jsep = class _Jsep {
      /**
       * @returns {string}
       */
      static get version() {
        return "1.4.0";
      }
      /**
       * @returns {string}
       */
      static toString() {
        return "JavaScript Expression Parser (JSEP) v" + _Jsep.version;
      }
      // ==================== CONFIG ================================
      /**
       * @method addUnaryOp
       * @param {string} op_name The name of the unary op to add
       * @returns {Jsep}
       */
      static addUnaryOp(op_name) {
        _Jsep.max_unop_len = Math.max(op_name.length, _Jsep.max_unop_len);
        _Jsep.unary_ops[op_name] = 1;
        return _Jsep;
      }
      /**
       * @method jsep.addBinaryOp
       * @param {string} op_name The name of the binary op to add
       * @param {number} precedence The precedence of the binary op (can be a float). Higher number = higher precedence
       * @param {boolean} [isRightAssociative=false] whether operator is right-associative
       * @returns {Jsep}
       */
      static addBinaryOp(op_name, precedence, isRightAssociative) {
        _Jsep.max_binop_len = Math.max(op_name.length, _Jsep.max_binop_len);
        _Jsep.binary_ops[op_name] = precedence;
        if (isRightAssociative) {
          _Jsep.right_associative.add(op_name);
        } else {
          _Jsep.right_associative.delete(op_name);
        }
        return _Jsep;
      }
      /**
       * @method addIdentifierChar
       * @param {string} char The additional character to treat as a valid part of an identifier
       * @returns {Jsep}
       */
      static addIdentifierChar(char) {
        _Jsep.additional_identifier_chars.add(char);
        return _Jsep;
      }
      /**
       * @method addLiteral
       * @param {string} literal_name The name of the literal to add
       * @param {*} literal_value The value of the literal
       * @returns {Jsep}
       */
      static addLiteral(literal_name, literal_value) {
        _Jsep.literals[literal_name] = literal_value;
        return _Jsep;
      }
      /**
       * @method removeUnaryOp
       * @param {string} op_name The name of the unary op to remove
       * @returns {Jsep}
       */
      static removeUnaryOp(op_name) {
        delete _Jsep.unary_ops[op_name];
        if (op_name.length === _Jsep.max_unop_len) {
          _Jsep.max_unop_len = _Jsep.getMaxKeyLen(_Jsep.unary_ops);
        }
        return _Jsep;
      }
      /**
       * @method removeAllUnaryOps
       * @returns {Jsep}
       */
      static removeAllUnaryOps() {
        _Jsep.unary_ops = {};
        _Jsep.max_unop_len = 0;
        return _Jsep;
      }
      /**
       * @method removeIdentifierChar
       * @param {string} char The additional character to stop treating as a valid part of an identifier
       * @returns {Jsep}
       */
      static removeIdentifierChar(char) {
        _Jsep.additional_identifier_chars.delete(char);
        return _Jsep;
      }
      /**
       * @method removeBinaryOp
       * @param {string} op_name The name of the binary op to remove
       * @returns {Jsep}
       */
      static removeBinaryOp(op_name) {
        delete _Jsep.binary_ops[op_name];
        if (op_name.length === _Jsep.max_binop_len) {
          _Jsep.max_binop_len = _Jsep.getMaxKeyLen(_Jsep.binary_ops);
        }
        _Jsep.right_associative.delete(op_name);
        return _Jsep;
      }
      /**
       * @method removeAllBinaryOps
       * @returns {Jsep}
       */
      static removeAllBinaryOps() {
        _Jsep.binary_ops = {};
        _Jsep.max_binop_len = 0;
        return _Jsep;
      }
      /**
       * @method removeLiteral
       * @param {string} literal_name The name of the literal to remove
       * @returns {Jsep}
       */
      static removeLiteral(literal_name) {
        delete _Jsep.literals[literal_name];
        return _Jsep;
      }
      /**
       * @method removeAllLiterals
       * @returns {Jsep}
       */
      static removeAllLiterals() {
        _Jsep.literals = {};
        return _Jsep;
      }
      // ==================== END CONFIG ============================
      /**
       * @returns {string}
       */
      get char() {
        return this.expr.charAt(this.index);
      }
      /**
       * @returns {number}
       */
      get code() {
        return this.expr.charCodeAt(this.index);
      }
      /**
       * @param {string} expr a string with the passed in express
       * @returns Jsep
       */
      constructor(expr) {
        this.expr = expr;
        this.index = 0;
      }
      /**
       * static top-level parser
       * @returns {jsep.Expression}
       */
      static parse(expr) {
        return new _Jsep(expr).parse();
      }
      /**
       * Get the longest key length of any object
       * @param {object} obj
       * @returns {number}
       */
      static getMaxKeyLen(obj) {
        return Math.max(0, ...Object.keys(obj).map((k) => k.length));
      }
      /**
       * `ch` is a character code in the next three functions
       * @param {number} ch
       * @returns {boolean}
       */
      static isDecimalDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      /**
       * Returns the precedence of a binary operator or `0` if it isn't a binary operator. Can be float.
       * @param {string} op_val
       * @returns {number}
       */
      static binaryPrecedence(op_val) {
        return _Jsep.binary_ops[op_val] || 0;
      }
      /**
       * Looks for start of identifier
       * @param {number} ch
       * @returns {boolean}
       */
      static isIdentifierStart(ch) {
        return ch >= 65 && ch <= 90 || // A...Z
        ch >= 97 && ch <= 122 || // a...z
        ch >= 128 && !_Jsep.binary_ops[String.fromCharCode(ch)] || // any non-ASCII that is not an operator
        _Jsep.additional_identifier_chars.has(String.fromCharCode(ch));
      }
      /**
       * @param {number} ch
       * @returns {boolean}
       */
      static isIdentifierPart(ch) {
        return _Jsep.isIdentifierStart(ch) || _Jsep.isDecimalDigit(ch);
      }
      /**
       * throw error at index of the expression
       * @param {string} message
       * @throws
       */
      throwError(message) {
        const error = new Error(message + " at character " + this.index);
        error.index = this.index;
        error.description = message;
        throw error;
      }
      /**
       * Run a given hook
       * @param {string} name
       * @param {jsep.Expression|false} [node]
       * @returns {?jsep.Expression}
       */
      runHook(name, node) {
        if (_Jsep.hooks[name]) {
          const env = {
            context: this,
            node
          };
          _Jsep.hooks.run(name, env);
          return env.node;
        }
        return node;
      }
      /**
       * Runs a given hook until one returns a node
       * @param {string} name
       * @returns {?jsep.Expression}
       */
      searchHook(name) {
        if (_Jsep.hooks[name]) {
          const env = {
            context: this
          };
          _Jsep.hooks[name].find(function(callback) {
            callback.call(env.context, env);
            return env.node;
          });
          return env.node;
        }
      }
      /**
       * Push `index` up to the next non-space character
       */
      gobbleSpaces() {
        let ch = this.code;
        while (ch === _Jsep.SPACE_CODE || ch === _Jsep.TAB_CODE || ch === _Jsep.LF_CODE || ch === _Jsep.CR_CODE) {
          ch = this.expr.charCodeAt(++this.index);
        }
        this.runHook("gobble-spaces");
      }
      /**
       * Top-level method to parse all expressions and returns compound or single node
       * @returns {jsep.Expression}
       */
      parse() {
        this.runHook("before-all");
        const nodes = this.gobbleExpressions();
        const node = nodes.length === 1 ? nodes[0] : {
          type: _Jsep.COMPOUND,
          body: nodes
        };
        return this.runHook("after-all", node);
      }
      /**
       * top-level parser (but can be reused within as well)
       * @param {number} [untilICode]
       * @returns {jsep.Expression[]}
       */
      gobbleExpressions(untilICode) {
        let nodes = [], ch_i, node;
        while (this.index < this.expr.length) {
          ch_i = this.code;
          if (ch_i === _Jsep.SEMCOL_CODE || ch_i === _Jsep.COMMA_CODE) {
            this.index++;
          } else {
            if (node = this.gobbleExpression()) {
              nodes.push(node);
            } else if (this.index < this.expr.length) {
              if (ch_i === untilICode) {
                break;
              }
              this.throwError('Unexpected "' + this.char + '"');
            }
          }
        }
        return nodes;
      }
      /**
       * The main parsing function.
       * @returns {?jsep.Expression}
       */
      gobbleExpression() {
        const node = this.searchHook("gobble-expression") || this.gobbleBinaryExpression();
        this.gobbleSpaces();
        return this.runHook("after-expression", node);
      }
      /**
       * Search for the operation portion of the string (e.g. `+`, `===`)
       * Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
       * and move down from 3 to 2 to 1 character until a matching binary operation is found
       * then, return that binary operation
       * @returns {string|boolean}
       */
      gobbleBinaryOp() {
        this.gobbleSpaces();
        let to_check = this.expr.substr(this.index, _Jsep.max_binop_len);
        let tc_len = to_check.length;
        while (tc_len > 0) {
          if (_Jsep.binary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
            this.index += tc_len;
            return to_check;
          }
          to_check = to_check.substr(0, --tc_len);
        }
        return false;
      }
      /**
       * This function is responsible for gobbling an individual expression,
       * e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
       * @returns {?jsep.BinaryExpression}
       */
      gobbleBinaryExpression() {
        let node, biop, prec, stack, biop_info, left, right, i, cur_biop;
        left = this.gobbleToken();
        if (!left) {
          return left;
        }
        biop = this.gobbleBinaryOp();
        if (!biop) {
          return left;
        }
        biop_info = {
          value: biop,
          prec: _Jsep.binaryPrecedence(biop),
          right_a: _Jsep.right_associative.has(biop)
        };
        right = this.gobbleToken();
        if (!right) {
          this.throwError("Expected expression after " + biop);
        }
        stack = [left, biop_info, right];
        while (biop = this.gobbleBinaryOp()) {
          prec = _Jsep.binaryPrecedence(biop);
          if (prec === 0) {
            this.index -= biop.length;
            break;
          }
          biop_info = {
            value: biop,
            prec,
            right_a: _Jsep.right_associative.has(biop)
          };
          cur_biop = biop;
          const comparePrev = (prev) => biop_info.right_a && prev.right_a ? prec > prev.prec : prec <= prev.prec;
          while (stack.length > 2 && comparePrev(stack[stack.length - 2])) {
            right = stack.pop();
            biop = stack.pop().value;
            left = stack.pop();
            node = {
              type: _Jsep.BINARY_EXP,
              operator: biop,
              left,
              right
            };
            stack.push(node);
          }
          node = this.gobbleToken();
          if (!node) {
            this.throwError("Expected expression after " + cur_biop);
          }
          stack.push(biop_info, node);
        }
        i = stack.length - 1;
        node = stack[i];
        while (i > 1) {
          node = {
            type: _Jsep.BINARY_EXP,
            operator: stack[i - 1].value,
            left: stack[i - 2],
            right: node
          };
          i -= 2;
        }
        return node;
      }
      /**
       * An individual part of a binary expression:
       * e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
       * @returns {boolean|jsep.Expression}
       */
      gobbleToken() {
        let ch, to_check, tc_len, node;
        this.gobbleSpaces();
        node = this.searchHook("gobble-token");
        if (node) {
          return this.runHook("after-token", node);
        }
        ch = this.code;
        if (_Jsep.isDecimalDigit(ch) || ch === _Jsep.PERIOD_CODE) {
          return this.gobbleNumericLiteral();
        }
        if (ch === _Jsep.SQUOTE_CODE || ch === _Jsep.DQUOTE_CODE) {
          node = this.gobbleStringLiteral();
        } else if (ch === _Jsep.OBRACK_CODE) {
          node = this.gobbleArray();
        } else {
          to_check = this.expr.substr(this.index, _Jsep.max_unop_len);
          tc_len = to_check.length;
          while (tc_len > 0) {
            if (_Jsep.unary_ops.hasOwnProperty(to_check) && (!_Jsep.isIdentifierStart(this.code) || this.index + to_check.length < this.expr.length && !_Jsep.isIdentifierPart(this.expr.charCodeAt(this.index + to_check.length)))) {
              this.index += tc_len;
              const argument = this.gobbleToken();
              if (!argument) {
                this.throwError("missing unaryOp argument");
              }
              return this.runHook("after-token", {
                type: _Jsep.UNARY_EXP,
                operator: to_check,
                argument,
                prefix: true
              });
            }
            to_check = to_check.substr(0, --tc_len);
          }
          if (_Jsep.isIdentifierStart(ch)) {
            node = this.gobbleIdentifier();
            if (_Jsep.literals.hasOwnProperty(node.name)) {
              node = {
                type: _Jsep.LITERAL,
                value: _Jsep.literals[node.name],
                raw: node.name
              };
            } else if (node.name === _Jsep.this_str) {
              node = {
                type: _Jsep.THIS_EXP
              };
            }
          } else if (ch === _Jsep.OPAREN_CODE) {
            node = this.gobbleGroup();
          }
        }
        if (!node) {
          return this.runHook("after-token", false);
        }
        node = this.gobbleTokenProperty(node);
        return this.runHook("after-token", node);
      }
      /**
       * Gobble properties of of identifiers/strings/arrays/groups.
       * e.g. `foo`, `bar.baz`, `foo['bar'].baz`
       * It also gobbles function calls:
       * e.g. `Math.acos(obj.angle)`
       * @param {jsep.Expression} node
       * @returns {jsep.Expression}
       */
      gobbleTokenProperty(node) {
        this.gobbleSpaces();
        let ch = this.code;
        while (ch === _Jsep.PERIOD_CODE || ch === _Jsep.OBRACK_CODE || ch === _Jsep.OPAREN_CODE || ch === _Jsep.QUMARK_CODE) {
          let optional;
          if (ch === _Jsep.QUMARK_CODE) {
            if (this.expr.charCodeAt(this.index + 1) !== _Jsep.PERIOD_CODE) {
              break;
            }
            optional = true;
            this.index += 2;
            this.gobbleSpaces();
            ch = this.code;
          }
          this.index++;
          if (ch === _Jsep.OBRACK_CODE) {
            node = {
              type: _Jsep.MEMBER_EXP,
              computed: true,
              object: node,
              property: this.gobbleExpression()
            };
            if (!node.property) {
              this.throwError('Unexpected "' + this.char + '"');
            }
            this.gobbleSpaces();
            ch = this.code;
            if (ch !== _Jsep.CBRACK_CODE) {
              this.throwError("Unclosed [");
            }
            this.index++;
          } else if (ch === _Jsep.OPAREN_CODE) {
            node = {
              type: _Jsep.CALL_EXP,
              "arguments": this.gobbleArguments(_Jsep.CPAREN_CODE),
              callee: node
            };
          } else if (ch === _Jsep.PERIOD_CODE || optional) {
            if (optional) {
              this.index--;
            }
            this.gobbleSpaces();
            node = {
              type: _Jsep.MEMBER_EXP,
              computed: false,
              object: node,
              property: this.gobbleIdentifier()
            };
          }
          if (optional) {
            node.optional = true;
          }
          this.gobbleSpaces();
          ch = this.code;
        }
        return node;
      }
      /**
       * Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
       * keep track of everything in the numeric literal and then calling `parseFloat` on that string
       * @returns {jsep.Literal}
       */
      gobbleNumericLiteral() {
        let number = "", ch, chCode;
        while (_Jsep.isDecimalDigit(this.code)) {
          number += this.expr.charAt(this.index++);
        }
        if (this.code === _Jsep.PERIOD_CODE) {
          number += this.expr.charAt(this.index++);
          while (_Jsep.isDecimalDigit(this.code)) {
            number += this.expr.charAt(this.index++);
          }
        }
        ch = this.char;
        if (ch === "e" || ch === "E") {
          number += this.expr.charAt(this.index++);
          ch = this.char;
          if (ch === "+" || ch === "-") {
            number += this.expr.charAt(this.index++);
          }
          while (_Jsep.isDecimalDigit(this.code)) {
            number += this.expr.charAt(this.index++);
          }
          if (!_Jsep.isDecimalDigit(this.expr.charCodeAt(this.index - 1))) {
            this.throwError("Expected exponent (" + number + this.char + ")");
          }
        }
        chCode = this.code;
        if (_Jsep.isIdentifierStart(chCode)) {
          this.throwError("Variable names cannot start with a number (" + number + this.char + ")");
        } else if (chCode === _Jsep.PERIOD_CODE || number.length === 1 && number.charCodeAt(0) === _Jsep.PERIOD_CODE) {
          this.throwError("Unexpected period");
        }
        return {
          type: _Jsep.LITERAL,
          value: parseFloat(number),
          raw: number
        };
      }
      /**
       * Parses a string literal, staring with single or double quotes with basic support for escape codes
       * e.g. `"hello world"`, `'this is\nJSEP'`
       * @returns {jsep.Literal}
       */
      gobbleStringLiteral() {
        let str = "";
        const startIndex = this.index;
        const quote = this.expr.charAt(this.index++);
        let closed = false;
        while (this.index < this.expr.length) {
          let ch = this.expr.charAt(this.index++);
          if (ch === quote) {
            closed = true;
            break;
          } else if (ch === "\\") {
            ch = this.expr.charAt(this.index++);
            switch (ch) {
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "b":
                str += "\b";
                break;
              case "f":
                str += "\f";
                break;
              case "v":
                str += "\v";
                break;
              default:
                str += ch;
            }
          } else {
            str += ch;
          }
        }
        if (!closed) {
          this.throwError('Unclosed quote after "' + str + '"');
        }
        return {
          type: _Jsep.LITERAL,
          value: str,
          raw: this.expr.substring(startIndex, this.index)
        };
      }
      /**
       * Gobbles only identifiers
       * e.g.: `foo`, `_value`, `$x1`
       * Also, this function checks if that identifier is a literal:
       * (e.g. `true`, `false`, `null`) or `this`
       * @returns {jsep.Identifier}
       */
      gobbleIdentifier() {
        let ch = this.code, start = this.index;
        if (_Jsep.isIdentifierStart(ch)) {
          this.index++;
        } else {
          this.throwError("Unexpected " + this.char);
        }
        while (this.index < this.expr.length) {
          ch = this.code;
          if (_Jsep.isIdentifierPart(ch)) {
            this.index++;
          } else {
            break;
          }
        }
        return {
          type: _Jsep.IDENTIFIER,
          name: this.expr.slice(start, this.index)
        };
      }
      /**
       * Gobbles a list of arguments within the context of a function call
       * or array literal. This function also assumes that the opening character
       * `(` or `[` has already been gobbled, and gobbles expressions and commas
       * until the terminator character `)` or `]` is encountered.
       * e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
       * @param {number} termination
       * @returns {jsep.Expression[]}
       */
      gobbleArguments(termination) {
        const args = [];
        let closed = false;
        let separator_count = 0;
        while (this.index < this.expr.length) {
          this.gobbleSpaces();
          let ch_i = this.code;
          if (ch_i === termination) {
            closed = true;
            this.index++;
            if (termination === _Jsep.CPAREN_CODE && separator_count && separator_count >= args.length) {
              this.throwError("Unexpected token " + String.fromCharCode(termination));
            }
            break;
          } else if (ch_i === _Jsep.COMMA_CODE) {
            this.index++;
            separator_count++;
            if (separator_count !== args.length) {
              if (termination === _Jsep.CPAREN_CODE) {
                this.throwError("Unexpected token ,");
              } else if (termination === _Jsep.CBRACK_CODE) {
                for (let arg = args.length; arg < separator_count; arg++) {
                  args.push(null);
                }
              }
            }
          } else if (args.length !== separator_count && separator_count !== 0) {
            this.throwError("Expected comma");
          } else {
            const node = this.gobbleExpression();
            if (!node || node.type === _Jsep.COMPOUND) {
              this.throwError("Expected comma");
            }
            args.push(node);
          }
        }
        if (!closed) {
          this.throwError("Expected " + String.fromCharCode(termination));
        }
        return args;
      }
      /**
       * Responsible for parsing a group of things within parentheses `()`
       * that have no identifier in front (so not a function call)
       * This function assumes that it needs to gobble the opening parenthesis
       * and then tries to gobble everything within that parenthesis, assuming
       * that the next thing it should see is the close parenthesis. If not,
       * then the expression probably doesn't have a `)`
       * @returns {boolean|jsep.Expression}
       */
      gobbleGroup() {
        this.index++;
        let nodes = this.gobbleExpressions(_Jsep.CPAREN_CODE);
        if (this.code === _Jsep.CPAREN_CODE) {
          this.index++;
          if (nodes.length === 1) {
            return nodes[0];
          } else if (!nodes.length) {
            return false;
          } else {
            return {
              type: _Jsep.SEQUENCE_EXP,
              expressions: nodes
            };
          }
        } else {
          this.throwError("Unclosed (");
        }
      }
      /**
       * Responsible for parsing Array literals `[1, 2, 3]`
       * This function assumes that it needs to gobble the opening bracket
       * and then tries to gobble the expressions as arguments.
       * @returns {jsep.ArrayExpression}
       */
      gobbleArray() {
        this.index++;
        return {
          type: _Jsep.ARRAY_EXP,
          elements: this.gobbleArguments(_Jsep.CBRACK_CODE)
        };
      }
    };
    var hooks = new Hooks();
    Object.assign(Jsep, {
      hooks,
      plugins: new Plugins(Jsep),
      // Node Types
      // ----------
      // This is the full set of types that any JSEP node can be.
      // Store them here to save space when minified
      COMPOUND: "Compound",
      SEQUENCE_EXP: "SequenceExpression",
      IDENTIFIER: "Identifier",
      MEMBER_EXP: "MemberExpression",
      LITERAL: "Literal",
      THIS_EXP: "ThisExpression",
      CALL_EXP: "CallExpression",
      UNARY_EXP: "UnaryExpression",
      BINARY_EXP: "BinaryExpression",
      ARRAY_EXP: "ArrayExpression",
      TAB_CODE: 9,
      LF_CODE: 10,
      CR_CODE: 13,
      SPACE_CODE: 32,
      PERIOD_CODE: 46,
      // '.'
      COMMA_CODE: 44,
      // ','
      SQUOTE_CODE: 39,
      // single quote
      DQUOTE_CODE: 34,
      // double quotes
      OPAREN_CODE: 40,
      // (
      CPAREN_CODE: 41,
      // )
      OBRACK_CODE: 91,
      // [
      CBRACK_CODE: 93,
      // ]
      QUMARK_CODE: 63,
      // ?
      SEMCOL_CODE: 59,
      // ;
      COLON_CODE: 58,
      // :
      // Operations
      // ----------
      // Use a quickly-accessible map to store all of the unary operators
      // Values are set to `1` (it really doesn't matter)
      unary_ops: {
        "-": 1,
        "!": 1,
        "~": 1,
        "+": 1
      },
      // Also use a map for the binary operations but set their values to their
      // binary precedence for quick reference (higher number = higher precedence)
      // see [Order of operations](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)
      binary_ops: {
        "||": 1,
        "??": 1,
        "&&": 2,
        "|": 3,
        "^": 4,
        "&": 5,
        "==": 6,
        "!=": 6,
        "===": 6,
        "!==": 6,
        "<": 7,
        ">": 7,
        "<=": 7,
        ">=": 7,
        "<<": 8,
        ">>": 8,
        ">>>": 8,
        "+": 9,
        "-": 9,
        "*": 10,
        "/": 10,
        "%": 10,
        "**": 11
      },
      // sets specific binary_ops as right-associative
      right_associative: /* @__PURE__ */ new Set(["**"]),
      // Additional valid identifier chars, apart from a-z, A-Z and 0-9 (except on the starting char)
      additional_identifier_chars: /* @__PURE__ */ new Set(["$", "_"]),
      // Literals
      // ----------
      // Store the values to return for the various literals we may encounter
      literals: {
        "true": true,
        "false": false,
        "null": null
      },
      // Except for `this`, which is special. This could be changed to something like `'self'` as well
      this_str: "this"
    });
    Jsep.max_unop_len = Jsep.getMaxKeyLen(Jsep.unary_ops);
    Jsep.max_binop_len = Jsep.getMaxKeyLen(Jsep.binary_ops);
    var jsep = (expr) => new Jsep(expr).parse();
    var stdClassProps = Object.getOwnPropertyNames(class Test {
    });
    Object.getOwnPropertyNames(Jsep).filter((prop) => !stdClassProps.includes(prop) && jsep[prop] === void 0).forEach((m) => {
      jsep[m] = Jsep[m];
    });
    jsep.Jsep = Jsep;
    var CONDITIONAL_EXP = "ConditionalExpression";
    var ternary = {
      name: "ternary",
      init(jsep2) {
        jsep2.hooks.add("after-expression", function gobbleTernary(env) {
          if (env.node && this.code === jsep2.QUMARK_CODE) {
            this.index++;
            const test = env.node;
            const consequent = this.gobbleExpression();
            if (!consequent) {
              this.throwError("Expected expression");
            }
            this.gobbleSpaces();
            if (this.code === jsep2.COLON_CODE) {
              this.index++;
              const alternate = this.gobbleExpression();
              if (!alternate) {
                this.throwError("Expected expression");
              }
              env.node = {
                type: CONDITIONAL_EXP,
                test,
                consequent,
                alternate
              };
              if (test.operator && jsep2.binary_ops[test.operator] <= 0.9) {
                let newTest = test;
                while (newTest.right.operator && jsep2.binary_ops[newTest.right.operator] <= 0.9) {
                  newTest = newTest.right;
                }
                env.node.test = newTest.right;
                newTest.right = env.node;
                env.node = test;
              }
            } else {
              this.throwError("Expected :");
            }
          }
        });
      }
    };
    jsep.plugins.register(ternary);
    var FSLASH_CODE = 47;
    var BSLASH_CODE = 92;
    var index = {
      name: "regex",
      init(jsep2) {
        jsep2.hooks.add("gobble-token", function gobbleRegexLiteral(env) {
          if (this.code === FSLASH_CODE) {
            const patternIndex = ++this.index;
            let inCharSet = false;
            while (this.index < this.expr.length) {
              if (this.code === FSLASH_CODE && !inCharSet) {
                const pattern = this.expr.slice(patternIndex, this.index);
                let flags = "";
                while (++this.index < this.expr.length) {
                  const code = this.code;
                  if (code >= 97 && code <= 122 || code >= 65 && code <= 90 || code >= 48 && code <= 57) {
                    flags += this.char;
                  } else {
                    break;
                  }
                }
                let value;
                try {
                  value = new RegExp(pattern, flags);
                } catch (e) {
                  this.throwError(e.message);
                }
                env.node = {
                  type: jsep2.LITERAL,
                  value,
                  raw: this.expr.slice(patternIndex - 1, this.index)
                };
                env.node = this.gobbleTokenProperty(env.node);
                return env.node;
              }
              if (this.code === jsep2.OBRACK_CODE) {
                inCharSet = true;
              } else if (inCharSet && this.code === jsep2.CBRACK_CODE) {
                inCharSet = false;
              }
              this.index += this.code === BSLASH_CODE ? 2 : 1;
            }
            this.throwError("Unclosed Regex");
          }
        });
      }
    };
    var PLUS_CODE = 43;
    var MINUS_CODE = 45;
    var plugin = {
      name: "assignment",
      assignmentOperators: /* @__PURE__ */ new Set(["=", "*=", "**=", "/=", "%=", "+=", "-=", "<<=", ">>=", ">>>=", "&=", "^=", "|=", "||=", "&&=", "??="]),
      updateOperators: [PLUS_CODE, MINUS_CODE],
      assignmentPrecedence: 0.9,
      init(jsep2) {
        const updateNodeTypes = [jsep2.IDENTIFIER, jsep2.MEMBER_EXP];
        plugin.assignmentOperators.forEach((op) => jsep2.addBinaryOp(op, plugin.assignmentPrecedence, true));
        jsep2.hooks.add("gobble-token", function gobbleUpdatePrefix(env) {
          const code = this.code;
          if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
            this.index += 2;
            env.node = {
              type: "UpdateExpression",
              operator: code === PLUS_CODE ? "++" : "--",
              argument: this.gobbleTokenProperty(this.gobbleIdentifier()),
              prefix: true
            };
            if (!env.node.argument || !updateNodeTypes.includes(env.node.argument.type)) {
              this.throwError(`Unexpected ${env.node.operator}`);
            }
          }
        });
        jsep2.hooks.add("after-token", function gobbleUpdatePostfix(env) {
          if (env.node) {
            const code = this.code;
            if (plugin.updateOperators.some((c) => c === code && c === this.expr.charCodeAt(this.index + 1))) {
              if (!updateNodeTypes.includes(env.node.type)) {
                this.throwError(`Unexpected ${env.node.operator}`);
              }
              this.index += 2;
              env.node = {
                type: "UpdateExpression",
                operator: code === PLUS_CODE ? "++" : "--",
                argument: env.node,
                prefix: false
              };
            }
          }
        });
        jsep2.hooks.add("after-expression", function gobbleAssignment(env) {
          if (env.node) {
            updateBinariesToAssignments(env.node);
          }
        });
        function updateBinariesToAssignments(node) {
          if (plugin.assignmentOperators.has(node.operator)) {
            node.type = "AssignmentExpression";
            updateBinariesToAssignments(node.left);
            updateBinariesToAssignments(node.right);
          } else if (!node.operator) {
            Object.values(node).forEach((val) => {
              if (val && typeof val === "object") {
                updateBinariesToAssignments(val);
              }
            });
          }
        }
      }
    };
    jsep.plugins.register(index, plugin);
    jsep.addUnaryOp("typeof");
    jsep.addLiteral("null", null);
    jsep.addLiteral("undefined", void 0);
    var BLOCKED_PROTO_PROPERTIES = /* @__PURE__ */ new Set(["constructor", "__proto__", "__defineGetter__", "__defineSetter__"]);
    var SafeEval = {
      /**
       * @param {jsep.Expression} ast
       * @param {Record<string, any>} subs
       */
      evalAst(ast, subs) {
        switch (ast.type) {
          case "BinaryExpression":
          case "LogicalExpression":
            return SafeEval.evalBinaryExpression(ast, subs);
          case "Compound":
            return SafeEval.evalCompound(ast, subs);
          case "ConditionalExpression":
            return SafeEval.evalConditionalExpression(ast, subs);
          case "Identifier":
            return SafeEval.evalIdentifier(ast, subs);
          case "Literal":
            return SafeEval.evalLiteral(ast, subs);
          case "MemberExpression":
            return SafeEval.evalMemberExpression(ast, subs);
          case "UnaryExpression":
            return SafeEval.evalUnaryExpression(ast, subs);
          case "ArrayExpression":
            return SafeEval.evalArrayExpression(ast, subs);
          case "CallExpression":
            return SafeEval.evalCallExpression(ast, subs);
          case "AssignmentExpression":
            return SafeEval.evalAssignmentExpression(ast, subs);
          default:
            throw SyntaxError("Unexpected expression", ast);
        }
      },
      evalBinaryExpression(ast, subs) {
        const result = {
          "||": (a, b) => a || b(),
          "&&": (a, b) => a && b(),
          "|": (a, b) => a | b(),
          "^": (a, b) => a ^ b(),
          "&": (a, b) => a & b(),
          // eslint-disable-next-line eqeqeq -- API
          "==": (a, b) => a == b(),
          // eslint-disable-next-line eqeqeq -- API
          "!=": (a, b) => a != b(),
          "===": (a, b) => a === b(),
          "!==": (a, b) => a !== b(),
          "<": (a, b) => a < b(),
          ">": (a, b) => a > b(),
          "<=": (a, b) => a <= b(),
          ">=": (a, b) => a >= b(),
          "<<": (a, b) => a << b(),
          ">>": (a, b) => a >> b(),
          ">>>": (a, b) => a >>> b(),
          "+": (a, b) => a + b(),
          "-": (a, b) => a - b(),
          "*": (a, b) => a * b(),
          "/": (a, b) => a / b(),
          "%": (a, b) => a % b()
        }[ast.operator](SafeEval.evalAst(ast.left, subs), () => SafeEval.evalAst(ast.right, subs));
        return result;
      },
      evalCompound(ast, subs) {
        let last;
        for (let i = 0; i < ast.body.length; i++) {
          if (ast.body[i].type === "Identifier" && ["var", "let", "const"].includes(ast.body[i].name) && ast.body[i + 1] && ast.body[i + 1].type === "AssignmentExpression") {
            i += 1;
          }
          const expr = ast.body[i];
          last = SafeEval.evalAst(expr, subs);
        }
        return last;
      },
      evalConditionalExpression(ast, subs) {
        if (SafeEval.evalAst(ast.test, subs)) {
          return SafeEval.evalAst(ast.consequent, subs);
        }
        return SafeEval.evalAst(ast.alternate, subs);
      },
      evalIdentifier(ast, subs) {
        if (Object.hasOwn(subs, ast.name)) {
          return subs[ast.name];
        }
        throw ReferenceError(`${ast.name} is not defined`);
      },
      evalLiteral(ast) {
        return ast.value;
      },
      evalMemberExpression(ast, subs) {
        const prop = String(
          // NOTE: `String(value)` throws error when
          // value has overwritten the toString method to return non-string
          // i.e. `value = {toString: () => []}`
          ast.computed ? SafeEval.evalAst(ast.property) : ast.property.name
          // `object.property` property is Identifier
        );
        const obj = SafeEval.evalAst(ast.object, subs);
        if (obj === void 0 || obj === null) {
          throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
        }
        if (!Object.hasOwn(obj, prop) && BLOCKED_PROTO_PROPERTIES.has(prop)) {
          throw TypeError(`Cannot read properties of ${obj} (reading '${prop}')`);
        }
        const result = obj[prop];
        if (typeof result === "function") {
          return result.bind(obj);
        }
        return result;
      },
      evalUnaryExpression(ast, subs) {
        const result = {
          "-": (a) => -SafeEval.evalAst(a, subs),
          "!": (a) => !SafeEval.evalAst(a, subs),
          "~": (a) => ~SafeEval.evalAst(a, subs),
          // eslint-disable-next-line no-implicit-coercion -- API
          "+": (a) => +SafeEval.evalAst(a, subs),
          typeof: (a) => typeof SafeEval.evalAst(a, subs)
        }[ast.operator](ast.argument);
        return result;
      },
      evalArrayExpression(ast, subs) {
        return ast.elements.map((el) => SafeEval.evalAst(el, subs));
      },
      evalCallExpression(ast, subs) {
        const args = ast.arguments.map((arg) => SafeEval.evalAst(arg, subs));
        const func = SafeEval.evalAst(ast.callee, subs);
        return func(...args);
      },
      evalAssignmentExpression(ast, subs) {
        if (ast.left.type !== "Identifier") {
          throw SyntaxError("Invalid left-hand side in assignment");
        }
        const id = ast.left.name;
        const value = SafeEval.evalAst(ast.right, subs);
        subs[id] = value;
        return subs[id];
      }
    };
    var SafeScript = class {
      /**
       * @param {string} expr Expression to evaluate
       */
      constructor(expr) {
        this.code = expr;
        this.ast = jsep(this.code);
      }
      /**
       * @param {object} context Object whose items will be added
       *   to evaluation
       * @returns {EvaluatedResult} Result of evaluated code
       */
      runInNewContext(context2) {
        const keyMap = Object.assign(/* @__PURE__ */ Object.create(null), context2);
        return SafeEval.evalAst(this.ast, keyMap);
      }
    };
    function push(arr, item) {
      arr = arr.slice();
      arr.push(item);
      return arr;
    }
    function unshift(item, arr) {
      arr = arr.slice();
      arr.unshift(item);
      return arr;
    }
    var NewError = class extends Error {
      /**
       * @param {AnyResult} value The evaluated scalar value
       */
      constructor(value) {
        super('JSONPath should not be called with "new" (it prevents return of (unwrapped) scalar values)');
        this.avoidNew = true;
        this.value = value;
        this.name = "NewError";
      }
    };
    function JSONPath(opts, expr, obj, callback, otherTypeCallback) {
      if (!(this instanceof JSONPath)) {
        try {
          return new JSONPath(opts, expr, obj, callback, otherTypeCallback);
        } catch (e) {
          if (!e.avoidNew) {
            throw e;
          }
          return e.value;
        }
      }
      if (typeof opts === "string") {
        otherTypeCallback = callback;
        callback = obj;
        obj = expr;
        expr = opts;
        opts = null;
      }
      const optObj = opts && typeof opts === "object";
      opts = opts || {};
      this.json = opts.json || obj;
      this.path = opts.path || expr;
      this.resultType = opts.resultType || "value";
      this.flatten = opts.flatten || false;
      this.wrap = Object.hasOwn(opts, "wrap") ? opts.wrap : true;
      this.sandbox = opts.sandbox || {};
      this.eval = opts.eval === void 0 ? "safe" : opts.eval;
      this.ignoreEvalErrors = typeof opts.ignoreEvalErrors === "undefined" ? false : opts.ignoreEvalErrors;
      this.parent = opts.parent || null;
      this.parentProperty = opts.parentProperty || null;
      this.callback = opts.callback || callback || null;
      this.otherTypeCallback = opts.otherTypeCallback || otherTypeCallback || function() {
        throw new TypeError("You must supply an otherTypeCallback callback option with the @other() operator.");
      };
      if (opts.autostart !== false) {
        const args = {
          path: optObj ? opts.path : expr
        };
        if (!optObj) {
          args.json = obj;
        } else if ("json" in opts) {
          args.json = opts.json;
        }
        const ret = this.evaluate(args);
        if (!ret || typeof ret !== "object") {
          throw new NewError(ret);
        }
        return ret;
      }
    }
    JSONPath.prototype.evaluate = function(expr, json, callback, otherTypeCallback) {
      let currParent = this.parent, currParentProperty = this.parentProperty;
      let {
        flatten,
        wrap
      } = this;
      this.currResultType = this.resultType;
      this.currEval = this.eval;
      this.currSandbox = this.sandbox;
      callback = callback || this.callback;
      this.currOtherTypeCallback = otherTypeCallback || this.otherTypeCallback;
      json = json || this.json;
      expr = expr || this.path;
      if (expr && typeof expr === "object" && !Array.isArray(expr)) {
        if (!expr.path && expr.path !== "") {
          throw new TypeError('You must supply a "path" property when providing an object argument to JSONPath.evaluate().');
        }
        if (!Object.hasOwn(expr, "json")) {
          throw new TypeError('You must supply a "json" property when providing an object argument to JSONPath.evaluate().');
        }
        ({
          json
        } = expr);
        flatten = Object.hasOwn(expr, "flatten") ? expr.flatten : flatten;
        this.currResultType = Object.hasOwn(expr, "resultType") ? expr.resultType : this.currResultType;
        this.currSandbox = Object.hasOwn(expr, "sandbox") ? expr.sandbox : this.currSandbox;
        wrap = Object.hasOwn(expr, "wrap") ? expr.wrap : wrap;
        this.currEval = Object.hasOwn(expr, "eval") ? expr.eval : this.currEval;
        callback = Object.hasOwn(expr, "callback") ? expr.callback : callback;
        this.currOtherTypeCallback = Object.hasOwn(expr, "otherTypeCallback") ? expr.otherTypeCallback : this.currOtherTypeCallback;
        currParent = Object.hasOwn(expr, "parent") ? expr.parent : currParent;
        currParentProperty = Object.hasOwn(expr, "parentProperty") ? expr.parentProperty : currParentProperty;
        expr = expr.path;
      }
      currParent = currParent || null;
      currParentProperty = currParentProperty || null;
      if (Array.isArray(expr)) {
        expr = JSONPath.toPathString(expr);
      }
      if (!expr && expr !== "" || !json) {
        return void 0;
      }
      const exprList = JSONPath.toPathArray(expr);
      if (exprList[0] === "$" && exprList.length > 1) {
        exprList.shift();
      }
      this._hasParentSelector = null;
      const result = this._trace(exprList, json, ["$"], currParent, currParentProperty, callback).filter(function(ea) {
        return ea && !ea.isParentSelector;
      });
      if (!result.length) {
        return wrap ? [] : void 0;
      }
      if (!wrap && result.length === 1 && !result[0].hasArrExpr) {
        return this._getPreferredOutput(result[0]);
      }
      return result.reduce((rslt, ea) => {
        const valOrPath = this._getPreferredOutput(ea);
        if (flatten && Array.isArray(valOrPath)) {
          rslt = rslt.concat(valOrPath);
        } else {
          rslt.push(valOrPath);
        }
        return rslt;
      }, []);
    };
    JSONPath.prototype._getPreferredOutput = function(ea) {
      const resultType = this.currResultType;
      switch (resultType) {
        case "all": {
          const path = Array.isArray(ea.path) ? ea.path : JSONPath.toPathArray(ea.path);
          ea.pointer = JSONPath.toPointer(path);
          ea.path = typeof ea.path === "string" ? ea.path : JSONPath.toPathString(ea.path);
          return ea;
        }
        case "value":
        case "parent":
        case "parentProperty":
          return ea[resultType];
        case "path":
          return JSONPath.toPathString(ea[resultType]);
        case "pointer":
          return JSONPath.toPointer(ea.path);
        default:
          throw new TypeError("Unknown result type");
      }
    };
    JSONPath.prototype._handleCallback = function(fullRetObj, callback, type) {
      if (callback) {
        const preferredOutput = this._getPreferredOutput(fullRetObj);
        fullRetObj.path = typeof fullRetObj.path === "string" ? fullRetObj.path : JSONPath.toPathString(fullRetObj.path);
        callback(preferredOutput, type, fullRetObj);
      }
    };
    JSONPath.prototype._trace = function(expr, val, path, parent, parentPropName, callback, hasArrExpr, literalPriority) {
      let retObj;
      if (!expr.length) {
        retObj = {
          path,
          value: val,
          parent,
          parentProperty: parentPropName,
          hasArrExpr
        };
        this._handleCallback(retObj, callback, "value");
        return retObj;
      }
      const loc = expr[0], x = expr.slice(1);
      const ret = [];
      function addRet(elems) {
        if (Array.isArray(elems)) {
          elems.forEach((t) => {
            ret.push(t);
          });
        } else {
          ret.push(elems);
        }
      }
      if ((typeof loc !== "string" || literalPriority) && val && Object.hasOwn(val, loc)) {
        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr));
      } else if (loc === "*") {
        this._walk(val, (m) => {
          addRet(this._trace(x, val[m], push(path, m), val, m, callback, true, true));
        });
      } else if (loc === "..") {
        addRet(this._trace(x, val, path, parent, parentPropName, callback, hasArrExpr));
        this._walk(val, (m) => {
          if (typeof val[m] === "object") {
            addRet(this._trace(expr.slice(), val[m], push(path, m), val, m, callback, true));
          }
        });
      } else if (loc === "^") {
        this._hasParentSelector = true;
        return {
          path: path.slice(0, -1),
          expr: x,
          isParentSelector: true
        };
      } else if (loc === "~") {
        retObj = {
          path: push(path, loc),
          value: parentPropName,
          parent,
          parentProperty: null
        };
        this._handleCallback(retObj, callback, "property");
        return retObj;
      } else if (loc === "$") {
        addRet(this._trace(x, val, path, null, null, callback, hasArrExpr));
      } else if (/^(-?\d*):(-?\d*):?(\d*)$/u.test(loc)) {
        addRet(this._slice(loc, x, val, path, parent, parentPropName, callback));
      } else if (loc.indexOf("?(") === 0) {
        if (this.currEval === false) {
          throw new Error("Eval [?(expr)] prevented in JSONPath expression.");
        }
        const safeLoc = loc.replace(/^\?\((.*?)\)$/u, "$1");
        const nested = /@.?([^?]*)[['](\??\(.*?\))(?!.\)\])[\]']/gu.exec(safeLoc);
        if (nested) {
          this._walk(val, (m) => {
            const npath = [nested[2]];
            const nvalue = nested[1] ? val[m][nested[1]] : val[m];
            const filterResults = this._trace(npath, nvalue, path, parent, parentPropName, callback, true);
            if (filterResults.length > 0) {
              addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
            }
          });
        } else {
          this._walk(val, (m) => {
            if (this._eval(safeLoc, val[m], m, path, parent, parentPropName)) {
              addRet(this._trace(x, val[m], push(path, m), val, m, callback, true));
            }
          });
        }
      } else if (loc[0] === "(") {
        if (this.currEval === false) {
          throw new Error("Eval [(expr)] prevented in JSONPath expression.");
        }
        addRet(this._trace(unshift(this._eval(loc, val, path.at(-1), path.slice(0, -1), parent, parentPropName), x), val, path, parent, parentPropName, callback, hasArrExpr));
      } else if (loc[0] === "@") {
        let addType = false;
        const valueType = loc.slice(1, -2);
        switch (valueType) {
          case "scalar":
            if (!val || !["object", "function"].includes(typeof val)) {
              addType = true;
            }
            break;
          case "boolean":
          case "string":
          case "undefined":
          case "function":
            if (typeof val === valueType) {
              addType = true;
            }
            break;
          case "integer":
            if (Number.isFinite(val) && !(val % 1)) {
              addType = true;
            }
            break;
          case "number":
            if (Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "nonFinite":
            if (typeof val === "number" && !Number.isFinite(val)) {
              addType = true;
            }
            break;
          case "object":
            if (val && typeof val === valueType) {
              addType = true;
            }
            break;
          case "array":
            if (Array.isArray(val)) {
              addType = true;
            }
            break;
          case "other":
            addType = this.currOtherTypeCallback(val, path, parent, parentPropName);
            break;
          case "null":
            if (val === null) {
              addType = true;
            }
            break;
          /* c8 ignore next 2 */
          default:
            throw new TypeError("Unknown value type " + valueType);
        }
        if (addType) {
          retObj = {
            path,
            value: val,
            parent,
            parentProperty: parentPropName
          };
          this._handleCallback(retObj, callback, "value");
          return retObj;
        }
      } else if (loc[0] === "`" && val && Object.hasOwn(val, loc.slice(1))) {
        const locProp = loc.slice(1);
        addRet(this._trace(x, val[locProp], push(path, locProp), val, locProp, callback, hasArrExpr, true));
      } else if (loc.includes(",")) {
        const parts = loc.split(",");
        for (const part of parts) {
          addRet(this._trace(unshift(part, x), val, path, parent, parentPropName, callback, true));
        }
      } else if (!literalPriority && val && Object.hasOwn(val, loc)) {
        addRet(this._trace(x, val[loc], push(path, loc), val, loc, callback, hasArrExpr, true));
      }
      if (this._hasParentSelector) {
        for (let t = 0; t < ret.length; t++) {
          const rett = ret[t];
          if (rett && rett.isParentSelector) {
            const tmp = this._trace(rett.expr, val, rett.path, parent, parentPropName, callback, hasArrExpr);
            if (Array.isArray(tmp)) {
              ret[t] = tmp[0];
              const tl = tmp.length;
              for (let tt = 1; tt < tl; tt++) {
                t++;
                ret.splice(t, 0, tmp[tt]);
              }
            } else {
              ret[t] = tmp;
            }
          }
        }
      }
      return ret;
    };
    JSONPath.prototype._walk = function(val, f) {
      if (Array.isArray(val)) {
        const n = val.length;
        for (let i = 0; i < n; i++) {
          f(i);
        }
      } else if (val && typeof val === "object") {
        Object.keys(val).forEach((m) => {
          f(m);
        });
      }
    };
    JSONPath.prototype._slice = function(loc, expr, val, path, parent, parentPropName, callback) {
      if (!Array.isArray(val)) {
        return void 0;
      }
      const len = val.length, parts = loc.split(":"), step = parts[2] && Number.parseInt(parts[2]) || 1;
      let start = parts[0] && Number.parseInt(parts[0]) || 0, end = parts[1] && Number.parseInt(parts[1]) || len;
      start = start < 0 ? Math.max(0, start + len) : Math.min(len, start);
      end = end < 0 ? Math.max(0, end + len) : Math.min(len, end);
      const ret = [];
      for (let i = start; i < end; i += step) {
        const tmp = this._trace(unshift(i, expr), val, path, parent, parentPropName, callback, true);
        tmp.forEach((t) => {
          ret.push(t);
        });
      }
      return ret;
    };
    JSONPath.prototype._eval = function(code, _v, _vname, path, parent, parentPropName) {
      this.currSandbox._$_parentProperty = parentPropName;
      this.currSandbox._$_parent = parent;
      this.currSandbox._$_property = _vname;
      this.currSandbox._$_root = this.json;
      this.currSandbox._$_v = _v;
      const containsPath = code.includes("@path");
      if (containsPath) {
        this.currSandbox._$_path = JSONPath.toPathString(path.concat([_vname]));
      }
      const scriptCacheKey = this.currEval + "Script:" + code;
      if (!JSONPath.cache[scriptCacheKey]) {
        let script = code.replaceAll("@parentProperty", "_$_parentProperty").replaceAll("@parent", "_$_parent").replaceAll("@property", "_$_property").replaceAll("@root", "_$_root").replaceAll(/@([.\s)[])/gu, "_$_v$1");
        if (containsPath) {
          script = script.replaceAll("@path", "_$_path");
        }
        if (this.currEval === "safe" || this.currEval === true || this.currEval === void 0) {
          JSONPath.cache[scriptCacheKey] = new this.safeVm.Script(script);
        } else if (this.currEval === "native") {
          JSONPath.cache[scriptCacheKey] = new this.vm.Script(script);
        } else if (typeof this.currEval === "function" && this.currEval.prototype && Object.hasOwn(this.currEval.prototype, "runInNewContext")) {
          const CurrEval = this.currEval;
          JSONPath.cache[scriptCacheKey] = new CurrEval(script);
        } else if (typeof this.currEval === "function") {
          JSONPath.cache[scriptCacheKey] = {
            runInNewContext: (context2) => this.currEval(script, context2)
          };
        } else {
          throw new TypeError(`Unknown "eval" property "${this.currEval}"`);
        }
      }
      try {
        return JSONPath.cache[scriptCacheKey].runInNewContext(this.currSandbox);
      } catch (e) {
        if (this.ignoreEvalErrors) {
          return false;
        }
        throw new Error("jsonPath: " + e.message + ": " + code);
      }
    };
    JSONPath.cache = {};
    JSONPath.toPathString = function(pathArr) {
      const x = pathArr, n = x.length;
      let p = "$";
      for (let i = 1; i < n; i++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
          p += /^[0-9*]+$/u.test(x[i]) ? "[" + x[i] + "]" : "['" + x[i] + "']";
        }
      }
      return p;
    };
    JSONPath.toPointer = function(pointer) {
      const x = pointer, n = x.length;
      let p = "";
      for (let i = 1; i < n; i++) {
        if (!/^(~|\^|@.*?\(\))$/u.test(x[i])) {
          p += "/" + x[i].toString().replaceAll("~", "~0").replaceAll("/", "~1");
        }
      }
      return p;
    };
    JSONPath.toPathArray = function(expr) {
      const {
        cache
      } = JSONPath;
      if (cache[expr]) {
        return cache[expr].concat();
      }
      const subx = [];
      const normalized = expr.replaceAll(/@(?:null|boolean|number|string|integer|undefined|nonFinite|scalar|array|object|function|other)\(\)/gu, ";$&;").replaceAll(/[['](\??\(.*?\))[\]'](?!.\])/gu, function($0, $1) {
        return "[#" + (subx.push($1) - 1) + "]";
      }).replaceAll(/\[['"]([^'\]]*)['"]\]/gu, function($0, prop) {
        return "['" + prop.replaceAll(".", "%@%").replaceAll("~", "%%@@%%") + "']";
      }).replaceAll("~", ";~;").replaceAll(/['"]?\.['"]?(?![^[]*\])|\[['"]?/gu, ";").replaceAll("%@%", ".").replaceAll("%%@@%%", "~").replaceAll(/(?:;)?(\^+)(?:;)?/gu, function($0, ups) {
        return ";" + ups.split("").join(";") + ";";
      }).replaceAll(/;;;|;;/gu, ";..;").replaceAll(/;$|'?\]|'$/gu, "");
      const exprList = normalized.split(";").map(function(exp) {
        const match = exp.match(/#(\d+)/u);
        return !match || !match[1] ? exp : subx[match[1]];
      });
      cache[expr] = exprList;
      return cache[expr].concat();
    };
    JSONPath.prototype.safeVm = {
      Script: SafeScript
    };
    JSONPath.prototype.vm = vm;
    exports2.JSONPath = JSONPath;
  }
});

// ../../packages/dd-trace/src/payload-tagging/tagging.js
var require_tagging = __commonJS({
  "../../packages/dd-trace/src/payload-tagging/tagging.js"(exports2, module2) {
    "use strict";
    var { PAYLOAD_TAGGING_MAX_TAGS } = require_constants3();
    var redactedKeys = /* @__PURE__ */ new Set([
      "authorization",
      "x-authorization",
      "password",
      "token"
    ]);
    var truncated = "truncated";
    var redacted = "redacted";
    function escapeKey(key) {
      return key.replaceAll(".", String.raw`\.`);
    }
    function tagsFromObject(object, opts) {
      const { maxDepth, prefix } = opts;
      let tagCount = 0;
      let abort = false;
      const result = {};
      function tagRec(prefix2, object2, depth = 0) {
        if (abort) {
          return;
        }
        if (tagCount >= PAYLOAD_TAGGING_MAX_TAGS - 1) {
          abort = true;
          result["_dd.payload_tags_incomplete"] = true;
          return;
        }
        if (depth >= maxDepth && object2 !== null && typeof object2 === "object") {
          tagCount += 1;
          result[prefix2] = truncated;
          return;
        }
        if (object2 === void 0) {
          tagCount += 1;
          result[prefix2] = "undefined";
          return;
        }
        if (object2 === null) {
          tagCount += 1;
          result[prefix2] = "null";
          return;
        }
        if (["number", "boolean"].includes(typeof object2) || Buffer.isBuffer(object2)) {
          tagCount += 1;
          result[prefix2] = object2.toString().slice(0, 5e3);
          return;
        }
        if (typeof object2 === "string") {
          tagCount += 1;
          result[prefix2] = object2.slice(0, 5e3);
        }
        if (typeof object2 === "object") {
          for (const [key, value] of Object.entries(object2)) {
            if (redactedKeys.has(key.toLowerCase())) {
              tagCount += 1;
              result[`${prefix2}.${escapeKey(key)}`] = redacted;
            } else {
              tagRec(`${prefix2}.${escapeKey(key)}`, value, depth + 1);
            }
          }
        }
      }
      tagRec(prefix, object);
      return result;
    }
    module2.exports = { tagsFromObject };
  }
});

// ../../packages/dd-trace/src/payload-tagging/index.js
var require_payload_tagging = __commonJS({
  "../../packages/dd-trace/src/payload-tagging/index.js"(exports2, module2) {
    "use strict";
    var rfdc = require_rfdc()({ proto: false, circles: false });
    var {
      PAYLOAD_TAG_REQUEST_PREFIX,
      PAYLOAD_TAG_RESPONSE_PREFIX
    } = require_constants3();
    var jsonpath = require_index_node_cjs().JSONPath;
    var { tagsFromObject } = require_tagging();
    function maybeJSONParseValue(value) {
      if (typeof value !== "string" || value[0] !== "{") {
        return value;
      }
      try {
        return JSON.parse(value);
      } catch {
        return value;
      }
    }
    function expand(object, expansionRules) {
      for (const rule of expansionRules) {
        jsonpath(rule, object, (value, _type, desc) => {
          desc.parent[desc.parentProperty] = maybeJSONParseValue(value);
        });
      }
    }
    function redact(object, redactionRules) {
      for (const rule of redactionRules) {
        jsonpath(rule, object, (_value, _type, desc) => {
          desc.parent[desc.parentProperty] = "redacted";
        });
      }
    }
    function computeTags(config, object, opts) {
      const payload = rfdc(object);
      const redactionRules = opts.prefix === PAYLOAD_TAG_REQUEST_PREFIX ? config.request : config.response;
      const expansionRules = config.expand;
      expand(payload, expansionRules);
      redact(payload, redactionRules);
      return tagsFromObject(payload, opts);
    }
    function tagsFromRequest(config, object, opts) {
      return computeTags(config, object, { ...opts, prefix: PAYLOAD_TAG_REQUEST_PREFIX });
    }
    function tagsFromResponse(config, object, opts) {
      return computeTags(config, object, { ...opts, prefix: PAYLOAD_TAG_RESPONSE_PREFIX });
    }
    module2.exports = { computeTags, tagsFromRequest, tagsFromResponse };
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/base.js
var require_base2 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/base.js"(exports2, module2) {
    "use strict";
    var analyticsSampler = require_analytics_sampler();
    var ClientPlugin = require_client5();
    var { storage } = require_datadog_core();
    var { isTrue } = require_util();
    var { tagsFromRequest, tagsFromResponse } = require_payload_tagging();
    var { getEnvironmentVariable } = require_config_helper();
    var BaseAwsSdkPlugin = class extends ClientPlugin {
      static id = "aws";
      static isPayloadReporter = false;
      get serviceIdentifier() {
        const id = this.constructor.id.toLowerCase();
        Object.defineProperty(this, "serviceIdentifier", {
          configurable: true,
          writable: true,
          enumerable: true,
          value: id
        });
        return id;
      }
      get cloudTaggingConfig() {
        return this._tracerConfig.cloudPayloadTagging;
      }
      get payloadTaggingRules() {
        return this.cloudTaggingConfig.rules.aws?.[this.constructor.id];
      }
      constructor(...args) {
        super(...args);
        this._parentMap = /* @__PURE__ */ new WeakMap();
        this.addBind(`apm:aws:request:start:${this.serviceIdentifier}`, (ctx) => {
          const {
            request: request2,
            operation,
            awsRegion,
            awsService
          } = ctx;
          const parentStore = ctx.parentStore = storage("legacy").getStore();
          const childOf = parentStore?.span;
          this._parentMap.set(request2, parentStore);
          if (!this.isEnabled(request2)) {
            return parentStore;
          }
          const meta = {
            "span.kind": "client",
            "service.name": this.serviceName(),
            "aws.operation": operation,
            "aws.region": awsRegion,
            region: awsRegion,
            "aws.partition": getPartition(awsRegion),
            aws_service: awsService,
            "aws.service": awsService,
            component: "aws-sdk"
          };
          if (this.requestTags) this.requestTags.set(request2, meta);
          const span = this.startSpan(this.operationFromRequest(request2), {
            childOf,
            meta,
            integrationName: "aws-sdk"
          }, ctx);
          analyticsSampler.sample(span, this.config.measured);
          storage("legacy").run(ctx.currentStore, () => {
            this.requestInject(span, request2);
          });
          if (this.constructor.isPayloadReporter && this.cloudTaggingConfig.requestsEnabled) {
            const maxDepth = this.cloudTaggingConfig.maxDepth;
            const requestTags = tagsFromRequest(this.payloadTaggingRules, request2.params, { maxDepth });
            span.addTags(requestTags);
          }
          return ctx.currentStore;
        });
        this.addSub(`apm:aws:request:start:${this.serviceIdentifier}`, (ctx) => {
          if (!this._tracerConfig?._isInServerlessEnvironment()) return;
          const { awsRegion, awsService, currentStore, request: request2 } = ctx;
          const peerServerlessStorage = storage("peerServerless");
          const hostname = getHostname({ awsParams: request2.params, awsService }, awsRegion);
          const peerServerlessStore = {};
          peerServerlessStorage.enterWith(peerServerlessStore);
          if (hostname) {
            currentStore.span.setTag("peer.service", hostname);
            peerServerlessStore.peerHostname = hostname;
          } else {
            currentStore.awsParams = request2.params;
            currentStore.awsService = awsService;
          }
        });
        this.addSub(`apm:aws:request:region:${this.serviceIdentifier}`, ({ region }) => {
          const store = storage("legacy").getStore();
          if (!store) return;
          const { span } = store;
          if (!span) return;
          span.setTag("aws.region", region);
          span.setTag("region", region);
          const partition = getPartition(region);
          if (partition) {
            span.setTag("aws.partition", partition);
          }
          if (!this._tracerConfig?._isInServerlessEnvironment()) return;
          const hostname = getHostname(store, region);
          if (!hostname) return;
          span.setTag("peer.service", hostname);
          const peerServerlessStore = storage("peerServerless").getStore();
          if (peerServerlessStore) {
            peerServerlessStore.peerHostname = hostname;
          }
        });
        this.addSub(`apm:aws:request:complete:${this.serviceIdentifier}`, (ctx) => {
          const { response, cbExists = false, currentStore } = ctx;
          if (!currentStore) return;
          const { span } = currentStore;
          if (!span) return;
          storage("legacy").run(currentStore, () => {
            if (!cbExists && this.serviceIdentifier === "sqs") {
              const params = response.request.params;
              const operation = response.request.operation;
              this.responseExtractDSMContext(operation, params, response.data ?? response, span);
            }
            this.addResponseTags(span, response);
            if (this._tracerConfig?.trace?.aws?.addSpanPointers) {
              this.addSpanPointers(span, response);
            }
          });
          this.finish(ctx);
        });
        this.addBind(`apm:aws:response:start:${this.serviceIdentifier}`, (ctx) => {
          return this._parentMap.get(ctx.request);
        });
      }
      requestInject(span, request2) {
      }
      addSpanPointers(span, response) {
      }
      operationFromRequest(request2) {
        return this.operationName({
          id: "aws",
          type: "web",
          kind: "client",
          awsService: this.serviceIdentifier
        });
      }
      serviceName() {
        return this.config.service || super.serviceName({
          id: "aws",
          type: "web",
          kind: "client",
          awsService: this.serviceIdentifier
        });
      }
      isEnabled(request2) {
        const serviceId = this.serviceIdentifier.toUpperCase();
        const envVarValue = getEnvironmentVariable(`DD_TRACE_AWS_SDK_${serviceId}_ENABLED`);
        return envVarValue ? isTrue(envVarValue) : true;
      }
      addResponseTags(span, response) {
        if (!span || !response.request) return;
        const params = response.request.params;
        const operation = response.request.operation;
        const extraTags = this.generateTags(params, operation, response) || {};
        const tags = {
          "aws.response.request_id": response.requestId,
          "resource.name": operation,
          "span.kind": "client",
          ...extraTags
        };
        span.addTags(tags);
        if (this.constructor.isPayloadReporter && this.cloudTaggingConfig.responsesEnabled) {
          const maxDepth = this.cloudTaggingConfig.maxDepth;
          const responseBody = this.extractResponseBody(response);
          const responseTags = tagsFromResponse(this.payloadTaggingRules, responseBody, { maxDepth });
          span.addTags(responseTags);
        }
      }
      extractResponseBody(response) {
        if (response.hasOwnProperty("data")) {
          return response.data;
        }
        return Object.fromEntries(
          Object.entries(response).filter(([key]) => !["request", "requestId", "error", "$metadata"].includes(key))
        );
      }
      generateTags() {
      }
      finish(ctx) {
        const { currentStore, response } = ctx;
        const { span } = currentStore;
        const error = response?.error || ctx.error;
        if (error) {
          span.setTag("error", error);
          const requestId = error.RequestId || error.requestId;
          if (requestId) {
            span.addTags({ "aws.response.request_id": requestId });
          }
        }
        if (response) {
          this.config.hooks.request(span, response);
        }
        super.finish(ctx);
      }
      configure(config) {
        super.configure(normalizeConfig(config, this.serviceIdentifier));
      }
    };
    function normalizeConfig(config, serviceIdentifier) {
      const hooks = getHooks(config);
      let specificConfig = config[serviceIdentifier];
      switch (typeof specificConfig) {
        case "undefined":
          specificConfig = {};
          break;
        case "boolean":
          specificConfig = { enabled: specificConfig };
          break;
      }
      const serviceId = serviceIdentifier.toUpperCase();
      const batchPropagationEnabled = isTrue(
        specificConfig.batchPropagationEnabled ?? getEnvironmentVariable(`DD_TRACE_AWS_SDK_${serviceId}_BATCH_PROPAGATION_ENABLED`) ?? config.batchPropagationEnabled ?? getEnvironmentVariable("DD_TRACE_AWS_SDK_BATCH_PROPAGATION_ENABLED")
      );
      return {
        ...config,
        ...specificConfig,
        splitByAwsService: config.splitByAwsService !== false,
        batchPropagationEnabled,
        hooks
      };
    }
    var noop = () => {
    };
    function getHooks(config) {
      const request2 = config.hooks?.request || noop;
      return { request: request2 };
    }
    function getHostname(store, region) {
      if (!store) return;
      if (!region) return;
      const { awsParams, awsService } = store;
      switch (awsService) {
        case "EventBridge":
          return `events.${region}.amazonaws.com`;
        case "SQS":
          return `sqs.${region}.amazonaws.com`;
        case "SNS":
          return `sns.${region}.amazonaws.com`;
        case "Kinesis":
          return `kinesis.${region}.amazonaws.com`;
        case "DynamoDBDocument":
        case "DynamoDB":
          return `dynamodb.${region}.amazonaws.com`;
        case "S3":
          return awsParams?.Bucket ? `${awsParams.Bucket}.s3.${region}.amazonaws.com` : `s3.${region}.amazonaws.com`;
      }
    }
    function getPartition(region) {
      if (!region) return;
      let partition = "aws";
      if (region.startsWith("cn-")) {
        partition = "aws-cn";
      } else if (region.startsWith("us-gov-")) {
        partition = "aws-us-gov";
      }
      return partition;
    }
    module2.exports = BaseAwsSdkPlugin;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js
var require_cloudwatchlogs = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/cloudwatchlogs.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var CloudwatchLogs = class extends BaseAwsSdkPlugin {
      static id = "cloudwatchlogs";
      generateTags(params, operation) {
        if (!params?.logGroupName) return {};
        return {
          "resource.name": `${operation} ${params.logGroupName}`,
          "aws.cloudwatch.logs.log_group_name": params.logGroupName,
          loggroupname: params.logGroupName
        };
      }
    };
    module2.exports = CloudwatchLogs;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/util.js
var require_util6 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/util.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var log = require_log2();
    function generatePointerHash(components) {
      const dataToHash = components.join("|");
      const hash = crypto.createHash("sha256").update(dataToHash).digest("hex");
      return hash.slice(0, 32);
    }
    function encodeValue(valueObject) {
      if (!valueObject) {
        return;
      }
      try {
        const type = Object.keys(valueObject)[0];
        const value = valueObject[type];
        switch (type) {
          case "S":
            return Buffer.from(value);
          case "N":
            return Buffer.from(value.toString());
          case "B":
            return Buffer.isBuffer(value) ? value : Buffer.from(value);
          default:
            log.debug("Found unknown type while trying to create DynamoDB span pointer:", type);
        }
      } catch (err) {
        log.debug("Failed to encode value while trying to create DynamoDB span pointer:", err.message);
      }
    }
    var extractPrimaryKeys = (keyNames, keyValuePairs) => {
      if (keyNames.length === 0) {
        return;
      }
      if (keyNames.length === 1) {
        const value = encodeValue(keyValuePairs[keyNames[0]]);
        if (value) {
          return [keyNames[0], value, "", ""];
        }
      } else {
        const [key1, key2] = keyNames.sort();
        const value1 = encodeValue(keyValuePairs[key1]);
        const value2 = encodeValue(keyValuePairs[key2]);
        if (value1 && value2) {
          return [key1, value1, key2, value2];
        }
      }
    };
    var extractQueueMetadata = (queueURL) => {
      if (!queueURL) {
        return null;
      }
      const parts = queueURL.split("/").filter(Boolean);
      const hasScheme = Boolean(parts[0]?.startsWith("http"));
      const minParts = hasScheme ? 4 : 3;
      if (parts.length < minParts) return null;
      const accountId = parts[parts.length - 2];
      const queueName = parts[parts.length - 1];
      const host = hasScheme ? parts[1] : parts[0];
      let region = "us-east-1";
      if (host.includes(".amazonaws.com") && !host.startsWith("queue")) {
        const startFrom = host.startsWith("sqs.") ? 4 : 0;
        const nextDot = host.indexOf(".", startFrom);
        region = host.slice(startFrom, nextDot);
      }
      let partition = "aws";
      if (region.startsWith("cn-")) {
        partition = "aws-cn";
      } else if (region.startsWith("us-gov-")) {
        partition = "aws-us-gov";
      }
      const arn = `arn:${partition}:sqs:${region}:${accountId}:${queueName}`;
      return { queueName, arn };
    };
    module2.exports = {
      generatePointerHash,
      encodeValue,
      extractPrimaryKeys,
      extractQueueMetadata
    };
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/dynamodb.js
var require_dynamodb = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/dynamodb.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var log = require_log2();
    var { DYNAMODB_PTR_KIND, SPAN_POINTER_DIRECTION } = require_constants3();
    var { extractPrimaryKeys, generatePointerHash } = require_util6();
    var DynamoDb = class _DynamoDb extends BaseAwsSdkPlugin {
      static id = "dynamodb";
      static peerServicePrecursors = ["tablename"];
      static isPayloadReporter = true;
      generateTags(params, operation, response) {
        const tags = {};
        if (params) {
          let tableName = params.TableName;
          if (params.RequestItems !== null && typeof params.RequestItems === "object") {
            const requestItemsKeys = Object.keys(params.RequestItems);
            if (requestItemsKeys.length === 1) {
              tableName = requestItemsKeys[0];
            }
          }
          if (tableName) {
            tags["resource.name"] = `${operation} ${tableName}`;
            tags["aws.dynamodb.table_name"] = tableName;
            tags.tablename = tableName;
          }
        }
        tags["span.type"] = "dynamodb";
        return tags;
      }
      addSpanPointers(span, response) {
        const request2 = response?.request;
        const operationName = request2?.operation;
        const hashes = [];
        switch (operationName) {
          case "putItem": {
            const hash = _DynamoDb.calculatePutItemHash(
              request2?.params?.TableName,
              request2?.params?.Item,
              this.getPrimaryKeyConfig()
            );
            if (hash) hashes.push(hash);
            break;
          }
          case "updateItem":
          case "deleteItem": {
            const hash = _DynamoDb.calculateHashWithKnownKeys(request2?.params?.TableName, request2?.params?.Key);
            if (hash) hashes.push(hash);
            break;
          }
          case "transactWriteItems": {
            const transactItems = request2?.params?.TransactItems || [];
            for (const item of transactItems) {
              if (item.Put) {
                const hash = _DynamoDb.calculatePutItemHash(item.Put.TableName, item.Put.Item, this.getPrimaryKeyConfig());
                if (hash) hashes.push(hash);
              } else {
                const operation = item.Update || item.Delete;
                if (operation) {
                  const hash = _DynamoDb.calculateHashWithKnownKeys(operation.TableName, operation.Key);
                  if (hash) hashes.push(hash);
                }
              }
            }
            break;
          }
          case "batchWriteItem": {
            const requestItems = request2?.params.RequestItems || {};
            for (const [tableName, operations] of Object.entries(requestItems)) {
              if (!Array.isArray(operations)) continue;
              for (const operation of operations) {
                if (operation?.PutRequest) {
                  const hash = _DynamoDb.calculatePutItemHash(tableName, operation.PutRequest.Item, this.getPrimaryKeyConfig());
                  if (hash) hashes.push(hash);
                } else if (operation?.DeleteRequest) {
                  const hash = _DynamoDb.calculateHashWithKnownKeys(tableName, operation.DeleteRequest.Key);
                  if (hash) hashes.push(hash);
                }
              }
            }
            break;
          }
        }
        for (const hash of hashes) {
          span.addSpanPointer(DYNAMODB_PTR_KIND, SPAN_POINTER_DIRECTION.DOWNSTREAM, hash);
        }
      }
      /**
       * Parses primary key config from the `DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS` env var.
       * Only runs when needed, and warns when missing or invalid config.
       * @returns {Object|undefined} Parsed config from env var or undefined if empty/missing/invalid config.
       */
      getPrimaryKeyConfig() {
        if (this.dynamoPrimaryKeyConfig) {
          return this.dynamoPrimaryKeyConfig;
        }
        const configStr = this._tracerConfig?.trace?.dynamoDb?.tablePrimaryKeys;
        if (!configStr) {
          log.warn(
            // eslint-disable-next-line @stylistic/max-len
            "Missing DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS env variable. Please add your table's primary keys under this env variable."
          );
          return;
        }
        try {
          const parsedConfig = JSON.parse(configStr);
          const config = {};
          for (const [tableName, primaryKeys] of Object.entries(parsedConfig)) {
            if (Array.isArray(primaryKeys) && primaryKeys.length > 0 && primaryKeys.length <= 2) {
              config[tableName] = primaryKeys;
            } else {
              log.warn(
                // eslint-disable-next-line @stylistic/max-len
                "Invalid primary key configuration for table: %s. Please fix the DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS env var.",
                tableName
              );
            }
          }
          this.dynamoPrimaryKeyConfig = config;
          return config;
        } catch (err) {
          log.warn("Failed to parse DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS:", err.message);
        }
      }
      /**
       * Calculates a hash for DynamoDB PutItem operations using table's configured primary keys.
       * @param {string} tableName - Name of the DynamoDB table.
       * @param {Object} item - Complete PutItem item parameter to be put.
       * @param {Object.<string, Array<string>>} primaryKeyConfig - Mapping of table names to an Array of primary key names
       *                                                         loaded from DD_TRACE_DYNAMODB_TABLE_PRIMARY_KEYS.
       * @returns {string|undefined} Hash combining table name and primary key/value pairs, or undefined if unable.
       */
      static calculatePutItemHash(tableName, item, primaryKeyConfig) {
        if (!tableName || !item) {
          log.debug("Unable to calculate hash because missing required parameters");
          return;
        }
        const keyNames = primaryKeyConfig?.[tableName];
        if (!keyNames) {
          return;
        }
        const keyValues = extractPrimaryKeys(keyNames, item);
        if (keyValues) {
          return generatePointerHash([tableName, ...keyValues]);
        }
      }
      /**
       * Calculates a hash for DynamoDB operations that have keys provided (UpdateItem, DeleteItem).
       * @param {string} tableName - Name of the DynamoDB table.
       * @param {Object} keysObject - Object containing primary key/value attributes in DynamoDB format.
       *                       (e.g., { userId: { S: "123" }, sortKey: { N: "456" } })
       * @returns {string|undefined} Hash value combining table name and primary key/value pairs, or undefined if unable.
       *
       * @example
       * calculateHashWithKnownKeys('UserTable', { userId: { S: "user123" }, timestamp: { N: "1234567" } })
       */
      static calculateHashWithKnownKeys(tableName, keysObject) {
        if (!tableName || !keysObject) {
          log.debug("Unable to calculate hash because missing parameters");
          return;
        }
        const keyNames = Object.keys(keysObject);
        const keyValues = extractPrimaryKeys(keyNames, keysObject);
        if (keyValues) {
          return generatePointerHash([tableName, ...keyValues]);
        }
      }
    };
    module2.exports = DynamoDb;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/eventbridge.js
var require_eventbridge = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/eventbridge.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var EventBridge = class extends BaseAwsSdkPlugin {
      static id = "eventbridge";
      static isPayloadReporter = true;
      generateTags(params, operation, response) {
        if (!params?.source) return {};
        const rulename = params.Name ?? "";
        return {
          "resource.name": operation ? `${operation} ${params.source}` : params.source,
          "aws.eventbridge.source": `${params.source}`,
          rulename: `${rulename}`
        };
      }
      /**
       * requestInject
       * @param {*} span
       * @param {*} request
       *
       * Docs: https://docs.aws.amazon.com/eventbridge/latest/APIReference/API_PutEventsRequestEntry.html
       * We cannot use the traceHeader field as that's reserved for X-Ray.
       * Detail must be a valid JSON string
       * Max size per event is 256kb (https://docs.aws.amazon.com/eventbridge/latest/userguide/eb-putevent-size.html)
       */
      requestInject(span, request2) {
        const operation = request2.operation;
        if (operation === "putEvents" && request2.params && request2.params.Entries && request2.params.Entries.length > 0 && request2.params.Entries[0].Detail) {
          try {
            const details = JSON.parse(request2.params.Entries[0].Detail);
            details._datadog = {};
            this.tracer.inject(span, "text_map", details._datadog);
            const finalData = JSON.stringify(details);
            const byteSize = Buffer.byteLength(finalData);
            if (byteSize >= 1024 * 256) {
              log.info("Payload size too large to pass context");
              return;
            }
            request2.params.Entries[0].Detail = finalData;
          } catch (e) {
            log.error("EventBridge error injecting request", e);
          }
        }
      }
    };
    module2.exports = EventBridge;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/kinesis.js
var require_kinesis = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/kinesis.js"(exports2, module2) {
    "use strict";
    var { DsmPathwayCodec, getSizeOrZero } = require_datastreams();
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var Kinesis = class extends BaseAwsSdkPlugin {
      static id = "kinesis";
      static peerServicePrecursors = ["streamname"];
      static isPayloadReporter = true;
      constructor(...args) {
        super(...args);
        this.requestTags = /* @__PURE__ */ new WeakMap();
        this.addBind("apm:aws:response:start:kinesis", (ctx) => {
          const { request: request2, response } = ctx;
          const plugin = this;
          let store = this._parentMap.get(request2);
          if (request2.operation === "getShardIterator" || request2.operation === "listShards") {
            return this.storeStreamName(request2.params, request2.operation, store);
          }
          if (request2.operation === "getRecords") {
            let span;
            const responseExtraction = this.responseExtract(request2.params, request2.operation, response);
            if (responseExtraction && responseExtraction.maybeChildOf) {
              ctx.needsFinish = true;
              const options = {
                childOf: responseExtraction.maybeChildOf,
                meta: {
                  ...this.requestTags.get(request2),
                  "span.kind": "server"
                },
                integrationName: "aws-sdk"
              };
              span = plugin.startSpan("aws.response", options, ctx);
              store = ctx.currentStore;
            }
            const { streamName } = store;
            this.responseExtractDSMContext(
              request2.operation,
              request2.params,
              response,
              span || null,
              { streamName }
            );
          }
          return store;
        });
        this.addSub("apm:aws:response:finish:kinesis", (ctx) => {
          if (!ctx.needsFinish) return;
          this.finish(ctx);
        });
      }
      generateTags(params, operation, response) {
        if (!params || !params.StreamName) return {};
        return {
          "resource.name": `${operation} ${params.StreamName}`,
          "aws.kinesis.stream_name": params.StreamName,
          streamname: params.StreamName
        };
      }
      storeStreamName(params, operation, store) {
        if (!operation) return store;
        if (operation !== "getShardIterator" && operation !== "listShards") return store;
        if (!params || !params.StreamName) return store;
        const streamName = params.StreamName;
        return { ...store, streamName };
      }
      responseExtract(params, operation, response) {
        if (operation !== "getRecords") return;
        if (params.Limit && params.Limit !== 1) return;
        if (!response || !response.Records || !response.Records[0]) return;
        const record = response.Records[0];
        try {
          const decodedData = JSON.parse(Buffer.from(record.Data).toString());
          return {
            maybeChildOf: this.tracer.extract("text_map", decodedData._datadog),
            parsedAttributes: decodedData._datadog
          };
        } catch (e) {
          log.error("Kinesis error extracting response", e);
        }
      }
      responseExtractDSMContext(operation, params, response, span, kwargs = {}) {
        const { streamName } = kwargs;
        if (!this.config.dsmEnabled) return;
        if (operation !== "getRecords") return;
        if (!response || !response.Records || !response.Records[0]) return;
        span = response.Records.length > 1 ? null : span;
        response.Records.forEach((record) => {
          const parsedAttributes = JSON.parse(Buffer.from(record.Data).toString());
          const payloadSize = getSizeOrZero(record.Data);
          if (parsedAttributes?._datadog) {
            this.tracer.decodeDataStreamsContext(parsedAttributes._datadog);
          }
          const tags = streamName ? ["direction:in", `topic:${streamName}`, "type:kinesis"] : ["direction:in", "type:kinesis"];
          this.tracer.setCheckpoint(tags, span, payloadSize);
        });
      }
      // AWS-SDK will b64 kinesis payloads
      // or will accept an already b64 encoded payload
      // This method handles both
      _tryParse(body) {
        try {
          return JSON.parse(body);
        } catch {
          log.info("Not JSON string. Trying Base64 encoded JSON string");
        }
        try {
          return JSON.parse(Buffer.from(body, "base64").toString("ascii"), true);
        } catch {
          return null;
        }
      }
      requestInject(span, request2) {
        const { operation, params } = request2;
        if (!params) return;
        let stream;
        switch (operation) {
          case "putRecord":
            stream = params.StreamArn ?? params.StreamName ?? "";
            this.injectToMessage(span, params, stream, true);
            break;
          case "putRecords":
            stream = params.StreamArn ?? params.StreamName ?? "";
            for (let i = 0; i < params.Records.length; i++) {
              this.injectToMessage(
                span,
                params.Records[i],
                stream,
                i === 0 || this.config.batchPropagationEnabled
              );
            }
        }
      }
      injectToMessage(span, params, stream, injectTraceContext) {
        if (!params) {
          return;
        }
        let parsedData;
        if (injectTraceContext || this.config.dsmEnabled) {
          parsedData = this._tryParse(params.Data);
          if (!parsedData) {
            log.error("Unable to parse payload, unable to pass trace context or set DSM checkpoint (if enabled)");
            return;
          }
        }
        const ddInfo = {};
        if (injectTraceContext) {
          this.tracer.inject(span, "text_map", ddInfo);
        }
        if (this.config.dsmEnabled) {
          parsedData._datadog = ddInfo;
          const dataStreamsContext = this.setDSMCheckpoint(span, parsedData, stream);
          DsmPathwayCodec.encode(dataStreamsContext, ddInfo);
        }
        if (Object.keys(ddInfo).length !== 0) {
          parsedData._datadog = ddInfo;
          const finalData = Buffer.from(JSON.stringify(parsedData));
          const byteSize = finalData.length;
          if (byteSize >= 1048576) {
            log.info("Payload size too large to pass context");
            return;
          }
          params.Data = finalData;
        }
      }
      setDSMCheckpoint(span, parsedData, stream) {
        const payloadSize = Buffer.byteLength(JSON.stringify(parsedData));
        const dataStreamsContext = this.tracer.setCheckpoint(["direction:out", `topic:${stream}`, "type:kinesis"], span, payloadSize);
        return dataStreamsContext;
      }
    };
    module2.exports = Kinesis;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/lambda.js
var require_lambda = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/lambda.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var Lambda = class extends BaseAwsSdkPlugin {
      static id = "lambda";
      generateTags(params, operation, response) {
        if (!params?.FunctionName) return {};
        return {
          "resource.name": `${operation} ${params.FunctionName}`,
          functionname: params.FunctionName,
          "aws.lambda": params.FunctionName
        };
      }
      requestInject(span, request2) {
        const operation = request2.operation;
        if (operation === "invoke") {
          if (!request2.params) {
            request2.params = {};
          }
          const isSyncInvocation = !request2.params.InvocationType || request2.params.InvocationType === "RequestResponse";
          if (isSyncInvocation) {
            try {
              let clientContext = {};
              if (request2.params.ClientContext) {
                const clientContextJson = Buffer.from(request2.params.ClientContext, "base64").toString("utf8");
                clientContext = JSON.parse(clientContextJson);
              }
              if (!clientContext.custom) {
                clientContext.custom = {};
              }
              this.tracer.inject(span, "text_map", clientContext.custom);
              const newContextBase64 = Buffer.from(JSON.stringify(clientContext)).toString("base64");
              request2.params.ClientContext = newContextBase64;
            } catch (err) {
              log.error("Lambda error injecting request", err);
            }
          }
        }
      }
      operationFromRequest(request2) {
        if (request2.operation === "invoke") {
          return this.operationName({
            type: "web",
            kind: "client"
          });
        }
        return this.operationName({
          id: "aws",
          type: "web",
          kind: "client",
          awsService: "lambda"
        });
      }
    };
    module2.exports = Lambda;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/redshift.js
var require_redshift = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/redshift.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var Redshift = class extends BaseAwsSdkPlugin {
      static id = "redshift";
      generateTags(params, operation, response) {
        if (!params?.ClusterIdentifier) return {};
        return {
          "resource.name": `${operation} ${params.ClusterIdentifier}`,
          "aws.redshift.cluster_identifier": params.ClusterIdentifier,
          clusteridentifier: params.ClusterIdentifier
        };
      }
    };
    module2.exports = Redshift;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/s3.js
var require_s3 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/s3.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var log = require_log2();
    var { generatePointerHash } = require_util6();
    var { S3_PTR_KIND, SPAN_POINTER_DIRECTION } = require_constants3();
    var S3 = class extends BaseAwsSdkPlugin {
      static id = "s3";
      static peerServicePrecursors = ["bucketname"];
      static isPayloadReporter = true;
      generateTags(params, operation, response) {
        if (!params?.Bucket) return {};
        return {
          "resource.name": `${operation} ${params.Bucket}`,
          "aws.s3.bucket_name": params.Bucket,
          bucketname: params.Bucket
        };
      }
      addSpanPointers(span, response) {
        const request2 = response?.request;
        const operationName = request2?.operation;
        if (!["putObject", "copyObject", "completeMultipartUpload"].includes(operationName)) {
          return;
        }
        const bucketName = request2?.params?.Bucket;
        const objectKey = request2?.params?.Key;
        let eTag = response?.ETag || // v3 PutObject & CompleteMultipartUpload
        response?.CopyObjectResult?.ETag || // v3 CopyObject
        response?.data?.ETag || // v2 PutObject & CompleteMultipartUpload
        response?.data?.CopyObjectResult?.ETag;
        if (!bucketName || !objectKey || !eTag) {
          log.debug("Unable to calculate span pointer hash because of missing parameters.");
          return;
        }
        if (eTag.startsWith('"') && eTag.endsWith('"')) {
          eTag = eTag.slice(1, -1);
        }
        const pointerHash = generatePointerHash([bucketName, objectKey, eTag]);
        span.addSpanPointer(S3_PTR_KIND, SPAN_POINTER_DIRECTION.DOWNSTREAM, pointerHash);
      }
    };
    module2.exports = S3;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/stepfunctions.js
var require_stepfunctions = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/stepfunctions.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var Stepfunctions = class extends BaseAwsSdkPlugin {
      static id = "stepfunctions";
      // This is the shape of StartExecutionInput, as defined in
      // https://github.com/aws/aws-sdk-js/blob/master/apis/states-2016-11-23.normal.json
      // "StartExecutionInput": {
      //   "type": "structure",
      //   "required": [
      //     "stateMachineArn"
      //   ],
      //   "members": {
      //     "stateMachineArn": {
      //       "shape": "Arn",
      //     },
      //     "name": {
      //       "shape": "Name",
      //     },
      //     "input": {
      //       "shape": "SensitiveData",
      //     },
      //     "traceHeader": {
      //       "shape": "TraceHeader",
      //     }
      //   }
      generateTags(params, operation, response) {
        if (!params) return {};
        const tags = { "resource.name": params.name ? `${operation} ${params.name}` : `${operation}` };
        if (operation === "startExecution" || operation === "startSyncExecution") {
          tags.statemachinearn = `${params.stateMachineArn}`;
        }
        return tags;
      }
      requestInject(span, request2) {
        const operation = request2.operation;
        if (operation === "startExecution" || operation === "startSyncExecution") {
          if (!request2.params || !request2.params.input) {
            return;
          }
          const input = request2.params.input;
          try {
            const inputObj = JSON.parse(input);
            if (inputObj !== null && typeof inputObj === "object") {
              inputObj._datadog = {};
              this.tracer.inject(span, "text_map", inputObj._datadog);
              const newInput = JSON.stringify(inputObj);
              request2.params.input = newInput;
            }
          } catch {
            log.info("Unable to treat input as JSON");
          }
        }
      }
    };
    module2.exports = Stepfunctions;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/sfn.js
var require_sfn = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/sfn.js"(exports2, module2) {
    "use strict";
    var Stepfunctions = require_stepfunctions();
    var Sfn = class extends Stepfunctions {
      static id = "sfn";
    };
    module2.exports = Sfn;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/sns.js
var require_sns = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/sns.js"(exports2, module2) {
    "use strict";
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams();
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var Sns = class extends BaseAwsSdkPlugin {
      static id = "sns";
      static peerServicePrecursors = ["topicname"];
      static isPayloadReporter = true;
      generateTags(params, operation, response) {
        if (!params) return {};
        if (!params.TopicArn && !(response.data && response.data.TopicArn)) return {};
        const TopicArn = params.TopicArn || response.data.TopicArn;
        const arnParts = TopicArn.split(":");
        const topicName = arnParts.at(-1);
        return {
          "resource.name": `${operation} ${params.TopicArn || response.data.TopicArn}`,
          "aws.sns.topic_arn": TopicArn,
          topicname: topicName
        };
      }
      operationFromRequest(request2) {
        switch (request2.operation) {
          case "publish":
          case "publishBatch":
            return this.operationName({
              type: "messaging",
              kind: "producer"
            });
        }
        return this.operationName({
          id: "aws",
          type: "web",
          kind: "client",
          awsService: "sns"
        });
      }
      requestInject(span, request2) {
        const { operation, params } = request2;
        if (!params) return;
        switch (operation) {
          case "publish":
            this.injectToMessage(span, params, params.TopicArn, true);
            break;
          case "publishBatch":
            for (let i = 0; i < params.PublishBatchRequestEntries.length; i++) {
              this.injectToMessage(
                span,
                params.PublishBatchRequestEntries[i],
                params.TopicArn,
                i === 0 || this.config.batchPropagationEnabled
              );
            }
            break;
        }
      }
      injectToMessage(span, params, topicArn, injectTraceContext) {
        if (!params.MessageAttributes) {
          params.MessageAttributes = {};
        } else if (Object.keys(params.MessageAttributes).length >= 10) {
          log.info("Message attributes full, skipping trace context injection");
          return;
        }
        const ddInfo = {};
        if (injectTraceContext) {
          this.tracer.inject(span, "text_map", ddInfo);
          params.MessageAttributes._datadog = {
            DataType: "Binary",
            BinaryValue: ddInfo
          };
        }
        if (this.config.dsmEnabled) {
          if (!params.MessageAttributes._datadog) {
            params.MessageAttributes._datadog = {
              DataType: "Binary",
              BinaryValue: ddInfo
            };
          }
          const dataStreamsContext = this.setDSMCheckpoint(span, params, topicArn);
          DsmPathwayCodec.encode(dataStreamsContext, ddInfo);
        }
        if (Object.keys(ddInfo).length !== 0) {
          params.MessageAttributes._datadog.BinaryValue = Buffer.from(JSON.stringify(ddInfo));
        } else if (params.MessageAttributes._datadog) {
          delete params.MessageAttributes._datadog;
        }
      }
      setDSMCheckpoint(span, params, topicArn) {
        if (topicArn) {
          const payloadSize = getHeadersSize(params);
          const dataStreamsContext = this.tracer.setCheckpoint(["direction:out", `topic:${topicArn}`, "type:sns"], span, payloadSize);
          return dataStreamsContext;
        }
      }
    };
    module2.exports = Sns;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/sqs.js
var require_sqs = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/sqs.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var BaseAwsSdkPlugin = require_base2();
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams();
    var { extractQueueMetadata } = require_util6();
    var Sqs = class extends BaseAwsSdkPlugin {
      static id = "sqs";
      static peerServicePrecursors = ["queuename"];
      static isPayloadReporter = true;
      constructor(...args) {
        super(...args);
        this.requestTags = /* @__PURE__ */ new WeakMap();
        this.addBind("apm:aws:response:start:sqs", (ctx) => {
          const { request: request2, response } = ctx;
          const contextExtraction = this.responseExtract(request2.params, request2.operation, response);
          let store = this._parentMap.get(request2);
          let span;
          let parsedMessageAttributes = null;
          if (contextExtraction && contextExtraction.datadogContext) {
            ctx.needsFinish = true;
            const options = {
              childOf: contextExtraction.datadogContext,
              meta: {
                ...this.requestTags.get(request2),
                "span.kind": "server"
              },
              integrationName: "aws-sdk"
            };
            parsedMessageAttributes = contextExtraction.parsedAttributes;
            span = this.startSpan("aws.response", options, ctx);
            store = ctx.currentStore;
          }
          this.responseExtractDSMContext(
            request2.operation,
            request2.params,
            response,
            span || null,
            { parsedAttributes: parsedMessageAttributes }
          );
          return store;
        });
        this.addSub("apm:aws:response:finish:sqs", (ctx) => {
          if (!ctx.needsFinish) return;
          this.finish(ctx);
        });
      }
      operationFromRequest(request2) {
        switch (request2.operation) {
          case "receiveMessage":
            return this.operationName({
              type: "messaging",
              kind: "consumer"
            });
          case "sendMessage":
          case "sendMessageBatch":
            return this.operationName({
              type: "messaging",
              kind: "producer"
            });
        }
        return this.operationName({
          id: "aws",
          type: "web",
          kind: "client",
          awsService: "sqs"
        });
      }
      isEnabled(request2) {
        const config = this.config;
        switch (request2.operation) {
          case "receiveMessage":
            return config.consumer !== false;
          case "sendMessage":
          case "sendMessageBatch":
            return config.producer !== false;
          default:
            return true;
        }
      }
      generateTags(params, operation, response) {
        if (!params || !params.QueueName && !params.QueueUrl) return {};
        const queueMetadata = extractQueueMetadata(params.QueueUrl);
        const queueName = queueMetadata?.queueName || params.QueueName;
        const tags = {
          "resource.name": `${operation} ${params.QueueName || params.QueueUrl}`,
          "aws.sqs.queue_name": params.QueueName || params.QueueUrl,
          queuename: queueName
        };
        if (queueMetadata?.arn) {
          tags["cloud.resource_id"] = queueMetadata.arn;
        }
        switch (operation) {
          case "receiveMessage":
            tags["span.type"] = "worker";
            tags["span.kind"] = "consumer";
            break;
          case "sendMessage":
          case "sendMessageBatch":
            tags["span.kind"] = "producer";
            break;
        }
        return tags;
      }
      responseExtract(params, operation, response) {
        if (operation !== "receiveMessage") return;
        if (params.MaxNumberOfMessages && params.MaxNumberOfMessages !== 1) return;
        if (!response || !response.Messages || !response.Messages[0]) return;
        let message = response.Messages[0];
        if (message.Body) {
          try {
            const body = JSON.parse(message.Body);
            if (body.Type === "Notification") {
              message = body;
            }
          } catch {
          }
        }
        if (!message.MessageAttributes || !message.MessageAttributes._datadog) return;
        const datadogAttribute = message.MessageAttributes._datadog;
        const parsedAttributes = this.parseDatadogAttributes(datadogAttribute);
        if (parsedAttributes) {
          return {
            datadogContext: this.tracer.extract("text_map", parsedAttributes),
            parsedAttributes
          };
        }
      }
      parseDatadogAttributes(attributes) {
        try {
          if (attributes.StringValue) {
            const textMap = attributes.StringValue;
            return JSON.parse(textMap);
          } else if (attributes.Type === "Binary" || attributes.DataType === "Binary") {
            const buffer = Buffer.from(attributes.Value ?? attributes.BinaryValue, "base64");
            return JSON.parse(buffer);
          }
        } catch (e) {
          log.error("Sqs error parsing DD attributes", e);
        }
      }
      responseExtractDSMContext(operation, params, response, span, kwargs = {}) {
        let { parsedAttributes } = kwargs;
        if (!this.config.dsmEnabled) return;
        if (operation !== "receiveMessage") return;
        if (!response || !response.Messages || !response.Messages[0]) return;
        span = response.Messages.length > 1 ? null : span;
        response.Messages.forEach((message) => {
          if (!parsedAttributes) {
            if (message.Body) {
              try {
                const body = JSON.parse(message.Body);
                if (body.Type === "Notification") {
                  message = body;
                }
              } catch {
              }
            }
            if (!parsedAttributes && message.MessageAttributes && message.MessageAttributes._datadog) {
              parsedAttributes = this.parseDatadogAttributes(message.MessageAttributes._datadog);
            }
          }
          const payloadSize = getHeadersSize({
            Body: message.Body,
            MessageAttributes: message.MessageAttributes
          });
          const queue = params.QueueUrl.split("/").pop();
          if (parsedAttributes) {
            this.tracer.decodeDataStreamsContext(parsedAttributes);
          }
          this.tracer.setCheckpoint(["direction:in", `topic:${queue}`, "type:sqs"], span, payloadSize);
        });
      }
      requestInject(span, request2) {
        const { operation, params } = request2;
        if (!params) return;
        switch (operation) {
          case "sendMessage":
            this.injectToMessage(span, params, params.QueueUrl, true);
            break;
          case "sendMessageBatch":
            for (let i = 0; i < params.Entries.length; i++) {
              this.injectToMessage(
                span,
                params.Entries[i],
                params.QueueUrl,
                i === 0 || this.config.batchPropagationEnabled
              );
            }
            break;
          case "receiveMessage":
            if (!params.MessageAttributeNames) {
              params.MessageAttributeNames = ["_datadog"];
            } else if (!params.MessageAttributeNames.includes("_datadog") && !params.MessageAttributeNames.includes(".*") && !params.MessageAttributeNames.includes("All")) {
              params.MessageAttributeNames.push("_datadog");
            }
            break;
        }
      }
      injectToMessage(span, params, queueUrl, injectTraceContext) {
        if (!params) {
          params = {};
        }
        if (!params.MessageAttributes) {
          params.MessageAttributes = {};
        } else if (Object.keys(params.MessageAttributes).length >= 10) {
          return;
        }
        const ddInfo = {};
        if (injectTraceContext) {
          this.tracer.inject(span, "text_map", ddInfo);
          params.MessageAttributes._datadog = {
            DataType: "String",
            StringValue: JSON.stringify(ddInfo)
          };
        }
        if (this.config.dsmEnabled) {
          if (!params.MessageAttributes._datadog) {
            params.MessageAttributes._datadog = {
              DataType: "String",
              StringValue: JSON.stringify(ddInfo)
            };
          }
          const dataStreamsContext = this.setDSMCheckpoint(span, params, queueUrl);
          if (dataStreamsContext) {
            DsmPathwayCodec.encode(dataStreamsContext, ddInfo);
            params.MessageAttributes._datadog.StringValue = JSON.stringify(ddInfo);
          }
        }
        if (params.MessageAttributes._datadog && Object.keys(ddInfo).length === 0) {
          delete params.MessageAttributes._datadog;
        }
      }
      setDSMCheckpoint(span, params, queueUrl) {
        const payloadSize = getHeadersSize({
          Body: params.MessageBody,
          MessageAttributes: params.MessageAttributes
        });
        const queue = queueUrl.split("/").pop();
        const dataStreamsContext = this.tracer.setCheckpoint(["direction:out", `topic:${queue}`, "type:sqs"], span, payloadSize);
        return dataStreamsContext;
      }
    };
    module2.exports = Sqs;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/states.js
var require_states = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/states.js"(exports2, module2) {
    "use strict";
    var Stepfunctions = require_stepfunctions();
    var States = class extends Stepfunctions {
      static id = "states";
    };
    module2.exports = States;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/utils.js
var require_utils4 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/utils.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var MODEL_TYPE_IDENTIFIERS = [
      "foundation-model/",
      "custom-model/",
      "provisioned-model/",
      "imported-module/",
      "prompt/",
      "endpoint/",
      "inference-profile/",
      "default-prompt-router/"
    ];
    var PROVIDER = {
      AI21: "AI21",
      AMAZON: "AMAZON",
      ANTHROPIC: "ANTHROPIC",
      COHERE: "COHERE",
      META: "META",
      STABILITY: "STABILITY",
      MISTRAL: "MISTRAL"
    };
    function extractTextAndResponseReasonFromStream(chunks, modelProvider, modelName) {
      const modelProviderUpper = modelProvider.toUpperCase();
      if (modelProviderUpper === PROVIDER.AMAZON && modelName.includes("embed") || modelProviderUpper === PROVIDER.COHERE && modelName.includes("embed") || modelProviderUpper === PROVIDER.STABILITY) {
        return {};
      }
      let message = "";
      let inputTokens = 0;
      let outputTokens = 0;
      let cacheReadTokens = 0;
      let cacheWriteTokens = 0;
      for (const { chunk: { bytes } } of chunks) {
        const body = JSON.parse(Buffer.from(bytes).toString("utf8"));
        switch (modelProviderUpper) {
          case PROVIDER.AMAZON: {
            if (body?.outputText) {
              message += body?.outputText;
              inputTokens = body?.inputTextTokenCount;
              outputTokens = body?.totalOutputTextTokenCount;
            } else if (body?.contentBlockDelta?.delta?.text) {
              message += body.contentBlockDelta.delta.text;
            }
            break;
          }
          case PROVIDER.AI21: {
            const content = body?.choices?.[0]?.delta?.content;
            if (content) {
              message += content;
            }
            break;
          }
          case PROVIDER.ANTHROPIC: {
            if (body.completion) {
              message += body.completion;
            } else if (body.delta?.text) {
              message += body.delta.text;
            }
            if (body.message?.usage?.input_tokens) inputTokens = body.message.usage.input_tokens;
            if (body.message?.usage?.output_tokens) outputTokens = body.message.usage.output_tokens;
            break;
          }
          case PROVIDER.COHERE: {
            if (body?.event_type === "stream-end") {
              message = body.response?.text;
            }
            break;
          }
          case PROVIDER.META: {
            message += body?.generation;
            break;
          }
          case PROVIDER.MISTRAL: {
            message += body?.outputs?.[0]?.text;
            break;
          }
        }
        const invocationMetrics = body["amazon-bedrock-invocationMetrics"];
        if (invocationMetrics) {
          inputTokens = invocationMetrics.inputTokenCount;
          outputTokens = invocationMetrics.outputTokenCount;
          cacheReadTokens = invocationMetrics.cacheReadInputTokenCount;
          cacheWriteTokens = invocationMetrics.cacheWriteInputTokenCount;
        }
      }
      return new Generation({
        message,
        role: "assistant",
        inputTokens,
        outputTokens,
        cacheReadTokens,
        cacheWriteTokens
      });
    }
    var Generation = class {
      constructor({
        message = "",
        finishReason = "",
        choiceId = "",
        role,
        inputTokens,
        outputTokens,
        cacheReadTokens,
        cacheWriteTokens
      } = {}) {
        this.message = typeof message === "string" ? message : JSON.stringify(message) || "";
        this.finishReason = finishReason || "";
        this.choiceId = choiceId || void 0;
        this.role = role;
        this.usage = {
          inputTokens,
          outputTokens,
          cacheReadTokens,
          cacheWriteTokens
        };
      }
    };
    var RequestParams = class {
      constructor({
        prompt = "",
        temperature,
        topP,
        topK,
        maxTokens,
        stopSequences = [],
        inputType = "",
        truncate = "",
        stream = "",
        n
      } = {}) {
        this.prompt = prompt;
        this.temperature = temperature;
        this.topP = topP;
        this.topK = topK;
        this.maxTokens = maxTokens;
        this.stopSequences = stopSequences || [];
        this.inputType = inputType || "";
        this.truncate = truncate || "";
        this.stream = stream || "";
        this.n = n;
      }
    };
    function parseModelId(modelId) {
      modelId = modelId.toLowerCase();
      if (!modelId.startsWith("arn:aws")) {
        const modelMeta = modelId.split(".");
        if (modelMeta.length < 2) {
          return { modelProvider: "custom", modelName: modelMeta[0] };
        }
        return { modelProvider: modelMeta.at(-2), modelName: modelMeta.at(-1) };
      }
      for (const identifier of MODEL_TYPE_IDENTIFIERS) {
        if (!modelId.includes(identifier)) {
          continue;
        }
        modelId = modelId.split(identifier).pop();
        if (["foundation-model/", "custom-model/"].includes(identifier)) {
          const modelMeta = modelId.split(".");
          if (modelMeta.length < 2) {
            return { modelProvider: "custom", modelName: modelId };
          }
          return { modelProvider: modelMeta.at(-2), modelName: modelMeta.at(-1) };
        }
        return { modelProvider: "custom", modelName: modelId };
      }
      return { modelProvider: "custom", modelName: "custom" };
    }
    function extractRequestParams(params, provider) {
      const requestBody = JSON.parse(params.body);
      const modelId = params.modelId;
      switch (provider.toUpperCase()) {
        case PROVIDER.AI21: {
          let userPrompt = requestBody.prompt;
          if (modelId.includes("jamba")) {
            for (const message of requestBody.messages) {
              if (message.role === "user") {
                userPrompt = message.content;
              }
            }
          }
          return new RequestParams({
            prompt: userPrompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences
          });
        }
        case PROVIDER.AMAZON: {
          const prompt = requestBody.inputText;
          if (modelId.includes("embed")) {
            return new RequestParams({ prompt });
          } else if (prompt !== void 0) {
            const textGenerationConfig = requestBody.textGenerationConfig || {};
            return new RequestParams({
              prompt,
              temperature: textGenerationConfig.temperature,
              topP: textGenerationConfig.topP,
              maxTokens: textGenerationConfig.maxTokenCount,
              stopSequences: textGenerationConfig.stopSequences
            });
          } else if (Array.isArray(requestBody.messages)) {
            const inferenceConfig = requestBody.inferenceConfig || {};
            const messages = [];
            if (Array.isArray(requestBody.system)) {
              for (const sysMsg of requestBody.system) {
                messages.push({
                  content: sysMsg.text,
                  role: "system"
                });
              }
            }
            for (const message of requestBody.messages) {
              const textBlocks = message.content?.filter((block) => block.text) || [];
              if (textBlocks.length > 0) {
                messages.push({
                  content: textBlocks.map((block) => block.text).join(""),
                  role: message.role
                });
              }
            }
            return new RequestParams({
              prompt: messages,
              temperature: inferenceConfig.temperature,
              topP: inferenceConfig.topP,
              maxTokens: inferenceConfig.maxTokens,
              stopSequences: inferenceConfig.stopSequences
            });
          }
          return new RequestParams({ prompt });
        }
        case PROVIDER.ANTHROPIC: {
          let prompt = requestBody.prompt;
          if (Array.isArray(requestBody.messages)) {
            for (let idx = requestBody.messages.length - 1; idx >= 0; idx--) {
              const message = requestBody.messages[idx];
              if (message.role === "user") {
                prompt = message.content?.filter((block) => block.type === "text").map((block) => block.text).join("");
                break;
              }
            }
          }
          return new RequestParams({
            prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens_to_sample ?? requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences
          });
        }
        case PROVIDER.COHERE: {
          if (modelId.includes("embed")) {
            return new RequestParams({
              prompt: requestBody.texts,
              inputType: requestBody.input_type,
              truncate: requestBody.truncate
            });
          }
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop_sequences,
            stream: requestBody.stream,
            n: requestBody.num_generations
          });
        }
        case PROVIDER.META: {
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_gen_len
          });
        }
        case PROVIDER.MISTRAL: {
          return new RequestParams({
            prompt: requestBody.prompt,
            temperature: requestBody.temperature,
            topP: requestBody.top_p,
            maxTokens: requestBody.max_tokens,
            stopSequences: requestBody.stop,
            topK: requestBody.top_k
          });
        }
        case PROVIDER.STABILITY: {
          return new RequestParams();
        }
        default: {
          return new RequestParams();
        }
      }
    }
    function extractTextAndResponseReason(response, provider, modelName) {
      const body = JSON.parse(Buffer.from(response.body).toString("utf8"));
      const shouldSetChoiceIds = provider.toUpperCase() === PROVIDER.COHERE && !modelName.includes("embed");
      try {
        switch (provider.toUpperCase()) {
          case PROVIDER.AI21: {
            if (modelName.includes("jamba")) {
              const generations = body.choices || [];
              if (generations.length > 0) {
                const generation = generations[0];
                return new Generation({
                  message: generation.message.content,
                  finishReason: generation.finish_reason,
                  choiceId: shouldSetChoiceIds ? generation.id : void 0,
                  role: generation.message.role,
                  inputTokens: body.usage?.prompt_tokens,
                  outputTokens: body.usage?.completion_tokens
                });
              }
            }
            const completions = body.completions || [];
            if (completions.length > 0) {
              const completion = completions[0];
              return new Generation({
                message: completion.data?.text,
                finishReason: completion?.finishReason,
                choiceId: shouldSetChoiceIds ? completion?.id : void 0,
                inputTokens: body.usage?.prompt_tokens,
                outputTokens: body.usage?.completion_tokens
              });
            }
            return new Generation();
          }
          case PROVIDER.AMAZON: {
            if (modelName.includes("embed")) {
              return new Generation({ message: body.embedding });
            }
            if (body.results) {
              const results = body.results || [];
              if (results.length > 0) {
                const result = results[0];
                return new Generation({
                  message: result.outputText,
                  finishReason: result.completionReason,
                  inputTokens: body.inputTextTokenCount,
                  outputTokens: result.tokenCount
                });
              }
            } else if (body.output) {
              const output = body.output || {};
              return new Generation({
                message: output.message?.content[0]?.text ?? "Unsupported content type",
                finishReason: body.stopReason,
                role: output.message?.role,
                inputTokens: body.usage?.inputTokens,
                outputTokens: body.usage?.outputTokens,
                cacheReadInputTokenCount: body.usage?.cacheReadInputTokenCount,
                cacheWriteInputTokenCount: body.usage?.cacheWriteInputTokenCount
              });
            }
            break;
          }
          case PROVIDER.ANTHROPIC: {
            let message = body.completion;
            if (Array.isArray(body.content)) {
              message = body.content.find((item) => item.type === "text")?.text ?? body.content;
            } else if (body.content) {
              message = body.content;
            }
            return new Generation({ message, finishReason: body.stop_reason });
          }
          case PROVIDER.COHERE: {
            if (modelName.includes("embed")) {
              const embeddings = body.embeddings || [[]];
              if (embeddings.length > 0) {
                return new Generation({ message: embeddings[0] });
              }
            }
            if (body.text) {
              return new Generation({
                message: body.text,
                finishReason: body.finish_reason,
                choiceId: shouldSetChoiceIds ? body.response_id : void 0
              });
            }
            const generations = body.generations || [];
            if (generations.length > 0) {
              const generation = generations[0];
              return new Generation({
                message: generation.text,
                finishReason: generation.finish_reason,
                choiceId: shouldSetChoiceIds ? generation.id : void 0
              });
            }
            break;
          }
          case PROVIDER.META: {
            return new Generation({
              message: body.generation,
              finishReason: body.stop_reason,
              inputTokens: body.prompt_token_count,
              outputTokens: body.generation_token_count
            });
          }
          case PROVIDER.MISTRAL: {
            const mistralGenerations = body.outputs || [];
            if (mistralGenerations.length > 0) {
              const generation = mistralGenerations[0];
              return new Generation({ message: generation.text, finishReason: generation.stop_reason });
            }
            break;
          }
          case PROVIDER.STABILITY: {
            return new Generation();
          }
          default: {
            return new Generation();
          }
        }
      } catch {
        log.warn("Unable to extract text/finishReason from response body. Defaulting to empty text/finishReason.");
        return new Generation();
      }
      return new Generation();
    }
    module2.exports = {
      Generation,
      RequestParams,
      extractTextAndResponseReasonFromStream,
      parseModelId,
      extractRequestParams,
      extractTextAndResponseReason,
      PROVIDER
    };
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/tracing.js
var require_tracing3 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/tracing.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var { parseModelId } = require_utils4();
    var enabledOperations = /* @__PURE__ */ new Set(["invokeModel", "invokeModelWithResponseStream"]);
    var BedrockRuntime = class extends BaseAwsSdkPlugin {
      static id = "bedrockruntime";
      isEnabled(request2) {
        const operation = request2.operation;
        if (!enabledOperations.has(operation)) {
          return false;
        }
        return super.isEnabled(request2);
      }
      generateTags(params, operation) {
        const { modelProvider, modelName } = parseModelId(params.modelId);
        return {
          "resource.name": operation,
          "aws.bedrock.request.model": modelName,
          "aws.bedrock.request.model_provider": modelProvider.toLowerCase()
        };
      }
    };
    module2.exports = BedrockRuntime;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/bedrockruntime.js
var require_bedrockruntime = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/bedrockruntime.js"(exports2, module2) {
    "use strict";
    var BaseLLMObsPlugin = require_base();
    var { storage } = require_datadog_core();
    var llmobsStore = storage("llmobs");
    var telemetry = require_telemetry4();
    var {
      extractRequestParams,
      extractTextAndResponseReason,
      parseModelId,
      extractTextAndResponseReasonFromStream
    } = require_utils4();
    var ENABLED_OPERATIONS = /* @__PURE__ */ new Set(["invokeModel", "invokeModelWithResponseStream"]);
    var requestIdsToTokens = {};
    var BedrockRuntimeLLMObsPlugin = class extends BaseLLMObsPlugin {
      constructor() {
        super(...arguments);
        this.addSub("apm:aws:request:complete:bedrockruntime", (ctx) => {
          const { response } = ctx;
          const request2 = response.request;
          const operation = request2.operation;
          if (!ENABLED_OPERATIONS.has(operation)) {
            return;
          }
          const { modelProvider, modelName } = parseModelId(request2.params.modelId);
          if (modelName.includes("embed")) {
            return;
          }
          const span = ctx.currentStore?.span;
          this.setLLMObsTags({ ctx, request: request2, span, response, modelProvider, modelName });
        });
        this.addSub("apm:aws:response:deserialize:bedrockruntime", ({ headers }) => {
          const requestId = headers["x-amzn-requestid"];
          const inputTokenCount = headers["x-amzn-bedrock-input-token-count"];
          const outputTokenCount = headers["x-amzn-bedrock-output-token-count"];
          const cacheReadTokenCount = headers["x-amzn-bedrock-cache-read-input-token-count"];
          const cacheWriteTokenCount = headers["x-amzn-bedrock-cache-write-input-token-count"];
          requestIdsToTokens[requestId] = {
            inputTokensFromHeaders: inputTokenCount && Number.parseInt(inputTokenCount),
            outputTokensFromHeaders: outputTokenCount && Number.parseInt(outputTokenCount),
            cacheReadTokensFromHeaders: cacheReadTokenCount && Number.parseInt(cacheReadTokenCount),
            cacheWriteTokensFromHeaders: cacheWriteTokenCount && Number.parseInt(cacheWriteTokenCount)
          };
        });
        this.addSub("apm:aws:response:streamed-chunk:bedrockruntime", ({ ctx, chunk }) => {
          if (!ctx.chunks) ctx.chunks = [];
          if (chunk) ctx.chunks.push(chunk);
        });
      }
      setLLMObsTags({ ctx, request: request2, span, response, modelProvider, modelName }) {
        const isStream = request2?.operation?.toLowerCase().includes("stream");
        telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: true, integration: "bedrock" });
        const parent = llmobsStore.getStore()?.span;
        this._tagger.registerLLMObsSpan(span, {
          parent,
          modelName: modelName.toLowerCase(),
          modelProvider: modelProvider.toLowerCase(),
          kind: "llm",
          name: "bedrock-runtime.command",
          integration: "bedrock"
        });
        const requestParams = extractRequestParams(request2.params, modelProvider);
        const textAndResponseReason = isStream ? extractTextAndResponseReasonFromStream(ctx.chunks, modelProvider, modelName) : extractTextAndResponseReason(response, modelProvider, modelName);
        this._tagger.tagMetadata(span, {
          temperature: Number.parseFloat(requestParams.temperature) || 0,
          max_tokens: Number.parseInt(requestParams.maxTokens) || 0
        });
        this._tagger.tagLLMIO(
          span,
          requestParams.prompt,
          [{ content: textAndResponseReason.message, role: textAndResponseReason.role }]
        );
        const { inputTokens, outputTokens, totalTokens, cacheReadTokens, cacheWriteTokens } = extractTokens({
          requestId: response.$metadata.requestId,
          usage: textAndResponseReason.usage
        });
        this._tagger.tagMetrics(span, {
          inputTokens,
          outputTokens,
          totalTokens,
          cacheReadTokens,
          cacheWriteTokens
        });
      }
    };
    function extractTokens({ requestId, usage }) {
      const {
        inputTokensFromHeaders,
        outputTokensFromHeaders,
        cacheReadTokensFromHeaders,
        cacheWriteTokensFromHeaders
      } = requestIdsToTokens[requestId] || {};
      delete requestIdsToTokens[requestId];
      const inputTokens = usage.inputTokens || inputTokensFromHeaders || 0;
      const outputTokens = usage.outputTokens || outputTokensFromHeaders || 0;
      const cacheReadTokens = usage.cacheReadTokens || cacheReadTokensFromHeaders || 0;
      const cacheWriteTokens = usage.cacheWriteTokens || cacheWriteTokensFromHeaders || 0;
      const normalizedInputTokens = inputTokens + cacheReadTokens + cacheWriteTokens;
      return {
        inputTokens: normalizedInputTokens,
        outputTokens,
        totalTokens: normalizedInputTokens + outputTokens,
        cacheReadTokens,
        cacheWriteTokens
      };
    }
    module2.exports = BedrockRuntimeLLMObsPlugin;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/index.js
var require_bedrockruntime2 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/bedrockruntime/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var BedrockRuntimeTracing = require_tracing3();
    var BedrockRuntimeLLMObsPlugin = require_bedrockruntime();
    var BedrockRuntimePlugin = class extends CompositePlugin {
      static id = "bedrockruntime";
      static get plugins() {
        return {
          llmobs: BedrockRuntimeLLMObsPlugin,
          tracing: BedrockRuntimeTracing
        };
      }
    };
    module2.exports = BedrockRuntimePlugin;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/default.js
var require_default = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/default.js"(exports2, module2) {
    "use strict";
    var BaseAwsSdkPlugin = require_base2();
    var Default = class extends BaseAwsSdkPlugin {
    };
    module2.exports = Default;
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/services/index.js
var require_services = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/services/index.js"(exports2) {
    "use strict";
    exports2.cloudwatchlogs = require_cloudwatchlogs();
    exports2.dynamodb = require_dynamodb();
    exports2.eventbridge = require_eventbridge();
    exports2.kinesis = require_kinesis();
    exports2.lambda = require_lambda();
    exports2.redshift = require_redshift();
    exports2.s3 = require_s3();
    exports2.sfn = require_sfn();
    exports2.sns = require_sns();
    exports2.sqs = require_sqs();
    exports2.states = require_states();
    exports2.stepfunctions = require_stepfunctions();
    exports2.bedrockruntime = require_bedrockruntime2();
    exports2.default = require_default();
  }
});

// ../../packages/datadog-plugin-aws-sdk/src/index.js
var require_src4 = __commonJS({
  "../../packages/datadog-plugin-aws-sdk/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var services = require_services();
    var AwsSdkPlugin = class extends Plugin {
      static id = "aws-sdk";
      constructor(...args) {
        super(...args);
        this.services = {};
        for (const name in services) {
          const ServicePlugin = services[name];
          this.services[name] = new ServicePlugin(...args);
        }
      }
      configure(config) {
        for (const service of Object.values(this.services)) {
          service.configure(config);
        }
      }
    };
    module2.exports = AwsSdkPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/producer.js
var require_producer = __commonJS({
  "../../packages/dd-trace/src/plugins/producer.js"(exports2, module2) {
    "use strict";
    var OutboundPlugin = require_outbound();
    var ProducerPlugin = class extends OutboundPlugin {
      static operation = "publish";
      static kind = "producer";
      static type = "messaging";
      startSpan(options, enterOrCtx) {
        const spanDefaults = {
          kind: this.constructor.kind
        };
        if (!options.service) {
          options.service = this.config.service || this.serviceName();
        }
        Object.keys(spanDefaults).forEach(
          (key) => {
            if (!options[key]) options[key] = spanDefaults[key];
          }
        );
        return super.startSpan(this.operationName(), options, enterOrCtx);
      }
    };
    module2.exports = ProducerPlugin;
  }
});

// ../../packages/datadog-plugin-azure-event-hubs/src/producer.js
var require_producer2 = __commonJS({
  "../../packages/datadog-plugin-azure-event-hubs/src/producer.js"(exports2, module2) {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    var ProducerPlugin = require_producer();
    var AzureEventHubsProducerPlugin = class extends ProducerPlugin {
      static get id() {
        return "azure-event-hubs";
      }
      static get operation() {
        return "send";
      }
      static get prefix() {
        return "tracing:apm:azure-event-hubs:send";
      }
      bindStart(ctx) {
        if (!batchLinksAreEnabled() && ctx.functionName === "tryAdd") {
          return ctx.currentStore;
        }
        const qualifiedNamespace = ctx.config.endpoint.replace("sb://", "").replace("/", "");
        const entityPath = ctx.config.entityPath;
        const span = this.startSpan({
          resource: entityPath,
          type: "messaging",
          meta: {
            component: "azure-event-hubs",
            "messaging.system": "eventhubs",
            "messaging.destination.name": entityPath,
            "network.destination.name": qualifiedNamespace
          }
        }, ctx);
        if (ctx.functionName === "tryAdd") {
          span._spanContext._name = "azure.eventhubs.create";
          span.setTag("messaging.operation", "create");
          if (ctx.eventData.messageID !== void 0) {
            span.setTag("message.id", ctx.eventData.messageID);
          }
          if (batchLinksAreEnabled()) {
            ctx.batch._spanContexts.push(span.context());
            injectTraceContext(this.tracer, span, ctx.eventData);
          }
        }
        if (ctx.functionName === "sendBatch") {
          const eventData = ctx.eventData;
          const eventDataLength = eventData.length || eventData._context.connection._eventsCount;
          span.setTag("messaging.operation", "send");
          span.setTag("messaging.batch.message_count", eventDataLength);
          if (eventData.constructor.name !== "EventDataBatchImpl" && Array.isArray(eventData)) {
            eventData.forEach((event) => {
              injectTraceContext(this.tracer, span, event);
            });
          } else {
            if (batchLinksAreEnabled()) {
              eventData._spanContexts.forEach((spanContext) => {
                span.addLink(spanContext);
              });
            }
          }
        }
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        super.finish();
      }
    };
    function injectTraceContext(tracer2, span, event) {
      if (!event.properties) {
        event.properties = {};
      }
      tracer2.inject(span, "text_map", event.properties);
    }
    function batchLinksAreEnabled() {
      const eh = getEnvironmentVariable("DD_TRACE_AZURE_EVENTHUBS_BATCH_LINKS_ENABLED");
      return eh !== "false";
    }
    module2.exports = AzureEventHubsProducerPlugin;
  }
});

// ../../packages/datadog-plugin-azure-event-hubs/src/index.js
var require_src5 = __commonJS({
  "../../packages/datadog-plugin-azure-event-hubs/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer2();
    var CompositePlugin = require_composite2();
    var AzureEventHubsPlugin = class extends CompositePlugin {
      static get id() {
        return "azure-event-hubs";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin
        };
      }
    };
    module2.exports = AzureEventHubsPlugin;
  }
});

// ../../packages/datadog-core/src/utils/src/uniq.js
var require_uniq = __commonJS({
  "../../packages/datadog-core/src/utils/src/uniq.js"(exports2, module2) {
    "use strict";
    module2.exports = function uniq(arr) {
      return [...new Set(arr)];
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/urlfilter.js
var require_urlfilter = __commonJS({
  "../../packages/dd-trace/src/plugins/util/urlfilter.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    function applyFilter(filter, uri) {
      if (typeof filter === "function") {
        return filter(uri);
      } else if (filter instanceof RegExp) {
        return filter.test(uri);
      } else if (Array.isArray(filter)) {
        return filter.some((filter2) => applyFilter(filter2, uri));
      }
      return filter === uri;
    }
    var urlFilter = {
      getFilter(config) {
        if (typeof config.filter === "function") {
          return config.filter;
        } else if (config.hasOwnProperty("filter")) {
          log.error("Expected `filter` to be a function. Overriding filter property to default.");
        }
        const allowlist = config.allowlist || config.whitelist || /.*/;
        const blocklist = config.blocklist || config.blacklist || [];
        return (uri) => applyFilter(allowlist, uri) && !applyFilter(blocklist, uri);
      }
    };
    module2.exports = urlFilter;
  }
});

// ../../packages/dd-trace/src/plugins/util/inferred_proxy.js
var require_inferred_proxy = __commonJS({
  "../../packages/dd-trace/src/plugins/util/inferred_proxy.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var tags = require_tags();
    var RESOURCE_NAME = tags.RESOURCE_NAME;
    var SPAN_TYPE = tags.SPAN_TYPE;
    var HTTP_URL = tags.HTTP_URL;
    var HTTP_METHOD = tags.HTTP_METHOD;
    var PROXY_HEADER_SYSTEM = "x-dd-proxy";
    var PROXY_HEADER_START_TIME_MS = "x-dd-proxy-request-time-ms";
    var PROXY_HEADER_PATH = "x-dd-proxy-path";
    var PROXY_HEADER_HTTPMETHOD = "x-dd-proxy-httpmethod";
    var PROXY_HEADER_DOMAIN = "x-dd-proxy-domain-name";
    var PROXY_HEADER_STAGE = "x-dd-proxy-stage";
    var supportedProxies = {
      "aws-apigateway": {
        spanName: "aws.apigateway",
        component: "aws-apigateway"
      }
    };
    function createInferredProxySpan(headers, childOf, tracer2, reqCtx, traceCtx, config, startSpanHelper) {
      if (!headers) {
        return null;
      }
      if (!tracer2._config?.inferredProxyServicesEnabled) {
        return null;
      }
      const proxyContext = extractInferredProxyContext(headers);
      if (!proxyContext) {
        return null;
      }
      const proxySpanInfo = supportedProxies[proxyContext.proxySystemName];
      log.debug("Successfully extracted inferred span info %s for proxy:", proxyContext, proxyContext.proxySystemName);
      const span = startSpanHelper(tracer2, proxySpanInfo.spanName, {
        childOf,
        type: "web",
        startTime: proxyContext.requestTime,
        integrationName: proxySpanInfo.component,
        meta: {
          service: proxyContext.domainName || tracer2._config.service,
          component: proxySpanInfo.component,
          [SPAN_TYPE]: "web",
          [HTTP_METHOD]: proxyContext.method,
          [HTTP_URL]: proxyContext.domainName + proxyContext.path,
          stage: proxyContext.stage
        }
      }, traceCtx, config);
      reqCtx.inferredProxySpan = span;
      childOf = span;
      log.debug("Successfully created inferred proxy span.");
      setInferredProxySpanTags(span, proxyContext);
      return childOf;
    }
    function setInferredProxySpanTags(span, proxyContext) {
      span.setTag(RESOURCE_NAME, `${proxyContext.method} ${proxyContext.path}`);
      span.setTag("_dd.inferred_span", 1);
      return span;
    }
    function extractInferredProxyContext(headers) {
      if (!(PROXY_HEADER_START_TIME_MS in headers)) {
        return null;
      }
      if (!(PROXY_HEADER_SYSTEM in headers && headers[PROXY_HEADER_SYSTEM] in supportedProxies)) {
        log.debug("Received headers to create inferred proxy span but headers include an unsupported proxy type", headers);
        return null;
      }
      return {
        requestTime: headers[PROXY_HEADER_START_TIME_MS] ? Number.parseInt(headers[PROXY_HEADER_START_TIME_MS], 10) : null,
        method: headers[PROXY_HEADER_HTTPMETHOD],
        path: headers[PROXY_HEADER_PATH],
        stage: headers[PROXY_HEADER_STAGE],
        domainName: headers[PROXY_HEADER_DOMAIN],
        proxySystemName: headers[PROXY_HEADER_SYSTEM]
      };
    }
    function finishInferredProxySpan(context2) {
      const { req } = context2;
      if (!context2.inferredProxySpan) return;
      if (context2.inferredProxySpanFinished && !req.stream) return;
      if (context2.inferredProxySpan) {
        context2.inferredProxySpan.finish();
        context2.inferredProxySpanFinished = true;
      }
    }
    module2.exports = {
      createInferredProxySpan,
      finishInferredProxySpan
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/ip_extractor.js
var require_ip_extractor = __commonJS({
  "../../packages/dd-trace/src/plugins/util/ip_extractor.js"(exports2, module2) {
    "use strict";
    var net = __require("net");
    var FORWARED_HEADER_NAME = "forwarded";
    var ipHeaderList = [
      "x-forwarded-for",
      "x-real-ip",
      "true-client-ip",
      "x-client-ip",
      FORWARED_HEADER_NAME,
      "forwarded-for",
      "x-cluster-client-ip",
      "fastly-client-ip",
      "cf-connecting-ip",
      "cf-connecting-ipv6"
    ];
    var privateCIDRs = [
      "127.0.0.0/8",
      "10.0.0.0/8",
      "172.16.0.0/12",
      "192.168.0.0/16",
      "169.254.0.0/16",
      "100.65.0.0/10",
      "::1/128",
      "fec0::/10",
      "fe80::/10",
      "fc00::/7",
      "fd00::/8"
    ];
    var privateIPMatcher = new net.BlockList();
    for (const cidr of privateCIDRs) {
      const [address, prefix] = cidr.split("/");
      privateIPMatcher.addSubnet(address, Number.parseInt(prefix), net.isIPv6(address) ? "ipv6" : "ipv4");
    }
    function extractIp(config, req) {
      const headers = req.headers;
      if (config.clientIpHeader) {
        if (!headers) return;
        const ipHeaderName = config.clientIpHeader;
        const header = headers[ipHeaderName];
        if (typeof header !== "string") return;
        const ip = findFirstIp(header, ipHeaderName === FORWARED_HEADER_NAME);
        return ip.public || ip.private;
      }
      let firstPrivateIp;
      if (headers) {
        for (const ipHeaderName of ipHeaderList) {
          const header = headers[ipHeaderName];
          if (typeof header !== "string") continue;
          const ip = findFirstIp(header, ipHeaderName === FORWARED_HEADER_NAME);
          if (ip.public) {
            return ip.public;
          } else if (!firstPrivateIp && ip.private) {
            firstPrivateIp = ip.private;
          }
        }
      }
      return firstPrivateIp || req.socket?.remoteAddress;
    }
    function findFirstIp(str, isForwardedHeader) {
      const result = {};
      if (!str) return result;
      const splitted = str.split(",");
      for (let chunk of splitted) {
        if (isForwardedHeader) {
          const forDirective = chunk.split(";").find((subchunk) => subchunk.trim().toLowerCase().startsWith("for="));
          if (forDirective) {
            chunk = forDirective.slice(4);
          }
        }
        chunk = chunk.trim();
        if (chunk.startsWith('"') && chunk.endsWith('"')) {
          chunk = chunk.slice(1, -1).trim();
        }
        chunk = cleanIp(chunk);
        if (!chunk) continue;
        const type = net.isIP(chunk);
        if (!type) continue;
        if (!privateIPMatcher.check(chunk, type === 6 ? "ipv6" : "ipv4")) {
          result.public = chunk;
          return result;
        }
        if (!result.private) result.private = chunk;
      }
      return result;
    }
    function cleanIp(input) {
      const colonIndex = input.indexOf(":");
      if (colonIndex !== -1 && input.includes(".")) {
        return input.slice(0, colonIndex).trim();
      }
      const closingBracketIndex = input.indexOf("]");
      if (closingBracketIndex !== -1 && input.startsWith("[")) {
        return input.slice(1, closingBracketIndex).trim();
      }
      return input;
    }
    module2.exports = {
      extractIp,
      ipHeaderList
    };
  }
});

// ../../packages/dd-trace/src/plugins/util/web.js
var require_web3 = __commonJS({
  "../../packages/dd-trace/src/plugins/util/web.js"(exports2, module2) {
    "use strict";
    var uniq = require_uniq();
    var analyticsSampler = require_analytics_sampler();
    var FORMAT_HTTP_HEADERS = "http_headers";
    var log = require_log2();
    var tags = require_tags();
    var types = require_types();
    var kinds = require_kinds();
    var urlFilter = require_urlfilter();
    var { ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants3();
    var { createInferredProxySpan, finishInferredProxySpan } = require_inferred_proxy();
    var TracingPlugin = require_tracing();
    var extractIp;
    var WEB = types.WEB;
    var SERVER = kinds.SERVER;
    var RESOURCE_NAME = tags.RESOURCE_NAME;
    var SERVICE_NAME = tags.SERVICE_NAME;
    var SPAN_TYPE = tags.SPAN_TYPE;
    var SPAN_KIND = tags.SPAN_KIND;
    var ERROR = tags.ERROR;
    var HTTP_METHOD = tags.HTTP_METHOD;
    var HTTP_URL = tags.HTTP_URL;
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_ROUTE = tags.HTTP_ROUTE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var HTTP_USERAGENT = tags.HTTP_USERAGENT;
    var HTTP_CLIENT_IP = tags.HTTP_CLIENT_IP;
    var MANUAL_DROP = tags.MANUAL_DROP;
    var HTTP2_HEADER_AUTHORITY = ":authority";
    var HTTP2_HEADER_SCHEME = ":scheme";
    var HTTP2_HEADER_PATH = ":path";
    var contexts = /* @__PURE__ */ new WeakMap();
    var ends = /* @__PURE__ */ new WeakMap();
    function createWebPlugin(tracer2, config = {}) {
      const plugin = new TracingPlugin(tracer2, tracer2._config);
      plugin.component = "web";
      plugin.config = config;
      return plugin;
    }
    function startSpanHelper(tracer2, name, options, traceCtx, config = {}) {
      if (!web.plugin) {
        web.plugin = createWebPlugin(tracer2, config);
      }
      return web.plugin.startSpan(name, { ...options, tracer: tracer2, config }, traceCtx);
    }
    var web = {
      TYPE: WEB,
      plugin: null,
      // Ensure the configuration has the correct structure and defaults.
      normalizeConfig(config) {
        const headers = getHeadersToRecord(config);
        const validateStatus = getStatusValidator(config);
        const hooks = getHooks(config);
        const filter = urlFilter.getFilter(config);
        const middleware = getMiddlewareSetting(config);
        const queryStringObfuscation = getQsObfuscator(config);
        extractIp = config.clientIpEnabled && require_ip_extractor().extractIp;
        return {
          ...config,
          headers,
          validateStatus,
          hooks,
          filter,
          middleware,
          queryStringObfuscation
        };
      },
      setFramework(req, name, config) {
        const context2 = this.patch(req);
        const span = context2.span;
        if (!span) return;
        span.context()._name = `${name}.request`;
        span.context()._tags.component = name;
        span._integrationName = name;
        web.setConfig(req, config);
      },
      setConfig(req, config) {
        const context2 = contexts.get(req);
        const span = context2.span;
        context2.config = config;
        if (!config.filter(req.url)) {
          span.setTag(MANUAL_DROP, true);
          span.context()._trace.isRecording = false;
        }
        if (config.service) {
          span.setTag(SERVICE_NAME, config.service);
        }
        analyticsSampler.sample(span, config.measured, true);
      },
      startSpan(tracer2, config, req, res, name, traceCtx) {
        const context2 = this.patch(req);
        let span;
        if (context2.span) {
          context2.span.context()._name = name;
          span = context2.span;
        } else {
          span = web.startChildSpan(tracer2, config, name, req, traceCtx);
        }
        context2.tracer = tracer2;
        context2.span = span;
        context2.res = res;
        this.setConfig(req, config);
        addRequestTags(context2, this.TYPE);
        return span;
      },
      wrap(req) {
        const context2 = contexts.get(req);
        if (!context2.instrumented) {
          this.wrapEnd(context2);
          context2.instrumented = true;
        }
      },
      // Start a span and activate a scope for a request.
      instrument(tracer2, config, req, res, name, callback) {
        const span = this.startSpan(tracer2, config, req, res, name);
        this.wrap(req);
        return callback && tracer2.scope().activate(span, () => callback(span));
      },
      // Reactivate the request scope in case it was changed by a middleware.
      reactivate(req, fn) {
        return reactivate(req, fn);
      },
      // Add a route segment that will be used for the resource name.
      enterRoute(req, path) {
        if (typeof path === "string") {
          contexts.get(req).paths.push(path);
        }
      },
      setRoute(req, path) {
        const context2 = contexts.get(req);
        if (!context2) return;
        context2.paths = [path];
      },
      // Remove the current route segment.
      exitRoute(req) {
        contexts.get(req).paths.pop();
      },
      // Start a new middleware span and activate a new scope with the span.
      wrapMiddleware(req, middleware, name, fn) {
        if (!this.active(req)) return fn();
        const context2 = contexts.get(req);
        const tracer2 = context2.tracer;
        const childOf = this.active(req);
        const config = context2.config;
        const traceCtx = context2.traceCtx;
        if (config.middleware === false) return this.bindAndWrapMiddlewareErrors(fn, req, tracer2, childOf);
        const span = startSpanHelper(tracer2, name, { childOf }, traceCtx, config);
        analyticsSampler.sample(span, config.measured);
        span.addTags({
          [RESOURCE_NAME]: middleware._name || middleware.name || "<anonymous>"
        });
        context2.middleware.push(span);
        return tracer2.scope().activate(span, fn);
      },
      // catch errors and apply to active span
      bindAndWrapMiddlewareErrors(fn, req, tracer2, activeSpan) {
        try {
          return tracer2.scope().bind(fn, activeSpan).apply(this, arguments);
        } catch (e) {
          web.addError(req, e);
          throw e;
        }
      },
      // Finish the active middleware span.
      finish(req, error) {
        if (!this.active(req)) return;
        const context2 = contexts.get(req);
        const span = context2.middleware.pop();
        if (span) {
          if (error) {
            span.addTags({
              [ERROR_TYPE]: error.name,
              [ERROR_MESSAGE]: error.message,
              [ERROR_STACK]: error.stack
            });
          }
          span.finish();
        }
      },
      // Register a callback to run before res.end() is called.
      beforeEnd(req, callback) {
        contexts.get(req).beforeEnd.push(callback);
      },
      // Prepare the request for instrumentation.
      patch(req) {
        let context2 = contexts.get(req);
        if (context2) return context2;
        context2 = req.stream && contexts.get(req.stream);
        if (context2) {
          contexts.set(req, context2);
          return context2;
        }
        context2 = {
          req,
          span: null,
          paths: [],
          middleware: [],
          beforeEnd: [],
          config: {}
        };
        contexts.set(req, context2);
        return context2;
      },
      // Return the request root span.
      root(req) {
        const context2 = contexts.get(req);
        return context2 ? context2.span : null;
      },
      // Return the active span.
      active(req) {
        const context2 = contexts.get(req);
        if (!context2) return null;
        if (context2.middleware.length === 0) return context2.span || null;
        return context2.middleware.at(-1);
      },
      // Extract the parent span from the headers and start a new span as its child
      startChildSpan(tracer2, config, name, req, traceCtx) {
        const headers = req.headers;
        const reqCtx = contexts.get(req);
        let childOf = tracer2.extract(FORMAT_HTTP_HEADERS, headers);
        if (tracer2._config?.inferredProxyServicesEnabled) {
          const proxySpan = createInferredProxySpan(headers, childOf, tracer2, reqCtx, traceCtx, config, startSpanHelper);
          if (proxySpan) {
            childOf = proxySpan;
          }
        }
        const span = startSpanHelper(tracer2, name, { childOf }, traceCtx, config);
        return span;
      },
      // Validate a request's status code and then add error tags if necessary
      addStatusError(req, statusCode) {
        const context2 = contexts.get(req);
        const { span, inferredProxySpan, error } = context2;
        const spanHasExistingError = span.context()._tags.error || span.context()._tags[ERROR_MESSAGE];
        const inferredSpanContext = inferredProxySpan?.context();
        const inferredSpanHasExistingError = inferredSpanContext?._tags.error || inferredSpanContext?._tags[ERROR_MESSAGE];
        const isValidStatusCode = context2.config.validateStatus(statusCode);
        if (!spanHasExistingError && !isValidStatusCode) {
          span.setTag(ERROR, error || true);
        }
        if (inferredProxySpan && !inferredSpanHasExistingError && !isValidStatusCode) {
          inferredProxySpan.setTag(ERROR, error || true);
        }
      },
      // Add an error to the request
      addError(req, error) {
        if (error instanceof Error) {
          const context2 = contexts.get(req);
          if (context2) {
            context2.error = error;
          }
        }
      },
      finishMiddleware(context2) {
        if (context2.finished) return;
        let span;
        while (span = context2.middleware.pop()) {
          span.finish();
        }
      },
      finishSpan(context2) {
        const { req, res } = context2;
        if (context2.finished && !req.stream) return;
        addRequestTags(context2, this.TYPE);
        addResponseTags(context2);
        context2.config.hooks.request(context2.span, req, res);
        addResourceTag(context2);
        context2.span.finish();
        context2.finished = true;
      },
      finishAll(context2) {
        for (const beforeEnd of context2.beforeEnd) {
          beforeEnd();
        }
        web.finishMiddleware(context2);
        web.finishSpan(context2);
        finishInferredProxySpan(context2);
      },
      obfuscateQs(config, url) {
        const { queryStringObfuscation } = config;
        if (queryStringObfuscation === false) return url;
        const i = url.indexOf("?");
        if (i === -1) return url;
        const path = url.slice(0, i);
        if (queryStringObfuscation === true) return path;
        let qs = url.slice(i + 1);
        qs = qs.replace(queryStringObfuscation, "<redacted>");
        return `${path}?${qs}`;
      },
      wrapWriteHead(context2) {
        const { req, res } = context2;
        const writeHead = res.writeHead;
        return function(statusCode, statusMessage, headers) {
          headers = typeof statusMessage === "string" ? headers : statusMessage;
          headers = { ...res.getHeaders(), ...headers };
          if (req.method.toLowerCase() === "options" && isOriginAllowed(req, headers)) {
            addAllowHeaders(req, res, headers);
          }
          return writeHead.apply(this, arguments);
        };
      },
      getContext(req) {
        return contexts.get(req);
      },
      wrapRes(context2, req, res, end) {
        return function() {
          web.finishAll(context2);
          return end.apply(res, arguments);
        };
      },
      wrapEnd(context2) {
        const scope = context2.tracer.scope();
        const req = context2.req;
        const res = context2.res;
        const end = res.end;
        res.writeHead = web.wrapWriteHead(context2);
        ends.set(res, this.wrapRes(context2, req, res, end));
        Object.defineProperty(res, "end", {
          configurable: true,
          get() {
            return ends.get(this);
          },
          set(value) {
            ends.set(this, scope.bind(value, context2.span));
          }
        });
      }
    };
    function addAllowHeaders(req, res, headers) {
      const allowHeaders = splitHeader(headers["access-control-allow-headers"]);
      const requestHeaders = splitHeader(req.headers["access-control-request-headers"]);
      const contextHeaders = [
        "x-datadog-origin",
        "x-datadog-parent-id",
        "x-datadog-sampled",
        // Deprecated, but still accept it in case it's sent.
        "x-datadog-sampling-priority",
        "x-datadog-trace-id",
        "x-datadog-tags"
      ];
      for (const header of contextHeaders) {
        if (requestHeaders.includes(header)) {
          allowHeaders.push(header);
        }
      }
      if (allowHeaders.length > 0) {
        res.setHeader("access-control-allow-headers", uniq(allowHeaders).join(","));
      }
    }
    function isOriginAllowed(req, headers) {
      const origin = req.headers.origin;
      const allowOrigin = headers["access-control-allow-origin"];
      return origin && (allowOrigin === "*" || allowOrigin === origin);
    }
    function splitHeader(str) {
      return typeof str === "string" ? str.split(/\s*,\s*/) : [];
    }
    function reactivate(req, fn) {
      const context2 = contexts.get(req);
      return context2 ? context2.tracer.scope().activate(context2.span, fn) : fn();
    }
    function addRequestTags(context2, spanType) {
      const { req, span, inferredProxySpan, config } = context2;
      const url = extractURL(req);
      span.addTags({
        [HTTP_URL]: web.obfuscateQs(config, url),
        [HTTP_METHOD]: req.method,
        [SPAN_KIND]: SERVER,
        [SPAN_TYPE]: spanType,
        [HTTP_USERAGENT]: req.headers["user-agent"]
      });
      if (extractIp && !span.context()._tags.hasOwnProperty(HTTP_CLIENT_IP)) {
        const clientIp = extractIp(config, req);
        if (clientIp) {
          span.setTag(HTTP_CLIENT_IP, clientIp);
          inferredProxySpan?.setTag(HTTP_CLIENT_IP, clientIp);
        }
      }
      addHeaders(context2);
    }
    function addResponseTags(context2) {
      const { req, res, paths, span, inferredProxySpan } = context2;
      const route = paths.join("");
      if (route) {
        span.setTag(HTTP_ROUTE, route);
      }
      span.addTags({
        [HTTP_STATUS_CODE]: res.statusCode
      });
      inferredProxySpan?.addTags({
        [HTTP_STATUS_CODE]: res.statusCode
      });
      web.addStatusError(req, res.statusCode);
    }
    function addResourceTag(context2) {
      const { req, span } = context2;
      const tags2 = span.context()._tags;
      if (tags2["resource.name"]) return;
      const resource = [req.method, tags2[HTTP_ROUTE]].filter(Boolean).join(" ");
      span.setTag(RESOURCE_NAME, resource);
    }
    function addHeaders(context2) {
      const { req, res, config, span, inferredProxySpan } = context2;
      config.headers.forEach(([key, tag]) => {
        const reqHeader = req.headers[key];
        const resHeader = res.getHeader(key);
        if (reqHeader) {
          span.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, reqHeader);
          inferredProxySpan?.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, reqHeader);
        }
        if (resHeader) {
          span.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, resHeader);
          inferredProxySpan?.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, resHeader);
        }
      });
    }
    function extractURL(req) {
      const headers = req.headers;
      if (req.stream) {
        return `${headers[HTTP2_HEADER_SCHEME]}://${headers[HTTP2_HEADER_AUTHORITY]}${headers[HTTP2_HEADER_PATH]}`;
      }
      const protocol = getProtocol(req);
      return `${protocol}://${req.headers.host}${req.originalUrl || req.url}`;
    }
    function getProtocol(req) {
      if (req.socket && req.socket.encrypted) return "https";
      if (req.connection && req.connection.encrypted) return "https";
      return "http";
    }
    function getHeadersToRecord(config) {
      if (Array.isArray(config.headers)) {
        try {
          return config.headers.map((h) => h.split(":")).map(([key, tag]) => [key.toLowerCase(), tag]);
        } catch (err) {
          log.error("Web plugin error getting headers", err);
        }
      } else if (config.hasOwnProperty("headers")) {
        log.error("Expected `headers` to be an array of strings.");
      }
      return [];
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 500;
    }
    var noop = () => {
    };
    function getHooks(config) {
      const request2 = config.hooks?.request ?? noop;
      return { request: request2 };
    }
    function getMiddlewareSetting(config) {
      if (config && typeof config.middleware === "boolean") {
        return config.middleware;
      } else if (config && config.hasOwnProperty("middleware")) {
        log.error("Expected `middleware` to be a boolean.");
      }
      return true;
    }
    function getQsObfuscator(config) {
      const obfuscator = config.queryStringObfuscation;
      if (typeof obfuscator === "boolean") {
        return obfuscator;
      }
      if (typeof obfuscator === "string") {
        if (obfuscator === "") return false;
        if (obfuscator === ".*") return true;
        try {
          return new RegExp(obfuscator, "gi");
        } catch (err) {
          log.error("Web plugin error getting qs obfuscator", err);
        }
      }
      if (config.hasOwnProperty("queryStringObfuscation")) {
        log.error("Expected `queryStringObfuscation` to be a regex string or boolean.");
      }
      return true;
    }
    module2.exports = web;
  }
});

// ../../packages/dd-trace/src/plugins/util/serverless.js
var require_serverless4 = __commonJS({
  "../../packages/dd-trace/src/plugins/util/serverless.js"(exports2, module2) {
    "use strict";
    var types = require_types();
    var web = require_web3();
    var serverless = { ...web };
    serverless.TYPE = types.SERVERLESS;
    module2.exports = serverless;
  }
});

// ../../packages/datadog-plugin-azure-functions/src/index.js
var require_src6 = __commonJS({
  "../../packages/datadog-plugin-azure-functions/src/index.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var serverless = require_serverless4();
    var web = require_web3();
    var triggerMap = {
      deleteRequest: "Http",
      http: "Http",
      get: "Http",
      patch: "Http",
      post: "Http",
      put: "Http",
      serviceBusQueue: "ServiceBus",
      serviceBusTopic: "ServiceBus",
      eventHub: "EventHubs"
    };
    var AzureFunctionsPlugin = class extends TracingPlugin {
      static id = "azure-functions";
      static operation = "invoke";
      static kind = "server";
      static type = "serverless";
      static prefix = "tracing:datadog:azure:functions:invoke";
      bindStart(ctx) {
        const meta = getMetaForTrigger(ctx);
        const triggerType = triggerMap[ctx.methodName];
        const isMessagingService = triggerType === "ServiceBus" || triggerType === "EventHubs";
        const childOf = isMessagingService ? null : extractTraceContext(this._tracer, ctx);
        const span = this.startSpan(this.operationName(), {
          childOf,
          service: this.serviceName(),
          type: "serverless",
          meta
        }, ctx);
        if (isMessagingService) {
          setSpanLinks(triggerType, this.tracer, span, ctx);
        }
        ctx.span = span;
        return ctx.currentStore;
      }
      error(ctx) {
        this.addError(ctx.error);
        ctx.currentStore.span.setTag("error.message", ctx.error);
      }
      asyncEnd(ctx) {
        const { httpRequest, methodName, result = {} } = ctx;
        if (triggerMap[methodName] === "Http") {
          const path = new URL(httpRequest.url).pathname;
          const req = {
            method: httpRequest.method,
            headers: Object.fromEntries(httpRequest.headers),
            url: path
          };
          const context2 = web.patch(req);
          context2.config = this.config;
          context2.paths = [path];
          context2.res = { statusCode: result.status };
          context2.span = ctx.currentStore.span;
          serverless.finishSpan(context2);
        } else {
          super.finish();
        }
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
    };
    function getMetaForTrigger({ functionName, methodName, invocationContext }) {
      let meta = {
        "aas.function.name": functionName,
        "aas.function.trigger": mapTriggerTag(methodName)
      };
      if (triggerMap[methodName] === "ServiceBus") {
        const triggerEntity = invocationContext.options.trigger.queueName || invocationContext.options.trigger.topicName;
        meta = {
          ...meta,
          "messaging.message_id": invocationContext.triggerMetadata.messageId,
          "messaging.operation": "receive",
          "messaging.system": "servicebus",
          "messaging.destination.name": triggerEntity,
          "resource.name": `ServiceBus ${functionName}`,
          "span.kind": "consumer"
        };
      } else if (triggerMap[methodName] === "EventHubs") {
        const partitionContext = invocationContext.triggerMetadata.triggerPartitionContext;
        meta = {
          ...meta,
          "messaging.destination.name": partitionContext.eventHubName,
          "messaging.operation": "receive",
          "messaging.system": "eventhubs",
          "resource.name": `EventHubs ${functionName}`,
          "span.kind": "consumer"
        };
      }
      return meta;
    }
    function mapTriggerTag(methodName) {
      return triggerMap[methodName] || "Unknown";
    }
    function extractTraceContext(tracer2, ctx) {
      switch (String(triggerMap[ctx.methodName])) {
        case "Http":
          return tracer2.extract("http_headers", Object.fromEntries(ctx.httpRequest.headers));
        default:
          null;
      }
    }
    function setSpanLinks(triggerType, tracer2, span, ctx) {
      const cardinality = ctx.invocationContext.options.trigger.cardinality;
      const triggerMetadata = ctx.invocationContext.triggerMetadata;
      const isServiceBus = triggerType === "ServiceBus";
      const properties = isServiceBus ? triggerMetadata.applicationProperties : triggerMetadata.properties;
      const propertiesArray = isServiceBus ? triggerMetadata.applicationPropertiesArray : triggerMetadata.propertiesArray;
      const addLinkFromProperties = (props) => {
        if (!props || Object.keys(props).length === 0) return;
        const spanContext = tracer2.extract("text_map", props);
        if (spanContext) {
          span.addLink(spanContext);
        }
      };
      if (cardinality === "many" && propertiesArray?.length > 0) {
        propertiesArray.forEach(addLinkFromProperties);
      } else if (cardinality === "one") {
        addLinkFromProperties(properties);
      }
    }
    module2.exports = AzureFunctionsPlugin;
  }
});

// ../../packages/datadog-plugin-azure-service-bus/src/producer.js
var require_producer3 = __commonJS({
  "../../packages/datadog-plugin-azure-service-bus/src/producer.js"(exports2, module2) {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    var ProducerPlugin = require_producer();
    var AzureServiceBusProducerPlugin = class extends ProducerPlugin {
      static get id() {
        return "azure-service-bus";
      }
      static get operation() {
        return "send";
      }
      static get prefix() {
        return "tracing:apm:azure-service-bus:send";
      }
      bindStart(ctx) {
        if (!batchLinksAreEnabled() && ctx.functionName === "tryAddMessage") {
          return ctx.currentStore;
        }
        const qualifiedSenderNamespace = ctx.config.host;
        const span = this.startSpan({
          resource: ctx.entityPath,
          type: "messaging",
          meta: {
            component: "azure-service-bus",
            "messaging.destination.name": ctx.entityPath,
            "messaging.operation": "send",
            "messaging.system": "servicebus",
            "network.destination.name": qualifiedSenderNamespace
          }
        }, ctx);
        if (ctx.functionName === "tryAddMessage") {
          span._spanContext._name = "azure.servicebus.create";
          span.setTag("messaging.operation", "create");
          if (ctx.msg.messageID !== void 0) {
            span.setTag("message.id", ctx.msg);
          }
          if (batchLinksAreEnabled()) {
            ctx.batch._spanContexts.push(span.context());
            injectTraceContext(this.tracer, span, ctx.msg);
          }
        }
        if (ctx.functionName === "send" || ctx.functionName === "sendBatch" || ctx.functionName === "scheduleMessages") {
          const messages = ctx.msg;
          const isBatch = messages.constructor?.name === "ServiceBusMessageBatchImpl";
          if (isBatch) {
            span.setTag("messaging.batch.message_count", messages.count);
            if (batchLinksAreEnabled()) {
              messages._spanContexts.forEach((spanContext) => {
                span.addLink(spanContext);
              });
            }
          } else if (Array.isArray(messages)) {
            span.setTag("messaging.batch.message_count", messages.length);
            messages.forEach((event) => {
              injectTraceContext(this.tracer, span, event);
            });
          } else {
            injectTraceContext(this.tracer, span, messages);
          }
        }
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        super.finish();
      }
    };
    function injectTraceContext(tracer2, span, msg) {
      if (!msg.applicationProperties) {
        msg.applicationProperties = {};
      }
      tracer2.inject(span, "text_map", msg.applicationProperties);
    }
    function batchLinksAreEnabled() {
      const sb = getEnvironmentVariable("DD_TRACE_AZURE_SERVICEBUS_BATCH_LINKS_ENABLED");
      return sb !== "false";
    }
    module2.exports = AzureServiceBusProducerPlugin;
  }
});

// ../../packages/datadog-plugin-azure-service-bus/src/index.js
var require_src7 = __commonJS({
  "../../packages/datadog-plugin-azure-service-bus/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer3();
    var CompositePlugin = require_composite2();
    var AzureServiceBusPlugin = class extends CompositePlugin {
      static get id() {
        return "azure-service-bus";
      }
      static get plugins() {
        return {
          producer: ProducerPlugin
        };
      }
    };
    module2.exports = AzureServiceBusPlugin;
  }
});

// ../../packages/dd-trace/src/ci-visibility/dynamic-instrumentation/index.js
var require_dynamic_instrumentation = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/dynamic-instrumentation/index.js"(exports2, module2) {
    "use strict";
    var { join } = __require("path");
    var { Worker, threadId: parentThreadId } = __require("worker_threads");
    var { randomUUID } = __require("crypto");
    var log = require_log2();
    var { getEnvironmentVariables } = require_config_helper();
    var getDebuggerConfig = require_config3();
    var probeIdToResolveBreakpointSet = /* @__PURE__ */ new Map();
    var probeIdToResolveBreakpointRemove = /* @__PURE__ */ new Map();
    var TestVisDynamicInstrumentation = class {
      constructor(config) {
        this._config = config;
        this.worker = null;
        this._readyPromise = new Promise((resolve) => {
          this._onReady = resolve;
        });
        this.breakpointSetChannel = new MessageChannel();
        this.breakpointHitChannel = new MessageChannel();
        this.breakpointRemoveChannel = new MessageChannel();
        this.onHitBreakpointByProbeId = /* @__PURE__ */ new Map();
      }
      removeProbe(probeId) {
        return new Promise((resolve) => {
          this.breakpointRemoveChannel.port2.postMessage(probeId);
          probeIdToResolveBreakpointRemove.set(probeId, resolve);
        });
      }
      // Return 2 elements:
      // 1. Probe ID
      // 2. Promise that's resolved when the breakpoint is set
      addLineProbe({ file, line }, onHitBreakpoint) {
        if (!this.worker) {
          this.start();
        }
        const probeId = randomUUID();
        this.breakpointSetChannel.port2.postMessage(
          { id: probeId, file, line }
        );
        this.onHitBreakpointByProbeId.set(probeId, onHitBreakpoint);
        return [
          probeId,
          new Promise((resolve) => {
            probeIdToResolveBreakpointSet.set(probeId, resolve);
          })
        ];
      }
      isReady() {
        return this._readyPromise;
      }
      start() {
        if (this.worker) return;
        log.debug("Starting Test Visibility - Dynamic Instrumentation client...");
        const probeChannel = new MessageChannel();
        const configChannel = new MessageChannel();
        this.worker = new Worker(
          join(__dirname, "worker", "index.js"),
          {
            execArgv: [],
            // Not passing `NODE_OPTIONS` results in issues with yarn, which relies on NODE_OPTIONS
            // for PnP support, hence why we deviate from the DI pattern here.
            // To avoid infinite initialization loops, we're disabling DI and tracing in the worker.
            env: {
              ...getEnvironmentVariables(),
              DD_CIVISIBILITY_ENABLED: "false",
              DD_TRACE_ENABLED: "false",
              DD_TEST_FAILED_TEST_REPLAY_ENABLED: "false",
              DD_CIVISIBILITY_MANUAL_API_ENABLED: "false",
              DD_TRACING_ENABLED: "false",
              DD_INSTRUMENTATION_TELEMETRY_ENABLED: "false"
            },
            workerData: {
              config: getDebuggerConfig(this._config),
              parentThreadId,
              probePort: probeChannel.port1,
              configPort: configChannel.port1,
              breakpointSetChannel: this.breakpointSetChannel.port1,
              breakpointHitChannel: this.breakpointHitChannel.port1,
              breakpointRemoveChannel: this.breakpointRemoveChannel.port1
            },
            transferList: [
              probeChannel.port1,
              configChannel.port1,
              this.breakpointSetChannel.port1,
              this.breakpointHitChannel.port1,
              this.breakpointRemoveChannel.port1
            ]
          }
        );
        this.worker.on("online", () => {
          log.debug("Test Visibility - Dynamic Instrumentation client is ready");
          this._onReady();
        });
        this.worker.on("error", (err) => {
          log.error("Test Visibility - Dynamic Instrumentation worker error", err);
        });
        this.worker.on("messageerror", (err) => {
          log.error("Test Visibility - Dynamic Instrumentation worker messageerror", err);
        });
        this.worker.unref();
        this.breakpointSetChannel.port2.on("message", (probeId) => {
          const resolve = probeIdToResolveBreakpointSet.get(probeId);
          if (resolve) {
            resolve();
            probeIdToResolveBreakpointSet.delete(probeId);
          }
        }).unref();
        this.breakpointHitChannel.port2.on("message", ({ snapshot }) => {
          const { probe: { id: probeId } } = snapshot;
          const onHit = this.onHitBreakpointByProbeId.get(probeId);
          if (onHit) {
            onHit({ snapshot });
          } else {
            log.warn("Received a breakpoint hit for an unknown probe");
          }
        }).unref();
        this.breakpointRemoveChannel.port2.on("message", (probeId) => {
          const resolve = probeIdToResolveBreakpointRemove.get(probeId);
          if (resolve) {
            resolve();
            probeIdToResolveBreakpointRemove.delete(probeId);
          }
        }).unref();
      }
    };
    var dynamicInstrumentation;
    module2.exports = function createAndGetTestVisDynamicInstrumentation(config) {
      if (dynamicInstrumentation) {
        return dynamicInstrumentation;
      }
      dynamicInstrumentation = new TestVisDynamicInstrumentation(config);
      return dynamicInstrumentation;
    };
  }
});

// ../../packages/dd-trace/src/plugins/ci_plugin.js
var require_ci_plugin = __commonJS({
  "../../packages/dd-trace/src/plugins/ci_plugin.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var {
      getTestEnvironmentMetadata,
      getTestSessionName,
      getCodeOwnersFileEntries,
      getTestParentSpan,
      getTestCommonTags,
      getCodeOwnersForFilename,
      TEST_CODE_OWNERS,
      CI_APP_ORIGIN,
      getTestSessionCommonTags,
      getTestModuleCommonTags,
      TEST_SUITE_ID,
      TEST_MODULE_ID,
      TEST_SESSION_ID,
      TEST_COMMAND,
      TEST_MODULE,
      TEST_SESSION_NAME,
      getTestSuiteCommonTags,
      TEST_STATUS,
      TEST_SKIPPED_BY_ITR,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_LEVEL_EVENT_TYPES,
      TEST_SUITE,
      getFileAndLineNumberFromError,
      DI_ERROR_DEBUG_INFO_CAPTURED,
      DI_DEBUG_ERROR_PREFIX,
      DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX,
      DI_DEBUG_ERROR_FILE_SUFFIX,
      DI_DEBUG_ERROR_LINE_SUFFIX,
      getLibraryCapabilitiesTags,
      getPullRequestDiff,
      getModifiedFilesFromDiff,
      getPullRequestBaseBranch
    } = require_test();
    var { getRepositoryRoot } = require_git();
    var Plugin = require_plugin();
    var { COMPONENT } = require_constants3();
    var log = require_log2();
    var {
      incrementCountMetric,
      distributionMetric,
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_ITR_SKIPPED
    } = require_telemetry();
    var {
      CI_PROVIDER_NAME,
      GIT_REPOSITORY_URL,
      GIT_COMMIT_SHA,
      GIT_BRANCH,
      CI_WORKSPACE_PATH,
      GIT_COMMIT_MESSAGE,
      GIT_TAG,
      GIT_PULL_REQUEST_BASE_BRANCH_SHA,
      GIT_COMMIT_HEAD_SHA,
      GIT_PULL_REQUEST_BASE_BRANCH,
      GIT_COMMIT_HEAD_MESSAGE
    } = require_tags2();
    var { OS_VERSION, OS_PLATFORM, OS_ARCHITECTURE, RUNTIME_NAME, RUNTIME_VERSION } = require_env();
    var getDiClient = require_dynamic_instrumentation();
    var { DD_MAJOR } = require_version2();
    var id = require_id();
    var FRAMEWORK_TO_TRIMMED_COMMAND = {
      vitest: "vitest run",
      mocha: "mocha",
      cucumber: "cucumber-js",
      playwright: "playwright test",
      jest: "jest"
    };
    var WORKER_EXPORTER_TO_TEST_FRAMEWORK = {
      vitest_worker: "vitest",
      jest_worker: "jest",
      cucumber_worker: "cucumber",
      mocha_worker: "mocha",
      playwright_worker: "playwright"
    };
    var TEST_FRAMEWORKS_TO_SKIP_GIT_METADATA_EXTRACTION = /* @__PURE__ */ new Set([
      "vitest",
      "jest",
      "mocha",
      "cucumber"
    ]);
    function getTestSuiteLevelVisibilityTags(testSuiteSpan, testFramework) {
      const testSuiteSpanContext = testSuiteSpan.context();
      const suiteTags = {
        [TEST_SUITE_ID]: testSuiteSpanContext.toSpanId(),
        [TEST_SESSION_ID]: testSuiteSpanContext.toTraceId(),
        [TEST_COMMAND]: testSuiteSpanContext._tags[TEST_COMMAND],
        [TEST_MODULE]: testFramework
      };
      if (testSuiteSpanContext._parentId) {
        suiteTags[TEST_MODULE_ID] = testSuiteSpanContext._parentId.toString(10);
      }
      return suiteTags;
    }
    module2.exports = class CiPlugin extends Plugin {
      constructor(...args) {
        super(...args);
        this.fileLineToProbeId = /* @__PURE__ */ new Map();
        this.rootDir = process.cwd();
        this._testSuiteSpansByTestSuite = /* @__PURE__ */ new Map();
        this.addSub(`ci:${this.constructor.id}:library-configuration`, (ctx) => {
          const { onDone, isParallel, frameworkVersion } = ctx;
          ctx.currentStore = storage("legacy").getStore();
          if (!this.tracer._exporter || !this.tracer._exporter.getLibraryConfiguration) {
            return onDone({ err: new Error("Test optimization was not initialized correctly") });
          }
          this.tracer._exporter.getLibraryConfiguration(this.testConfiguration, (err, libraryConfig) => {
            if (err) {
              log.error("Library configuration could not be fetched. %s", err.message);
            } else {
              this.libraryConfig = libraryConfig;
            }
            const libraryCapabilitiesTags = getLibraryCapabilitiesTags(this.constructor.id, isParallel, frameworkVersion);
            const metadataTags = {
              test: {
                ...libraryCapabilitiesTags
              }
            };
            this.tracer._exporter.addMetadataTags(metadataTags);
            onDone({ err, libraryConfig });
          });
        });
        this.addBind(`ci:${this.constructor.id}:test-suite:skippable`, (ctx) => {
          return ctx.currentStore;
        });
        this.addSub(`ci:${this.constructor.id}:test-suite:skippable`, ({ onDone }) => {
          if (!this.tracer._exporter?.getSkippableSuites) {
            return onDone({ err: new Error("Test optimization was not initialized correctly") });
          }
          this.tracer._exporter.getSkippableSuites(this.testConfiguration, (err, skippableSuites, itrCorrelationId) => {
            if (err) {
              log.error("Skippable suites could not be fetched. %s", err.message);
            } else {
              this.itrCorrelationId = itrCorrelationId;
            }
            onDone({ err, skippableSuites, itrCorrelationId });
          });
        });
        this.addSub(`ci:${this.constructor.id}:session:start`, ({ command, frameworkVersion, rootDir }) => {
          const childOf = getTestParentSpan(this.tracer);
          const testSessionSpanMetadata = getTestSessionCommonTags(command, frameworkVersion, this.constructor.id);
          const testModuleSpanMetadata = getTestModuleCommonTags(command, frameworkVersion, this.constructor.id);
          this.command = command;
          this.frameworkVersion = frameworkVersion;
          this.rootDir = rootDir;
          const testSessionName = getTestSessionName(
            this.config,
            DD_MAJOR < 6 ? this.command : FRAMEWORK_TO_TRIMMED_COMMAND[this.constructor.id],
            this.testEnvironmentMetadata
          );
          const metadataTags = {};
          for (const testLevel of TEST_LEVEL_EVENT_TYPES) {
            metadataTags[testLevel] = {
              [TEST_SESSION_NAME]: testSessionName
            };
          }
          if (this.tracer._exporter.addMetadataTags) {
            this.tracer._exporter.addMetadataTags(metadataTags);
          }
          this.testSessionSpan = this.tracer.startSpan(`${this.constructor.id}.test_session`, {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSessionSpanMetadata
            },
            integrationName: this.constructor.id
          });
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "session");
          this.testModuleSpan = this.tracer.startSpan(`${this.constructor.id}.test_module`, {
            childOf: this.testSessionSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testModuleSpanMetadata
            },
            integrationName: this.constructor.id
          });
          if (this.constructor.id === "vitest") {
            process.env.DD_CIVISIBILITY_TEST_SESSION_ID = this.testSessionSpan.context().toTraceId();
            process.env.DD_CIVISIBILITY_TEST_MODULE_ID = this.testModuleSpan.context().toSpanId();
            process.env.DD_CIVISIBILITY_TEST_COMMAND = this.command;
          }
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "module");
        });
        this.addSub(`ci:${this.constructor.id}:itr:skipped-suites`, ({ skippedSuites, frameworkVersion }) => {
          const testCommand = this.testSessionSpan.context()._tags[TEST_COMMAND];
          skippedSuites.forEach((testSuite) => {
            const testSuiteMetadata = getTestSuiteCommonTags(testCommand, frameworkVersion, testSuite, this.constructor.id);
            if (this.itrCorrelationId) {
              testSuiteMetadata[ITR_CORRELATION_ID] = this.itrCorrelationId;
            }
            this.tracer.startSpan(`${this.constructor.id}.test_suite`, {
              childOf: this.testModuleSpan,
              tags: {
                [COMPONENT]: this.constructor.id,
                ...this.testEnvironmentMetadata,
                ...testSuiteMetadata,
                [TEST_STATUS]: "skip",
                [TEST_SKIPPED_BY_ITR]: "true"
              },
              integrationName: this.constructor.id
            }).finish();
          });
          this.telemetry.count(TELEMETRY_ITR_SKIPPED, { testLevel: "suite" }, skippedSuites.length);
        });
        this.addBind(`ci:${this.constructor.id}:known-tests`, (ctx) => {
          return ctx.currentStore;
        });
        this.addSub(`ci:${this.constructor.id}:known-tests`, ({ onDone }) => {
          if (!this.tracer._exporter?.getKnownTests) {
            return onDone({ err: new Error("Test optimization was not initialized correctly") });
          }
          this.tracer._exporter.getKnownTests(this.testConfiguration, (err, knownTests) => {
            if (err) {
              log.error("Known tests could not be fetched. %s", err.message);
              this.libraryConfig.isEarlyFlakeDetectionEnabled = false;
              this.libraryConfig.isKnownTestsEnabled = false;
            }
            onDone({ err, knownTests });
          });
        });
        this.addBind(`ci:${this.constructor.id}:test-management-tests`, (ctx) => {
          return ctx.currentStore;
        });
        this.addSub(`ci:${this.constructor.id}:test-management-tests`, ({ onDone }) => {
          if (!this.tracer._exporter?.getTestManagementTests) {
            return onDone({ err: new Error("Test optimization was not initialized correctly") });
          }
          this.tracer._exporter.getTestManagementTests(this.testConfiguration, (err, testManagementTests) => {
            if (err) {
              log.error("Test management tests could not be fetched. %s", err.message);
              this.libraryConfig.isTestManagementEnabled = false;
            }
            onDone({ err, testManagementTests });
          });
        });
        this.addBind(`ci:${this.constructor.id}:modified-files`, (ctx) => {
          return ctx.currentStore;
        });
        this.addSub(`ci:${this.constructor.id}:modified-files`, ({ onDone }) => {
          const {
            [GIT_PULL_REQUEST_BASE_BRANCH]: pullRequestBaseBranch,
            [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: pullRequestBaseBranchSha,
            [GIT_COMMIT_HEAD_SHA]: commitHeadSha
          } = this.testEnvironmentMetadata;
          const baseBranchSha = pullRequestBaseBranchSha || getPullRequestBaseBranch(pullRequestBaseBranch);
          if (baseBranchSha) {
            const diff = getPullRequestDiff(baseBranchSha, commitHeadSha);
            const modifiedFiles = getModifiedFilesFromDiff(diff);
            if (modifiedFiles) {
              return onDone({ err: null, modifiedFiles });
            }
          }
          return onDone({ err: new Error("No modified tests could have been retrieved") });
        });
        this.addSub(`ci:${this.constructor.id}:worker-report:trace`, (traces) => {
          const formattedTraces = JSON.parse(traces);
          for (const trace2 of formattedTraces) {
            for (const span of trace2) {
              span.span_id = id(span.span_id);
              span.trace_id = id(span.trace_id);
              span.parent_id = id(span.parent_id);
              if (span.name?.startsWith(`${this.constructor.id}.`)) {
                for (const key in this.testEnvironmentMetadata) {
                  if (key.startsWith("git.")) {
                    span.meta[key] = this.testEnvironmentMetadata[key];
                  }
                }
              }
              if (span.name === "cucumber.test" || span.name === "mocha.test") {
                const testSuite = span.meta[TEST_SUITE];
                const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite);
                if (!testSuiteSpan) {
                  log.warn(`Test suite span not found for test span with test suite ${testSuite}`);
                  continue;
                }
                const testSuiteTags = getTestSuiteLevelVisibilityTags(testSuiteSpan, this.constructor.id);
                span.meta = {
                  ...span.meta,
                  ...testSuiteTags
                };
              }
            }
            this.tracer._exporter.export(trace2);
          }
        });
        this.addSub(`ci:${this.constructor.id}:worker-report:logs`, (logsPayloads) => {
          JSON.parse(logsPayloads).forEach(({ logMessage }) => {
            this.tracer._exporter.exportDiLogs(this.testEnvironmentMetadata, logMessage);
          });
        });
      }
      get telemetry() {
        const testFramework = this.constructor.id;
        return {
          ciVisEvent: function(name, testLevel, tags = {}) {
            incrementCountMetric(name, {
              testLevel,
              testFramework,
              isUnsupportedCIProvider: !this.ciProviderName,
              ...tags
            });
          },
          count: function(name, tags, value = 1) {
            incrementCountMetric(name, tags, value);
          },
          distribution: function(name, tags, measure) {
            distributionMetric(name, tags, measure);
          }
        };
      }
      configure(config, shouldGetEnvironmentData = true) {
        super.configure(config);
        if (!shouldGetEnvironmentData) {
          return;
        }
        if (config.isTestDynamicInstrumentationEnabled && !this.di) {
          this.di = getDiClient();
        }
        if (this.testConfiguration) {
          return;
        }
        const exporter = this.config.experimental?.exporter;
        const workerTestFramework = WORKER_EXPORTER_TO_TEST_FRAMEWORK[exporter];
        this.shouldSkipGitMetadataExtraction = workerTestFramework && TEST_FRAMEWORKS_TO_SKIP_GIT_METADATA_EXTRACTION.has(workerTestFramework);
        this.testEnvironmentMetadata = getTestEnvironmentMetadata(
          this.constructor.id,
          this.config,
          this.shouldSkipGitMetadataExtraction
        );
        const {
          [GIT_REPOSITORY_URL]: repositoryUrl,
          [GIT_COMMIT_SHA]: sha,
          [OS_VERSION]: osVersion,
          [OS_PLATFORM]: osPlatform,
          [OS_ARCHITECTURE]: osArchitecture,
          [RUNTIME_NAME]: runtimeName,
          [RUNTIME_VERSION]: runtimeVersion,
          [GIT_BRANCH]: branch,
          [CI_PROVIDER_NAME]: ciProviderName,
          [CI_WORKSPACE_PATH]: repositoryRoot,
          [GIT_COMMIT_MESSAGE]: commitMessage,
          [GIT_TAG]: tag,
          [GIT_PULL_REQUEST_BASE_BRANCH_SHA]: pullRequestBaseSha,
          [GIT_COMMIT_HEAD_SHA]: commitHeadSha,
          [GIT_COMMIT_HEAD_MESSAGE]: commitHeadMessage
        } = this.testEnvironmentMetadata;
        this.repositoryRoot = repositoryRoot || getRepositoryRoot() || process.cwd();
        this.codeOwnersEntries = getCodeOwnersFileEntries(this.repositoryRoot);
        this.ciProviderName = ciProviderName;
        this.testConfiguration = {
          repositoryUrl,
          sha,
          osVersion,
          osPlatform,
          osArchitecture,
          runtimeName,
          runtimeVersion,
          branch,
          testLevel: "suite",
          commitMessage,
          tag,
          pullRequestBaseSha,
          commitHeadSha,
          commitHeadMessage
        };
      }
      getCodeOwners(tags) {
        const {
          [TEST_SOURCE_FILE]: testSourceFile,
          [TEST_SUITE]: testSuite
        } = tags;
        let codeOwners = getCodeOwnersForFilename(testSourceFile, this.codeOwnersEntries);
        if (!codeOwners) {
          codeOwners = getCodeOwnersForFilename(testSuite, this.codeOwnersEntries);
        }
        return codeOwners;
      }
      startTestSpan(testName, testSuite, testSuiteSpan, extraTags = {}) {
        const childOf = getTestParentSpan(this.tracer);
        let testTags = {
          ...getTestCommonTags(
            testName,
            testSuite,
            this.frameworkVersion,
            this.constructor.id
          ),
          [COMPONENT]: this.constructor.id,
          ...extraTags
        };
        const codeOwners = this.getCodeOwners(testTags);
        if (codeOwners) {
          testTags[TEST_CODE_OWNERS] = codeOwners;
        }
        if (testSuiteSpan) {
          childOf._trace.startTime = testSuiteSpan.context()._trace.startTime;
          childOf._trace.ticks = testSuiteSpan.context()._trace.ticks;
          const suiteTags = {
            [TEST_SUITE_ID]: testSuiteSpan.context().toSpanId(),
            [TEST_SESSION_ID]: testSuiteSpan.context().toTraceId(),
            [TEST_COMMAND]: testSuiteSpan.context()._tags[TEST_COMMAND],
            [TEST_MODULE]: this.constructor.id
          };
          if (testSuiteSpan.context()._parentId) {
            suiteTags[TEST_MODULE_ID] = testSuiteSpan.context()._parentId.toString(10);
          }
          testTags = {
            ...testTags,
            ...suiteTags
          };
        }
        this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "test", { hasCodeOwners: !!codeOwners });
        const testSpan = this.tracer.startSpan(`${this.constructor.id}.test`, {
          childOf,
          tags: {
            ...this.testEnvironmentMetadata,
            ...testTags
          },
          integrationName: this.constructor.id
        });
        testSpan.context()._trace.origin = CI_APP_ORIGIN;
        return testSpan;
      }
      onDiBreakpointHit({ snapshot }) {
        if (!this.activeTestSpan || this.activeTestSpan.context()._isFinished) {
          log.warn("Breakpoint snapshot could not be attached to the active test span");
          return;
        }
        const stackIndex = this.testErrorStackIndex;
        this.activeTestSpan.setTag(DI_ERROR_DEBUG_INFO_CAPTURED, "true");
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_SNAPSHOT_ID_SUFFIX}`,
          snapshot.id
        );
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_FILE_SUFFIX}`,
          snapshot.probe.location.file
        );
        this.activeTestSpan.setTag(
          `${DI_DEBUG_ERROR_PREFIX}.${stackIndex}.${DI_DEBUG_ERROR_LINE_SUFFIX}`,
          Number(snapshot.probe.location.lines[0])
        );
        const activeTestSpanContext = this.activeTestSpan.context();
        this.tracer._exporter.exportDiLogs(this.testEnvironmentMetadata, {
          debugger: { snapshot },
          dd: {
            trace_id: activeTestSpanContext.toTraceId(),
            span_id: activeTestSpanContext.toSpanId()
          }
        });
      }
      removeAllDiProbes() {
        if (this.fileLineToProbeId.size === 0) {
          return Promise.resolve();
        }
        log.debug("Removing all Dynamic Instrumentation probes");
        const promises = [];
        for (const fileLine of this.fileLineToProbeId.keys()) {
          const [file, line] = fileLine.split(":");
          promises.push(this.removeDiProbe({ file, line }));
        }
        return Promise.all(promises);
      }
      removeDiProbe({ file, line }) {
        const probeId = this.fileLineToProbeId.get(`${file}:${line}`);
        log.warn("Removing probe from %s:%s, with id: %s", file, line, probeId);
        this.fileLineToProbeId.delete(probeId);
        return this.di.removeProbe(probeId);
      }
      addDiProbe(err) {
        if (!err?.stack) {
          log.warn("Can not add breakpoint if the test error does not have a stack");
          return;
        }
        const [file, line, stackIndex] = getFileAndLineNumberFromError(err, this.repositoryRoot);
        if (!file || !Number.isInteger(line)) {
          log.warn("Could not add breakpoint for dynamic instrumentation");
          return;
        }
        log.debug("Adding breakpoint for Dynamic Instrumentation");
        this.testErrorStackIndex = stackIndex;
        const activeProbeKey = `${file}:${line}`;
        if (this.fileLineToProbeId.has(activeProbeKey)) {
          log.warn("Probe already set for this line");
          const oldProbeId = this.fileLineToProbeId.get(activeProbeKey);
          return {
            probeId: oldProbeId,
            setProbePromise: Promise.resolve(),
            stackIndex,
            file,
            line
          };
        }
        const [probeId, setProbePromise] = this.di.addLineProbe({ file, line }, this.onDiBreakpointHit.bind(this));
        this.fileLineToProbeId.set(activeProbeKey, probeId);
        return {
          probeId,
          setProbePromise,
          stackIndex,
          file,
          line
        };
      }
    };
  }
});

// ../../packages/datadog-plugin-cucumber/src/index.js
var require_src8 = __commonJS({
  "../../packages/datadog-plugin-cucumber/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      TEST_SKIP_REASON,
      TEST_STATUS,
      TEST_SOURCE_START,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      CUCUMBER_IS_PARALLEL,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest,
      getTestEndLine
    } = require_test();
    var { RESOURCE_NAME } = require_tags();
    var { COMPONENT, ERROR_MESSAGE } = require_constants3();
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TELEMETRY_TEST_SESSION
    } = require_telemetry();
    var BREAKPOINT_HIT_GRACE_PERIOD_MS = 200;
    var BREAKPOINT_SET_GRACE_PERIOD_MS = 200;
    var isCucumberWorker = !!getEnvironmentVariable("CUCUMBER_WORKER_ID");
    var CucumberPlugin = class extends CiPlugin {
      static id = "cucumber";
      constructor(...args) {
        super(...args);
        this.sourceRoot = process.cwd();
        this.addSub("ci:cucumber:session:finish", ({
          status,
          isSuitesSkipped,
          numSkippedSuites,
          testCodeCoverageLinesTotal,
          hasUnskippableSuites,
          hasForcedToRunSuites,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          isParallel
        }) => {
          const { isSuitesSkippingEnabled, isCodeCoverageEnabled } = this.libraryConfig || {};
          addIntelligentTestRunnerSpanTags(
            this.testSessionSpan,
            this.testModuleSpan,
            {
              isSuitesSkipped,
              isSuitesSkippingEnabled,
              isCodeCoverageEnabled,
              testCodeCoverageLinesTotal,
              skippingCount: numSkippedSuites,
              skippingType: "suite",
              hasUnskippableSuites,
              hasForcedToRunSuites
            }
          );
          if (isEarlyFlakeDetectionEnabled) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, "true");
          }
          if (isEarlyFlakeDetectionFaulty) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, "faulty");
          }
          if (isParallel) {
            this.testSessionSpan.setTag(CUCUMBER_IS_PARALLEL, "true");
          }
          if (isTestManagementTestsEnabled) {
            this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, "true");
          }
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "module");
          this.testSessionSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "session");
          finishAllTraceSpans(this.testSessionSpan);
          this.telemetry.count(TELEMETRY_TEST_SESSION, {
            provider: this.ciProviderName,
            autoInjected: !!getEnvironmentVariable("DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER")
          });
          this.libraryConfig = null;
          this.tracer._exporter.flush();
        });
        this.addSub("ci:cucumber:test-suite:start", ({
          testFileAbsolutePath,
          isUnskippable,
          isForcedToRun,
          itrCorrelationId
        }) => {
          const testSuitePath = getTestSuitePath(testFileAbsolutePath, process.cwd());
          const testSourceFile = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot);
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            testSuitePath,
            "cucumber"
          );
          if (isUnskippable) {
            this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: "suite" });
            testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = "true";
          }
          if (isForcedToRun) {
            this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: "suite" });
            testSuiteMetadata[TEST_ITR_FORCED_RUN] = "true";
          }
          if (itrCorrelationId) {
            testSuiteMetadata[ITR_CORRELATION_ID] = itrCorrelationId;
          }
          if (testSourceFile) {
            testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile;
            testSuiteMetadata[TEST_SOURCE_START] = 1;
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata);
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners;
          }
          const testSuiteSpan = this.tracer.startSpan("cucumber.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            },
            integrationName: this.constructor.id
          });
          this._testSuiteSpansByTestSuite.set(testSuitePath, testSuiteSpan);
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "suite");
          if (this.libraryConfig?.isCodeCoverageEnabled) {
            this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, "suite", { library: "istanbul" });
          }
        });
        this.addSub("ci:cucumber:test-suite:finish", ({ status, testSuitePath }) => {
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuitePath);
          testSuiteSpan.setTag(TEST_STATUS, status);
          testSuiteSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "suite");
        });
        this.addSub("ci:cucumber:test-suite:code-coverage", ({ coverageFiles, suiteFile, testSuitePath }) => {
          if (!this.libraryConfig?.isCodeCoverageEnabled) {
            return;
          }
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY);
          }
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuitePath);
          const relativeCoverageFiles = [...coverageFiles, suiteFile].map((filename) => getTestSuitePath(filename, this.repositoryRoot));
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, relativeCoverageFiles.length);
          const formattedCoverage = {
            sessionId: testSuiteSpan.context()._traceId,
            suiteId: testSuiteSpan.context()._spanId,
            files: relativeCoverageFiles
          };
          this.tracer._exporter.exportCoverage(formattedCoverage);
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, "suite", { library: "istanbul" });
        });
        this.addBind("ci:cucumber:test:start", (ctx) => {
          const { testName, testFileAbsolutePath, testSourceLine, isParallel, promises } = ctx;
          const store = storage("legacy").getStore();
          const testSuite = getTestSuitePath(testFileAbsolutePath, this.sourceRoot);
          const testSourceFile = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot);
          const extraTags = {
            [TEST_SOURCE_START]: testSourceLine,
            [TEST_SOURCE_FILE]: testSourceFile
          };
          if (isParallel) {
            extraTags[CUCUMBER_IS_PARALLEL] = "true";
          }
          const span = this.startTestSpan(testName, testSuite, extraTags);
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          this.activeTestSpan = span;
          if (promises && this.runningTestProbe) {
            promises.hitBreakpointPromise = new Promise((resolve) => {
              setTimeout(resolve, BREAKPOINT_HIT_GRACE_PERIOD_MS);
            });
          }
          return ctx.currentStore;
        });
        this.addSub("ci:cucumber:test:retry", ({ span, isFirstAttempt, error, isAtrRetry }) => {
          if (!isFirstAttempt) {
            span.setTag(TEST_IS_RETRY, "true");
            if (isAtrRetry) {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
            } else {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext);
            }
          }
          span.setTag("error", error);
          if (isFirstAttempt && this.di && error && this.libraryConfig?.isDiEnabled) {
            const probeInformation = this.addDiProbe(error);
            if (probeInformation) {
              const { file, line, stackIndex } = probeInformation;
              this.runningTestProbe = { file, line };
              this.testErrorStackIndex = stackIndex;
              const waitUntil = Date.now() + BREAKPOINT_SET_GRACE_PERIOD_MS;
              while (Date.now() < waitUntil) {
              }
            }
          }
          span.setTag(TEST_STATUS, "fail");
          span.finish();
          finishAllTraceSpans(span);
        });
        this.addBind("ci:cucumber:test-step:start", (ctx) => {
          const { resource } = ctx;
          const store = storage("legacy").getStore();
          const childOf = store ? store.span : store;
          const span = this.tracer.startSpan("cucumber.step", {
            childOf,
            tags: {
              [COMPONENT]: this.constructor.id,
              "cucumber.step": resource,
              [RESOURCE_NAME]: resource
            },
            integrationName: this.constructor.id
          });
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          return ctx.currentStore;
        });
        this.addSub("ci:cucumber:test:finish", ({
          span,
          isStep,
          status,
          skipReason,
          error,
          errorMessage,
          isNew,
          isEfdRetry,
          isFlakyRetry,
          isAttemptToFix,
          isAttemptToFixRetry,
          hasFailedAllRetries,
          hasPassedAllRetries,
          hasFailedAttemptToFix,
          isDisabled,
          isQuarantined,
          isModified
        }) => {
          const statusTag = isStep ? "step.status" : TEST_STATUS;
          span.setTag(statusTag, status);
          if (isNew) {
            span.setTag(TEST_IS_NEW, "true");
            if (isEfdRetry) {
              span.setTag(TEST_IS_RETRY, "true");
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd);
            }
          }
          if (skipReason) {
            span.setTag(TEST_SKIP_REASON, skipReason);
          }
          if (error) {
            span.setTag("error", error);
          } else if (errorMessage) {
            span.setTag(ERROR_MESSAGE, errorMessage);
          }
          if (isFlakyRetry > 0) {
            span.setTag(TEST_IS_RETRY, "true");
            span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
          }
          if (hasFailedAllRetries) {
            span.setTag(TEST_HAS_FAILED_ALL_RETRIES, "true");
          }
          if (isAttemptToFix) {
            span.setTag(TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX, "true");
          }
          if (isAttemptToFixRetry) {
            span.setTag(TEST_IS_RETRY, "true");
            span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf);
            if (hasPassedAllRetries) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "true");
            } else if (hasFailedAttemptToFix) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
            }
          }
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, "true");
          }
          if (isQuarantined) {
            span.setTag(TEST_MANAGEMENT_IS_QUARANTINED, "true");
          }
          if (isModified) {
            span.setTag(TEST_IS_MODIFIED, "true");
            if (isEfdRetry) {
              span.setTag(TEST_IS_RETRY, "true");
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd);
            }
          }
          span.finish();
          if (!isStep) {
            const spanTags = span.context()._tags;
            this.telemetry.ciVisEvent(
              TELEMETRY_EVENT_FINISHED,
              "test",
              {
                hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
                isNew,
                isRum: spanTags[TEST_IS_RUM_ACTIVE] === "true",
                browserDriver: spanTags[TEST_BROWSER_DRIVER]
              }
            );
            finishAllTraceSpans(span);
            if (isCucumberWorker) {
              this.tracer._exporter.flush();
            }
            this.activeTestSpan = null;
            if (this.runningTestProbe) {
              this.removeDiProbe(this.runningTestProbe);
              this.runningTestProbe = null;
            }
          }
        });
        this.addBind("ci:cucumber:error", (ctx) => {
          const { err } = ctx;
          if (err) {
            const span = ctx.currentStore.span;
            span.setTag("error", err);
            ctx.parentStore = ctx.currentStore;
            ctx.currentStore = { ...ctx.currentStore, span };
          }
          return ctx.currentStore;
        });
        this.addBind("ci:cucumber:test:fn", (ctx) => {
          return ctx.currentStore;
        });
        this.addSub("ci:cucumber:is-modified-test", ({
          scenarios,
          testFileAbsolutePath,
          modifiedFiles,
          stepIds,
          stepDefinitions,
          setIsModified
        }) => {
          const testScenarioPath = getTestSuitePath(testFileAbsolutePath, this.repositoryRoot || process.cwd());
          for (const scenario of scenarios) {
            const isModified = isModifiedTest(
              testScenarioPath,
              scenario.location.line,
              scenario.steps[scenario.steps.length - 1].location.line,
              modifiedFiles,
              "cucumber"
            );
            if (isModified) {
              setIsModified(true);
              return;
            }
          }
          for (const stepDefinition of stepDefinitions) {
            if (!stepIds?.includes(stepDefinition.id)) {
              continue;
            }
            const testStartLineStep = stepDefinition.line;
            const testEndLineStep = getTestEndLine(stepDefinition.code, testStartLineStep);
            const isModified = isModifiedTest(
              stepDefinition.uri,
              testStartLineStep,
              testEndLineStep,
              modifiedFiles,
              "cucumber"
            );
            if (isModified) {
              setIsModified(true);
              return;
            }
          }
          setIsModified(false);
        });
      }
      startTestSpan(testName, testSuite, extraTags) {
        const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite);
        return super.startTestSpan(
          testName,
          testSuite,
          testSuiteSpan,
          extraTags
        );
      }
    };
    module2.exports = CucumberPlugin;
  }
});

// ../../packages/datadog-plugin-playwright/src/index.js
var require_src9 = __commonJS({
  "../../packages/datadog-plugin-playwright/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var id = require_id();
    var CiPlugin = require_ci_plugin();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      TEST_SOURCE_START,
      TEST_CODE_OWNERS,
      TEST_SOURCE_FILE,
      TEST_PARAMETERS,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TELEMETRY_TEST_SESSION,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_ENABLED,
      TEST_BROWSER_NAME,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_SESSION_ID,
      TEST_MODULE_ID,
      TEST_COMMAND,
      TEST_MODULE,
      TEST_SUITE,
      TEST_SUITE_ID,
      TEST_NAME,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_VERSION,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest
    } = require_test();
    var { RESOURCE_NAME } = require_tags();
    var { COMPONENT } = require_constants3();
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED
    } = require_telemetry();
    var { appClosing: appClosingTelemetry } = require_telemetry3();
    var PlaywrightPlugin = class extends CiPlugin {
      static id = "playwright";
      constructor(...args) {
        super(...args);
        this._testSuiteSpansByTestSuiteAbsolutePath = /* @__PURE__ */ new Map();
        this.numFailedTests = 0;
        this.numFailedSuites = 0;
        this.addSub("ci:playwright:test:is-modified", ({
          filePath,
          modifiedFiles,
          onDone
        }) => {
          const testSuite = getTestSuitePath(filePath, this.repositoryRoot);
          const isModified = isModifiedTest(testSuite, 0, 0, modifiedFiles, this.constructor.id);
          onDone({ isModified });
        });
        this.addSub("ci:playwright:session:finish", ({
          status,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onDone
        }) => {
          this.testModuleSpan.setTag(TEST_STATUS, status);
          this.testSessionSpan.setTag(TEST_STATUS, status);
          if (isEarlyFlakeDetectionEnabled) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, "true");
          }
          if (isEarlyFlakeDetectionFaulty) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, "faulty");
          }
          if (this.numFailedSuites > 0) {
            let errorMessage = `Test suites failed: ${this.numFailedSuites}.`;
            if (this.numFailedTests > 0) {
              errorMessage += ` Tests failed: ${this.numFailedTests}`;
            }
            const error = new Error(errorMessage);
            this.testModuleSpan.setTag("error", error);
            this.testSessionSpan.setTag("error", error);
          }
          if (isTestManagementTestsEnabled) {
            this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, "true");
          }
          this.testModuleSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "module");
          this.testSessionSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "session");
          finishAllTraceSpans(this.testSessionSpan);
          this.telemetry.count(TELEMETRY_TEST_SESSION, {
            provider: this.ciProviderName,
            autoInjected: !!getEnvironmentVariable("DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER")
          });
          appClosingTelemetry();
          this.tracer._exporter.flush(onDone);
          this.numFailedTests = 0;
        });
        this.addBind("ci:playwright:test-suite:start", (ctx) => {
          const { testSuiteAbsolutePath } = ctx;
          const store = storage("legacy").getStore();
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir);
          const testSourceFile = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            testSuite,
            "playwright"
          );
          if (testSourceFile) {
            testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile;
            testSuiteMetadata[TEST_SOURCE_START] = 1;
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata);
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners;
          }
          const testSuiteSpan = this.tracer.startSpan("playwright.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "suite");
          ctx.parentStore = store;
          ctx.currentStore = { ...store, testSuiteSpan };
          this._testSuiteSpansByTestSuiteAbsolutePath.set(testSuiteAbsolutePath, testSuiteSpan);
          return ctx.currentStore;
        });
        this.addSub("ci:playwright:test-suite:finish", ({ testSuiteSpan, status, error }) => {
          if (!testSuiteSpan) return;
          if (error) {
            testSuiteSpan.setTag("error", error);
            testSuiteSpan.setTag(TEST_STATUS, "fail");
          } else {
            testSuiteSpan.setTag(TEST_STATUS, status);
          }
          if (status === "fail" || error) {
            this.numFailedSuites++;
          }
          testSuiteSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "suite");
        });
        this.addSub("ci:playwright:test:page-goto", ({
          isRumActive,
          page
        }) => {
          const store = storage("legacy").getStore();
          const span = store && store.span;
          if (!span) return;
          if (isRumActive) {
            span.setTag(TEST_IS_RUM_ACTIVE, "true");
            if (page) {
              const browserVersion = page.context().browser().version();
              if (browserVersion) {
                span.setTag(TEST_BROWSER_VERSION, browserVersion);
              }
              const url = page.url();
              const domain = new URL(url).hostname;
              page.context().addCookies([{
                name: "datadog-ci-visibility-test-execution-id",
                value: span.context().toTraceId(),
                domain,
                path: "/"
              }]);
            }
          }
        });
        this.addBind("ci:playwright:test:start", (ctx) => {
          const {
            testName,
            testSuiteAbsolutePath,
            testSourceLine,
            browserName,
            isDisabled
          } = ctx;
          const store = storage("legacy").getStore();
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.rootDir);
          const testSourceFile = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const span = this.startTestSpan(
            testName,
            testSuiteAbsolutePath,
            testSuite,
            testSourceFile,
            testSourceLine,
            browserName
          );
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, "true");
          }
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          return ctx.currentStore;
        });
        this.addSub("ci:playwright:worker:report", (serializedTraces) => {
          const traces = JSON.parse(serializedTraces);
          const formattedTraces = [];
          for (const trace2 of traces) {
            const formattedTrace = [];
            for (const span of trace2) {
              const formattedSpan = {
                ...span,
                span_id: id(span.span_id),
                trace_id: id(span.trace_id),
                parent_id: id(span.parent_id)
              };
              if (span.name === "playwright.test") {
                formattedSpan.meta[TEST_SESSION_ID] = this.testSessionSpan.context().toTraceId();
                formattedSpan.meta[TEST_MODULE_ID] = this.testModuleSpan.context().toSpanId();
                formattedSpan.meta[TEST_COMMAND] = this.command;
                formattedSpan.meta[TEST_MODULE] = this.constructor.id;
                const testSuite = this._testSuiteSpansByTestSuiteAbsolutePath.get(
                  formattedSpan.meta.test_suite_absolute_path
                );
                if (testSuite) {
                  formattedSpan.meta[TEST_SUITE_ID] = testSuite.context().toSpanId();
                }
                const testSuitePath = getTestSuitePath(formattedSpan.meta.test_suite_absolute_path, this.rootDir);
                const testSourceFile = getTestSuitePath(formattedSpan.meta.test_suite_absolute_path, this.repositoryRoot);
                formattedSpan.meta[TEST_SUITE] = testSuitePath;
                formattedSpan.meta[TEST_SOURCE_FILE] = testSourceFile;
                formattedSpan.resource = `${testSuitePath}.${formattedSpan.meta[TEST_NAME]}`;
                delete formattedSpan.meta.test_suite_absolute_path;
              }
              formattedTrace.push(formattedSpan);
            }
            formattedTraces.push(formattedTrace);
          }
          formattedTraces.forEach((trace2) => {
            this.tracer._exporter.export(trace2);
          });
        });
        this.addSub("ci:playwright:test:finish", ({
          span,
          testStatus,
          steps,
          error,
          extraTags,
          isNew,
          isEfdRetry,
          isRetry,
          isAttemptToFix,
          isDisabled,
          isQuarantined,
          isAttemptToFixRetry,
          hasFailedAllRetries,
          hasPassedAttemptToFixRetries,
          hasFailedAttemptToFixRetries,
          isAtrRetry,
          isModified,
          onDone
        }) => {
          if (!span) return;
          const isRUMActive = span.context()._tags[TEST_IS_RUM_ACTIVE];
          span.setTag(TEST_STATUS, testStatus);
          if (error) {
            span.setTag("error", error);
          }
          if (extraTags) {
            span.addTags(extraTags);
          }
          if (isNew) {
            span.setTag(TEST_IS_NEW, "true");
            if (isEfdRetry) {
              span.setTag(TEST_IS_RETRY, "true");
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd);
            }
          }
          if (isRetry) {
            span.setTag(TEST_IS_RETRY, "true");
            if (isAtrRetry) {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
            } else {
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext);
            }
          }
          if (hasFailedAllRetries) {
            span.setTag(TEST_HAS_FAILED_ALL_RETRIES, "true");
          }
          if (isAttemptToFix) {
            span.setTag(TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX, "true");
          }
          if (isAttemptToFixRetry) {
            span.setTag(TEST_IS_RETRY, "true");
            span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf);
          }
          if (hasPassedAttemptToFixRetries) {
            span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "true");
          } else if (hasFailedAttemptToFixRetries) {
            span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
          }
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, "true");
          }
          if (isQuarantined) {
            span.setTag(TEST_MANAGEMENT_IS_QUARANTINED, "true");
          }
          if (isModified) {
            span.setTag(TEST_IS_MODIFIED, "true");
            if (isEfdRetry) {
              span.setTag(TEST_IS_RETRY, "true");
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.efd);
            }
          }
          steps.forEach((step) => {
            const stepStartTime = step.startTime.getTime();
            const stepSpan = this.tracer.startSpan("playwright.step", {
              childOf: span,
              startTime: stepStartTime,
              tags: {
                [COMPONENT]: this.constructor.id,
                "playwright.step": step.title,
                [RESOURCE_NAME]: step.title
              }
            });
            if (step.error) {
              stepSpan.setTag("error", step.error);
            }
            let stepDuration = step.duration;
            if (stepDuration <= 0 || Number.isNaN(stepDuration)) {
              stepDuration = 0;
            }
            stepSpan.finish(stepStartTime + stepDuration);
          });
          if (testStatus === "fail") {
            this.numFailedTests++;
          }
          this.telemetry.ciVisEvent(
            TELEMETRY_EVENT_FINISHED,
            "test",
            {
              hasCodeOwners: !!span.context()._tags[TEST_CODE_OWNERS],
              isNew,
              isRum: isRUMActive,
              browserDriver: "playwright"
            }
          );
          span.finish();
          finishAllTraceSpans(span);
          if (getEnvironmentVariable("DD_PLAYWRIGHT_WORKER")) {
            this.tracer._exporter.flush(onDone);
          }
        });
      }
      // TODO: this runs both in worker and main process (main process: skipped tests that do not go through _runTest)
      startTestSpan(testName, testSuiteAbsolutePath, testSuite, testSourceFile, testSourceLine, browserName) {
        const testSuiteSpan = this._testSuiteSpansByTestSuiteAbsolutePath.get(testSuiteAbsolutePath);
        const extraTags = {
          [TEST_SOURCE_START]: testSourceLine
        };
        if (testSourceFile) {
          extraTags[TEST_SOURCE_FILE] = testSourceFile || testSuite;
        }
        if (browserName) {
          extraTags[TEST_PARAMETERS] = JSON.stringify({ arguments: { browser: browserName }, metadata: {} });
          extraTags[TEST_BROWSER_NAME] = browserName;
        }
        extraTags.test_suite_absolute_path = testSuiteAbsolutePath;
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags);
      }
    };
    module2.exports = PlaywrightPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/storage.js
var require_storage5 = __commonJS({
  "../../packages/dd-trace/src/plugins/storage.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var StoragePlugin = class extends ClientPlugin {
      static type = "storage";
      constructor(...args) {
        super(...args);
        this.system = this.constructor.system || this.component;
      }
      startSpan(name, options, ctx) {
        if (!options.service && this.system) {
          options.service = `${this.tracer._service}-${this.system}`;
        }
        return super.startSpan(name, options, ctx);
      }
    };
    module2.exports = StoragePlugin;
  }
});

// ../../packages/dd-trace/src/plugins/database.js
var require_database = __commonJS({
  "../../packages/dd-trace/src/plugins/database.js"(exports2, module2) {
    "use strict";
    var StoragePlugin = require_storage5();
    var { PEER_SERVICE_KEY, PEER_SERVICE_SOURCE_KEY } = require_constants3();
    var DatabasePlugin = class extends StoragePlugin {
      static operation = "query";
      static peerServicePrecursors = ["db.name"];
      constructor(...args) {
        super(...args);
        this.serviceTags = {
          dddbs: "",
          encodedDddbs: "",
          dde: "",
          encodedDde: "",
          ddps: "",
          encodedDdps: "",
          ddpv: "",
          encodedDdpv: ""
        };
      }
      encodingServiceTags(serviceTag, encodeATag, spanConfig) {
        if (serviceTag !== spanConfig) {
          this.serviceTags[serviceTag] = spanConfig;
          this.serviceTags[encodeATag] = encodeURIComponent(spanConfig);
        }
      }
      createDBMPropagationCommentService(serviceName, span) {
        this.encodingServiceTags("dddbs", "encodedDddbs", serviceName);
        this.encodingServiceTags("dde", "encodedDde", this.tracer._env);
        this.encodingServiceTags("ddps", "encodedDdps", this.tracer._service);
        this.encodingServiceTags("ddpv", "encodedDdpv", this.tracer._version);
        if (span.context()._tags["out.host"]) {
          this.encodingServiceTags("ddh", "encodedDdh", span._spanContext._tags["out.host"]);
        }
        if (span.context()._tags["db.name"]) {
          this.encodingServiceTags("dddb", "encodedDddb", span._spanContext._tags["db.name"]);
        }
        const { encodedDddb, encodedDddbs, encodedDde, encodedDdh, encodedDdps, encodedDdpv } = this.serviceTags;
        let dbmComment = `dddb='${encodedDddb}',dddbs='${encodedDddbs}',dde='${encodedDde}',ddh='${encodedDdh}',ddps='${encodedDdps}',ddpv='${encodedDdpv}'`;
        const peerData = this.getPeerService(span.context()._tags);
        if (peerData !== void 0 && peerData[PEER_SERVICE_SOURCE_KEY] === PEER_SERVICE_KEY) {
          this.encodingServiceTags("ddprs", "encodedDdprs", peerData[PEER_SERVICE_KEY]);
          const { encodedDdprs } = this.serviceTags;
          dbmComment += `,ddprs='${encodedDdprs}'`;
        }
        return dbmComment;
      }
      getDbmServiceName(span, tracerService) {
        if (this._tracerConfig.spanComputePeerService) {
          const peerData = this.getPeerService(span.context()._tags);
          return this.getPeerServiceRemap(peerData)[PEER_SERVICE_KEY] || tracerService;
        }
        return tracerService;
      }
      createDbmComment(span, serviceName, disableFullMode = false) {
        const mode = this.config.dbmPropagationMode;
        const dbmService = this.getDbmServiceName(span, serviceName);
        if (mode === "disabled") {
          return null;
        }
        const servicePropagation = this.createDBMPropagationCommentService(dbmService, span);
        if (disableFullMode || mode === "service") {
          return servicePropagation;
        } else if (mode === "full") {
          span.setTag("_dd.dbm_trace_injected", "true");
          const traceparent = span._spanContext.toTraceparent();
          return `${servicePropagation},traceparent='${traceparent}'`;
        }
      }
      injectDbmQuery(span, query, serviceName, disableFullMode = false) {
        const dbmTraceComment = this.createDbmComment(span, serviceName, disableFullMode);
        if (!dbmTraceComment) {
          return query;
        }
        return this.config.appendComment ? `${query} /*${dbmTraceComment}*/` : `/*${dbmTraceComment}*/ ${query}`;
      }
      maybeTruncate(query) {
        const maxLength = typeof this.config.truncate === "number" ? this.config.truncate : 5e3;
        if (this.config.truncate && query && query.length > maxLength) {
          query = `${query.slice(0, maxLength - 3)}...`;
        }
        return query;
      }
    };
    module2.exports = DatabasePlugin;
  }
});

// ../../packages/datadog-plugin-elasticsearch/src/index.js
var require_src10 = __commonJS({
  "../../packages/datadog-plugin-elasticsearch/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var ElasticsearchPlugin = class extends DatabasePlugin {
      static id = "elasticsearch";
      bindStart(ctx) {
        const { params } = ctx;
        const body = getBody(params.body || params.bulkBody);
        this.startSpan(this.operationName(), {
          service: this.serviceName({ pluginConfig: this.config }),
          resource: `${params.method} ${quantizePath(params.path)}`,
          type: "elasticsearch",
          kind: "client",
          meta: {
            "db.type": this.system,
            [`${this.system}.url`]: params.path,
            [`${this.system}.method`]: params.method,
            [`${this.system}.body`]: body,
            [`${this.system}.params`]: JSON.stringify(params.querystring || params.query)
          }
        }, ctx);
        return ctx.currentStore;
      }
      bindFinish(ctx) {
        const { params } = ctx;
        const span = this.activeSpan;
        this.config.hooks.query(span, params);
        super.finish(ctx);
        return ctx.parentStore;
      }
    };
    function getBody(body) {
      return body && JSON.stringify(body);
    }
    function quantizePath(path) {
      return path && path.replaceAll(/[0-9]+/g, "?");
    }
    module2.exports = ElasticsearchPlugin;
  }
});

// ../../packages/datadog-plugin-google-cloud-pubsub/src/producer.js
var require_producer4 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-pubsub/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var { DsmPathwayCodec, getHeadersSize } = require_datastreams();
    var GoogleCloudPubsubProducerPlugin = class extends ProducerPlugin {
      static id = "google-cloud-pubsub";
      static operation = "request";
      bindStart(ctx) {
        const { request: request2, api, projectId } = ctx;
        if (api !== "publish") return;
        const messages = request2.messages || [];
        const topic = request2.topic;
        const span = this.startSpan({
          // TODO: rename
          resource: `${api} ${topic}`,
          meta: {
            "gcloud.project_id": projectId,
            "pubsub.method": api,
            // TODO: remove
            "pubsub.topic": topic
          }
        }, ctx);
        for (const msg of messages) {
          if (!msg.attributes) {
            msg.attributes = {};
          }
          this.tracer.inject(span, "text_map", msg.attributes);
          if (this.config.dsmEnabled) {
            const payloadSize = getHeadersSize(msg);
            const dataStreamsContext = this.tracer.setCheckpoint(["direction:out", `topic:${topic}`, "type:google-pubsub"], span, payloadSize);
            DsmPathwayCodec.encode(dataStreamsContext, msg.attributes);
          }
        }
        return ctx.currentStore;
      }
    };
    module2.exports = GoogleCloudPubsubProducerPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/inbound.js
var require_inbound = __commonJS({
  "../../packages/dd-trace/src/plugins/inbound.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var InboundPlugin = class extends TracingPlugin {
      bindFinish(ctx) {
        return ctx.parentStore;
      }
    };
    module2.exports = InboundPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/consumer.js
var require_consumer = __commonJS({
  "../../packages/dd-trace/src/plugins/consumer.js"(exports2, module2) {
    "use strict";
    var InboundPlugin = require_inbound();
    var ConsumerPlugin = class extends InboundPlugin {
      static operation = "receive";
      static kind = "consumer";
      static type = "messaging";
      startSpan(options, enterOrCtx) {
        if (!options.service) {
          options.service = this.config.service || this.serviceName();
        }
        if (!options.kind) {
          options.kind = this.constructor.kind;
        }
        return super.startSpan(this.operationName(), options, enterOrCtx);
      }
    };
    module2.exports = ConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-google-cloud-pubsub/src/consumer.js
var require_consumer2 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-pubsub/src/consumer.js"(exports2, module2) {
    "use strict";
    var { getMessageSize } = require_datastreams();
    var ConsumerPlugin = require_consumer();
    var GoogleCloudPubsubConsumerPlugin = class extends ConsumerPlugin {
      static id = "google-cloud-pubsub";
      static operation = "receive";
      bindStart(ctx) {
        const { message } = ctx;
        const subscription = message._subscriber._subscription;
        const topic = subscription.metadata && subscription.metadata.topic;
        const childOf = this.tracer.extract("text_map", message.attributes) || null;
        const span = this.startSpan({
          childOf,
          resource: topic,
          type: "worker",
          meta: {
            "gcloud.project_id": subscription.pubsub.projectId,
            "pubsub.topic": topic
          },
          metrics: {
            "pubsub.ack": 0
          }
        }, ctx);
        if (this.config.dsmEnabled && message?.attributes) {
          const payloadSize = getMessageSize(message);
          this.tracer.decodeDataStreamsContext(message.attributes);
          this.tracer.setCheckpoint(["direction:in", `topic:${topic}`, "type:google-pubsub"], span, payloadSize);
        }
        return ctx.currentStore;
      }
      bindFinish(ctx) {
        const { message } = ctx;
        const span = ctx.currentStore.span;
        if (message?._handled) {
          span.setTag("pubsub.ack", 1);
        }
        super.finish();
        return ctx.parentStore;
      }
    };
    module2.exports = GoogleCloudPubsubConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-google-cloud-pubsub/src/client.js
var require_client6 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-pubsub/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var GoogleCloudPubsubClientPlugin = class extends ClientPlugin {
      static id = "google-cloud-pubsub";
      static type = "messaging";
      static operation = "request";
      start(ctx) {
        const { request: request2, api, projectId } = ctx;
        if (api === "publish") return;
        this.startSpan(this.operationName(), {
          service: this.config.service || this.serviceName(),
          resource: [api, request2.name].filter(Boolean).join(" "),
          kind: this.constructor.kind,
          meta: {
            "pubsub.method": api,
            "gcloud.project_id": projectId
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = GoogleCloudPubsubClientPlugin;
  }
});

// ../../packages/datadog-plugin-google-cloud-pubsub/src/index.js
var require_src11 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-pubsub/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer4();
    var ConsumerPlugin = require_consumer2();
    var ClientPlugin = require_client6();
    var CompositePlugin = require_composite2();
    var GoogleCloudPubsubPlugin = class extends CompositePlugin {
      static id = "google-cloud-pubsub";
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin
        };
      }
    };
    module2.exports = GoogleCloudPubsubPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/util/llm.js
var require_llm = __commonJS({
  "../../packages/dd-trace/src/plugins/util/llm.js"(exports2, module2) {
    "use strict";
    var Sampler = require_sampler2();
    var RE_NEWLINE = /\n/g;
    var RE_TAB = /\t/g;
    function normalize(text, limit = 128) {
      if (typeof text !== "string" || text.length === 0) return;
      if (text.length > limit) {
        return text.slice(0, limit) + "...";
      }
      text = text.replaceAll(RE_NEWLINE, String.raw`\n`).replaceAll(RE_TAB, String.raw`\t`);
      if (text.length > limit) {
        return text.slice(0, limit) + "...";
      }
      return text;
    }
    function isPromptCompletionSampled(sampler, span) {
      return sampler.isSampled(span);
    }
    module2.exports = function makeUtilities(integrationName, tracerConfig) {
      const integrationConfig = tracerConfig[integrationName] || {};
      const { spanCharLimit, spanPromptCompletionSampleRate } = integrationConfig;
      const sampler = new Sampler(spanPromptCompletionSampleRate ?? 1);
      return {
        normalize: (str) => normalize(str, spanCharLimit),
        /**
         * Determines whether a prompt completion should be sampled based on the configured sampling rate.
         *
         * @param {import('index').Span|import('index').SpanContext} span
         * @returns {boolean} `true` if the prompt completion should be sampled, otherwise `false`.
         */
        isPromptCompletionSampled: (span) => isPromptCompletionSampled(sampler, span)
      };
    };
  }
});

// ../../packages/datadog-plugin-google-cloud-vertexai/src/utils.js
var require_utils5 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-vertexai/src/utils.js"(exports2, module2) {
    "use strict";
    function extractModel(instance) {
      const model = instance.model || instance.resourcePath || instance.publisherModelEndpoint;
      return model?.split("/").pop();
    }
    function extractSystemInstructions(instance) {
      const systemInstruction = instance.systemInstruction;
      if (!systemInstruction) return [];
      if (typeof systemInstruction === "string") return [systemInstruction];
      return systemInstruction.parts?.map((part) => part.text);
    }
    module2.exports = {
      extractModel,
      extractSystemInstructions
    };
  }
});

// ../../packages/datadog-plugin-google-cloud-vertexai/src/tracing.js
var require_tracing4 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-vertexai/src/tracing.js"(exports2, module2) {
    "use strict";
    var { MEASURED } = require_tags();
    var { storage } = require_datadog_core();
    var TracingPlugin = require_tracing();
    var makeUtilities = require_llm();
    var {
      extractModel
    } = require_utils5();
    var GoogleCloudVertexAITracingPlugin = class extends TracingPlugin {
      static id = "google-cloud-vertexai";
      static prefix = "tracing:apm:vertexai:request";
      constructor() {
        super(...arguments);
        Object.assign(this, makeUtilities("vertexai", this._tracerConfig));
      }
      bindStart(ctx) {
        const { instance, resource } = ctx;
        const span = this.startSpan("vertexai.request", {
          service: this.config.service,
          resource,
          kind: "client",
          meta: {
            [MEASURED]: 1,
            "vertexai.request.model": extractModel(instance)
          }
        }, false);
        const store = storage("legacy").getStore() || {};
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span;
        if (!span) return;
        span.finish();
      }
    };
    module2.exports = GoogleCloudVertexAITracingPlugin;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/vertexai.js
var require_vertexai = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/vertexai.js"(exports2, module2) {
    "use strict";
    var LLMObsPlugin = require_base();
    var {
      extractModel,
      extractSystemInstructions
    } = require_utils5();
    var VertexAILLMObsPlugin = class extends LLMObsPlugin {
      static integration = "vertexai";
      // used for llmobs telemetry
      static id = "vertexai";
      static prefix = "tracing:apm:vertexai:request";
      getLLMObsSpanRegisterOptions(ctx) {
        const history = ctx.instance?.historyInternal || [];
        ctx.history = history;
        return {
          kind: "llm",
          modelName: extractModel(ctx.instance),
          modelProvider: "google",
          name: ctx.resource
        };
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span;
        if (!span) return;
        const { instance, result, request: request2 } = ctx;
        const history = ctx.history || [];
        const systemInstructions = extractSystemInstructions(instance);
        const metadata = getMetadata(instance);
        const inputMessages = extractInputMessages(request2, history, systemInstructions);
        const outputMessages = extractOutputMessages(result);
        const metrics2 = extractMetrics(result);
        this._tagger.tagLLMIO(span, inputMessages, outputMessages);
        this._tagger.tagMetadata(span, metadata);
        this._tagger.tagMetrics(span, metrics2);
      }
    };
    function getMetadata(instance) {
      const metadata = {};
      const modelConfig = instance.generationConfig;
      if (!modelConfig) return metadata;
      for (const [parameter, parameterKey] of [
        ["temperature", "temperature"],
        ["maxOutputTokens", "max_output_tokens"],
        ["candidateCount", "candidate_count"],
        ["topP", "top_p"],
        ["topK", "top_k"]
      ]) {
        if (modelConfig[parameter]) {
          metadata[parameterKey] = modelConfig[parameter];
        }
      }
      return metadata;
    }
    function extractInputMessages(request2, history, systemInstructions) {
      const contents = typeof request2 === "string" || Array.isArray(request2) ? request2 : request2.contents;
      const messages = [];
      if (systemInstructions) {
        for (const instruction of systemInstructions) {
          messages.push({ content: instruction || "", role: "system" });
        }
      }
      for (const content of history) {
        messages.push(...extractMessagesFromContent(content));
      }
      if (typeof contents === "string") {
        messages.push({ content: contents });
        return messages;
      }
      if (isPart(contents)) {
        messages.push(extractMessageFromPart(contents));
        return messages;
      }
      if (!Array.isArray(contents)) {
        messages.push({
          content: `[Non-array content object: ${typeof contents.toString === "function" ? contents.toString() : String(contents)}]`
        });
        return messages;
      }
      for (const content of contents) {
        if (typeof content === "string") {
          messages.push({ content });
          continue;
        }
        if (isPart(content)) {
          messages.push(extractMessageFromPart(content));
          continue;
        }
        messages.push(...extractMessagesFromContent(content));
      }
      return messages;
    }
    function extractOutputMessages(result) {
      if (!result) return [{ content: "" }];
      const { response } = result;
      if (!response) return [{ content: "" }];
      const outputMessages = [];
      const candidates = response.candidates || [];
      for (const candidate of candidates) {
        const content = candidate.content || "";
        outputMessages.push(...extractMessagesFromContent(content));
      }
      return outputMessages;
    }
    function extractMessagesFromContent(content) {
      const messages = [];
      const role = content.role || "";
      const parts = content.parts || [];
      if (parts == null || parts.length === 0 || !Array.isArray(parts)) {
        const message = {
          content: `[Non-text content object: ${typeof content.toString === "function" ? content.toString() : String(content)}]`
        };
        if (role) message.role = role;
        messages.push(message);
        return messages;
      }
      for (const part of parts) {
        const message = extractMessageFromPart(part, role);
        messages.push(message);
      }
      return messages;
    }
    function extractMessageFromPart(part, role) {
      const text = part.text || "";
      const functionCall = part.functionCall;
      const functionResponse = part.functionResponse;
      const message = { content: text };
      if (role) message.role = role;
      if (functionCall) {
        message.toolCalls = [{
          name: functionCall.name,
          arguments: functionCall.args
        }];
      }
      if (functionResponse) {
        message.content = `[tool result: ${functionResponse.response}]`;
      }
      return message;
    }
    function extractMetrics(result) {
      if (!result) return {};
      const { response } = result;
      if (!response) return {};
      const tokenCounts = response.usageMetadata;
      const metrics2 = {};
      if (tokenCounts) {
        metrics2.inputTokens = tokenCounts.promptTokenCount;
        metrics2.outputTokens = tokenCounts.candidatesTokenCount;
        metrics2.totalTokens = tokenCounts.totalTokenCount;
      }
      return metrics2;
    }
    function isPart(part) {
      return part.text || part.functionCall || part.functionResponse;
    }
    module2.exports = VertexAILLMObsPlugin;
  }
});

// ../../packages/datadog-plugin-google-cloud-vertexai/src/index.js
var require_src12 = __commonJS({
  "../../packages/datadog-plugin-google-cloud-vertexai/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var GoogleVertexAITracingPlugin = require_tracing4();
    var VertexAILLMObsPlugin = require_vertexai();
    var GoogleCloudVertexAIPlugin = class extends CompositePlugin {
      static id = "google-cloud-vertexai";
      static get plugins() {
        return {
          llmobs: VertexAILLMObsPlugin,
          tracing: GoogleVertexAITracingPlugin
        };
      }
    };
    module2.exports = GoogleCloudVertexAIPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/server.js
var require_server5 = __commonJS({
  "../../packages/dd-trace/src/plugins/server.js"(exports2, module2) {
    "use strict";
    var InboundPlugin = require_inbound();
    var ServerPlugin = class extends InboundPlugin {
      static operation = "request";
      static kind = "server";
      static type = "web";
      // a default that may eventually be overriden by nonweb servers
    };
    module2.exports = ServerPlugin;
  }
});

// ../../packages/datadog-plugin-grpc/src/util.js
var require_util7 = __commonJS({
  "../../packages/datadog-plugin-grpc/src/util.js"(exports2, module2) {
    "use strict";
    var pick = require_pick();
    var log = require_log2();
    module2.exports = {
      getMethodMetadata(path, kind) {
        const tags = {
          path,
          kind,
          name: "",
          service: "",
          package: ""
        };
        if (typeof path !== "string") return tags;
        const methodParts = path.split("/");
        if (methodParts.length > 2) {
          const serviceParts = methodParts[1].split(".");
          const name = methodParts[2];
          const service = serviceParts.pop();
          const pkg = serviceParts.join(".");
          tags.name = name;
          tags.service = service;
          tags.package = pkg;
        } else {
          tags.name = methodParts.at(-1);
        }
        return tags;
      },
      addMetadataTags(span, metadata, filter, type) {
        if (!metadata || typeof metadata.getMap !== "function") return;
        const values = filter(metadata.getMap());
        for (const key in values) {
          span.setTag(`grpc.${type}.metadata.${key}`, values[key]);
        }
      },
      // TODO: extract this to shared utils and add unit tests
      getFilter(config, filter) {
        if (typeof config[filter] === "function") {
          return config[filter];
        }
        if (Array.isArray(config[filter])) {
          return (element) => pick(element, config[filter]);
        }
        if (config.hasOwnProperty(filter)) {
          log.error("Expected '%s' to be an array or function.", filter);
        }
        return () => ({});
      }
    };
  }
});

// ../../packages/datadog-plugin-grpc/src/server.js
var require_server6 = __commonJS({
  "../../packages/datadog-plugin-grpc/src/server.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var ServerPlugin = require_server5();
    var { TEXT_MAP } = require_formats();
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util7();
    var GrpcServerPlugin = class extends ServerPlugin {
      static id = "grpc";
      static operation = "server:request";
      static prefix = "apm:grpc:server:request";
      constructor(...args) {
        super(...args);
        this.addTraceSub("update", ({ code }) => {
          const span = this.activeSpan;
          if (!span) return;
          this.addCode(span, code);
        });
        this.addTraceBind("emit", ({ currentStore }) => {
          return currentStore;
        });
      }
      bindStart(message) {
        const store = storage("legacy").getStore();
        const { name, metadata, type } = message;
        const metadataFilter = this.config.metadataFilter;
        const childOf = extract(this.tracer, metadata);
        const method = getMethodMetadata(name, type);
        const span = this.startSpan(this.operationName(), {
          childOf,
          service: this.config.service || this.serviceName(),
          resource: name,
          kind: "server",
          type: "web",
          meta: {
            component: "grpc",
            "grpc.method.kind": method.kind,
            "grpc.method.path": method.path,
            "grpc.method.name": method.name,
            "grpc.method.service": method.service,
            "grpc.method.package": method.package
          },
          metrics: {
            "grpc.status.code": 0
          }
        });
        addMetadataTags(span, metadata, metadataFilter, "request");
        message.span = span;
        message.parentStore = store;
        message.currentStore = { ...store, span };
        return message.currentStore;
      }
      bindAsyncStart({ parentStore }) {
        return parentStore;
      }
      error({ error }) {
        const span = this.activeSpan;
        if (!span) return;
        this.addCode(span, error.code);
        if (error.code && !this._tracerConfig.grpc.server.error.statuses.includes(error.code)) {
          return;
        }
        this.addError(error);
      }
      finish({ span, code, trailer }) {
        if (!span) return;
        const metadataFilter = this.config.metadataFilter;
        this.addCode(span, code);
        if (trailer && metadataFilter) {
          addMetadataTags(span, trailer, metadataFilter, "response");
        }
        span.finish();
      }
      configure(config) {
        const metadataFilter = getFilter(config, "metadata");
        return super.configure({ ...config, metadataFilter });
      }
      addCode(span, code) {
        if (code !== void 0) {
          span.setTag("grpc.status.code", code);
        }
      }
    };
    function extract(tracer2, metadata) {
      if (!metadata || typeof metadata.getMap !== "function") return null;
      return tracer2.extract(TEXT_MAP, metadata.getMap());
    }
    module2.exports = GrpcServerPlugin;
  }
});

// ../../packages/datadog-plugin-grpc/src/client.js
var require_client7 = __commonJS({
  "../../packages/datadog-plugin-grpc/src/client.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var ClientPlugin = require_client5();
    var { TEXT_MAP } = require_formats();
    var { addMetadataTags, getFilter, getMethodMetadata } = require_util7();
    var GrpcClientPlugin = class extends ClientPlugin {
      static id = "grpc";
      static operation = "client:request";
      static prefix = "apm:grpc:client:request";
      static peerServicePrecursors = ["rpc.service"];
      constructor(...args) {
        super(...args);
        this.addTraceBind("emit", ({ parentStore }) => {
          return parentStore;
        });
      }
      bindStart(message) {
        const store = storage("legacy").getStore();
        const { metadata, path, type } = message;
        const metadataFilter = this.config.metadataFilter;
        const method = getMethodMetadata(path, type);
        const span = this.startSpan(this.operationName(), {
          service: this.config.service || this.serviceName(),
          resource: path,
          kind: "client",
          type: "http",
          meta: {
            component: "grpc",
            "grpc.method.kind": method.kind,
            "grpc.method.path": method.path,
            "grpc.method.name": method.name,
            "grpc.method.service": method.service,
            "grpc.method.package": method.package
          },
          metrics: {
            "grpc.status.code": 0
          }
        }, false);
        if (method.service && method.package) {
          span.setTag("rpc.service", method.package + "." + method.service);
        }
        if (metadata) {
          addMetadataTags(span, metadata, metadataFilter, "request");
          inject(this.tracer, span, metadata);
        }
        message.span = span;
        message.parentStore = store;
        message.currentStore = { ...store, span };
        return message.currentStore;
      }
      bindAsyncStart({ parentStore }) {
        return parentStore;
      }
      error({ span = this.activeSpan, error }) {
        this.addCode(span, error.code);
        if (error.code && !this._tracerConfig.grpc.client.error.statuses.includes(error.code)) {
          return;
        }
        this.addError(error, span);
      }
      finish({ span, result, peer }) {
        if (!span) return;
        const { code, metadata } = result || {};
        const metadataFilter = this.config.metadataFilter;
        this.addCode(span, code);
        if (metadata && metadataFilter) {
          addMetadataTags(span, metadata, metadataFilter, "response");
        }
        if (peer) {
          const parts = peer.split(":");
          if (/^\d+/.test(parts.at(-1))) {
            const port = parts.at(-1);
            const ip = parts.slice(0, -1).join(":");
            span.setTag("network.destination.ip", ip);
            span.setTag("network.destination.port", port);
          } else {
            span.setTag("network.destination.ip", peer);
          }
        }
        this.tagPeerService(span);
        span.finish();
      }
      configure(config) {
        const metadataFilter = getFilter(config, "metadata");
        return super.configure({ ...config, metadataFilter });
      }
      addCode(span, code) {
        if (code !== void 0 && span) {
          span.setTag("grpc.status.code", code);
        }
      }
    };
    function inject(tracer2, span, metadata) {
      if (typeof metadata.set !== "function") return;
      const carrier = {};
      tracer2.inject(span, TEXT_MAP, carrier);
      for (const key in carrier) {
        metadata.set(key, carrier[key]);
      }
    }
    module2.exports = GrpcClientPlugin;
  }
});

// ../../packages/datadog-plugin-grpc/src/index.js
var require_src13 = __commonJS({
  "../../packages/datadog-plugin-grpc/src/index.js"(exports2, module2) {
    "use strict";
    var GrpcServerPlugin = require_server6();
    var GrpcClientPlugin = require_client7();
    var CompositePlugin = require_composite2();
    var GrpcPlugin = class extends CompositePlugin {
      static id = "grpc";
      static get plugins() {
        return {
          server: GrpcServerPlugin,
          client: GrpcClientPlugin
        };
      }
    };
    module2.exports = GrpcPlugin;
  }
});

// ../../packages/datadog-plugin-web/src/index.js
var require_src14 = __commonJS({
  "../../packages/datadog-plugin-web/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var web = require_web3();
    var WebPlugin = class extends Plugin {
      static id = "web";
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
      setFramework(req, name, config) {
        web.setFramework(req, name, config);
      }
    };
    module2.exports = WebPlugin;
  }
});

// ../../packages/datadog-plugin-router/src/index.js
var require_src15 = __commonJS({
  "../../packages/datadog-plugin-router/src/index.js"(exports2, module2) {
    "use strict";
    var web = require_web3();
    var WebPlugin = require_src14();
    var analyticsSampler = require_analytics_sampler();
    var { storage } = require_datadog_core();
    var { COMPONENT } = require_constants3();
    var RouterPlugin = class extends WebPlugin {
      static id = "router";
      constructor(...args) {
        super(...args);
        this._storeStack = [];
        this._contexts = /* @__PURE__ */ new WeakMap();
        this.addSub(`apm:${this.constructor.id}:middleware:enter`, ({ req, name, route }) => {
          const childOf = this._getActive(req) || this._getStoreSpan();
          if (!childOf) return;
          const span = this._getMiddlewareSpan(name, childOf);
          const context2 = this._createContext(req, route, childOf);
          if (childOf !== span) {
            context2.middleware.push(span);
          }
          const store = storage("legacy").getStore();
          this._storeStack.push(store);
          this.enter(span, store);
          web.patch(req);
          web.setRoute(req, context2.route);
        });
        this.addSub(`apm:${this.constructor.id}:middleware:next`, ({ req }) => {
          const context2 = this._contexts.get(req);
          if (!context2) return;
          context2.stack.pop();
        });
        this.addSub(`apm:${this.constructor.id}:middleware:finish`, ({ req }) => {
          const context2 = this._contexts.get(req);
          if (!context2 || context2.middleware.length === 0) return;
          context2.middleware.pop().finish();
        });
        this.addSub(`apm:${this.constructor.id}:middleware:exit`, ({ req }) => {
          const savedStore = this._storeStack.pop();
          const span = savedStore && savedStore.span;
          this.enter(span, savedStore);
        });
        this.addSub(`apm:${this.constructor.id}:middleware:error`, ({ req, error }) => {
          web.addError(req, error);
          if (!this.config.middleware) return;
          const span = this._getActive(req);
          if (!span) return;
          span.setTag("error", error);
        });
        this.addSub("apm:http:server:request:finish", ({ req }) => {
          const context2 = this._contexts.get(req);
          if (!context2) return;
          let span;
          while (span = context2.middleware.pop()) {
            span.finish();
          }
        });
      }
      _getActive(req) {
        const context2 = this._contexts.get(req);
        if (!context2) return;
        if (context2.middleware.length === 0) return context2.span;
        return context2.middleware.at(-1);
      }
      _getStoreSpan() {
        const store = storage("legacy").getStore();
        return store && store.span;
      }
      _getMiddlewareSpan(name, childOf) {
        if (this.config.middleware === false) {
          return childOf;
        }
        const span = this.tracer.startSpan(`${this.constructor.id}.middleware`, {
          childOf,
          integrationName: this.constructor.id,
          tags: {
            [COMPONENT]: this.constructor.id,
            "resource.name": name || "<anonymous>"
          }
        });
        analyticsSampler.sample(span, this.config.measured);
        return span;
      }
      _createContext(req, route, span) {
        let context2 = this._contexts.get(req);
        if (!route || route === "/" || route === "*") {
          route = "";
        }
        if (context2) {
          context2.stack.push(route);
          route = context2.stack.join("");
          if (isMoreSpecificThan(route, context2.route)) {
            context2.route = route;
          }
        } else {
          context2 = {
            span,
            stack: [route],
            route,
            middleware: []
          };
          this._contexts.set(req, context2);
        }
        return context2;
      }
    };
    function isMoreSpecificThan(routeA, routeB) {
      if (!routeIsRegex(routeA) && routeIsRegex(routeB)) {
        return true;
      }
      return routeA.length > routeB.length;
    }
    function routeIsRegex(route) {
      return route.includes("(/");
    }
    module2.exports = RouterPlugin;
  }
});

// ../../packages/datadog-plugin-hapi/src/index.js
var require_src16 = __commonJS({
  "../../packages/datadog-plugin-hapi/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var RouterPlugin = require_src15();
    var web = require_web3();
    var HapiPlugin = class extends RouterPlugin {
      static id = "hapi";
      constructor(...args) {
        super(...args);
        this._requestSpans = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:hapi:request:handle", ({ req }) => {
          const store = storage("legacy").getStore();
          const span = store && store.span;
          this.setFramework(req, "hapi", this.config);
          this._requestSpans.set(req, span);
        });
        this.addSub("apm:hapi:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
        this.addSub("apm:hapi:request:error", (error) => {
          if (!error || !error.isBoom || !this.config.validateStatus(error.output.statusCode)) {
            this.addError(error);
          }
        });
        this.addBind("apm:hapi:extension:start", ({ req }) => {
          return this._requestSpans.get(req);
        });
      }
    };
    module2.exports = HapiPlugin;
  }
});

// ../../packages/datadog-plugin-jest/src/index.js
var require_src17 = __commonJS({
  "../../packages/datadog-plugin-jest/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      TEST_STATUS,
      JEST_TEST_RUNNER,
      finishAllTraceSpans,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_PARAMETERS,
      TEST_COMMAND,
      TEST_FRAMEWORK_VERSION,
      TEST_SOURCE_START,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      JEST_DISPLAY_NAME,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      getFormattedError,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED
    } = require_test();
    var { COMPONENT } = require_constants3();
    var id = require_id();
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_TEST_SESSION
    } = require_telemetry();
    var log = require_log2();
    var isJestWorker = !!getEnvironmentVariable("JEST_WORKER_ID");
    var CHILD_MESSAGE_END = 2;
    function withTimeout(promise, timeoutMs) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeoutMs);
        promise.then(resolve);
      });
    }
    var JestPlugin = class extends CiPlugin {
      static id = "jest";
      // The lists are the same for every test suite, so we can cache them
      getUnskippableSuites(unskippableSuitesList) {
        if (!this.unskippableSuites) {
          this.unskippableSuites = JSON.parse(unskippableSuitesList);
        }
        return this.unskippableSuites;
      }
      getForcedToRunSuites(forcedToRunSuitesList) {
        if (!this.forcedToRunSuites) {
          this.forcedToRunSuites = JSON.parse(forcedToRunSuitesList);
        }
        return this.forcedToRunSuites;
      }
      constructor(...args) {
        super(...args);
        if (isJestWorker) {
          const handler = ([message]) => {
            if (message === CHILD_MESSAGE_END) {
              if (this.testSuiteSpan) {
                this.testSuiteSpan.finish();
                finishAllTraceSpans(this.testSuiteSpan);
              }
              this.tracer._exporter.flush();
              process.removeListener("message", handler);
            }
          };
          process.on("message", handler);
        }
        this.testSuiteSpanPerTestSuiteAbsolutePath = /* @__PURE__ */ new Map();
        this.addSub("ci:jest:session:finish", ({
          status,
          isSuitesSkipped,
          isSuitesSkippingEnabled,
          isCodeCoverageEnabled,
          testCodeCoverageLinesTotal,
          numSkippedSuites,
          hasUnskippableSuites,
          hasForcedToRunSuites,
          error,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onDone
        }) => {
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.setTag(TEST_STATUS, status);
          if (error) {
            this.testSessionSpan.setTag("error", error);
            this.testModuleSpan.setTag("error", error);
          }
          addIntelligentTestRunnerSpanTags(
            this.testSessionSpan,
            this.testModuleSpan,
            {
              isSuitesSkipped,
              isSuitesSkippingEnabled,
              isCodeCoverageEnabled,
              testCodeCoverageLinesTotal,
              skippingType: "suite",
              skippingCount: numSkippedSuites,
              hasUnskippableSuites,
              hasForcedToRunSuites
            }
          );
          if (isEarlyFlakeDetectionEnabled) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, "true");
          }
          if (isEarlyFlakeDetectionFaulty) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, "faulty");
          }
          if (isTestManagementTestsEnabled) {
            this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, "true");
          }
          this.testModuleSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "module");
          this.testSessionSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "session");
          finishAllTraceSpans(this.testSessionSpan);
          this.telemetry.count(TELEMETRY_TEST_SESSION, {
            provider: this.ciProviderName,
            autoInjected: !!getEnvironmentVariable("DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER")
          });
          this.tracer._exporter.flush(() => {
            if (onDone) {
              onDone();
            }
          });
        });
        this.addSub("ci:jest:session:configuration", (configs) => {
          configs.forEach((config) => {
            config._ddTestSessionId = this.testSessionSpan.context().toTraceId();
            config._ddTestModuleId = this.testModuleSpan.context().toSpanId();
            config._ddTestCommand = this.testSessionSpan.context()._tags[TEST_COMMAND];
            config._ddItrCorrelationId = this.itrCorrelationId;
            config._ddIsEarlyFlakeDetectionEnabled = !!this.libraryConfig?.isEarlyFlakeDetectionEnabled;
            config._ddEarlyFlakeDetectionNumRetries = this.libraryConfig?.earlyFlakeDetectionNumRetries ?? 0;
            config._ddRepositoryRoot = this.repositoryRoot;
            config._ddIsFlakyTestRetriesEnabled = this.libraryConfig?.isFlakyTestRetriesEnabled ?? false;
            config._ddIsTestManagementTestsEnabled = this.libraryConfig?.isTestManagementEnabled ?? false;
            config._ddTestManagementAttemptToFixRetries = this.libraryConfig?.testManagementAttemptToFixRetries ?? 0;
            config._ddFlakyTestRetriesCount = this.libraryConfig?.flakyTestRetriesCount;
            config._ddIsDiEnabled = this.libraryConfig?.isDiEnabled ?? false;
            config._ddIsKnownTestsEnabled = this.libraryConfig?.isKnownTestsEnabled ?? false;
            config._ddIsImpactedTestsEnabled = this.libraryConfig?.isImpactedTestsEnabled ?? false;
          });
        });
        this.addSub("ci:jest:test-suite:start", ({
          testSuite,
          testSourceFile,
          testEnvironmentOptions,
          frameworkVersion,
          displayName,
          testSuiteAbsolutePath
        }) => {
          const {
            _ddTestSessionId: testSessionId,
            _ddTestCommand: testCommand,
            _ddTestModuleId: testModuleId,
            _ddItrCorrelationId: itrCorrelationId,
            _ddForcedToRun,
            _ddUnskippable,
            _ddTestCodeCoverageEnabled
          } = testEnvironmentOptions;
          const testSessionSpanContext = this.tracer.extract("text_map", {
            "x-datadog-trace-id": testSessionId,
            "x-datadog-parent-id": testModuleId
          });
          const testSuiteMetadata = getTestSuiteCommonTags(testCommand, frameworkVersion, testSuite, "jest");
          if (_ddUnskippable) {
            const unskippableSuites = this.getUnskippableSuites(_ddUnskippable);
            if (unskippableSuites[testSuite]) {
              this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: "suite" });
              testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = "true";
            }
            if (_ddForcedToRun) {
              const forcedToRunSuites = this.getForcedToRunSuites(_ddForcedToRun);
              if (forcedToRunSuites[testSuite]) {
                this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: "suite" });
                testSuiteMetadata[TEST_ITR_FORCED_RUN] = "true";
              }
            }
          }
          if (itrCorrelationId) {
            testSuiteMetadata[ITR_CORRELATION_ID] = itrCorrelationId;
          }
          if (displayName) {
            testSuiteMetadata[JEST_DISPLAY_NAME] = displayName;
          }
          if (testSourceFile) {
            testSuiteMetadata[TEST_SOURCE_FILE] = testSourceFile;
            testSuiteMetadata[TEST_SOURCE_START] = 1;
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata);
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners;
          }
          this.testSuiteSpan = this.tracer.startSpan("jest.test_suite", {
            childOf: testSessionSpanContext,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            },
            integrationName: this.constructor.id
          });
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "suite");
          if (_ddTestCodeCoverageEnabled) {
            this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, "suite", { library: "istanbul" });
          }
          this.testSuiteSpanPerTestSuiteAbsolutePath.set(testSuiteAbsolutePath, this.testSuiteSpan);
        });
        this.addSub("ci:jest:worker-report:coverage", (data) => {
          const formattedCoverages = JSON.parse(data).map((coverage) => ({
            sessionId: id(coverage.sessionId),
            suiteId: id(coverage.suiteId),
            files: coverage.files
          }));
          formattedCoverages.forEach((formattedCoverage) => {
            this.tracer._exporter.exportCoverage(formattedCoverage);
          });
        });
        this.addSub("ci:jest:test-suite:finish", ({ status, errorMessage, error, testSuiteAbsolutePath }) => {
          const testSuiteSpan = this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath);
          if (!testSuiteSpan) {
            log.warn('"ci:jest:test-suite:finish": no span found for test suite absolute path %s', testSuiteAbsolutePath);
            return;
          }
          const hasStatus = testSuiteSpan.context()._tags[TEST_STATUS];
          if (!hasStatus) {
            testSuiteSpan.setTag(TEST_STATUS, status);
          }
          if (error) {
            testSuiteSpan.setTag("error", error);
            testSuiteSpan.setTag(TEST_STATUS, "fail");
          } else if (errorMessage) {
            testSuiteSpan.setTag("error", new Error(errorMessage));
            testSuiteSpan.setTag(TEST_STATUS, "fail");
          }
          process.nextTick(() => {
            testSuiteSpan.finish();
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "suite");
            finishAllTraceSpans(testSuiteSpan);
            if (isJestWorker) {
              this.tracer._exporter.flush();
            }
            this.removeAllDiProbes();
            this.testSuiteSpanPerTestSuiteAbsolutePath.delete(testSuiteAbsolutePath);
          });
        });
        this.addSub("ci:jest:test-suite:error", ({ error, errorMessage, testSuiteAbsolutePath }) => {
          const runningTestSuiteSpan = this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath);
          if (!runningTestSuiteSpan) {
            log.warn('"ci:jest:test-suite:error": no span found for test suite absolute path %s', testSuiteAbsolutePath);
            return;
          }
          if (error) {
            runningTestSuiteSpan.setTag("error", error);
          } else if (errorMessage) {
            runningTestSuiteSpan.setTag("error", new Error(errorMessage));
          }
          runningTestSuiteSpan.setTag(TEST_STATUS, "fail");
        });
        this.addSub("ci:jest:test-suite:code-coverage", ({ coverageFiles, testSuite, mockedFiles }) => {
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY);
          }
          const files = [...coverageFiles, ...mockedFiles, testSuite];
          const { _traceId, _spanId } = this.testSuiteSpan.context();
          const formattedCoverage = {
            sessionId: _traceId,
            suiteId: _spanId,
            files
          };
          this.tracer._exporter.exportCoverage(formattedCoverage);
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, "suite", { library: "istanbul" });
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, files.length);
        });
        this.addBind("ci:jest:test:start", (ctx) => {
          const store = storage("legacy").getStore();
          const span = this.startTestSpan(ctx);
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          this.activeTestSpan = span;
          return ctx.currentStore;
        });
        this.addBind("ci:jest:test:fn", (ctx) => {
          return ctx.currentStore;
        });
        this.addSub("ci:jest:test:finish", ({
          span,
          status,
          testStartLine,
          attemptToFixPassed,
          failedAllTests,
          attemptToFixFailed,
          isAtrRetry
        }) => {
          span.setTag(TEST_STATUS, status);
          if (testStartLine) {
            span.setTag(TEST_SOURCE_START, testStartLine);
          }
          if (attemptToFixPassed) {
            span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "true");
          } else if (attemptToFixFailed) {
            span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
          }
          if (failedAllTests) {
            span.setTag(TEST_HAS_FAILED_ALL_RETRIES, "true");
          }
          if (isAtrRetry) {
            span.setTag(TEST_IS_RETRY, "true");
            span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
          }
          const spanTags = span.context()._tags;
          this.telemetry.ciVisEvent(
            TELEMETRY_EVENT_FINISHED,
            "test",
            {
              hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
              isNew: spanTags[TEST_IS_NEW] === "true",
              isRum: spanTags[TEST_IS_RUM_ACTIVE] === "true",
              browserDriver: spanTags[TEST_BROWSER_DRIVER]
            }
          );
          span.finish();
          finishAllTraceSpans(span);
          this.activeTestSpan = null;
        });
        this.addSub("ci:jest:test:err", ({ span, error, shouldSetProbe, promises }) => {
          if (error && span) {
            span.setTag(TEST_STATUS, "fail");
            span.setTag("error", getFormattedError(error, this.repositoryRoot));
            if (shouldSetProbe) {
              const probeInformation = this.addDiProbe(error);
              if (probeInformation) {
                const { setProbePromise } = probeInformation;
                promises.isProbeReady = withTimeout(setProbePromise, 2e3);
              }
            }
          }
        });
        this.addSub("ci:jest:test:skip", ({
          test,
          isDisabled
        }) => {
          const span = this.startTestSpan(test);
          span.setTag(TEST_STATUS, "skip");
          if (isDisabled) {
            span.setTag(TEST_MANAGEMENT_IS_DISABLED, "true");
          }
          span.finish();
        });
      }
      startTestSpan(test) {
        const {
          suite,
          name,
          displayName,
          testParameters,
          frameworkVersion,
          testStartLine,
          testSourceFile,
          isNew,
          isEfdRetry,
          isAttemptToFix,
          isAttemptToFixRetry,
          isJestRetry,
          isDisabled,
          isQuarantined,
          isModified,
          testSuiteAbsolutePath
        } = test;
        const extraTags = {
          [JEST_TEST_RUNNER]: "jest-circus",
          [TEST_PARAMETERS]: testParameters,
          [TEST_FRAMEWORK_VERSION]: frameworkVersion
        };
        if (testStartLine) {
          extraTags[TEST_SOURCE_START] = testStartLine;
        }
        extraTags[TEST_SOURCE_FILE] = testSourceFile || suite;
        if (displayName) {
          extraTags[JEST_DISPLAY_NAME] = displayName;
        }
        if (isAttemptToFix) {
          extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = "true";
        }
        if (isAttemptToFixRetry) {
          extraTags[TEST_IS_RETRY] = "true";
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atf;
        } else if (isEfdRetry) {
          extraTags[TEST_IS_RETRY] = "true";
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd;
        } else if (isJestRetry) {
          extraTags[TEST_IS_RETRY] = "true";
          extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.ext;
        }
        if (isDisabled) {
          extraTags[TEST_MANAGEMENT_IS_DISABLED] = "true";
        }
        if (isQuarantined) {
          extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = "true";
        }
        if (isModified) {
          extraTags[TEST_IS_MODIFIED] = "true";
        }
        if (isNew) {
          extraTags[TEST_IS_NEW] = "true";
        }
        const testSuiteSpan = this.testSuiteSpanPerTestSuiteAbsolutePath.get(testSuiteAbsolutePath) || this.testSuiteSpan;
        return super.startTestSpan(name, suite, testSuiteSpan, extraTags);
      }
    };
    module2.exports = JestPlugin;
  }
});

// ../../packages/datadog-plugin-koa/src/index.js
var require_src18 = __commonJS({
  "../../packages/datadog-plugin-koa/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var web = require_web3();
    var KoaPlugin = class extends RouterPlugin {
      static id = "koa";
      constructor(...args) {
        super(...args);
        this.addSub("apm:koa:request:handle", ({ req }) => {
          this.setFramework(req, "koa", this.config);
        });
        this.addSub("apm:koa:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
    };
    module2.exports = KoaPlugin;
  }
});

// ../../packages/datadog-plugin-langchain/src/handlers/default.js
var require_default2 = __commonJS({
  "../../packages/datadog-plugin-langchain/src/handlers/default.js"(exports2, module2) {
    "use strict";
    var LangChainHandler = class {
      // no-op for default handler
      extractProvider(instance) {
      }
      // no-op for default handler
      extractModel(instance) {
      }
    };
    module2.exports = LangChainHandler;
  }
});

// ../../packages/datadog-plugin-langchain/src/handlers/language_models.js
var require_language_models = __commonJS({
  "../../packages/datadog-plugin-langchain/src/handlers/language_models.js"(exports2, module2) {
    "use strict";
    var LangChainHandler = require_default2();
    var LangChainLanguageModelHandler = class extends LangChainHandler {
      extractProvider(instance) {
        return typeof instance._llmType === "function" && instance._llmType().split("-")[0];
      }
      extractModel(instance) {
        for (const attr of ["model", "modelName", "modelId", "modelKey", "repoId"]) {
          const modelName = instance[attr];
          if (modelName) return modelName;
        }
      }
    };
    module2.exports = LangChainLanguageModelHandler;
  }
});

// ../../packages/datadog-plugin-langchain/src/handlers/embedding.js
var require_embedding = __commonJS({
  "../../packages/datadog-plugin-langchain/src/handlers/embedding.js"(exports2, module2) {
    "use strict";
    var LangChainHandler = require_default2();
    var LangChainEmbeddingHandler = class extends LangChainHandler {
      extractProvider(instance) {
        return instance.constructor.name.split("Embeddings")[0].toLowerCase();
      }
      extractModel(instance) {
        for (const attr of ["model", "modelName", "modelId", "modelKey", "repoId"]) {
          const modelName = instance[attr];
          if (modelName) return modelName;
        }
      }
    };
    module2.exports = LangChainEmbeddingHandler;
  }
});

// ../../packages/datadog-plugin-langchain/src/tracing.js
var require_tracing5 = __commonJS({
  "../../packages/datadog-plugin-langchain/src/tracing.js"(exports2, module2) {
    "use strict";
    var { MEASURED } = require_tags();
    var { storage } = require_datadog_core();
    var TracingPlugin = require_tracing();
    var MODEL = "langchain.request.model";
    var PROVIDER = "langchain.request.provider";
    var TYPE = "langchain.request.type";
    var LangChainHandler = require_default2();
    var LangChainLanguageModelHandler = require_language_models();
    var LangChainEmbeddingHandler = require_embedding();
    var BaseLangChainTracingPlugin = class extends TracingPlugin {
      static id = "langchain";
      static operation = "invoke";
      static system = "langchain";
      constructor() {
        super(...arguments);
        this.handlers = {
          chain: new LangChainHandler(this._tracerConfig),
          chat_model: new LangChainLanguageModelHandler(this._tracerConfig),
          llm: new LangChainLanguageModelHandler(this._tracerConfig),
          embedding: new LangChainEmbeddingHandler(this._tracerConfig),
          default: new LangChainHandler(this._tracerConfig)
        };
      }
      bindStart(ctx) {
        ctx.args = ctx.arguments;
        ctx.instance = ctx.self;
        const type = ctx.type = this.constructor.lcType;
        const ns = ctx.self.lc_namespace || ctx.namespace;
        const resourceParts = [...ns, ctx.self.constructor.name];
        if (type === "tool") {
          resourceParts.push(ctx.instance.name);
        }
        const resource = ctx.resource = resourceParts.join(".");
        const handler = this.handlers[type] || this.handlers.default;
        const instance = ctx.instance;
        const provider = handler.extractProvider(instance);
        const model = handler.extractModel(instance);
        const span = this.startSpan("langchain.request", {
          service: this.config.service,
          resource,
          kind: "client",
          meta: {
            [MEASURED]: 1
          }
        }, false);
        const tags = {};
        if (provider) tags[PROVIDER] = provider;
        if (model) tags[MODEL] = model;
        if (type) tags[TYPE] = type;
        span.addTags(tags);
        const store = storage("legacy").getStore() || {};
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore.span;
        span.finish();
      }
      getHandler(type) {
        return this.handlers[type] || this.handlers.default;
      }
    };
    var RunnableSequenceInvokePlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_rs_invoke";
      static lcType = "chain";
      static prefix = "tracing:orchestrion:@langchain/core:RunnableSequence_invoke";
    };
    var RunnableSequenceBatchPlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_rs_batch";
      static lcType = "chain";
      static prefix = "tracing:orchestrion:@langchain/core:RunnableSequence_batch";
    };
    var BaseChatModelGeneratePlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_chat_model_generate";
      static lcType = "chat_model";
      static prefix = "tracing:orchestrion:@langchain/core:BaseChatModel_generate";
    };
    var BaseLLMGeneratePlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_llm_generate";
      static lcType = "llm";
      static prefix = "tracing:orchestrion:@langchain/core:BaseLLM_generate";
    };
    var EmbeddingsEmbedQueryPlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_embeddings_embed_query";
      static lcType = "embedding";
      static prefix = "tracing:apm:@langchain/core:Embeddings_embedQuery";
    };
    var EmbeddingsEmbedDocumentsPlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_embeddings_embed_documents";
      static lcType = "embedding";
      static prefix = "tracing:apm:@langchain/core:Embeddings_embedDocuments";
    };
    var ToolInvokePlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_tool_invoke";
      static lcType = "tool";
      static prefix = "tracing:orchestrion:@langchain/core:Tool_invoke";
    };
    var VectorStoreSimilaritySearchPlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_vectorstore_similarity_search";
      static lcType = "similarity_search";
      static prefix = "tracing:orchestrion:@langchain/core:VectorStore_similaritySearch";
    };
    var VectorStoreSimilaritySearchWithScorePlugin = class extends BaseLangChainTracingPlugin {
      static id = "langchain_vectorstore_similarity_search_with_score";
      static lcType = "similarity_search";
      static prefix = "tracing:orchestrion:@langchain/core:VectorStore_similaritySearchWithScore";
    };
    module2.exports = [
      RunnableSequenceInvokePlugin,
      RunnableSequenceBatchPlugin,
      BaseChatModelGeneratePlugin,
      BaseLLMGeneratePlugin,
      EmbeddingsEmbedQueryPlugin,
      EmbeddingsEmbedDocumentsPlugin,
      ToolInvokePlugin,
      VectorStoreSimilaritySearchPlugin,
      VectorStoreSimilaritySearchWithScorePlugin
    ];
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/index.js
var require_handlers = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/index.js"(exports2, module2) {
    "use strict";
    var ROLE_MAPPINGS = {
      human: "user",
      ai: "assistant",
      system: "system"
    };
    var LangChainLLMObsHandler = class {
      constructor(tagger) {
        this._tagger = tagger;
      }
      getName({ span }) {
        return span?.context()._tags?.["resource.name"];
      }
      setMetaTags() {
      }
      formatIO(messages) {
        if (messages.constructor.name === "Object") {
          const formatted = {};
          for (const [key, value] of Object.entries(messages)) {
            formatted[key] = this.formatIO(value);
          }
          return formatted;
        } else if (Array.isArray(messages)) {
          return messages.map((message) => this.formatIO(message));
        }
        return this.getContentFromMessage(messages);
      }
      getContentFromMessage(message) {
        if (typeof message === "string") {
          return message;
        }
        try {
          const messageContent = {};
          messageContent.content = message.content || "";
          const role = this.getRole(message);
          if (role) messageContent.role = role;
          return messageContent;
        } catch {
          return JSON.stringify(message);
        }
      }
      checkTokenUsageChatOrLLMResult(results) {
        const llmOutput = results.llmOutput;
        const tokens = {
          inputTokens: 0,
          outputTokens: 0,
          totalTokens: 0
        };
        if (!llmOutput) return tokens;
        const tokenUsage = llmOutput.tokenUsage || llmOutput.usageMetadata || llmOutput.usage || {};
        if (!tokenUsage) return tokens;
        tokens.inputTokens = tokenUsage.promptTokens || tokenUsage.inputTokens || 0;
        tokens.outputTokens = tokenUsage.completionTokens || tokenUsage.outputTokens || 0;
        tokens.totalTokens = tokenUsage.totalTokens || tokens.inputTokens + tokens.outputTokens;
        return tokens;
      }
      checkTokenUsageFromAIMessage(message) {
        let usage = message.usage_metadata || message.additional_kwargs?.usage;
        const runId = message.run_id || message.id || "";
        const runIdBase = runId ? runId.split("-").slice(0, -1).join("-") : "";
        const responseMetadata = message.response_metadata || {};
        usage = usage || responseMetadata.usage || responseMetadata.tokenUsage || {};
        const inputTokens = usage.promptTokens || usage.inputTokens || usage.prompt_tokens || usage.input_tokens || 0;
        const outputTokens = usage.completionTokens || usage.outputTokens || usage.completion_tokens || usage.output_tokens || 0;
        const totalTokens = usage.totalTokens || inputTokens + outputTokens;
        return {
          tokens: {
            inputTokens,
            outputTokens,
            totalTokens
          },
          runId: runIdBase
        };
      }
      getRole(message) {
        if (message.role) return ROLE_MAPPINGS[message.role] || message.role;
        const type = typeof message.getType === "function" && message.getType() || typeof message._getType === "function" && message._getType();
        return ROLE_MAPPINGS[type] || type;
      }
    };
    module2.exports = LangChainLLMObsHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/util.js
var require_util8 = __commonJS({
  "../../packages/dd-trace/src/llmobs/util.js"(exports2, module2) {
    "use strict";
    var { SPAN_KINDS } = require_tags3();
    function encodeUnicode(str = "") {
      let result = "";
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        result += code > 127 ? `\\u${code.toString(16).padStart(4, "0")}` : str[i];
      }
      return result;
    }
    function validateKind(kind) {
      if (!SPAN_KINDS.includes(kind)) {
        throw new Error(`
      Invalid span kind specified: "${kind}"
      Must be one of: ${SPAN_KINDS.join(", ")}
    `);
      }
      return kind;
    }
    function parseArgumentNames(str) {
      const result = [];
      let current = "";
      let closerCount = 0;
      let recording = true;
      let inSingleLineComment = false;
      let inMultiLineComment = false;
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        const nextChar = str[i + 1];
        if (!inMultiLineComment && char === "/" && nextChar === "/") {
          inSingleLineComment = true;
          i++;
          continue;
        }
        if (!inSingleLineComment && char === "/" && nextChar === "*") {
          inMultiLineComment = true;
          i++;
          continue;
        }
        if (inSingleLineComment && char === "\n") {
          inSingleLineComment = false;
          continue;
        }
        if (inMultiLineComment && char === "*" && nextChar === "/") {
          inMultiLineComment = false;
          i++;
          continue;
        }
        if (inSingleLineComment || inMultiLineComment) {
          continue;
        }
        if (["{", "[", "("].includes(char)) {
          closerCount++;
        } else if (["}", "]", ")"].includes(char)) {
          closerCount--;
        } else if (char === "=" && nextChar !== ">" && closerCount === 0) {
          recording = false;
          result.push(current.trim());
          current = "";
          continue;
        } else if (char === "," && closerCount === 0) {
          if (recording) {
            result.push(current.trim());
            current = "";
          }
          recording = true;
          continue;
        }
        if (recording) {
          current += char;
        }
      }
      if (current && recording) {
        result.push(current.trim());
      }
      return result;
    }
    function findArgumentsBounds(str) {
      let start = -1;
      let end = -1;
      let closerCount = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str[i];
        if (char === "(") {
          if (closerCount === 0) {
            start = i;
          }
          closerCount++;
        } else if (char === ")") {
          closerCount--;
          if (closerCount === 0) {
            end = i;
            break;
          }
        }
      }
      return { start, end };
    }
    var memo = /* @__PURE__ */ new WeakMap();
    function getFunctionArguments(fn, args = []) {
      if (!fn) return;
      if (!args.length) return;
      if (args.length === 1) return args[0];
      try {
        let names;
        if (memo.has(fn)) {
          names = memo.get(fn);
        } else {
          const fnString = fn.toString();
          const { start, end } = findArgumentsBounds(fnString);
          names = parseArgumentNames(fnString.slice(start + 1, end));
          memo.set(fn, names);
        }
        const argsObject = {};
        for (const argIdx in args) {
          const name = names[argIdx];
          const arg = args[argIdx];
          const spread = name?.startsWith("...");
          if (spread) {
            argsObject[name.slice(3)] = args.slice(argIdx);
            break;
          }
          argsObject[name] = arg;
        }
        return argsObject;
      } catch {
        return args;
      }
    }
    function spanHasError(span) {
      const tags = span.context()._tags;
      return !!(tags.error || tags["error.type"]);
    }
    module2.exports = {
      encodeUnicode,
      validateKind,
      getFunctionArguments,
      spanHasError
    };
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/chain.js
var require_chain = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/chain.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var { spanHasError } = require_util8();
    var LangChainLLMObsChainHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        let input;
        if (inputs) {
          input = this.formatIO(inputs);
        }
        const output = !results || spanHasError(span) ? "" : this.formatIO(results);
        this._tagger.tagTextIO(span, input, output);
      }
    };
    module2.exports = LangChainLLMObsChainHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/chat_model.js
var require_chat_model = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/chat_model.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var LLMObsTagger = require_tagger2();
    var { spanHasError } = require_util8();
    var LLM = "llm";
    var LangChainLLMObsChatModelHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results, options, integrationName }) {
        if (integrationName === "openai" && options?.response_format) {
          this._tagger.changeKind(span, LLM);
        }
        const spanKind = LLMObsTagger.getSpanKind(span);
        const isWorkflow = spanKind === "workflow";
        const inputMessages = [];
        if (!Array.isArray(inputs)) inputs = [inputs];
        for (const messageSet of inputs) {
          for (const message of messageSet) {
            const content = message.content || "";
            const role = this.getRole(message);
            inputMessages.push({ content, role });
          }
        }
        if (spanHasError(span)) {
          if (isWorkflow) {
            this._tagger.tagTextIO(span, inputMessages, [{ content: "" }]);
          } else {
            this._tagger.tagLLMIO(span, inputMessages, [{ content: "" }]);
          }
          return;
        }
        const outputMessages = [];
        let inputTokens = 0;
        let outputTokens = 0;
        let totalTokens = 0;
        let tokensSetTopLevel = false;
        const tokensPerRunId = {};
        if (!isWorkflow) {
          const tokens = this.checkTokenUsageChatOrLLMResult(results);
          inputTokens = tokens.inputTokens;
          outputTokens = tokens.outputTokens;
          totalTokens = tokens.totalTokens;
          tokensSetTopLevel = totalTokens > 0;
        }
        for (const messageSet of results.generations) {
          for (const chatCompletion of messageSet) {
            const chatCompletionMessage = chatCompletion.message;
            const role = this.getRole(chatCompletionMessage);
            const content = chatCompletionMessage.text || "";
            const toolCalls = this.extractToolCalls(chatCompletionMessage);
            outputMessages.push({ content, role, toolCalls });
            if (!isWorkflow && !tokensSetTopLevel) {
              const { tokens, runId } = this.checkTokenUsageFromAIMessage(chatCompletionMessage);
              if (tokensPerRunId[runId]) {
                tokensPerRunId[runId].inputTokens += tokens.inputTokens;
                tokensPerRunId[runId].outputTokens += tokens.outputTokens;
                tokensPerRunId[runId].totalTokens += tokens.totalTokens;
              } else {
                tokensPerRunId[runId] = tokens;
              }
            }
          }
        }
        if (!isWorkflow && !tokensSetTopLevel) {
          inputTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.inputTokens, 0);
          outputTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.outputTokens, 0);
          totalTokens = Object.values(tokensPerRunId).reduce((acc, val) => acc + val.totalTokens, 0);
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, inputMessages, outputMessages);
        } else {
          this._tagger.tagLLMIO(span, inputMessages, outputMessages);
          this._tagger.tagMetrics(span, {
            inputTokens,
            outputTokens,
            totalTokens
          });
        }
      }
      extractToolCalls(message) {
        let toolCalls = message.tool_calls;
        if (!toolCalls) return [];
        const toolCallsInfo = [];
        if (!Array.isArray(toolCalls)) toolCalls = [toolCalls];
        for (const toolCall of toolCalls) {
          toolCallsInfo.push({
            name: toolCall.name || "",
            arguments: toolCall.args || {},
            tool_id: toolCall.id || ""
          });
        }
        return toolCallsInfo;
      }
    };
    module2.exports = LangChainLLMObsChatModelHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/llm.js
var require_llm2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/llm.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var LLMObsTagger = require_tagger2();
    var { spanHasError } = require_util8();
    var LangChainLLMObsLlmHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const isWorkflow = LLMObsTagger.getSpanKind(span) === "workflow";
        const prompts = Array.isArray(inputs) ? inputs : [inputs];
        let outputs;
        if (spanHasError(span)) {
          outputs = [{ content: "" }];
        } else {
          outputs = results.generations.map((completion) => ({ content: completion[0].text }));
          if (!isWorkflow) {
            const tokens = this.checkTokenUsageChatOrLLMResult(results);
            this._tagger.tagMetrics(span, tokens);
          }
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, prompts, outputs);
        } else {
          this._tagger.tagLLMIO(span, prompts, outputs);
        }
      }
    };
    module2.exports = LangChainLLMObsLlmHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/embedding.js
var require_embedding2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/embedding.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var LLMObsTagger = require_tagger2();
    var { spanHasError } = require_util8();
    var LangChainLLMObsEmbeddingHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const isWorkflow = LLMObsTagger.getSpanKind(span) === "workflow";
        let embeddingInput, embeddingOutput;
        if (isWorkflow) {
          embeddingInput = this.formatIO(inputs);
        } else {
          const input = Array.isArray(inputs) ? inputs : [inputs];
          embeddingInput = input.map((doc) => ({ text: doc }));
        }
        if (spanHasError(span) || !results) {
          embeddingOutput = "";
        } else {
          let embeddingDimensions, embeddingsCount;
          if (typeof results[0] === "number") {
            embeddingsCount = 1;
            embeddingDimensions = results.length;
          } else {
            embeddingsCount = results.length;
            embeddingDimensions = results[0].length;
          }
          embeddingOutput = `[${embeddingsCount} embedding(s) returned with size ${embeddingDimensions}]`;
        }
        if (isWorkflow) {
          this._tagger.tagTextIO(span, embeddingInput, embeddingOutput);
        } else {
          this._tagger.tagEmbeddingIO(span, embeddingInput, embeddingOutput);
        }
      }
    };
    module2.exports = LangChainLLMObsEmbeddingHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/tool.js
var require_tool = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/tool.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var LangChainLLMObsToolHandler = class extends LangChainLLMObsHandler {
      getName({ instance }) {
        return instance.name;
      }
      setMetaTags({ span, inputs, results }) {
        this._tagger.tagTextIO(span, inputs, results);
      }
    };
    module2.exports = LangChainLLMObsToolHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/vectorstore.js
var require_vectorstore = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/handlers/vectorstore.js"(exports2, module2) {
    "use strict";
    var LangChainLLMObsHandler = require_handlers();
    var { spanHasError } = require_util8();
    var LangChainLLMObsVectorStoreHandler = class extends LangChainLLMObsHandler {
      setMetaTags({ span, inputs, results }) {
        const input = this.formatIO(inputs);
        if (spanHasError(span)) {
          this._tagger.tagRetrievalIO(span, input);
          return;
        }
        const documents = [];
        for (const documentResult of results) {
          let document, score;
          if (Array.isArray(documentResult)) {
            document = documentResult[0];
            score = documentResult[1];
          } else {
            document = documentResult;
          }
          documents.push({
            text: document.pageContent,
            id: document.id,
            name: document.metadata?.source,
            score
          });
        }
        this._tagger.tagRetrievalIO(span, input, documents);
      }
    };
    module2.exports = LangChainLLMObsVectorStoreHandler;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/langchain/index.js
var require_langchain2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/langchain/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var LLMObsPlugin = require_base();
    var pluginManager = require_index()._pluginManager;
    var ANTHROPIC_PROVIDER_NAME = "anthropic";
    var BEDROCK_PROVIDER_NAME = "amazon_bedrock";
    var OPENAI_PROVIDER_NAME = "openai";
    var SUPPORTED_INTEGRATIONS = /* @__PURE__ */ new Set(["openai"]);
    var LLM_SPAN_TYPES = /* @__PURE__ */ new Set(["llm", "chat_model", "embedding"]);
    var LLM = "llm";
    var WORKFLOW = "workflow";
    var EMBEDDING = "embedding";
    var TOOL = "tool";
    var RETRIEVAL = "retrieval";
    var ChainHandler = require_chain();
    var ChatModelHandler = require_chat_model();
    var LlmHandler = require_llm2();
    var EmbeddingHandler = require_embedding2();
    var ToolHandler = require_tool();
    var VectorStoreHandler = require_vectorstore();
    var BaseLangChainLLMObsPlugin = class extends LLMObsPlugin {
      static integration = "langchain";
      static id = "langchain";
      static prefix = "tracing:apm:langchain:invoke";
      constructor() {
        super(...arguments);
        this._handlers = {
          chain: new ChainHandler(this._tagger),
          chat_model: new ChatModelHandler(this._tagger),
          llm: new LlmHandler(this._tagger),
          embedding: new EmbeddingHandler(this._tagger),
          tool: new ToolHandler(this._tagger),
          similarity_search: new VectorStoreHandler(this._tagger)
        };
      }
      getLLMObsSpanRegisterOptions(ctx) {
        const span = ctx.currentStore?.span;
        const tags = span?.context()._tags || {};
        const modelProvider = tags["langchain.request.provider"];
        const modelName = tags["langchain.request.model"];
        const kind = this.getKind(ctx.type, modelProvider);
        const instance = ctx.instance || ctx.self;
        const handler = this._handlers[ctx.type];
        const name = handler?.getName({ span, instance });
        return {
          modelProvider,
          modelName,
          kind,
          name
        };
      }
      setLLMObsTags(ctx) {
        ctx.args = ctx.arguments;
        ctx.instance = ctx.self;
        const span = ctx.currentStore?.span;
        const type = ctx.type = this.constructor.lcType;
        if (!Object.keys(this._handlers).includes(type)) {
          log.warn("Unsupported LangChain operation type:", type);
          return;
        }
        const provider = span?.context()._tags["langchain.request.provider"];
        const integrationName = this.getIntegrationName(type, provider);
        this.setMetadata(span, provider);
        const inputs = ctx.args?.[0];
        const options = ctx.args?.[1];
        const results = ctx.result;
        this._handlers[type].setMetaTags({ span, inputs, results, options, integrationName });
      }
      setMetadata(span, provider) {
        if (!provider) return;
        const metadata = {};
        const temperature = span?.context()._tags[`langchain.request.${provider}.parameters.temperature`] || span?.context()._tags[`langchain.request.${provider}.parameters.model_kwargs.temperature`];
        const maxTokens = span?.context()._tags[`langchain.request.${provider}.parameters.max_tokens`] || span?.context()._tags[`langchain.request.${provider}.parameters.maxTokens`] || span?.context()._tags[`langchain.request.${provider}.parameters.model_kwargs.max_tokens`];
        if (temperature) {
          metadata.temperature = Number.parseFloat(temperature);
        }
        if (maxTokens) {
          metadata.maxTokens = Number.parseInt(maxTokens);
        }
        this._tagger.tagMetadata(span, metadata);
      }
      getKind(type, provider) {
        if (LLM_SPAN_TYPES.has(type)) {
          const llmobsIntegration = this.getIntegrationName(type, provider);
          if (!this.isLLMIntegrationEnabled(llmobsIntegration)) {
            return type === "embedding" ? EMBEDDING : LLM;
          }
        }
        switch (type) {
          case "tool":
            return TOOL;
          case "similarity_search":
            return RETRIEVAL;
          default:
            return WORKFLOW;
        }
      }
      getIntegrationName(type, provider = "custom") {
        if (provider.startsWith(BEDROCK_PROVIDER_NAME)) {
          return "bedrock";
        } else if (provider.startsWith(OPENAI_PROVIDER_NAME)) {
          return "openai";
        } else if (type === "chat_model" && provider.startsWith(ANTHROPIC_PROVIDER_NAME)) {
          return "anthropic";
        }
        return provider;
      }
      isLLMIntegrationEnabled(integration) {
        return SUPPORTED_INTEGRATIONS.has(integration) && pluginManager?._pluginsByName[integration]?.llmobs?._enabled;
      }
    };
    var RunnableSequenceInvokePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_rs_invoke";
      static lcType = "chain";
      static prefix = "tracing:orchestrion:@langchain/core:RunnableSequence_invoke";
    };
    var RunnableSequenceBatchPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_rs_batch";
      static lcType = "chain";
      static prefix = "tracing:orchestrion:@langchain/core:RunnableSequence_batch";
    };
    var BaseChatModelGeneratePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_chat_model_generate";
      static lcType = "chat_model";
      static prefix = "tracing:orchestrion:@langchain/core:BaseChatModel_generate";
    };
    var BaseLLMGeneratePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_llm_generate";
      static lcType = "llm";
      static prefix = "tracing:orchestrion:@langchain/core:BaseLLM_generate";
    };
    var EmbeddingsEmbedQueryPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_embeddings_embed_query";
      static lcType = "embedding";
      static prefix = "tracing:apm:@langchain/core:Embeddings_embedQuery";
    };
    var EmbeddingsEmbedDocumentsPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_embeddings_embed_documents";
      static lcType = "embedding";
      static prefix = "tracing:apm:@langchain/core:Embeddings_embedDocuments";
    };
    var ToolInvokePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_tool_invoke";
      static lcType = "tool";
      static prefix = "tracing:orchestrion:@langchain/core:Tool_invoke";
    };
    var VectorStoreSimilaritySearchPlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_vectorstore_similarity_search";
      static lcType = "similarity_search";
      static prefix = "tracing:orchestrion:@langchain/core:VectorStore_similaritySearch";
    };
    var VectorStoreSimilaritySearchWithScorePlugin = class extends BaseLangChainLLMObsPlugin {
      static id = "llmobs_langchain_vectorstore_similarity_search_with_score";
      static lcType = "similarity_search";
      static prefix = "tracing:orchestrion:@langchain/core:VectorStore_similaritySearchWithScore";
    };
    module2.exports = [
      RunnableSequenceInvokePlugin,
      RunnableSequenceBatchPlugin,
      BaseChatModelGeneratePlugin,
      BaseLLMGeneratePlugin,
      EmbeddingsEmbedQueryPlugin,
      EmbeddingsEmbedDocumentsPlugin,
      ToolInvokePlugin,
      VectorStoreSimilaritySearchPlugin,
      VectorStoreSimilaritySearchWithScorePlugin
    ];
  }
});

// ../../packages/datadog-plugin-langchain/src/index.js
var require_src19 = __commonJS({
  "../../packages/datadog-plugin-langchain/src/index.js"(exports2, module2) {
    "use strict";
    var langChainTracingPlugins = require_tracing5();
    var langChainLLMObsPlugins = require_langchain2();
    var CompositePlugin = require_composite2();
    var plugins = {};
    for (const Plugin of langChainLLMObsPlugins) {
      plugins[Plugin.id] = Plugin;
    }
    for (const Plugin of langChainTracingPlugins) {
      plugins[Plugin.id] = Plugin;
    }
    var LangChainPlugin = class extends CompositePlugin {
      static id = "langchain";
      static plugins = plugins;
    };
    module2.exports = LangChainPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/cache.js
var require_cache = __commonJS({
  "../../packages/dd-trace/src/plugins/cache.js"(exports2, module2) {
    "use strict";
    var StoragePlugin = require_storage5();
    var CachePlugin = class extends StoragePlugin {
      static operation = "command";
      startSpan(options, ctx) {
        if (!options.kind) {
          options.kind = this.constructor.kind;
        }
        return super.startSpan(this.operationName(), options, ctx);
      }
    };
    module2.exports = CachePlugin;
  }
});

// ../../packages/datadog-plugin-redis/src/index.js
var require_src20 = __commonJS({
  "../../packages/datadog-plugin-redis/src/index.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var CachePlugin = require_cache();
    var urlFilter = require_urlfilter();
    var RedisPlugin = class extends CachePlugin {
      static id = "redis";
      static system = "redis";
      constructor(...args) {
        super(...args);
        this._spanType = "redis";
      }
      bindStart(ctx) {
        const { db, command, args, connectionOptions, connectionName } = ctx;
        const resource = command;
        const normalizedCommand = command.toUpperCase();
        if (!this.config.filter(normalizedCommand)) {
          return { noop: true };
        }
        this.startSpan({
          resource,
          service: this.serviceName({ pluginConfig: this.config, system: this.system, connectionName }),
          type: this._spanType,
          meta: {
            "db.type": this._spanType,
            "db.name": db || "0",
            [`${this._spanType}.raw_command`]: formatCommand(normalizedCommand, args),
            "out.host": connectionOptions.host,
            [CLIENT_PORT_KEY]: connectionOptions.port
          }
        }, ctx);
        return ctx.currentStore;
      }
      configure(config) {
        super.configure(normalizeConfig(config));
      }
    };
    function formatCommand(command, args) {
      if (!args || command === "AUTH") return command;
      for (let i = 0, l = args.length; i < l; i++) {
        if (typeof args[i] === "function") continue;
        command = `${command} ${formatArg(args[i])}`;
        if (command.length > 1e3) return trim(command, 1e3);
      }
      return command;
    }
    function formatArg(arg) {
      switch (typeof arg) {
        case "string":
        case "number":
          return trim(String(arg), 100);
        default:
          return "?";
      }
    }
    function trim(str, maxlen) {
      if (str.length > maxlen) {
        str = str.slice(0, maxlen - 3) + "...";
      }
      return str;
    }
    function normalizeConfig(config) {
      if (config.allowlist) uppercaseAllEntries(config.allowlist);
      if (config.whitelist) uppercaseAllEntries(config.whitelist);
      if (config.blocklist) uppercaseAllEntries(config.blocklist);
      if (config.blacklist) uppercaseAllEntries(config.blacklist);
      const filter = urlFilter.getFilter(config);
      return { ...config, filter };
    }
    function uppercaseAllEntries(entries) {
      for (let i = 0; i < entries.length; i++) {
        entries[i] = String(entries[i]).toUpperCase();
      }
    }
    module2.exports = RedisPlugin;
  }
});

// ../../packages/datadog-plugin-opensearch/src/index.js
var require_src21 = __commonJS({
  "../../packages/datadog-plugin-opensearch/src/index.js"(exports2, module2) {
    "use strict";
    var ElasticsearchPlugin = require_src10();
    var OpenSearchPlugin = class extends ElasticsearchPlugin {
      static id = "opensearch";
    };
    module2.exports = OpenSearchPlugin;
  }
});

// ../../packages/datadog-plugin-prisma/src/client.js
var require_client8 = __commonJS({
  "../../packages/datadog-plugin-prisma/src/client.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var PrismaClientPlugin = class extends DatabasePlugin {
      static id = "prisma";
      static operation = "client";
      static system = "prisma";
      static prefix = "tracing:apm:prisma:client";
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config });
        const resource = formatResourceName(ctx.resourceName, ctx.attributes);
        const options = { service, resource };
        if (ctx.resourceName === "operation") {
          options.meta = {
            prisma: {
              method: ctx.attributes.method,
              model: ctx.attributes.model,
              type: "client"
            }
          };
        }
        const operationName = this.operationName({ operation: this.operation });
        this.startSpan(operationName, options, ctx);
        return ctx.currentStore;
      }
      end(ctx) {
        if (Object.hasOwn(ctx, "result")) {
          this.finish(ctx);
        }
      }
      bindAsyncStart(ctx) {
        return this.bindFinish(ctx);
      }
      asyncStart(ctx) {
        this.finish(ctx);
      }
      error(error) {
        this.addError(error);
      }
    };
    function formatResourceName(resource, attributes) {
      if (attributes?.name) {
        return `${attributes.name}`.trim();
      }
      if (attributes?.model && attributes.method) {
        return `${attributes.model}.${attributes.method}`.trim();
      }
      return resource;
    }
    module2.exports = PrismaClientPlugin;
  }
});

// ../../packages/datadog-plugin-prisma/src/engine.js
var require_engine = __commonJS({
  "../../packages/datadog-plugin-prisma/src/engine.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var { CLIENT_PORT_KEY } = require_constants3();
    var databaseDriverMapper = {
      postgresql: {
        type: "sql",
        "db.type": "postgres"
      },
      mysql: {
        type: "sql",
        "db.type": "mysql"
      },
      mongodb: {
        type: "mongodb",
        "db.type": "mongodb"
      },
      sqlite: {
        type: "sql",
        "db.type": "sqlite"
      }
    };
    var PrismaEngine = class extends DatabasePlugin {
      static id = "prisma";
      static operation = "engine";
      static system = "prisma";
      start(ctx) {
        const { engineSpan, allEngineSpans, childOf, dbConfig } = ctx;
        const service = this.serviceName({ pluginConfig: this.config, system: this.system });
        const spanName = engineSpan.name.slice(14);
        const options = {
          childOf,
          resource: spanName,
          service,
          kind: engineSpan.kind,
          meta: {
            prisma: {
              name: spanName,
              type: "engine"
            }
          }
        };
        if (spanName === "db_query") {
          const query = engineSpan.attributes["db.query.text"];
          const originalStatement = this.maybeTruncate(query);
          const type = databaseDriverMapper[engineSpan.attributes["db.system"]]?.type;
          const dbType = databaseDriverMapper[engineSpan.attributes["db.system"]]?.["db.type"];
          options.resource = originalStatement;
          options.type = type || engineSpan.attributes["db.system"];
          options.meta["db.type"] = dbType || engineSpan.attributes["db.system"];
          options.meta["db.name"] = dbConfig?.database;
          options.meta["db.user"] = dbConfig?.user;
          options.meta["out.host"] = dbConfig?.host;
          options.meta[CLIENT_PORT_KEY] = dbConfig?.port;
        }
        const activeSpan = this.startSpan(this.operationName({ operation: this.operation }), options);
        activeSpan._startTime = hrTimeToUnixTimeMs(engineSpan.startTime);
        for (const span of allEngineSpans) {
          if (span.parentId === engineSpan.id) {
            const startCtx = { engineSpan: span, allEngineSpans, childOf: activeSpan, dbConfig };
            this.start(startCtx);
          }
        }
        const unixEndTime = hrTimeToUnixTimeMs(engineSpan.endTime);
        activeSpan.finish(unixEndTime);
      }
    };
    function hrTimeToUnixTimeMs([seconds, nanoseconds]) {
      return seconds * 1e3 + nanoseconds / 1e6;
    }
    module2.exports = PrismaEngine;
  }
});

// ../../packages/datadog-plugin-prisma/src/index.js
var require_src22 = __commonJS({
  "../../packages/datadog-plugin-prisma/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var PrismaClientPlugin = require_client8();
    var PrismaEnginePlugin = require_engine();
    var PrismaPlugin = class extends CompositePlugin {
      static id = "prisma";
      static get plugins() {
        return {
          client: PrismaClientPlugin,
          engine: PrismaEnginePlugin
        };
      }
      configure(config) {
        return super.configure(config);
      }
    };
    module2.exports = PrismaPlugin;
  }
});

// ../../packages/datadog-plugin-vitest/src/index.js
var require_src23 = __commonJS({
  "../../packages/datadog-plugin-vitest/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestSuiteCommonTags,
      getTestSessionName,
      getIsFaultyEarlyFlakeDetection,
      TEST_SOURCE_FILE,
      TEST_IS_RETRY,
      TEST_CODE_COVERAGE_LINES_PCT,
      TEST_CODE_OWNERS,
      TEST_LEVEL_EVENT_TYPES,
      TEST_SESSION_NAME,
      TEST_SOURCE_START,
      TEST_IS_NEW,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_HAS_FAILED_ALL_RETRIES,
      getLibraryCapabilitiesTags,
      TEST_RETRY_REASON_TYPES,
      isModifiedTest,
      TEST_IS_MODIFIED
    } = require_test();
    var { COMPONENT } = require_constants3();
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_TEST_SESSION
    } = require_telemetry();
    var { DD_MAJOR } = require_version2();
    var MILLISECONDS_TO_SUBTRACT_FROM_FAILED_TEST_DURATION = 5;
    var VitestPlugin = class extends CiPlugin {
      static id = "vitest";
      constructor(...args) {
        super(...args);
        this.taskToFinishTime = /* @__PURE__ */ new WeakMap();
        this.addSub("ci:vitest:test:is-new", ({ knownTests, testSuiteAbsolutePath, testName, onDone }) => {
          if (!knownTests.vitest) {
            return onDone(false);
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const testsForThisTestSuite = knownTests.vitest[testSuite] || [];
          onDone(!testsForThisTestSuite.includes(testName));
        });
        this.addSub("ci:vitest:test:is-attempt-to-fix", ({
          testManagementTests,
          testSuiteAbsolutePath,
          testName,
          onDone
        }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const { isAttemptToFix } = this.getTestProperties(testManagementTests, testSuite, testName);
          onDone(isAttemptToFix ?? false);
        });
        this.addSub("ci:vitest:test:is-disabled", ({ testManagementTests, testSuiteAbsolutePath, testName, onDone }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const { isDisabled } = this.getTestProperties(testManagementTests, testSuite, testName);
          onDone(isDisabled);
        });
        this.addSub("ci:vitest:test:is-quarantined", ({ testManagementTests, testSuiteAbsolutePath, testName, onDone }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const { isQuarantined } = this.getTestProperties(testManagementTests, testSuite, testName);
          onDone(isQuarantined);
        });
        this.addSub("ci:vitest:test:is-modified", ({ modifiedFiles, testSuiteAbsolutePath, onDone }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const isModified = isModifiedTest(testSuite, 0, 0, modifiedFiles, this.constructor.id);
          onDone(isModified);
        });
        this.addSub("ci:vitest:is-early-flake-detection-faulty", ({
          knownTests,
          testFilepaths,
          onDone
        }) => {
          const isFaulty = getIsFaultyEarlyFlakeDetection(
            testFilepaths.map((testFilepath) => getTestSuitePath(testFilepath, this.repositoryRoot)),
            knownTests,
            this.libraryConfig.earlyFlakeDetectionFaultyThreshold
          );
          onDone(isFaulty);
        });
        this.addBind("ci:vitest:test:start", (ctx) => {
          const {
            testName,
            testSuiteAbsolutePath,
            isRetry,
            isNew,
            isAttemptToFix,
            isQuarantined,
            isDisabled,
            mightHitProbe,
            isRetryReasonEfd,
            isRetryReasonAttemptToFix,
            isRetryReasonAtr,
            isModified
          } = ctx;
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const store = storage("legacy").getStore();
          const extraTags = {
            [TEST_SOURCE_FILE]: testSuite
          };
          if (isRetry) {
            extraTags[TEST_IS_RETRY] = "true";
            if (isRetryReasonAttemptToFix) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atf;
            } else if (isRetryReasonEfd) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd;
            } else if (isRetryReasonAtr) {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.atr;
            } else {
              extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.ext;
            }
          }
          if (isNew) {
            extraTags[TEST_IS_NEW] = "true";
          }
          if (isAttemptToFix) {
            extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = "true";
          }
          if (isQuarantined) {
            extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = "true";
          }
          if (isDisabled) {
            extraTags[TEST_MANAGEMENT_IS_DISABLED] = "true";
          }
          if (isModified) {
            extraTags[TEST_IS_MODIFIED] = "true";
          }
          const span = this.startTestSpan(
            testName,
            testSuite,
            this.testSuiteSpan,
            extraTags
          );
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          if (mightHitProbe) {
            this.activeTestSpan = span;
          }
          return ctx.currentStore;
        });
        this.addBind("ci:vitest:test:finish-time", (ctx) => {
          const { status, task, attemptToFixPassed, attemptToFixFailed } = ctx;
          const span = ctx.currentStore?.span;
          if (span) {
            span.setTag(TEST_STATUS, status);
            if (attemptToFixPassed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "true");
            } else if (attemptToFixFailed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
            }
            this.taskToFinishTime.set(task, span._getTime());
            ctx.parentStore = ctx.currentStore;
            ctx.currentStore = { ...ctx.currentStore, span };
          }
          return ctx.currentStore;
        });
        this.addSub("ci:vitest:test:pass", ({ span, task }) => {
          if (span) {
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "test", {
              hasCodeowners: !!span.context()._tags[TEST_CODE_OWNERS]
            });
            span.setTag(TEST_STATUS, "pass");
            span.finish(this.taskToFinishTime.get(task));
            finishAllTraceSpans(span);
          }
        });
        this.addSub("ci:vitest:test:error", ({
          span,
          duration,
          error,
          shouldSetProbe,
          promises,
          hasFailedAllRetries,
          attemptToFixFailed
        }) => {
          if (!span) {
            return;
          }
          if (shouldSetProbe && this.di && error?.stack) {
            const probeInformation = this.addDiProbe(error);
            if (probeInformation) {
              const { file, line, stackIndex, setProbePromise } = probeInformation;
              this.runningTestProbe = { file, line };
              this.testErrorStackIndex = stackIndex;
              promises.setProbePromise = setProbePromise;
            }
          }
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "test", {
            hasCodeowners: !!span.context()._tags[TEST_CODE_OWNERS]
          });
          span.setTag(TEST_STATUS, "fail");
          if (error) {
            span.setTag("error", error);
          }
          if (hasFailedAllRetries) {
            span.setTag(TEST_HAS_FAILED_ALL_RETRIES, "true");
          }
          if (attemptToFixFailed) {
            span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
          }
          if (duration) {
            span.finish(span._startTime + duration - MILLISECONDS_TO_SUBTRACT_FROM_FAILED_TEST_DURATION);
          } else {
            span.finish();
          }
          finishAllTraceSpans(span);
        });
        this.addSub("ci:vitest:test:skip", ({ testName, testSuiteAbsolutePath, isNew, isDisabled }) => {
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const testSpan = this.startTestSpan(
            testName,
            testSuite,
            this.testSuiteSpan,
            {
              [TEST_SOURCE_FILE]: testSuite,
              [TEST_SOURCE_START]: 1,
              // we can't get the proper start line in vitest
              [TEST_STATUS]: "skip",
              ...isDisabled ? { [TEST_MANAGEMENT_IS_DISABLED]: "true" } : {},
              ...isNew ? { [TEST_IS_NEW]: "true" } : {}
            }
          );
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "test", {
            hasCodeowners: !!testSpan.context()._tags[TEST_CODE_OWNERS]
          });
          testSpan.finish();
        });
        this.addBind("ci:vitest:test-suite:start", (ctx) => {
          const { testSuiteAbsolutePath, frameworkVersion } = ctx;
          this.command = getEnvironmentVariable("DD_CIVISIBILITY_TEST_COMMAND");
          this.frameworkVersion = frameworkVersion;
          const testSessionSpanContext = this.tracer.extract("text_map", {
            "x-datadog-trace-id": getEnvironmentVariable("DD_CIVISIBILITY_TEST_SESSION_ID"),
            "x-datadog-parent-id": getEnvironmentVariable("DD_CIVISIBILITY_TEST_MODULE_ID")
          });
          const trimmedCommand = DD_MAJOR < 6 ? this.command : "vitest run";
          const testSessionName = getTestSessionName(this.config, trimmedCommand, this.testEnvironmentMetadata);
          const metadataTags = {};
          for (const testLevel of TEST_LEVEL_EVENT_TYPES) {
            metadataTags[testLevel] = {
              [TEST_SESSION_NAME]: testSessionName
            };
          }
          if (this.tracer._exporter.addMetadataTags) {
            const libraryCapabilitiesTags = getLibraryCapabilitiesTags(this.constructor.id);
            metadataTags.test = {
              ...metadataTags.test,
              ...libraryCapabilitiesTags
            };
            this.tracer._exporter.addMetadataTags(metadataTags);
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot);
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            testSuite,
            "vitest"
          );
          testSuiteMetadata[TEST_SOURCE_FILE] = testSuite;
          testSuiteMetadata[TEST_SOURCE_START] = 1;
          const codeOwners = this.getCodeOwners(testSuiteMetadata);
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners;
          }
          const testSuiteSpan = this.tracer.startSpan("vitest.test_suite", {
            childOf: testSessionSpanContext,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            }
          });
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "suite");
          const store = storage("legacy").getStore();
          ctx.parentStore = store;
          ctx.currentStore = { ...store, testSuiteSpan };
          this.testSuiteSpan = testSuiteSpan;
          return ctx.currentStore;
        });
        this.addSub("ci:vitest:test-suite:finish", ({ testSuiteSpan, status, onFinish }) => {
          if (testSuiteSpan) {
            testSuiteSpan.setTag(TEST_STATUS, status);
            testSuiteSpan.finish();
            finishAllTraceSpans(testSuiteSpan);
          }
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "suite");
          this.tracer._exporter.flush(onFinish);
          if (this.runningTestProbe) {
            this.removeDiProbe(this.runningTestProbe);
          }
        });
        this.addBind("ci:vitest:test-suite:error", (ctx) => {
          const { error } = ctx;
          const testSuiteSpan = ctx.currentStore?.testSuiteSpan;
          if (testSuiteSpan && error) {
            testSuiteSpan.setTag("error", error);
            testSuiteSpan.setTag(TEST_STATUS, "fail");
            ctx.parentStore = ctx.currentStore;
            ctx.currentStore = { ...ctx.currentStore, testSuiteSpan };
          }
          return ctx.currentStore;
        });
        this.addSub("ci:vitest:session:finish", ({
          status,
          error,
          testCodeCoverageLinesTotal,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementTestsEnabled,
          onFinish
        }) => {
          this.testSessionSpan.setTag(TEST_STATUS, status);
          this.testModuleSpan.setTag(TEST_STATUS, status);
          if (error) {
            this.testModuleSpan.setTag("error", error);
            this.testSessionSpan.setTag("error", error);
          }
          if (testCodeCoverageLinesTotal !== void 0) {
            this.testModuleSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal);
            this.testSessionSpan.setTag(TEST_CODE_COVERAGE_LINES_PCT, testCodeCoverageLinesTotal);
          }
          if (isEarlyFlakeDetectionEnabled) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, "true");
          }
          if (isEarlyFlakeDetectionFaulty) {
            this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, "faulty");
          }
          if (isTestManagementTestsEnabled) {
            this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, "true");
          }
          this.testModuleSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "module");
          this.testSessionSpan.finish();
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "session");
          finishAllTraceSpans(this.testSessionSpan);
          this.telemetry.count(TELEMETRY_TEST_SESSION, {
            provider: this.ciProviderName,
            autoInjected: !!getEnvironmentVariable("DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER")
          });
          this.tracer._exporter.flush(onFinish);
        });
      }
      getTestProperties(testManagementTests, testSuite, testName) {
        const { attempt_to_fix: isAttemptToFix, disabled: isDisabled, quarantined: isQuarantined } = testManagementTests?.vitest?.suites?.[testSuite]?.tests?.[testName]?.properties || {};
        return { isAttemptToFix, isDisabled, isQuarantined };
      }
    };
    module2.exports = VitestPlugin;
  }
});

// ../../packages/datadog-plugin-aerospike/src/index.js
var require_src24 = __commonJS({
  "../../packages/datadog-plugin-aerospike/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var DatabasePlugin = require_database();
    var AEROSPIKE_PEER_SERVICE = "aerospike.namespace";
    var AerospikePlugin = class extends DatabasePlugin {
      static id = "aerospike";
      static operation = "command";
      static system = "aerospike";
      static prefix = "tracing:apm:aerospike:command";
      static peerServicePrecursors = [AEROSPIKE_PEER_SERVICE];
      bindStart(ctx) {
        const { commandName, commandArgs } = ctx;
        const resourceName = commandName.slice(0, commandName.indexOf("Command"));
        const store = storage("legacy").getStore();
        const childOf = store ? store.span : null;
        const meta = getMeta(resourceName, commandArgs);
        const span = this.startSpan(this.operationName(), {
          childOf,
          service: this.serviceName({ pluginConfig: this.config }),
          type: "aerospike",
          kind: "client",
          resource: resourceName,
          meta
        }, false);
        ctx.parentStore = store;
        ctx.currentStore = { ...store, span };
        return ctx.currentStore;
      }
      bindAsyncStart(ctx) {
        if (ctx.currentStore) {
          this.tagPeerService(ctx.currentStore.span);
          ctx.currentStore.span.finish();
        }
        return ctx.parentStore;
      }
      end(ctx) {
        if (ctx.result) {
          this.tagPeerService(ctx.currentStore.span);
          ctx.currentStore.span.finish();
        }
      }
      error(ctx) {
        if (ctx.error) {
          const error = ctx.error;
          const span = ctx.currentStore.span;
          span.setTag("error", error);
        }
      }
    };
    function getMeta(resourceName, commandArgs) {
      let meta = {};
      if (resourceName.includes("Index")) {
        const [ns, set2, bin, exp, index] = commandArgs;
        meta = commandArgs.length > 8 ? getMetaForIndex(ns, set2, bin, index) : getMetaForIndex(ns, set2, bin, exp);
      } else if (resourceName === "Query") {
        const { ns, set: set2 } = commandArgs[2];
        meta = getMetaForQuery({ ns, set: set2 });
      } else if (isKeyObject(commandArgs[0])) {
        const { ns, set: set2, key } = commandArgs[0];
        meta = getMetaForKey(ns, set2, key);
      }
      return meta;
    }
    function getMetaForIndex(ns, set2, bin, index) {
      return {
        [AEROSPIKE_PEER_SERVICE]: ns,
        "aerospike.setname": set2,
        "aerospike.bin": bin,
        "aerospike.index": index
      };
    }
    function getMetaForKey(ns, set2, key) {
      return {
        "aerospike.key": `${ns}:${set2}:${key}`,
        [AEROSPIKE_PEER_SERVICE]: ns,
        "aerospike.setname": set2,
        "aerospike.userkey": key
      };
    }
    function getMetaForQuery(queryObj) {
      const { ns, set: set2 } = queryObj;
      return {
        [AEROSPIKE_PEER_SERVICE]: ns,
        "aerospike.setname": set2
      };
    }
    function isKeyObject(obj) {
      return obj && obj.ns !== void 0 && obj.set !== void 0 && obj.key !== void 0;
    }
    module2.exports = AerospikePlugin;
  }
});

// ../../packages/datadog-plugin-ai/src/utils.js
var require_utils6 = __commonJS({
  "../../packages/datadog-plugin-ai/src/utils.js"(exports2, module2) {
    "use strict";
    var { parseModelId } = require_utils4();
    function getModelProvider(tags) {
      const modelProviderTag = tags["ai.model.provider"];
      const providerParts = modelProviderTag?.split(".");
      const provider = providerParts?.[0];
      if (provider === "amazon-bedrock") {
        const modelId = tags["ai.model.id"];
        const model = modelId && parseModelId(modelId);
        return model?.modelProvider ?? provider;
      }
      return provider;
    }
    module2.exports = {
      getModelProvider
    };
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/ai/util.js
var require_util9 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/ai/util.js"(exports2, module2) {
    "use strict";
    var MODEL_METADATA_KEYS = /* @__PURE__ */ new Set([
      "frequency_penalty",
      "max_tokens",
      "presence_penalty",
      "temperature",
      "top_p",
      "top_k",
      "stop_sequences"
    ]);
    function getSpanTags(ctx) {
      const span = ctx.currentStore?.span;
      const carrier = ctx.attributes ?? span?.context()._tags ?? {};
      return carrier;
    }
    function getOperation(span) {
      const name = span._name;
      if (!name) return;
      return name.split(".").pop();
    }
    function getUsage(tags) {
      const usage = {};
      const inputTokens = tags["ai.usage.inputTokens"] ?? tags["ai.usage.promptTokens"];
      const outputTokens = tags["ai.usage.outputTokens"] ?? tags["ai.usage.completionTokens"];
      if (inputTokens != null) usage.inputTokens = inputTokens;
      if (outputTokens != null) usage.outputTokens = outputTokens;
      const totalTokens = tags["ai.usage.totalTokens"] ?? inputTokens + outputTokens;
      if (!Number.isNaN(totalTokens)) usage.totalTokens = totalTokens;
      return usage;
    }
    function getJsonStringValue(str, defaultValue) {
      let maybeValue = defaultValue;
      try {
        maybeValue = JSON.parse(str);
      } catch {
      }
      return maybeValue;
    }
    function getModelMetadata(tags) {
      const modelMetadata = {};
      for (const metadata of MODEL_METADATA_KEYS) {
        const metadataTagKey = `gen_ai.request.${metadata}`;
        const metadataValue = tags[metadataTagKey];
        if (metadataValue) {
          modelMetadata[metadata] = metadataValue;
        }
      }
      return Object.keys(modelMetadata).length ? modelMetadata : null;
    }
    function getGenerationMetadata(tags) {
      const metadata = {};
      for (const tag of Object.keys(tags)) {
        if (!tag.startsWith("ai.settings")) continue;
        const settingKey = tag.split(".").pop();
        const transformedKey = settingKey.replaceAll(/[A-Z]/g, (letter) => "_" + letter.toLowerCase());
        if (MODEL_METADATA_KEYS.has(transformedKey)) continue;
        const settingValue = tags[tag];
        metadata[settingKey] = settingValue;
      }
      return Object.keys(metadata).length ? metadata : null;
    }
    function getToolNameFromTags(tags) {
      const toolName = tags["ai.toolCall.name"];
      if (!toolName) return null;
      const parsedToolName = Number.parseInt(toolName);
      if (!Number.isNaN(parsedToolName)) return null;
      return toolName;
    }
    function getToolCallResultContent(content) {
      const { output, result } = content;
      if (output) {
        if (output.type === "text") {
          return output.value;
        } else if (output.type === "json") {
          return JSON.stringify(output.value);
        }
        return "[Unparsable Tool Result]";
      } else if (result) {
        if (typeof result === "string") {
          return result;
        }
        try {
          return JSON.stringify(result);
        } catch {
          return "[Unparsable Tool Result]";
        }
      } else {
        return "[Unsupported Tool Result]";
      }
    }
    function getLlmObsSpanName(operation, functionId) {
      return functionId ? `${functionId}.${operation}` : operation;
    }
    module2.exports = {
      getSpanTags,
      getOperation,
      getUsage,
      getJsonStringValue,
      getModelMetadata,
      getGenerationMetadata,
      getToolNameFromTags,
      getToolCallResultContent,
      getLlmObsSpanName
    };
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/ai/index.js
var require_ai2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/ai/index.js"(exports2, module2) {
    "use strict";
    var BaseLLMObsPlugin = require_base();
    var { getModelProvider } = require_utils6();
    var { channel } = require_dc_polyfill();
    var toolCreationCh = channel("dd-trace:vercel-ai:tool");
    var setAttributesCh = channel("dd-trace:vercel-ai:span:setAttributes");
    var { MODEL_NAME, MODEL_PROVIDER, NAME } = require_tags3();
    var {
      getSpanTags,
      getOperation,
      getUsage,
      getJsonStringValue,
      getModelMetadata,
      getGenerationMetadata,
      getToolNameFromTags,
      getToolCallResultContent,
      getLlmObsSpanName
    } = require_util9();
    var SPAN_NAME_TO_KIND_MAPPING = {
      // embeddings
      embed: "workflow",
      embedMany: "workflow",
      doEmbed: "embedding",
      // object generation
      generateObject: "workflow",
      streamObject: "workflow",
      // text generation
      generateText: "workflow",
      streamText: "workflow",
      // llm operations
      doGenerate: "llm",
      doStream: "llm",
      // tools
      toolCall: "tool"
    };
    var VercelAILLMObsPlugin = class extends BaseLLMObsPlugin {
      static id = "ai";
      static integration = "ai";
      static prefix = "tracing:dd-trace:vercel-ai";
      /**
       * The available tools within the runtime scope of this integration.
       * This essentially acts as a global registry for all tools made through the Vercel AI SDK.
       * @type {Set<Record<string, any>>}
       */
      #availableTools;
      /**
       * A mapping of tool call IDs to tool names.
       * This is used to map the tool call ID to the tool name for the output message.
       * @type {Record<string, string>}
       */
      #toolCallIdsToName;
      constructor(...args) {
        super(...args);
        this.#toolCallIdsToName = {};
        this.#availableTools = /* @__PURE__ */ new Set();
        toolCreationCh.subscribe((toolArgs) => {
          this.#availableTools.add(toolArgs);
        });
        setAttributesCh.subscribe(({ ctx, attributes }) => {
          Object.assign(ctx.attributes, attributes);
        });
      }
      /**
       * Does a best-effort attempt to find the right tool name for the given tool description.
       * This is because the Vercel AI SDK does not tag tools by name properly, but
       * rather by the index they were passed in. Tool names appear nowhere in the span tags.
       *
       * We use the tool description as the next best identifier for a tool.
       *
       * @param {string} toolDescription
       * @returns {string | undefined}
       */
      findToolName(toolDescription) {
        for (const availableTool of this.#availableTools) {
          const description = availableTool.description;
          if (description === toolDescription && availableTool.id) {
            return availableTool.id;
          }
        }
      }
      /**
       * @override
       */
      getLLMObsSpanRegisterOptions(ctx) {
        const span = ctx.currentStore?.span;
        const operation = getOperation(span);
        const kind = SPAN_NAME_TO_KIND_MAPPING[operation];
        if (!kind) return;
        return { kind, name: getLlmObsSpanName(operation, ctx.attributes["ai.telemetry.functionId"]) };
      }
      /**
       * @override
       */
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span;
        if (!span) return;
        const operation = getOperation(span);
        const kind = SPAN_NAME_TO_KIND_MAPPING[operation];
        if (!kind) return;
        const tags = getSpanTags(ctx);
        if (["embedding", "llm"].includes(kind)) {
          this._tagger._setTag(span, MODEL_NAME, tags["ai.model.id"]);
          this._tagger._setTag(span, MODEL_PROVIDER, getModelProvider(tags));
        }
        switch (operation) {
          case "embed":
          case "embedMany":
            this.setEmbeddingWorkflowTags(span, tags);
            break;
          case "doEmbed":
            this.setEmbeddingTags(span, tags);
            break;
          case "generateObject":
          case "streamObject":
            this.setObjectGenerationTags(span, tags);
            break;
          case "generateText":
          case "streamText":
            this.setTextGenerationTags(span, tags);
            break;
          case "doGenerate":
          case "doStream":
            this.setLLMOperationTags(span, tags);
            break;
          case "toolCall":
            this.setToolTags(span, tags);
            break;
          default:
            break;
        }
      }
      setEmbeddingWorkflowTags(span, tags) {
        const inputs = tags["ai.value"] ?? tags["ai.values"];
        const parsedInputs = Array.isArray(inputs) ? inputs.map((input) => getJsonStringValue(input, "")) : getJsonStringValue(inputs, "");
        const embeddingsOutput = tags["ai.embedding"] ?? tags["ai.embeddings"];
        const isSingleEmbedding = !Array.isArray(embeddingsOutput);
        const numberOfEmbeddings = isSingleEmbedding ? 1 : embeddingsOutput.length;
        const embeddingsLength = getJsonStringValue(isSingleEmbedding ? embeddingsOutput : embeddingsOutput?.[0], []).length;
        const output = `[${numberOfEmbeddings} embedding(s) returned with size ${embeddingsLength}]`;
        this._tagger.tagTextIO(span, parsedInputs, output);
        const metadata = getGenerationMetadata(tags);
        this._tagger.tagMetadata(span, metadata);
      }
      setEmbeddingTags(span, tags) {
        const inputs = tags["ai.values"];
        if (!Array.isArray(inputs)) return;
        const parsedInputs = inputs.map((input) => getJsonStringValue(input, ""));
        const embeddingsOutput = tags["ai.embeddings"];
        const numberOfEmbeddings = embeddingsOutput?.length;
        const embeddingsLength = getJsonStringValue(embeddingsOutput?.[0], []).length;
        const output = `[${numberOfEmbeddings} embedding(s) returned with size ${embeddingsLength}]`;
        this._tagger.tagEmbeddingIO(span, parsedInputs, output);
        const usage = tags["ai.usage.tokens"];
        this._tagger.tagMetrics(span, {
          inputTokens: usage,
          totalTokens: usage
        });
      }
      setObjectGenerationTags(span, tags) {
        const promptInfo = getJsonStringValue(tags["ai.prompt"], {});
        const lastUserPrompt = promptInfo.prompt ?? promptInfo.messages.reverse().find((message) => message.role === "user")?.content;
        const prompt = Array.isArray(lastUserPrompt) ? lastUserPrompt.map((part) => part.text ?? "").join("") : lastUserPrompt;
        const output = tags["ai.response.object"];
        this._tagger.tagTextIO(span, prompt, output);
        const metadata = getGenerationMetadata(tags) ?? {};
        metadata.schema = getJsonStringValue(tags["ai.schema"], {});
        this._tagger.tagMetadata(span, metadata);
      }
      setTextGenerationTags(span, tags) {
        const promptInfo = getJsonStringValue(tags["ai.prompt"], {});
        const lastUserPrompt = promptInfo.prompt ?? promptInfo.messages.reverse().find((message) => message.role === "user")?.content;
        const prompt = Array.isArray(lastUserPrompt) ? lastUserPrompt.map((part) => part.text ?? "").join("") : lastUserPrompt;
        const output = tags["ai.response.text"];
        this._tagger.tagTextIO(span, prompt, output);
        const metadata = getGenerationMetadata(tags);
        this._tagger.tagMetadata(span, metadata);
      }
      /**
       * @param {import('../../../opentracing/span')} span
       * @param {Record<string, unknown>} tags
       */
      setLLMOperationTags(span, tags) {
        const toolsForModel = tags["ai.prompt.tools"]?.map(getJsonStringValue);
        const inputMessages = getJsonStringValue(tags["ai.prompt.messages"], []);
        const parsedInputMessages = [];
        for (const message of inputMessages) {
          const formattedMessages = this.formatMessage(message, toolsForModel);
          parsedInputMessages.push(...formattedMessages);
        }
        const outputMessage = this.formatOutputMessage(tags, toolsForModel);
        this._tagger.tagLLMIO(span, parsedInputMessages, outputMessage);
        const metadata = getModelMetadata(tags);
        this._tagger.tagMetadata(span, metadata);
        const usage = getUsage(tags);
        this._tagger.tagMetrics(span, usage);
      }
      setToolTags(span, tags) {
        const toolCallId = tags["ai.toolCall.id"];
        const name = getToolNameFromTags(tags) ?? this.#toolCallIdsToName[toolCallId];
        if (name) this._tagger._setTag(span, NAME, name);
        const input = tags["ai.toolCall.args"];
        const output = tags["ai.toolCall.result"];
        this._tagger.tagTextIO(span, input, output);
      }
      formatOutputMessage(tags, toolsForModel) {
        const outputMessageText = tags["ai.response.text"] ?? tags["ai.response.object"];
        const outputMessageToolCalls = getJsonStringValue(tags["ai.response.toolCalls"], []);
        const formattedToolCalls = [];
        for (const toolCall of outputMessageToolCalls) {
          const toolCallArgs = getJsonStringValue(toolCall.args, {});
          const toolDescription = toolsForModel?.find((tool) => toolCall.toolName === tool.name)?.description;
          const name = this.findToolName(toolDescription);
          this.#toolCallIdsToName[toolCall.toolCallId] = name;
          formattedToolCalls.push({
            arguments: toolCallArgs,
            name,
            toolId: toolCall.toolCallId,
            type: "function"
          });
        }
        return {
          role: "assistant",
          content: outputMessageText,
          toolCalls: formattedToolCalls
        };
      }
      /**
       * Returns a list of formatted messages from a message object.
       * Most of these will just be one entry, but in the case of a "tool" role,
       * it is possible to have multiple tool call results in a single message that we
       * need to split into multiple messages.
       *
       * @param {*} message
       * @param {*} toolsForModel
       * @returns {Array<{role: string, content: string, toolId?: string,
       *   toolCalls?: Array<{arguments: string, name: string, toolId: string, type: string}>}>}
       */
      formatMessage(message, toolsForModel) {
        const { role, content } = message;
        if (role === "system") {
          return [{ role, content }];
        } else if (role === "user") {
          let finalContent = "";
          for (const part of content) {
            const { type } = part;
            if (type === "text") {
              finalContent += part.text;
            }
          }
          return [{ role, content: finalContent }];
        } else if (role === "assistant") {
          const toolCalls = [];
          let finalContent = "";
          for (const part of content) {
            const { type } = part;
            if (["text", "reasoning", "redacted-reasoning"].includes(type)) {
              finalContent += part.text ?? part.data;
            } else if (type === "tool-call") {
              const toolDescription = toolsForModel?.find((tool) => part.toolName === tool.name)?.description;
              const name = this.findToolName(toolDescription);
              toolCalls.push({
                arguments: part.args,
                name,
                toolId: part.toolCallId,
                type: "function"
              });
            }
          }
          const finalMessage = {
            role,
            content: finalContent
          };
          if (toolCalls.length) {
            finalMessage.toolCalls = toolCalls.length ? toolCalls : void 0;
          }
          return [finalMessage];
        } else if (role === "tool") {
          const finalMessages = [];
          for (const part of content) {
            if (part.type === "tool-result") {
              const safeResult = getToolCallResultContent(part);
              finalMessages.push({
                role,
                content: safeResult,
                toolId: part.toolCallId
              });
            }
          }
          return finalMessages;
        }
        return [];
      }
    };
    module2.exports = VercelAILLMObsPlugin;
  }
});

// ../../packages/datadog-plugin-ai/src/tracing.js
var require_tracing6 = __commonJS({
  "../../packages/datadog-plugin-ai/src/tracing.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var { getModelProvider } = require_utils6();
    var VercelAITracingPlugin = class extends TracingPlugin {
      static id = "ai";
      static prefix = "tracing:dd-trace:vercel-ai";
      bindStart(ctx) {
        const { attributes, name } = ctx;
        const model = attributes["ai.model.id"];
        const modelProvider = getModelProvider(attributes);
        this.startSpan(name, {
          meta: {
            "resource.name": attributes["resource.name"] ?? name,
            "ai.request.model": model,
            "ai.request.model_provider": modelProvider
          }
        }, ctx);
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        const span = ctx.currentStore?.span;
        span?.finish();
      }
    };
    module2.exports = VercelAITracingPlugin;
  }
});

// ../../packages/datadog-plugin-ai/src/index.js
var require_src25 = __commonJS({
  "../../packages/datadog-plugin-ai/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var VercelAILLMObsPlugin = require_ai2();
    var VercelAITracingPlugin = require_tracing6();
    var VercelAIPlugin = class extends CompositePlugin {
      static get id() {
        return "ai";
      }
      static get plugins() {
        return {
          llmobs: VercelAILLMObsPlugin,
          tracing: VercelAITracingPlugin
        };
      }
    };
    module2.exports = VercelAIPlugin;
  }
});

// ../../packages/datadog-plugin-amqp10/src/util.js
var require_util10 = __commonJS({
  "../../packages/datadog-plugin-amqp10/src/util.js"(exports2, module2) {
    "use strict";
    function getAddress(link) {
      if (!link || !link.session || !link.session.connection) return {};
      return link.session.connection.address || {};
    }
    function getShortName(link) {
      if (!link || !link.name) return null;
      return link.name.split("_").slice(0, -1).join("_");
    }
    module2.exports = { getAddress, getShortName };
  }
});

// ../../packages/datadog-plugin-amqp10/src/producer.js
var require_producer5 = __commonJS({
  "../../packages/datadog-plugin-amqp10/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var { CLIENT_PORT_KEY } = require_constants3();
    var { getAddress, getShortName } = require_util10();
    var Amqp10ProducerPlugin = class extends ProducerPlugin {
      static id = "amqp10";
      static operation = "send";
      static system = "amqp";
      bindStart(ctx) {
        const { link } = ctx;
        const address = getAddress(link);
        const target = getShortName(link);
        this.startSpan({
          resource: ["send", target].filter(Boolean).join(" "),
          meta: {
            "amqp.link.target.address": target,
            "amqp.link.role": "sender",
            "out.host": address.host,
            [CLIENT_PORT_KEY]: address.port,
            "amqp.link.name": link.name,
            "amqp.link.handle": link.handle,
            "amqp.connection.host": address.host,
            "amqp.connection.port": address.port,
            "amqp.connection.user": address.user
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = Amqp10ProducerPlugin;
  }
});

// ../../packages/datadog-plugin-amqp10/src/consumer.js
var require_consumer3 = __commonJS({
  "../../packages/datadog-plugin-amqp10/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var { getAddress, getShortName } = require_util10();
    var Amqp10ConsumerPlugin = class extends ConsumerPlugin {
      static id = "amqp10";
      static system = "amqp";
      bindStart(ctx) {
        const { link } = ctx;
        const source = getShortName(link);
        const address = getAddress(link);
        this.startSpan({
          resource: ["receive", source].filter(Boolean).join(" "),
          type: "worker",
          meta: {
            "amqp.link.source.address": source,
            "amqp.link.role": "receiver",
            "amqp.link.name": link.name,
            "amqp.link.handle": link.handle,
            "amqp.connection.host": address.host,
            "amqp.connection.port": address.port,
            "amqp.connection.user": address.user
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = Amqp10ConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-amqp10/src/index.js
var require_src26 = __commonJS({
  "../../packages/datadog-plugin-amqp10/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer5();
    var ConsumerPlugin = require_consumer3();
    var CompositePlugin = require_composite2();
    var Amqp10Plugin = class extends CompositePlugin {
      static id = "amqp10";
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin
        };
      }
    };
    module2.exports = Amqp10Plugin;
  }
});

// ../../packages/datadog-plugin-amqplib/src/util.js
var require_util11 = __commonJS({
  "../../packages/datadog-plugin-amqplib/src/util.js"(exports2, module2) {
    "use strict";
    function getResourceName(method, fields = {}) {
      return [
        method,
        fields.exchange,
        fields.routingKey,
        fields.queue,
        fields.source,
        fields.destination
      ].filter(Boolean).join(" ");
    }
    module2.exports = { getResourceName };
  }
});

// ../../packages/datadog-plugin-amqplib/src/producer.js
var require_producer6 = __commonJS({
  "../../packages/datadog-plugin-amqplib/src/producer.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var { CLIENT_PORT_KEY } = require_constants3();
    var ProducerPlugin = require_producer();
    var { DsmPathwayCodec, getAmqpMessageSize } = require_datastreams();
    var { getResourceName } = require_util11();
    var AmqplibProducerPlugin = class extends ProducerPlugin {
      static id = "amqplib";
      static operation = "publish";
      bindStart(ctx) {
        const { channel = {}, method, fields, message } = ctx;
        if (method !== "basic.publish") return;
        const stream = channel.connection && channel.connection.stream || {};
        const span = this.startSpan({
          resource: getResourceName(method, fields),
          meta: {
            "out.host": stream._host,
            [CLIENT_PORT_KEY]: stream.remotePort,
            "amqp.queue": fields.queue,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        }, ctx);
        fields.headers = fields.headers || {};
        this.tracer.inject(span, TEXT_MAP, fields.headers);
        if (this.config.dsmEnabled) {
          const hasRoutingKey = fields.routingKey != null;
          const payloadSize = getAmqpMessageSize({ content: message, headers: fields.headers });
          const exchangeOrTopicTag = hasRoutingKey && !fields.exchange ? `topic:${fields.routingKey}` : `exchange:${fields.exchange}`;
          const dataStreamsContext = this.tracer.setCheckpoint(
            ["direction:out", exchangeOrTopicTag, `has_routing_key:${hasRoutingKey}`, "type:rabbitmq"],
            span,
            payloadSize
          );
          DsmPathwayCodec.encode(dataStreamsContext, fields.headers);
        }
        return ctx.currentStore;
      }
    };
    module2.exports = AmqplibProducerPlugin;
  }
});

// ../../packages/datadog-plugin-amqplib/src/consumer.js
var require_consumer4 = __commonJS({
  "../../packages/datadog-plugin-amqplib/src/consumer.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var ConsumerPlugin = require_consumer();
    var { getAmqpMessageSize } = require_datastreams();
    var { getResourceName } = require_util11();
    var AmqplibConsumerPlugin = class extends ConsumerPlugin {
      static id = "amqplib";
      static operation = "consume";
      bindStart(ctx) {
        const { method, fields = {}, message, queue } = ctx;
        if (method !== "basic.deliver" && method !== "basic.get") return;
        const childOf = extract(this.tracer, message);
        const queueName = queue || fields.queue || fields.routingKey;
        const span = this.startSpan({
          childOf,
          resource: getResourceName(method, fields),
          type: "worker",
          meta: {
            "amqp.queue": queueName,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        }, ctx);
        if (this.config.dsmEnabled && message?.properties?.headers) {
          const payloadSize = getAmqpMessageSize({ headers: message.properties.headers, content: message.content });
          this.tracer.decodeDataStreamsContext(message.properties.headers);
          this.tracer.setCheckpoint(["direction:in", `topic:${queueName}`, "type:rabbitmq"], span, payloadSize);
        }
        return ctx.currentStore;
      }
    };
    function extract(tracer2, message) {
      return message ? tracer2.extract(TEXT_MAP, message.properties.headers) : null;
    }
    module2.exports = AmqplibConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-amqplib/src/client.js
var require_client9 = __commonJS({
  "../../packages/datadog-plugin-amqplib/src/client.js"(exports2, module2) {
    "use strict";
    var { TEXT_MAP } = require_formats();
    var { CLIENT_PORT_KEY } = require_constants3();
    var ClientPlugin = require_client5();
    var { getResourceName } = require_util11();
    var AmqplibClientPlugin = class extends ClientPlugin {
      static id = "amqplib";
      static type = "messaging";
      static operation = "command";
      bindStart(ctx) {
        const { channel = {}, method, fields } = ctx;
        if (method === "basic.deliver" || method === "basic.get") return;
        if (method === "basic.publish") return;
        const stream = channel.connection && channel.connection.stream || {};
        const span = this.startSpan(this.operationName(), {
          service: this.config.service || this.serviceName(),
          resource: getResourceName(method, fields),
          kind: this.constructor.kind,
          meta: {
            "out.host": stream._host,
            [CLIENT_PORT_KEY]: stream.remotePort,
            "amqp.queue": fields.queue,
            "amqp.exchange": fields.exchange,
            "amqp.routingKey": fields.routingKey,
            "amqp.consumerTag": fields.consumerTag,
            "amqp.source": fields.source,
            "amqp.destination": fields.destination
          }
        }, ctx);
        fields.headers = fields.headers || {};
        this.tracer.inject(span, TEXT_MAP, fields.headers);
        return ctx.currentStore;
      }
    };
    module2.exports = AmqplibClientPlugin;
  }
});

// ../../packages/datadog-plugin-amqplib/src/index.js
var require_src27 = __commonJS({
  "../../packages/datadog-plugin-amqplib/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer6();
    var ConsumerPlugin = require_consumer4();
    var ClientPlugin = require_client9();
    var CompositePlugin = require_composite2();
    var AmqplibPlugin = class extends CompositePlugin {
      static id = "amqplib";
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          client: ClientPlugin
        };
      }
    };
    module2.exports = AmqplibPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/schema.js
var require_schema2 = __commonJS({
  "../../packages/dd-trace/src/plugins/schema.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var SERIALIZATION = "serialization";
    var DESERIALIZATION = "deserialization";
    var SchemaPlugin = class extends Plugin {
      constructor(...args) {
        super(...args);
        this.addSub(`apm:${this.constructor.id}:serialize-start`, this.handleSerializeStart.bind(this));
        this.addSub(`apm:${this.constructor.id}:deserialize-end`, this.handleDeserializeFinish.bind(this));
      }
      handleSerializeStart(args) {
        const activeSpan = this.tracer.scope().active();
        if (activeSpan && this.config.dsmEnabled) {
          this.constructor.schemaExtractor.attachSchemaOnSpan(
            args,
            activeSpan,
            SERIALIZATION,
            this.tracer
          );
        }
      }
      handleDeserializeFinish(args) {
        const activeSpan = this.tracer.scope().active();
        if (activeSpan && this.config.dsmEnabled) {
          this.constructor.schemaExtractor.attachSchemaOnSpan(
            args,
            activeSpan,
            DESERIALIZATION,
            this.tracer
          );
        }
      }
    };
    module2.exports = SchemaPlugin;
  }
});

// ../../packages/datadog-plugin-avsc/src/schema_iterator.js
var require_schema_iterator = __commonJS({
  "../../packages/datadog-plugin-avsc/src/schema_iterator.js"(exports2, module2) {
    "use strict";
    var AVRO = "avro";
    var {
      SCHEMA_DEFINITION,
      SCHEMA_ID,
      SCHEMA_NAME,
      SCHEMA_OPERATION,
      SCHEMA_WEIGHT,
      SCHEMA_TYPE
    } = require_constants3();
    var log = require_log2();
    var {
      SchemaBuilder
    } = require_datastreams();
    var SchemaExtractor = class _SchemaExtractor {
      constructor(schema) {
        this.schema = schema;
      }
      static getType(type) {
        const typeMapping = {
          string: "string",
          int: "integer",
          long: "integer",
          float: "number",
          double: "number",
          boolean: "boolean",
          bytes: "string",
          record: "object",
          enum: "string",
          array: "array",
          map: "object",
          fixed: "string"
        };
        const typeName = type.typeName ?? type.name ?? type;
        return typeName === "null" ? typeName : typeMapping[typeName] || "string";
      }
      static extractProperty(field, schemaName, fieldName, builder, depth) {
        let array = false;
        let type;
        let format;
        let enumValues;
        let description;
        let ref;
        const fieldType = field.type?.types ?? field.type?.typeName ?? field.type;
        if (Array.isArray(fieldType)) {
          type = "union[" + fieldType.map((t) => _SchemaExtractor.getType(t.type || t)).join(",") + "]";
        } else if (fieldType === "array") {
          array = true;
          const nestedType = field.type.itemsType.typeName;
          type = _SchemaExtractor.getType(nestedType);
        } else if (fieldType === "record") {
          type = "object";
          ref = `#/components/schemas/${field.type.name}`;
          if (!_SchemaExtractor.extractSchema(field.type, builder, depth + 1, this)) {
            return false;
          }
        } else if (fieldType === "enum") {
          enumValues = [];
          let i = 0;
          type = "string";
          while (field.type.symbols[i]) {
            enumValues.push(field.type.symbols[i]);
            i += 1;
          }
        } else {
          type = _SchemaExtractor.getType(fieldType.type || fieldType);
          if (fieldType === "bytes") {
            format = "byte";
          } else if (fieldType === "int") {
            format = "int32";
          } else if (fieldType === "long") {
            format = "int64";
          } else if (fieldType === "float") {
            format = "float";
          } else if (fieldType === "double") {
            format = "double";
          }
        }
        return builder.addProperty(schemaName, fieldName, array, type, description, ref, format, enumValues);
      }
      static extractSchema(schema, builder, depth, extractor) {
        depth += 1;
        const schemaName = schema.name;
        if (extractor) {
          const nestedSchemaExtractor = new _SchemaExtractor(schema);
          builder.iterator = nestedSchemaExtractor;
          const nestedSchema = SchemaBuilder.getSchema(schemaName, nestedSchemaExtractor, builder);
          for (const nestedSubSchemaName in nestedSchema.components.schemas) {
            if (nestedSchema.components.schemas.hasOwnProperty(nestedSubSchemaName)) {
              builder.schema.components.schemas[nestedSubSchemaName] = nestedSchema.components.schemas[nestedSubSchemaName];
            }
          }
          return true;
        }
        if (!builder.shouldExtractSchema(schemaName, depth)) {
          return false;
        }
        if (schema.fields?.[Symbol.iterator]) {
          for (const field of schema.fields) {
            if (!this.extractProperty(field, schemaName, field.name, builder, depth)) {
              log.warn(
                "DSM: Unable to extract field with name: %s from Avro schema with name: %s",
                field.name,
                schemaName
              );
            }
          }
        } else {
          log.warn("DSM: schema.fields is not iterable from Avro schema with name: %s", schemaName);
        }
        return true;
      }
      static extractSchemas(descriptor, dataStreamsProcessor) {
        return dataStreamsProcessor.getSchema(descriptor.name, new _SchemaExtractor(descriptor));
      }
      iterateOverSchema(builder) {
        this.constructor.extractSchema(this.schema, builder, 0);
      }
      static attachSchemaOnSpan(args, span, operation, tracer2) {
        const { messageClass } = args;
        const descriptor = messageClass?.constructor?.type ?? messageClass;
        if (!descriptor || !span) {
          return;
        }
        if (span.context()._tags[SCHEMA_TYPE] && operation === "serialization") {
          return;
        }
        span.setTag(SCHEMA_TYPE, AVRO);
        span.setTag(SCHEMA_NAME, descriptor.name);
        span.setTag(SCHEMA_OPERATION, operation);
        if (!tracer2._dataStreamsProcessor.canSampleSchema(operation)) {
          return;
        }
        if (!tracer2._prioritySampler.isSampled(span)) {
          return;
        }
        const weight = tracer2._dataStreamsProcessor.trySampleSchema(operation);
        if (weight === 0) {
          return;
        }
        const schemaData = SchemaBuilder.getSchemaDefinition(
          this.extractSchemas(descriptor, tracer2._dataStreamsProcessor)
        );
        span.setTag(SCHEMA_DEFINITION, schemaData.definition);
        span.setTag(SCHEMA_WEIGHT, weight);
        span.setTag(SCHEMA_ID, schemaData.id);
      }
    };
    module2.exports = SchemaExtractor;
  }
});

// ../../packages/datadog-plugin-avsc/src/index.js
var require_src28 = __commonJS({
  "../../packages/datadog-plugin-avsc/src/index.js"(exports2, module2) {
    "use strict";
    var SchemaPlugin = require_schema2();
    var SchemaExtractor = require_schema_iterator();
    var AvscPlugin = class extends SchemaPlugin {
      static id = "avsc";
      static schemaExtractor = SchemaExtractor;
    };
    module2.exports = AvscPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/log_plugin.js
var require_log_plugin = __commonJS({
  "../../packages/dd-trace/src/plugins/log_plugin.js"(exports2, module2) {
    "use strict";
    var { LOG } = require_formats();
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    function messageProxy(message, holder) {
      return new Proxy(message, {
        get(target, key) {
          if (shouldOverride(target, key)) {
            return holder.dd;
          }
          return target[key];
        },
        ownKeys(target) {
          const ownKeys = Reflect.ownKeys(target);
          if (!Object.hasOwn(target, "dd") && Reflect.isExtensible(target)) {
            ownKeys.push("dd");
          }
          return ownKeys;
        },
        getOwnPropertyDescriptor(target, p) {
          return Reflect.getOwnPropertyDescriptor(shouldOverride(target, p) ? holder : target, p);
        }
      });
    }
    function shouldOverride(target, p) {
      return p === "dd" && !Object.hasOwn(target, p) && Reflect.isExtensible(target);
    }
    module2.exports = class LogPlugin extends Plugin {
      constructor(...args) {
        super(...args);
        this.addSub(`apm:${this.constructor.id}:log`, (arg) => {
          const span = storage("legacy").getStore()?.span;
          const holder = {};
          this.tracer.inject(span, LOG, holder);
          arg.message = messageProxy(arg.message, holder);
        });
      }
      configure(config) {
        return super.configure({
          ...config,
          enabled: config.enabled && (config.logInjection || config.ciVisAgentlessLogSubmissionEnabled)
        });
      }
    };
  }
});

// ../../packages/datadog-plugin-bunyan/src/index.js
var require_src29 = __commonJS({
  "../../packages/datadog-plugin-bunyan/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var BunyanPlugin = class extends LogPlugin {
      static id = "bunyan";
    };
    module2.exports = BunyanPlugin;
  }
});

// ../../packages/datadog-plugin-cassandra-driver/src/index.js
var require_src30 = __commonJS({
  "../../packages/datadog-plugin-cassandra-driver/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var CASSANDRA_CONTACT_POINTS_KEY = "db.cassandra.contact.points";
    var CassandraDriverPlugin = class extends DatabasePlugin {
      static id = "cassandra-driver";
      static system = "cassandra";
      static peerServicePrecursors = [CASSANDRA_CONTACT_POINTS_KEY];
      bindStart(ctx) {
        let { keyspace, query, contactPoints = {} } = ctx;
        if (Array.isArray(query)) {
          query = combine(query);
        }
        this.startSpan(this.operationName(), {
          service: this.serviceName({ pluginConfig: this.config, system: this.system }),
          resource: trim(query, 5e3),
          type: "cassandra",
          kind: "client",
          meta: {
            "db.type": "cassandra",
            "cassandra.query": query,
            "cassandra.keyspace": keyspace,
            [CASSANDRA_CONTACT_POINTS_KEY]: contactPoints.join(",") || null
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    function combine(queries) {
      return queries.map((query) => (query.query || query).replace(/;?$/, ";")).join(" ");
    }
    function trim(str, size) {
      if (!str || str.length <= size) return str;
      return `${str.slice(0, size - 3)}...`;
    }
    module2.exports = CassandraDriverPlugin;
  }
});

// ../../node_modules/shell-quote/parse.js
var require_parse = __commonJS({
  "../../node_modules/shell-quote/parse.js"(exports2, module2) {
    "use strict";
    var CONTROL = "(?:" + [
      "\\|\\|",
      "\\&\\&",
      ";;",
      "\\|\\&",
      "\\<\\(",
      "\\<\\<\\<",
      ">>",
      ">\\&",
      "<\\&",
      "[&;()|<>]"
    ].join("|") + ")";
    var controlRE = new RegExp("^" + CONTROL + "$");
    var META = "|&;()<> \\t";
    var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
    var DOUBLE_QUOTE = "'((\\\\'|[^'])*?)'";
    var hash = /^#$/;
    var SQ = "'";
    var DQ = '"';
    var DS = "$";
    var TOKEN = "";
    var mult = 4294967296;
    for (i = 0; i < 4; i++) {
      TOKEN += (mult * Math.random()).toString(16);
    }
    var i;
    var startsWithToken = new RegExp("^" + TOKEN);
    function matchAll(s, r) {
      var origIndex = r.lastIndex;
      var matches = [];
      var matchObj;
      while (matchObj = r.exec(s)) {
        matches.push(matchObj);
        if (r.lastIndex === matchObj.index) {
          r.lastIndex += 1;
        }
      }
      r.lastIndex = origIndex;
      return matches;
    }
    function getVar(env, pre, key) {
      var r = typeof env === "function" ? env(key) : env[key];
      if (typeof r === "undefined" && key != "") {
        r = "";
      } else if (typeof r === "undefined") {
        r = "$";
      }
      if (typeof r === "object") {
        return pre + TOKEN + JSON.stringify(r) + TOKEN;
      }
      return pre + r;
    }
    function parseInternal(string, env, opts) {
      if (!opts) {
        opts = {};
      }
      var BS = opts.escape || "\\";
      var BAREWORD = "(\\" + BS + `['"` + META + `]|[^\\s'"` + META + "])+";
      var chunker = new RegExp([
        "(" + CONTROL + ")",
        // control chars
        "(" + BAREWORD + "|" + SINGLE_QUOTE + "|" + DOUBLE_QUOTE + ")+"
      ].join("|"), "g");
      var matches = matchAll(string, chunker);
      if (matches.length === 0) {
        return [];
      }
      if (!env) {
        env = {};
      }
      var commented = false;
      return matches.map(function(match) {
        var s = match[0];
        if (!s || commented) {
          return void 0;
        }
        if (controlRE.test(s)) {
          return { op: s };
        }
        var quote = false;
        var esc = false;
        var out = "";
        var isGlob = false;
        var i2;
        function parseEnvVar() {
          i2 += 1;
          var varend;
          var varname;
          var char = s.charAt(i2);
          if (char === "{") {
            i2 += 1;
            if (s.charAt(i2) === "}") {
              throw new Error("Bad substitution: " + s.slice(i2 - 2, i2 + 1));
            }
            varend = s.indexOf("}", i2);
            if (varend < 0) {
              throw new Error("Bad substitution: " + s.slice(i2));
            }
            varname = s.slice(i2, varend);
            i2 = varend;
          } else if (/[*@#?$!_-]/.test(char)) {
            varname = char;
            i2 += 1;
          } else {
            var slicedFromI = s.slice(i2);
            varend = slicedFromI.match(/[^\w\d_]/);
            if (!varend) {
              varname = slicedFromI;
              i2 = s.length;
            } else {
              varname = slicedFromI.slice(0, varend.index);
              i2 += varend.index - 1;
            }
          }
          return getVar(env, "", varname);
        }
        for (i2 = 0; i2 < s.length; i2++) {
          var c = s.charAt(i2);
          isGlob = isGlob || !quote && (c === "*" || c === "?");
          if (esc) {
            out += c;
            esc = false;
          } else if (quote) {
            if (c === quote) {
              quote = false;
            } else if (quote == SQ) {
              out += c;
            } else {
              if (c === BS) {
                i2 += 1;
                c = s.charAt(i2);
                if (c === DQ || c === BS || c === DS) {
                  out += c;
                } else {
                  out += BS + c;
                }
              } else if (c === DS) {
                out += parseEnvVar();
              } else {
                out += c;
              }
            }
          } else if (c === DQ || c === SQ) {
            quote = c;
          } else if (controlRE.test(c)) {
            return { op: s };
          } else if (hash.test(c)) {
            commented = true;
            var commentObj = { comment: string.slice(match.index + i2 + 1) };
            if (out.length) {
              return [out, commentObj];
            }
            return [commentObj];
          } else if (c === BS) {
            esc = true;
          } else if (c === DS) {
            out += parseEnvVar();
          } else {
            out += c;
          }
        }
        if (isGlob) {
          return { op: "glob", pattern: out };
        }
        return out;
      }).reduce(function(prev, arg) {
        return typeof arg === "undefined" ? prev : prev.concat(arg);
      }, []);
    }
    module2.exports = function parse(s, env, opts) {
      var mapped = parseInternal(s, env, opts);
      if (typeof env !== "function") {
        return mapped;
      }
      return mapped.reduce(function(acc, s2) {
        if (typeof s2 === "object") {
          return acc.concat(s2);
        }
        var xs = s2.split(RegExp("(" + TOKEN + ".*?" + TOKEN + ")", "g"));
        if (xs.length === 1) {
          return acc.concat(xs[0]);
        }
        return acc.concat(xs.filter(Boolean).map(function(x) {
          if (startsWithToken.test(x)) {
            return JSON.parse(x.split(TOKEN)[1]);
          }
          return x;
        }));
      }, []);
    };
  }
});

// ../../packages/datadog-plugin-child_process/src/scrub-cmd-params.js
var require_scrub_cmd_params = __commonJS({
  "../../packages/datadog-plugin-child_process/src/scrub-cmd-params.js"(exports2, module2) {
    "use strict";
    var shellParser = require_parse();
    var ALLOWED_ENV_VARIABLES = /* @__PURE__ */ new Set(["LD_PRELOAD", "LD_LIBRARY_PATH", "PATH"]);
    var PROCESS_DENYLIST = /* @__PURE__ */ new Set(["md5"]);
    var VARNAMES_REGEX = /\$([\w\d_]*)(?:[^\w\d_]|$)/gmi;
    var PARAM_PATTERN = "^-{0,2}(?:p(?:ass(?:w(?:or)?d)?)?|address|api[-_]?key|e?mail|secret(?:[-_]?key)?|a(?:ccess|uth)[-_]?token|mysql_pwd|credentials|(?:stripe)?token)$";
    var regexParam = new RegExp(PARAM_PATTERN, "i");
    var ENV_PATTERN = String.raw`^(\w+=\w+;)*\w+=\w+;?$`;
    var envVarRegex = new RegExp(ENV_PATTERN);
    var REDACTED = "?";
    function extractVarNames(expression) {
      const varNames = /* @__PURE__ */ new Set();
      let match;
      while (match = VARNAMES_REGEX.exec(expression)) {
        varNames.add(match[1]);
      }
      const varNamesObject = {};
      for (const varName of varNames.keys()) {
        varNamesObject[varName] = `$${varName}`;
      }
      return varNamesObject;
    }
    function getTokensByExpression(expressionTokens) {
      const expressionListTokens = [];
      let wipExpressionTokens = [];
      let isNewExpression = true;
      expressionTokens.forEach((token) => {
        if (isNewExpression) {
          expressionListTokens.push(wipExpressionTokens);
          isNewExpression = false;
        }
        wipExpressionTokens.push(token);
        if (token.op) {
          wipExpressionTokens = [];
          isNewExpression = true;
        }
      });
      return expressionListTokens;
    }
    function scrubChildProcessCmd(expression) {
      const varNames = extractVarNames(expression);
      const expressionTokens = shellParser(expression, varNames);
      const expressionListTokens = getTokensByExpression(expressionTokens);
      const result = [];
      expressionListTokens.forEach((expressionTokens2) => {
        let foundBinary = false;
        for (let index = 0; index < expressionTokens2.length; index++) {
          const token = expressionTokens2[index];
          if (token === null) {
            continue;
          } else if (typeof token === "object") {
            if (token.pattern) {
              result.push(token.pattern);
            } else if (token.op) {
              result.push(token.op);
            } else if (token.comment) {
              result.push(`#${token.comment}`);
            }
          } else if (foundBinary) {
            const paramKeyValue = token.split("=");
            const paramKey = paramKeyValue[0];
            if (regexParam.test(paramKey)) {
              if (paramKeyValue.length === 1) {
                expressionTokens2[index + 1] = REDACTED;
                result.push(token);
              } else {
                result.push(`${paramKey}=${REDACTED}`);
              }
            } else {
              result.push(token);
            }
          } else {
            if (envVarRegex.test(token)) {
              const envSplit = token.split("=");
              if (ALLOWED_ENV_VARIABLES.has(envSplit[0])) {
                result.push(token);
              } else {
                envSplit[1] = REDACTED;
                const newToken = envSplit.join("=");
                expressionTokens2[index] = newToken;
                result.push(newToken);
              }
            } else {
              foundBinary = true;
              result.push(token);
              if (PROCESS_DENYLIST.has(token)) {
                for (index++; index < expressionTokens2.length; index++) {
                  const token2 = expressionTokens2[index];
                  if (token2.op) {
                    result.push(token2.op);
                  } else {
                    expressionTokens2[index] = REDACTED;
                    result.push(REDACTED);
                  }
                }
                break;
              }
            }
          }
        }
      });
      return result;
    }
    module2.exports = scrubChildProcessCmd;
  }
});

// ../../packages/datadog-plugin-child_process/src/index.js
var require_src31 = __commonJS({
  "../../packages/datadog-plugin-child_process/src/index.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var scrubChildProcessCmd = require_scrub_cmd_params();
    var MAX_ARG_SIZE = 4096;
    function truncateCommand(cmdFields) {
      let size = cmdFields[0].length;
      let truncated = false;
      for (let i = 1; i < cmdFields.length; i++) {
        if (size >= MAX_ARG_SIZE) {
          truncated = true;
          cmdFields[i] = "";
          continue;
        }
        const argLen = cmdFields[i].length;
        if (size < MAX_ARG_SIZE && size + argLen > MAX_ARG_SIZE) {
          cmdFields[i] = cmdFields[i].slice(0, 2);
          truncated = true;
        }
        size += argLen;
      }
      return truncated;
    }
    var ChildProcessPlugin = class extends TracingPlugin {
      static id = "child_process";
      static prefix = "tracing:datadog:child_process:execution";
      get tracer() {
        return this._tracer;
      }
      start(ctx) {
        const { command, shell } = ctx;
        if (typeof command !== "string") {
          return;
        }
        const cmdFields = scrubChildProcessCmd(command);
        const truncated = truncateCommand(cmdFields);
        const property = shell === true ? "cmd.shell" : "cmd.exec";
        const meta = {
          component: "subprocess",
          [property]: shell === true ? cmdFields.join(" ") : JSON.stringify(cmdFields)
        };
        if (truncated) {
          meta["cmd.truncated"] = `${truncated}`;
        }
        this.startSpan("command_execution", {
          service: this.config.service || this._tracerConfig.service,
          resource: shell === true ? "sh" : cmdFields[0],
          type: "system",
          meta
        }, ctx);
        return ctx.currentStore;
      }
      end(ctx) {
        const { result, error } = ctx;
        let exitCode;
        if (result !== void 0) {
          exitCode = result?.status || 0;
        } else if (error === void 0) {
          return;
        } else {
          exitCode = error?.status || error?.code || 0;
        }
        const span = ctx.currentStore?.span || this.activeSpan;
        span?.setTag("cmd.exit_code", `${exitCode}`);
        span?.finish();
        return ctx.parentStore;
      }
      error(ctx) {
        const { error } = ctx;
        const span = ctx.currentStore?.span || this.activeSpan;
        this.addError(error, span);
        return ctx.parentStore;
      }
      asyncEnd(ctx) {
        const { result } = ctx;
        const span = ctx.currentStore?.span || this.activeSpan;
        span?.setTag("cmd.exit_code", `${result}`);
        span?.finish();
        return ctx.parentStore;
      }
    };
    module2.exports = ChildProcessPlugin;
  }
});

// ../../packages/datadog-plugin-connect/src/index.js
var require_src32 = __commonJS({
  "../../packages/datadog-plugin-connect/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var ConnectPlugin = class extends RouterPlugin {
      static id = "connect";
      constructor(...args) {
        super(...args);
        this.addSub("apm:connect:request:handle", ({ req }) => {
          this.setFramework(req, "connect", this.config);
        });
      }
    };
    module2.exports = ConnectPlugin;
  }
});

// ../../packages/datadog-plugin-couchbase/src/index.js
var require_src33 = __commonJS({
  "../../packages/datadog-plugin-couchbase/src/index.js"(exports2, module2) {
    "use strict";
    var StoragePlugin = require_storage5();
    var { storage } = require_datadog_core();
    var CouchBasePlugin = class extends StoragePlugin {
      static id = "couchbase";
      static peerServicePrecursors = ["db.couchbase.seed.nodes"];
      addBinds(func, start) {
        this.addBind(`apm:couchbase:${func}:start`, start);
        this.addSub(`apm:couchbase:${func}:error`, ({ error }) => this.addError(error));
        this.addSub(`apm:couchbase:${func}:finish`, (ctx) => this.finish(ctx));
        this.addBind(`apm:couchbase:${func}:callback:start`, callbackStart);
        this.addBind(`apm:couchbase:${func}:callback:finish`, callbackFinish);
      }
      startSpan(operation, customTags, { bucket, collection, seedNodes }, ctx) {
        const tags = {
          "db.type": "couchbase",
          component: "couchbase",
          "resource.name": `couchbase.${operation}`,
          "span.kind": this.constructor.kind,
          "db.couchbase.seed.nodes": seedNodes
        };
        if (bucket) tags["couchbase.bucket.name"] = bucket.name;
        if (collection) tags["couchbase.collection.name"] = collection.name;
        for (const tag in customTags) {
          tags[tag] = customTags[tag];
        }
        return super.startSpan(
          this.operationName({ operation }),
          {
            service: this.serviceName({ pluginConfig: this.config }),
            meta: tags
          },
          ctx
        );
      }
      constructor(...args) {
        super(...args);
        this.addBinds("query", (ctx) => {
          const { resource, bucket, seedNodes } = ctx;
          this.startSpan(
            "query",
            {
              "span.type": "sql",
              "resource.name": resource,
              "span.kind": this.constructor.kind
            },
            { bucket, seedNodes },
            ctx
          );
          return ctx.currentStore;
        });
        this.addBind("apm:couchbase:bucket:maybeInvoke:callback:start", callbackStart);
        this.addBind("apm:couchbase:bucket:maybeInvoke:callback:finish", callbackFinish);
        this.addBind("apm:couchbase:cluster:maybeInvoke:callback:start", callbackStart);
        this.addBind("apm:couchbase:cluster:maybeInvoke:callback:finish", callbackFinish);
        this._addCommandSubs("upsert");
        this._addCommandSubs("insert");
        this._addCommandSubs("replace");
        this._addCommandSubs("append");
        this._addCommandSubs("prepend");
      }
      _addCommandSubs(name) {
        this.addBinds(name, (ctx) => {
          const { bucket, collection, seedNodes } = ctx;
          this.startSpan(name, {}, { bucket, collection, seedNodes }, ctx);
          return ctx.currentStore;
        });
      }
    };
    function callbackStart(ctx) {
      ctx.parentStore = storage("legacy").getStore();
      return ctx.parentStore;
    }
    function callbackFinish(ctx) {
      return ctx.parentStore;
    }
    module2.exports = CouchBasePlugin;
  }
});

// ../../packages/datadog-plugin-cypress/src/index.js
var require_src34 = __commonJS({
  "../../packages/datadog-plugin-cypress/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var CypressPlugin = class extends Plugin {
      static id = "cypress";
    };
    module2.exports = CypressPlugin;
  }
});

// ../../packages/datadog-plugin-dns/src/lookup.js
var require_lookup = __commonJS({
  "../../packages/datadog-plugin-dns/src/lookup.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var DNSLookupPlugin = class extends ClientPlugin {
      static id = "dns";
      static operation = "lookup";
      bindStart(ctx) {
        const [hostname] = ctx.args;
        this.startSpan("dns.lookup", {
          service: this.config.service,
          resource: hostname,
          kind: "client",
          meta: {
            "dns.hostname": hostname,
            "dns.address": "",
            "dns.addresses": ""
          }
        }, ctx);
        return ctx.currentStore;
      }
      bindFinish(ctx) {
        const span = ctx.currentStore.span;
        const result = ctx.result;
        if (Array.isArray(result)) {
          const addresses = Array.isArray(result) ? result.map((address) => address.address).sort() : [result];
          span.setTag("dns.address", addresses[0]);
          span.setTag("dns.addresses", addresses.join(","));
        } else {
          span.setTag("dns.address", result);
        }
        return ctx.parentStore;
      }
    };
    module2.exports = DNSLookupPlugin;
  }
});

// ../../packages/datadog-plugin-dns/src/lookup_service.js
var require_lookup_service = __commonJS({
  "../../packages/datadog-plugin-dns/src/lookup_service.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var DNSLookupServicePlugin = class extends ClientPlugin {
      static id = "dns";
      static operation = "lookup_service";
      bindStart(ctx) {
        const [address, port] = ctx.args;
        this.startSpan("dns.lookup_service", {
          service: this.config.service,
          resource: `${address}:${port}`,
          kind: "client",
          meta: {
            "dns.address": address
          },
          metrics: {
            "dns.port": port
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = DNSLookupServicePlugin;
  }
});

// ../../packages/datadog-plugin-dns/src/resolve.js
var require_resolve = __commonJS({
  "../../packages/datadog-plugin-dns/src/resolve.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var DNSResolvePlugin = class extends ClientPlugin {
      static id = "dns";
      static operation = "resolve";
      bindStart(ctx) {
        const [hostname, maybeType] = ctx.args;
        const rrtype = typeof maybeType === "string" ? maybeType : "A";
        this.startSpan("dns.resolve", {
          service: this.config.service,
          resource: `${rrtype} ${hostname}`,
          kind: "client",
          meta: {
            "dns.hostname": hostname,
            "dns.rrtype": rrtype
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = DNSResolvePlugin;
  }
});

// ../../packages/datadog-plugin-dns/src/reverse.js
var require_reverse = __commonJS({
  "../../packages/datadog-plugin-dns/src/reverse.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var DNSReversePlugin = class extends ClientPlugin {
      static id = "dns";
      static operation = "reverse";
      bindStart(ctx) {
        const [ip] = ctx.args;
        this.startSpan("dns.reverse", {
          service: this.config.service,
          resource: ip,
          kind: "client",
          meta: {
            "dns.ip": ip
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = DNSReversePlugin;
  }
});

// ../../packages/datadog-plugin-dns/src/index.js
var require_src35 = __commonJS({
  "../../packages/datadog-plugin-dns/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var DNSLookupPlugin = require_lookup();
    var DNSLookupServicePlugin = require_lookup_service();
    var DNSResolvePlugin = require_resolve();
    var DNSReversePlugin = require_reverse();
    var DNSPlugin = class extends CompositePlugin {
      static id = "dns";
      static get plugins() {
        return {
          lookup: DNSLookupPlugin,
          lookup_service: DNSLookupServicePlugin,
          resolve: DNSResolvePlugin,
          reverse: DNSReversePlugin
        };
      }
    };
    module2.exports = DNSPlugin;
  }
});

// ../../packages/datadog-plugin-dd-trace-api/src/index.js
var require_src36 = __commonJS({
  "../../packages/datadog-plugin-dd-trace-api/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var telemetryMetrics = require_metrics();
    var apiMetrics = telemetryMetrics.manager.namespace("tracers");
    var { getEnvironmentVariable } = require_config_helper();
    var objectMap = /* @__PURE__ */ new WeakMap();
    var injectionEnabledTag = `injection_enabled:${getEnvironmentVariable("DD_INJECTION_ENABLED") ? "yes" : "no"}`;
    module2.exports = class DdTraceApiPlugin extends Plugin {
      static id = "dd-trace-api";
      constructor(...args) {
        super(...args);
        const tracer2 = this._tracer;
        this.addSub("datadog-api:v1:tracerinit", ({ proxy }) => {
          const proxyVal = proxy();
          objectMap.set(proxyVal, tracer2);
          objectMap.set(proxyVal.appsec, tracer2.appsec);
          objectMap.set(proxyVal.dogstatsd, tracer2.dogstatsd);
        });
        const handleEvent = (name) => {
          const counter = apiMetrics.count("public_api.called", [
            `name:${name.replaceAll(":", ".")}`,
            "api_version:v1",
            injectionEnabledTag
          ]);
          this.addSub(`datadog-api:v1:${name}`, ({ self: self2, args: args2, ret, proxy, revProxy }) => {
            counter.inc();
            if (name.includes(":")) {
              name = name.split(":").pop();
            }
            if (objectMap.has(self2)) {
              self2 = objectMap.get(self2);
            }
            for (let i = 0; i < args2.length; i++) {
              if (objectMap.has(args2[i])) {
                args2[i] = objectMap.get(args2[i]);
              }
              if (typeof args2[i] === "function") {
                const orig = args2[i];
                args2[i] = (...fnArgs) => {
                  for (let j = 0; j < fnArgs.length; j++) {
                    if (revProxy && revProxy[j]) {
                      const proxyVal = revProxy[j]();
                      objectMap.set(proxyVal, fnArgs[j]);
                      fnArgs[j] = proxyVal;
                    }
                  }
                  return orig(...fnArgs);
                };
              }
            }
            try {
              ret.value = self2[name](...args2);
              if (proxy) {
                const proxyVal = proxy();
                objectMap.set(proxyVal, ret.value);
                ret.value = proxyVal;
              }
            } catch (e) {
              ret.error = e;
            }
          });
        };
        handleEvent("startSpan");
        handleEvent("wrap");
        handleEvent("trace");
        handleEvent("inject");
        handleEvent("extract");
        handleEvent("getRumData");
        handleEvent("profilerStarted");
        handleEvent("context:toTraceId");
        handleEvent("context:toSpanId");
        handleEvent("context:toTraceparent");
        handleEvent("span:context");
        handleEvent("span:setTag");
        handleEvent("span:addTags");
        handleEvent("span:finish");
        handleEvent("span:addLink");
        handleEvent("scope");
        handleEvent("scope:activate");
        handleEvent("scope:active");
        handleEvent("scope:bind");
        handleEvent("appsec:blockRequest");
        handleEvent("appsec:isUserBlocked");
        handleEvent("appsec:setUser");
        handleEvent("appsec:trackCustomEvent");
        handleEvent("appsec:trackUserLoginFailureEvent");
        handleEvent("appsec:trackUserLoginSuccessEvent");
        handleEvent("dogstatsd:decrement");
        handleEvent("dogstatsd:distribution");
        handleEvent("dogstatsd:flush");
        handleEvent("dogstatsd:gauge");
        handleEvent("dogstatsd:histogram");
        handleEvent("dogstatsd:increment");
        handleEvent("use");
      }
    };
  }
});

// ../../packages/datadog-plugin-express/src/tracing.js
var require_tracing7 = __commonJS({
  "../../packages/datadog-plugin-express/src/tracing.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var ExpressTracingPlugin = class extends RouterPlugin {
      static id = "express";
      constructor(...args) {
        super(...args);
        this.addSub("apm:express:request:handle", ({ req }) => {
          this.setFramework(req, "express", this.config);
        });
      }
    };
    module2.exports = ExpressTracingPlugin;
  }
});

// ../../packages/datadog-plugin-express/src/code_origin.js
var require_code_origin = __commonJS({
  "../../packages/datadog-plugin-express/src/code_origin.js"(exports2, module2) {
    "use strict";
    var { entryTags } = require_datadog_code_origin();
    var Plugin = require_plugin();
    var web = require_web3();
    var ExpressCodeOriginForSpansPlugin = class extends Plugin {
      static id = "express";
      constructor(...args) {
        super(...args);
        const layerTags = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:express:middleware:enter", ({ req, layer }) => {
          const tags = layerTags.get(layer);
          if (!tags) return;
          web.getContext(req)?.span?.addTags(tags);
        });
        this.addSub("apm:express:route:added", ({ topOfStackFunc, layer }) => {
          if (!layer) return;
          if (layerTags.has(layer)) return;
          layerTags.set(layer, entryTags(topOfStackFunc));
        });
        this.addSub("apm:router:middleware:enter", ({ req, layer }) => {
          const tags = layerTags.get(layer);
          if (!tags) return;
          web.getContext(req)?.span?.addTags(tags);
        });
        this.addSub("apm:router:route:added", ({ topOfStackFunc, layer }) => {
          if (!layer) return;
          if (layerTags.has(layer)) return;
          layerTags.set(layer, entryTags(topOfStackFunc));
        });
      }
    };
    module2.exports = ExpressCodeOriginForSpansPlugin;
  }
});

// ../../packages/datadog-plugin-express/src/index.js
var require_src37 = __commonJS({
  "../../packages/datadog-plugin-express/src/index.js"(exports2, module2) {
    "use strict";
    var ExpressTracingPlugin = require_tracing7();
    var ExpressCodeOriginForSpansPlugin = require_code_origin();
    var CompositePlugin = require_composite2();
    var ExpressPlugin = class extends CompositePlugin {
      static id = "express";
      static get plugins() {
        return {
          tracing: ExpressTracingPlugin,
          codeOriginForSpans: ExpressCodeOriginForSpansPlugin
        };
      }
    };
    module2.exports = ExpressPlugin;
  }
});

// ../../packages/datadog-plugin-fastify/src/tracing.js
var require_tracing8 = __commonJS({
  "../../packages/datadog-plugin-fastify/src/tracing.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var { storage } = require_datadog_core();
    var FastifyTracingPlugin = class extends RouterPlugin {
      static id = "fastify";
      constructor(...args) {
        super(...args);
        this.addSub("apm:fastify:request:handle", ({ req }) => {
          this.setFramework(req, "fastify", this.config);
        });
        this.addBind("datadog:fastify:pre-parsing:start", getParentStore);
        this.addBind("datadog:fastify:pre-validation:start", getParentStore);
        this.addSub("datadog:fastify:pre-parsing:finish", (ctx) => {
          return ctx.parentStore;
        });
        this.addSub("datadog:fastify:pre-validation:finish", (ctx) => {
          return ctx.parentStore;
        });
        this.addSub("datadog:fastify:callback:execute", getParentStore);
      }
    };
    function getParentStore(ctx) {
      ctx.parentStore = ctx.parentStore ?? storage("legacy").getStore();
      return ctx.parentStore;
    }
    module2.exports = FastifyTracingPlugin;
  }
});

// ../../packages/datadog-plugin-fastify/src/code_origin.js
var require_code_origin2 = __commonJS({
  "../../packages/datadog-plugin-fastify/src/code_origin.js"(exports2, module2) {
    "use strict";
    var { entryTags } = require_datadog_code_origin();
    var Plugin = require_plugin();
    var web = require_web3();
    var kCodeOriginForSpansTagsSym = Symbol("datadog.codeOriginForSpansTags");
    var FastifyCodeOriginForSpansPlugin = class extends Plugin {
      static id = "fastify";
      constructor(...args) {
        super(...args);
        this.addSub("apm:fastify:request:handle", ({ req, routeConfig }) => {
          const tags = routeConfig?.[kCodeOriginForSpansTagsSym];
          if (!tags) return;
          web.getContext(req)?.span?.addTags(tags);
        });
        this.addSub("apm:fastify:route:added", ({ routeOptions, onRoute }) => {
          if (!routeOptions.config) routeOptions.config = {};
          routeOptions.config[kCodeOriginForSpansTagsSym] = entryTags(onRoute);
        });
      }
    };
    module2.exports = FastifyCodeOriginForSpansPlugin;
  }
});

// ../../packages/datadog-plugin-fastify/src/index.js
var require_src38 = __commonJS({
  "../../packages/datadog-plugin-fastify/src/index.js"(exports2, module2) {
    "use strict";
    var FastifyTracingPlugin = require_tracing8();
    var FastifyCodeOriginForSpansPlugin = require_code_origin2();
    var CompositePlugin = require_composite2();
    var FastifyPlugin = class extends CompositePlugin {
      static id = "fastify";
      static get plugins() {
        return {
          tracing: FastifyTracingPlugin,
          codeOriginForSpans: FastifyCodeOriginForSpansPlugin
        };
      }
    };
    module2.exports = FastifyPlugin;
  }
});

// ../../packages/datadog-plugin-find-my-way/src/index.js
var require_src39 = __commonJS({
  "../../packages/datadog-plugin-find-my-way/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var web = require_web3();
    var FindMyWayPlugin = class extends Plugin {
      static id = "find-my-way";
      constructor(...args) {
        super(...args);
        this.addSub("apm:find-my-way:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
    };
    module2.exports = FindMyWayPlugin;
  }
});

// ../../packages/datadog-plugin-http/src/client.js
var require_client10 = __commonJS({
  "../../packages/datadog-plugin-http/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var { storage } = require_datadog_core();
    var tags = require_tags();
    var analyticsSampler = require_analytics_sampler();
    var formats = require_formats();
    var HTTP_HEADERS = formats.HTTP_HEADERS;
    var urlFilter = require_urlfilter();
    var log = require_log2();
    var { CLIENT_PORT_KEY, COMPONENT, ERROR_MESSAGE, ERROR_TYPE, ERROR_STACK } = require_constants3();
    var { URL: URL2 } = __require("url");
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var HttpClientPlugin = class extends ClientPlugin {
      static id = "http";
      static prefix = "apm:http:client:request";
      bindStart(message) {
        const { args, http = {} } = message;
        const store = storage("legacy").getStore();
        const options = args.options;
        const agent = options.agent || options._defaultAgent || http.globalAgent || {};
        const protocol = options.protocol || agent.protocol || "http:";
        const hostname = options.hostname || options.host || "localhost";
        const host = options.port ? `${hostname}:${options.port}` : hostname;
        const pathname = options.path || options.pathname;
        const path = pathname ? pathname.split(/[?#]/)[0] : "/";
        const uri = `${protocol}//${host}${path}`;
        const allowed = this.config.filter(uri);
        const method = (options.method || "GET").toUpperCase();
        const childOf = store && allowed ? store.span : null;
        const span = this.startSpan(this.operationName(), {
          childOf,
          integrationName: this.constructor.id,
          meta: {
            [COMPONENT]: this.constructor.id,
            "span.kind": "client",
            "service.name": this.serviceName({ pluginConfig: this.config, sessionDetails: extractSessionDetails(options) }),
            "resource.name": method,
            "span.type": "http",
            "http.method": method,
            "http.url": uri,
            "out.host": hostname
          },
          metrics: {
            [CLIENT_PORT_KEY]: Number.parseInt(options.port)
          }
        }, false);
        if (!allowed) {
          span._spanContext._trace.record = false;
        }
        if (this.shouldInjectTraceHeaders(options, uri)) {
          options.headers = { ...options.headers };
          this.tracer.inject(span, HTTP_HEADERS, options.headers);
        }
        analyticsSampler.sample(span, this.config.measured);
        message.span = span;
        message.parentStore = store;
        message.currentStore = { ...store, span };
        return message.currentStore;
      }
      shouldInjectTraceHeaders(options, uri) {
        if (!this.config.propagationFilter(uri)) {
          return false;
        }
        return true;
      }
      bindAsyncStart({ parentStore }) {
        return parentStore;
      }
      finish(ctx) {
        const { req, res, span } = ctx;
        if (!span) return;
        if (res) {
          const status = res.status || res.statusCode;
          span.setTag(HTTP_STATUS_CODE, status);
          if (!this.config.validateStatus(status)) {
            span.setTag("error", 1);
          }
          addResponseHeaders(res, span, this.config);
        }
        if (req) {
          addRequestHeaders(req, span, this.config);
        }
        this.config.hooks.request(span, req, res);
        super.finish(ctx);
      }
      error({ span, error, args, customRequestTimeout }) {
        if (!span) return;
        if (error) {
          span.addTags({
            [ERROR_TYPE]: error.name,
            [ERROR_MESSAGE]: error.message || error.code,
            [ERROR_STACK]: error.stack
          });
        } else {
          if (!args.options.agent?.options?.timeout && !customRequestTimeout) return;
          span.setTag("error", 1);
        }
      }
      configure(config) {
        return super.configure(normalizeClientConfig(config));
      }
    };
    function addResponseHeaders(res, span, config) {
      if (!res.headers) return;
      const headers = typeof res.headers.entries === "function" ? Object.fromEntries(res.headers.entries()) : res.headers;
      config.headers.forEach(([key, tag]) => {
        const value = headers[key];
        if (value) {
          span.setTag(tag || `${HTTP_RESPONSE_HEADERS}.${key}`, value);
        }
      });
    }
    function addRequestHeaders(req, span, config) {
      const headers = req.headers && typeof req.headers.entries === "function" ? Object.fromEntries(req.headers.entries()) : req.headers || req.getHeaders();
      config.headers.forEach(([key, tag]) => {
        const value = Array.isArray(headers[key]) ? headers[key].toString() : headers[key];
        if (value) {
          span.setTag(tag || `${HTTP_REQUEST_HEADERS}.${key}`, value);
        }
      });
    }
    function normalizeClientConfig(config) {
      const validateStatus = getStatusValidator(config);
      const filter = getFilter(config);
      const propagationFilter = getFilter({ blocklist: config.propagationBlocklist });
      const headers = getHeaders(config);
      const hooks = getHooks(config);
      return {
        ...config,
        validateStatus,
        filter,
        propagationFilter,
        headers,
        hooks
      };
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 400 || code >= 500;
    }
    function getFilter(config) {
      config = { ...config, blocklist: config.blocklist || [] };
      return urlFilter.getFilter(config);
    }
    function getHeaders(config) {
      if (!Array.isArray(config.headers)) return [];
      const result = [];
      for (const header of config.headers) {
        if (typeof header === "string") {
          const separatorIndex = header.indexOf(":");
          result.push(
            separatorIndex === -1 ? [header, void 0] : [
              header.slice(0, separatorIndex).toLowerCase(),
              header.slice(separatorIndex + 1)
            ]
          );
        }
      }
      return result;
    }
    var noop = () => {
    };
    function getHooks(config) {
      const request2 = config.hooks?.request ?? noop;
      return { request: request2 };
    }
    function extractSessionDetails(options) {
      if (typeof options === "string") {
        return new URL2(options).host;
      }
      const host = options.hostname || options.host || "localhost";
      const port = options.port;
      return { host, port };
    }
    module2.exports = HttpClientPlugin;
  }
});

// ../../packages/datadog-plugin-fetch/src/index.js
var require_src40 = __commonJS({
  "../../packages/datadog-plugin-fetch/src/index.js"(exports2, module2) {
    "use strict";
    var HttpClientPlugin = require_client10();
    var FetchPlugin = class extends HttpClientPlugin {
      static id = "fetch";
      static prefix = "tracing:apm:fetch:request";
      bindStart(ctx) {
        const req = ctx.req;
        const options = new URL(req.url);
        options.headers = Object.fromEntries(req.headers.entries());
        options.method = req.method;
        ctx.args = { options };
        const store = super.bindStart(ctx);
        for (const name in options.headers) {
          if (!req.headers.has(name)) {
            req.headers.set(name, options.headers[name]);
          }
        }
        return store;
      }
      error(ctx) {
        if (ctx.error.name === "AbortError") return;
        return super.error(ctx);
      }
      asyncEnd(ctx) {
        ctx.res = ctx.result;
        return this.finish(ctx);
      }
    };
    module2.exports = FetchPlugin;
  }
});

// ../../packages/datadog-plugin-graphql/src/utils.js
var require_utils7 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/utils.js"(exports2, module2) {
    "use strict";
    function extractErrorIntoSpanEvent(config, span, exc) {
      const attributes = {};
      if (exc.name) {
        attributes.type = exc.name;
      }
      if (exc.stack) {
        attributes.stacktrace = exc.stack;
      }
      if (exc.locations) {
        attributes.locations = [];
        for (const location of exc.locations) {
          attributes.locations.push(`${location.line}:${location.column}`);
        }
      }
      if (exc.path) {
        attributes.path = exc.path.map(String);
      }
      if (exc.message) {
        attributes.message = exc.message;
      }
      if (config.graphqlErrorExtensions) {
        for (const ext of config.graphqlErrorExtensions) {
          if (exc.extensions?.[ext]) {
            const value = exc.extensions[ext];
            if (typeof value === "number" || typeof value === "boolean") {
              attributes[`extensions.${ext}`] = value;
            } else {
              attributes[`extensions.${ext}`] = String(value);
            }
          }
        }
      }
      span.addEvent("dd.graphql.query.error", attributes, Date.now());
    }
    module2.exports = {
      extractErrorIntoSpanEvent
    };
  }
});

// ../../packages/datadog-plugin-graphql/src/execute.js
var require_execute2 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/execute.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var { extractErrorIntoSpanEvent } = require_utils7();
    var tools;
    var GraphQLExecutePlugin = class extends TracingPlugin {
      static id = "graphql";
      static operation = "execute";
      static type = "graphql";
      static kind = "server";
      bindStart(ctx) {
        const { operation, args, docSource } = ctx;
        const type = operation && operation.operation;
        const name = operation && operation.name && operation.name.value;
        const document = args.document;
        const source = this.config.source && document && docSource;
        const span = this.startSpan(this.operationName(), {
          service: this.config.service || this.serviceName(),
          resource: getSignature(document, name, type, this.config.signature),
          kind: this.constructor.kind,
          type: this.constructor.type,
          meta: {
            "graphql.operation.type": type,
            "graphql.operation.name": name,
            "graphql.source": source
          }
        }, ctx);
        addVariableTags(this.config, span, args.variableValues);
        return ctx.currentStore;
      }
      finish(ctx) {
        const { res, args } = ctx;
        const span = ctx?.currentStore?.span || this.activeSpan;
        this.config.hooks.execute(span, args, res);
        if (res?.errors) {
          for (const err of res.errors) {
            extractErrorIntoSpanEvent(this._tracerConfig, span, err);
          }
        }
        super.finish(ctx);
        return ctx.parentStore;
      }
    };
    function addVariableTags(config, span, variableValues) {
      const tags = {};
      if (variableValues && config.variables) {
        const variables = config.variables(variableValues);
        for (const param in variables) {
          tags[`graphql.variables.${param}`] = variables[param];
        }
      }
      span.addTags(tags);
    }
    function getSignature(document, operationName, operationType, calculate) {
      if (calculate !== false && tools !== false) {
        try {
          try {
            tools = tools || require_tools();
          } catch (e) {
            tools = false;
            throw e;
          }
          return tools.defaultEngineReportingSignature(document, operationName);
        } catch {
        }
      }
      return [operationType, operationName].filter(Boolean).join(" ");
    }
    module2.exports = GraphQLExecutePlugin;
  }
});

// ../../packages/datadog-plugin-graphql/src/parse.js
var require_parse2 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/parse.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var GraphQLParsePlugin = class extends TracingPlugin {
      static id = "graphql";
      static operation = "parser";
      bindStart(ctx) {
        this.startSpan("graphql.parse", {
          service: this.config.service,
          type: "graphql",
          meta: {}
        }, ctx);
        return ctx.currentStore;
      }
      finish(ctx) {
        const { source, document, docSource } = ctx;
        const span = ctx?.currentStore?.span || this.activeSpan;
        if (this.config.source && document) {
          span.setTag("graphql.source", docSource);
        }
        this.config.hooks.parse(span, source, document);
        super.finish(ctx);
        return ctx.parentStore;
      }
    };
    module2.exports = GraphQLParsePlugin;
  }
});

// ../../packages/datadog-plugin-graphql/src/validate.js
var require_validate2 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/validate.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var { extractErrorIntoSpanEvent } = require_utils7();
    var GraphQLValidatePlugin = class extends TracingPlugin {
      static id = "graphql";
      static operation = "validate";
      bindStart(ctx) {
        const { docSource, document } = ctx;
        const source = this.config.source && document && docSource;
        this.startSpan("graphql.validate", {
          service: this.config.service,
          type: "graphql",
          meta: {
            "graphql.source": source
          }
        }, ctx);
        return ctx.currentStore;
      }
      finish(ctx) {
        const { document, errors } = ctx;
        const span = ctx?.currentStore?.span || this.activeSpan;
        this.config.hooks.validate(span, document, errors);
        if (errors) {
          for (const err of errors) {
            extractErrorIntoSpanEvent(this._tracerConfig, span, err);
          }
        }
        super.finish(ctx);
        return ctx.parentStore;
      }
    };
    module2.exports = GraphQLValidatePlugin;
  }
});

// ../../packages/datadog-plugin-graphql/src/resolve.js
var require_resolve2 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/resolve.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var dc = require_dc_polyfill();
    var collapsedPathSym = Symbol("collapsedPaths");
    var GraphQLResolvePlugin = class extends TracingPlugin {
      static id = "graphql";
      static operation = "resolve";
      start(fieldCtx) {
        const { info, rootCtx, args } = fieldCtx;
        const path = getPath(info, this.config);
        const parentField = getParentField(rootCtx, pathToArray(info && info.path));
        const childOf = parentField?.ctx?.currentStore?.span;
        fieldCtx.parent = parentField;
        if (!shouldInstrument(this.config, path)) return;
        const computedPathString = path.join(".");
        if (this.config.collapse) {
          if (rootCtx.fields[computedPathString]) return;
          if (!rootCtx[collapsedPathSym]) {
            rootCtx[collapsedPathSym] = {};
          } else if (rootCtx[collapsedPathSym][computedPathString]) {
            return;
          }
          rootCtx[collapsedPathSym][computedPathString] = true;
        }
        const document = rootCtx.source;
        const fieldNode = info.fieldNodes.find((fieldNode2) => fieldNode2.kind === "Field");
        const loc = this.config.source && document && fieldNode && fieldNode.loc;
        const source = loc && document.slice(loc.start, loc.end);
        const span = this.startSpan("graphql.resolve", {
          service: this.config.service,
          resource: `${info.fieldName}:${info.returnType}`,
          childOf,
          type: "graphql",
          meta: {
            "graphql.field.name": info.fieldName,
            "graphql.field.path": computedPathString,
            "graphql.field.type": info.returnType.name,
            "graphql.source": source
          }
        }, fieldCtx);
        if (fieldNode && this.config.variables && fieldNode.arguments) {
          const variables = this.config.variables(info.variableValues);
          fieldNode.arguments.filter((arg) => arg.value?.name && arg.value.kind === "Variable" && variables[arg.value.name.value]).forEach((arg) => {
            const name = arg.value.name.value;
            span.setTag(`graphql.variables.${name}`, variables[name]);
          });
        }
        if (this.resolverStartCh.hasSubscribers) {
          this.resolverStartCh.publish({ ctx: rootCtx, resolverInfo: getResolverInfo(info, args) });
        }
        return fieldCtx.currentStore;
      }
      constructor(...args) {
        super(...args);
        this.addTraceSub("updateField", (ctx) => {
          const { field, info, error } = ctx;
          const path = getPath(info, this.config);
          if (!shouldInstrument(this.config, path)) return;
          const span = ctx?.currentStore?.span || this.activeSpan;
          field.finishTime = span._getTime ? span._getTime() : 0;
          field.error = field.error || error;
        });
        this.resolverStartCh = dc.channel("datadog:graphql:resolver:start");
      }
      configure(config) {
        super.configure(config.depth === 0 ? false : config);
      }
      finish(ctx) {
        const { finishTime } = ctx;
        const span = ctx?.currentStore?.span || this.activeSpan;
        span.finish(finishTime);
        return ctx.parentStore;
      }
    };
    function shouldInstrument(config, path) {
      let depth = 0;
      for (const item of path) {
        if (typeof item === "string") {
          depth += 1;
        }
      }
      return config.depth < 0 || config.depth >= depth;
    }
    function getPath(info, config) {
      const responsePathAsArray = config.collapse ? withCollapse(pathToArray) : pathToArray;
      return responsePathAsArray(info && info.path);
    }
    function pathToArray(path) {
      const flattened = [];
      let curr = path;
      while (curr) {
        flattened.push(curr.key);
        curr = curr.prev;
      }
      return flattened.reverse();
    }
    function withCollapse(responsePathAsArray) {
      return function() {
        return responsePathAsArray.apply(this, arguments).map((segment) => typeof segment === "number" ? "*" : segment);
      };
    }
    function getResolverInfo(info, args) {
      let resolverInfo = null;
      const resolverVars = {};
      if (args) {
        Object.assign(resolverVars, args);
      }
      let hasResolvers = false;
      const directives = info.fieldNodes?.[0]?.directives;
      if (Array.isArray(directives)) {
        for (const directive of directives) {
          const argList = {};
          for (const argument of directive.arguments) {
            argList[argument.name.value] = argument.value.value;
          }
          if (directive.arguments.length > 0) {
            hasResolvers = true;
            resolverVars[directive.name.value] = argList;
          }
        }
      }
      if (hasResolvers || args && Object.keys(resolverVars).length) {
        resolverInfo = { [info.fieldName]: resolverVars };
      }
      return resolverInfo;
    }
    function getParentField(parentCtx, path) {
      for (let i = path.length - 1; i > 0; i--) {
        const field = getField(parentCtx, path.slice(0, i));
        if (field) {
          return field;
        }
      }
      return null;
    }
    function getField(parentCtx, path) {
      return parentCtx.fields[path.join(".")];
    }
    module2.exports = GraphQLResolvePlugin;
  }
});

// ../../packages/datadog-plugin-graphql/src/index.js
var require_src41 = __commonJS({
  "../../packages/datadog-plugin-graphql/src/index.js"(exports2, module2) {
    "use strict";
    var pick = require_pick();
    var CompositePlugin = require_composite2();
    var log = require_log2();
    var GraphQLExecutePlugin = require_execute2();
    var GraphQLParsePlugin = require_parse2();
    var GraphQLValidatePlugin = require_validate2();
    var GraphQLResolvePlugin = require_resolve2();
    var GraphQLPlugin = class extends CompositePlugin {
      static id = "graphql";
      static get plugins() {
        return {
          execute: GraphQLExecutePlugin,
          parse: GraphQLParsePlugin,
          validate: GraphQLValidatePlugin,
          resolve: GraphQLResolvePlugin
        };
      }
      /**
       * @override
       */
      configure(config) {
        return super.configure(validateConfig(config));
      }
    };
    function validateConfig(config) {
      return {
        ...config,
        depth: getDepth(config),
        variables: getVariablesFilter(config),
        collapse: config.collapse === void 0 || !!config.collapse,
        hooks: getHooks(config)
      };
    }
    function getDepth(config) {
      if (typeof config.depth === "number") {
        return config.depth;
      } else if (config.hasOwnProperty("depth")) {
        log.error("Expected `depth` to be a integer.");
      }
      return -1;
    }
    function getVariablesFilter(config) {
      if (typeof config.variables === "function") {
        return config.variables;
      } else if (Array.isArray(config.variables)) {
        return (variables) => pick(variables, config.variables);
      } else if (config.hasOwnProperty("variables")) {
        log.error("Expected `variables` to be an array or function.");
      }
      return null;
    }
    var noop = () => {
    };
    function getHooks({ hooks }) {
      const execute = hooks?.execute ?? noop;
      const parse = hooks?.parse ?? noop;
      const validate = hooks?.validate ?? noop;
      return { execute, parse, validate };
    }
    module2.exports = GraphQLPlugin;
  }
});

// ../../packages/datadog-plugin-hono/src/index.js
var require_src42 = __commonJS({
  "../../packages/datadog-plugin-hono/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var web = require_web3();
    var HonoPlugin = class extends RouterPlugin {
      static id = "hono";
      constructor(...args) {
        super(...args);
        this.addSub("apm:hono:request:handle", ({ req }) => {
          this.setFramework(req, "hono", this.config);
        });
        this.addSub("apm:hono:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
        this.addSub("apm:hono:request:error", ({ req, error }) => {
          web.addError(req, error);
        });
      }
    };
    module2.exports = HonoPlugin;
  }
});

// ../../packages/dd-trace/src/appsec/channels.js
var require_channels2 = __commonJS({
  "../../packages/dd-trace/src/appsec/channels.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    module2.exports = {
      apolloChannel: dc.tracingChannel("datadog:apollo:request"),
      apolloHttpServerChannel: dc.tracingChannel("datadog:apollo:httpserver"),
      apolloServerCoreChannel: dc.tracingChannel("datadog:apollo-server-core:request"),
      bodyParser: dc.channel("datadog:body-parser:read:finish"),
      childProcessExecutionTracingChannel: dc.tracingChannel("datadog:child_process:execution"),
      cookieParser: dc.channel("datadog:cookie-parser:read:finish"),
      expressMiddlewareError: dc.channel("apm:express:middleware:error"),
      expressProcessParams: dc.channel("datadog:express:process_params:start"),
      expressSession: dc.channel("datadog:express-session:middleware:finish"),
      fastifyBodyParser: dc.channel("datadog:fastify:body-parser:finish"),
      fastifyCookieParser: dc.channel("datadog:fastify-cookie:read:finish"),
      fastifyMiddlewareError: dc.channel("apm:fastify:middleware:error"),
      fastifyPathParams: dc.channel("datadog:fastify:path-params:finish"),
      fastifyQueryParams: dc.channel("datadog:fastify:query-params:finish"),
      fastifyResponseChannel: dc.channel("datadog:fastify:response:finish"),
      fsOperationStart: dc.channel("apm:fs:operation:start"),
      graphqlMiddlewareChannel: dc.tracingChannel("datadog:apollo:middleware"),
      httpClientRequestStart: dc.channel("apm:http:client:request:start"),
      incomingHttpRequestEnd: dc.channel("dd-trace:incomingHttpRequestEnd"),
      incomingHttpRequestStart: dc.channel("dd-trace:incomingHttpRequestStart"),
      multerParser: dc.channel("datadog:multer:read:finish"),
      mysql2OuterQueryStart: dc.channel("datadog:mysql2:outerquery:start"),
      nextBodyParsed: dc.channel("apm:next:body-parsed"),
      nextQueryParsed: dc.channel("apm:next:query-parsed"),
      passportUser: dc.channel("datadog:passport:deserializeUser:finish"),
      passportVerify: dc.channel("datadog:passport:verify:finish"),
      pgPoolQueryStart: dc.channel("datadog:pg:pool:query:start"),
      pgQueryStart: dc.channel("apm:pg:query:start"),
      queryParser: dc.channel("datadog:query:read:finish"),
      responseBody: dc.channel("datadog:express:response:json:start"),
      responseSetHeader: dc.channel("datadog:http:server:response:set-header:start"),
      responseWriteHead: dc.channel("apm:http:server:response:writeHead:start"),
      routerParam: dc.channel("datadog:router:param:start"),
      routerMiddlewareError: dc.channel("apm:router:middleware:error"),
      setCookieChannel: dc.channel("datadog:iast:set-cookie"),
      setUncaughtExceptionCaptureCallbackStart: dc.channel("datadog:process:setUncaughtExceptionCaptureCallback:start"),
      startGraphqlResolve: dc.channel("datadog:graphql:resolver:start"),
      wafRunFinished: dc.channel("datadog:waf:run:finish")
    };
  }
});

// ../../packages/datadog-plugin-http/src/server.js
var require_server7 = __commonJS({
  "../../packages/datadog-plugin-http/src/server.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server5();
    var { storage } = require_datadog_core();
    var web = require_web3();
    var { incomingHttpRequestStart, incomingHttpRequestEnd } = require_channels2();
    var { COMPONENT } = require_constants3();
    var HttpServerPlugin = class extends ServerPlugin {
      static id = "http";
      static prefix = "apm:http:server:request";
      constructor(...args) {
        super(...args);
        this._parentStore = void 0;
        this.addTraceSub("exit", (message) => this.exit(message));
      }
      start({ req, res, abortController }) {
        const store = storage("legacy").getStore();
        const span = web.startSpan(
          this.tracer,
          {
            ...this.config,
            service: this.config.service || this.serviceName()
          },
          req,
          res,
          this.operationName()
        );
        span.setTag(COMPONENT, this.constructor.id);
        span._integrationName = this.constructor.id;
        this._parentStore = store;
        this.enter(span, { ...store, req, res });
        const context2 = web.getContext(req);
        if (!context2.instrumented) {
          context2.res.writeHead = web.wrapWriteHead(context2);
          context2.instrumented = true;
        }
        if (incomingHttpRequestStart.hasSubscribers) {
          incomingHttpRequestStart.publish({ req, res, abortController });
        }
      }
      error(error) {
        web.addError(error);
      }
      finish({ req }) {
        const context2 = web.getContext(req);
        if (!context2 || !context2.res) return;
        if (incomingHttpRequestEnd.hasSubscribers) {
          incomingHttpRequestEnd.publish({ req, res: context2.res });
        }
        web.finishAll(context2);
      }
      exit({ req }) {
        const span = this._parentStore && this._parentStore.span;
        this.enter(span, this._parentStore);
        this._parentStore = void 0;
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
    };
    module2.exports = HttpServerPlugin;
  }
});

// ../../packages/datadog-plugin-http/src/index.js
var require_src43 = __commonJS({
  "../../packages/datadog-plugin-http/src/index.js"(exports2, module2) {
    "use strict";
    var HttpServerPlugin = require_server7();
    var HttpClientPlugin = require_client10();
    var CompositePlugin = require_composite2();
    var HttpPlugin = class extends CompositePlugin {
      static id = "http";
      static get plugins() {
        return {
          server: HttpServerPlugin,
          client: HttpClientPlugin
        };
      }
    };
    module2.exports = HttpPlugin;
  }
});

// ../../packages/datadog-plugin-http2/src/server.js
var require_server8 = __commonJS({
  "../../packages/datadog-plugin-http2/src/server.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server5();
    var web = require_web3();
    var { COMPONENT } = require_constants3();
    var Http2ServerPlugin = class extends ServerPlugin {
      constructor(tracer2, config) {
        super(tracer2, config);
        this.addBind("apm:http2:server:response:emit", this.bindEmit);
      }
      static id = "http2";
      static prefix = "apm:http2:server:request";
      bindStart(ctx) {
        const { req, res } = ctx;
        const span = web.startSpan(
          this.tracer,
          {
            ...this.config,
            service: this.config.service || this.serviceName()
          },
          req,
          res,
          this.operationName(),
          ctx
        );
        span.setTag(COMPONENT, this.constructor.id);
        span._integrationName = this.constructor.id;
        ctx.currentStore.req = req;
        ctx.currentStore.res = res;
        const context2 = web.getContext(req);
        if (!context2.instrumented) {
          context2.res.writeHead = web.wrapWriteHead(context2);
          context2.instrumented = true;
        }
        return ctx.currentStore;
      }
      bindEmit(ctx) {
        if (ctx.eventName !== "close") return ctx.currentStore;
        const { req } = ctx;
        const context2 = web.getContext(req);
        if (!context2 || !context2.res) return;
        web.finishAll(context2);
        return ctx.currentStore;
      }
      error(error) {
        web.addError(error);
      }
      configure(config) {
        return super.configure(web.normalizeConfig(config));
      }
    };
    module2.exports = Http2ServerPlugin;
  }
});

// ../../packages/datadog-plugin-http2/src/client.js
var require_client11 = __commonJS({
  "../../packages/datadog-plugin-http2/src/client.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var ClientPlugin = require_client5();
    var URL2 = __require("url").URL;
    var log = require_log2();
    var tags = require_tags();
    var kinds = require_kinds();
    var formats = require_formats();
    var { COMPONENT, CLIENT_PORT_KEY } = require_constants3();
    var urlFilter = require_urlfilter();
    var HTTP_HEADERS = formats.HTTP_HEADERS;
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var HTTP_REQUEST_HEADERS = tags.HTTP_REQUEST_HEADERS;
    var HTTP_RESPONSE_HEADERS = tags.HTTP_RESPONSE_HEADERS;
    var SPAN_KIND = tags.SPAN_KIND;
    var CLIENT = kinds.CLIENT;
    var HTTP2_HEADER_METHOD = ":method";
    var HTTP2_HEADER_PATH = ":path";
    var HTTP2_HEADER_STATUS = ":status";
    var HTTP2_METHOD_GET = "GET";
    var Http2ClientPlugin = class extends ClientPlugin {
      static id = "http2";
      static prefix = "apm:http2:client:request";
      bindStart(message) {
        const { authority, options, headers = {} } = message;
        const sessionDetails = extractSessionDetails(authority, options);
        const path = headers[HTTP2_HEADER_PATH] || "/";
        const pathname = path.split(/[?#]/)[0];
        const method = headers[HTTP2_HEADER_METHOD] || HTTP2_METHOD_GET;
        const uri = `${sessionDetails.protocol}//${sessionDetails.host}:${sessionDetails.port}${pathname}`;
        const allowed = this.config.filter(uri);
        const store = storage("legacy").getStore();
        const childOf = store && allowed ? store.span : null;
        const span = this.startSpan(this.operationName(), {
          childOf,
          integrationName: this.constructor.id,
          meta: {
            [COMPONENT]: this.constructor.id,
            [SPAN_KIND]: CLIENT,
            "service.name": this.serviceName({ pluginConfig: this.config, sessionDetails }),
            "resource.name": method,
            "span.type": "http",
            "http.method": method,
            "http.url": uri,
            "out.host": sessionDetails.host
          },
          metrics: {
            [CLIENT_PORT_KEY]: Number.parseInt(sessionDetails.port)
          }
        }, false);
        if (!allowed) {
          span._spanContext._trace.record = false;
        }
        addHeaderTags(span, headers, HTTP_REQUEST_HEADERS, this.config);
        if (!hasAmazonSignature(headers, path)) {
          this.tracer.inject(span, HTTP_HEADERS, headers);
        }
        message.parentStore = store;
        message.currentStore = { ...store, span };
        return message.currentStore;
      }
      bindAsyncStart(ctx) {
        const { eventName, eventData, currentStore, parentStore } = ctx;
        if (!currentStore) return storage("legacy").getStore();
        switch (eventName) {
          case "response":
            this._onResponse(currentStore, eventData);
            return parentStore;
          case "error":
            this._onError(currentStore, eventData, ctx);
            return parentStore;
          case "close":
            this._onClose(ctx);
            return parentStore;
        }
        return storage("legacy").getStore();
      }
      configure(config) {
        return super.configure(normalizeConfig(config));
      }
      _onResponse(store, headers) {
        const status = headers && headers[HTTP2_HEADER_STATUS];
        store.span.setTag(HTTP_STATUS_CODE, status);
        if (!this.config.validateStatus(status)) {
          storage("legacy").run(store, () => this.addError());
        }
        addHeaderTags(store.span, headers, HTTP_RESPONSE_HEADERS, this.config);
      }
      _onError({ span }, error, ctx) {
        span.setTag("error", error);
        super.finish(ctx);
      }
      _onClose(ctx) {
        super.finish(ctx);
      }
    };
    function extractSessionDetails(authority, options) {
      if (typeof authority === "string") {
        authority = new URL2(authority);
      }
      const protocol = authority.protocol || options.protocol || "https:";
      let port = authority.port === "" ? authority.protocol === "http:" ? "80" : "443" : String(authority.port);
      let host = authority.hostname || authority.host || "localhost";
      if (protocol === "https:" && options) {
        port = options.port || port;
        host = options.host || host;
      }
      return { protocol, port, host };
    }
    function hasAmazonSignature(headers, path) {
      if (path?.toLowerCase().includes("x-amz-signature=")) {
        return true;
      }
      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          const lowerCaseKey = key.toLowerCase();
          if (lowerCaseKey === "x-amz-signature" && value) {
            return true;
          }
          if (lowerCaseKey === "authorization" && value) {
            const authorization = Array.isArray(value) ? value : [value];
            if (authorization.some((val) => val.startsWith("AWS4-HMAC-SHA256"))) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function getStatusValidator(config) {
      if (typeof config.validateStatus === "function") {
        return config.validateStatus;
      } else if (config.hasOwnProperty("validateStatus")) {
        log.error("Expected `validateStatus` to be a function.");
      }
      return (code) => code < 400 || code >= 500;
    }
    function normalizeConfig(config) {
      const validateStatus = getStatusValidator(config);
      const filter = getFilter(config);
      const headers = getHeaders(config);
      return {
        ...config,
        validateStatus,
        filter,
        headers
      };
    }
    function getFilter(config) {
      config = { ...config, blocklist: config.blocklist || [] };
      return urlFilter.getFilter(config);
    }
    function addHeaderTags(span, headers, prefix, config) {
      if (!headers) return;
      config.headers.forEach((key) => {
        const value = headers[key];
        if (value) {
          span.setTag(`${prefix}.${key}`, value);
        }
      });
    }
    function getHeaders(config) {
      if (!Array.isArray(config.headers)) return [];
      return config.headers.filter((key) => typeof key === "string").map((key) => key.toLowerCase());
    }
    module2.exports = Http2ClientPlugin;
  }
});

// ../../packages/datadog-plugin-http2/src/index.js
var require_src44 = __commonJS({
  "../../packages/datadog-plugin-http2/src/index.js"(exports2, module2) {
    "use strict";
    var Http2ServerPlugin = require_server8();
    var Http2ClientPlugin = require_client11();
    var CompositePlugin = require_composite2();
    var Http2Plugin = class extends CompositePlugin {
      static id = "http2";
      static get plugins() {
        return {
          server: Http2ServerPlugin,
          client: Http2ClientPlugin
        };
      }
    };
    module2.exports = Http2Plugin;
  }
});

// ../../packages/datadog-plugin-ioredis/src/index.js
var require_src45 = __commonJS({
  "../../packages/datadog-plugin-ioredis/src/index.js"(exports2, module2) {
    "use strict";
    var RedisPlugin = require_src20();
    var IORedisPlugin = class extends RedisPlugin {
      static id = "ioredis";
    };
    module2.exports = IORedisPlugin;
  }
});

// ../../packages/datadog-plugin-iovalkey/src/index.js
var require_src46 = __commonJS({
  "../../packages/datadog-plugin-iovalkey/src/index.js"(exports2, module2) {
    "use strict";
    var RedisPlugin = require_src20();
    var IOValkeyPlugin = class extends RedisPlugin {
      static id = "iovalkey";
      static system = "valkey";
      constructor(...args) {
        super(...args);
        this._spanType = "valkey";
      }
    };
    module2.exports = IOValkeyPlugin;
  }
});

// ../../packages/datadog-plugin-kafkajs/src/producer.js
var require_producer7 = __commonJS({
  "../../packages/datadog-plugin-kafkajs/src/producer.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer();
    var { DsmPathwayCodec, getMessageSize } = require_datastreams();
    var BOOTSTRAP_SERVERS_KEY = "messaging.kafka.bootstrap.servers";
    var MESSAGING_DESTINATION_KEY = "messaging.destination.name";
    var KafkajsProducerPlugin = class extends ProducerPlugin {
      static id = "kafkajs";
      static operation = "produce";
      static peerServicePrecursors = [BOOTSTRAP_SERVERS_KEY];
      constructor() {
        super(...arguments);
        this.addSub(`apm:${this.constructor.id}:produce:commit`, (message) => this.commit(message));
      }
      /**
       * Transform individual commit details sent by kafkajs' event reporter
       * into actionable backlog items for DSM
       *
       * @typedef {object} ProducerBacklog
       * @property {number} type
       * @property {string} topic
       * @property {number} partition
       * @property {number} offset
       *
       * @typedef {object} ProducerResponseItem
       * @property {string} topic
       * @property {number} partition
       * @property {import('kafkajs/utils/long').Long} [offset]
       * @property {import('kafkajs/utils/long').Long} [baseOffset]
       *
       * @param {ProducerResponseItem} response
       * @returns {ProducerBacklog}
       */
      transformProduceResponse(response) {
        const { topicName: topic, partition, offset, baseOffset } = response;
        const offsetAsLong = offset || baseOffset;
        return {
          type: "kafka_produce",
          partition,
          offset: offsetAsLong ? Number(offsetAsLong) : void 0,
          topic
        };
      }
      /**
       *
       * @param {ProducerResponseItem[]} commitList
       * @returns {void}
       */
      commit(ctx) {
        const commitList = ctx.result;
        if (!this.config.dsmEnabled) return;
        if (!commitList || !Array.isArray(commitList)) return;
        const keys = [
          "type",
          "partition",
          "offset",
          "topic"
        ];
        for (const commit of commitList.map(this.transformProduceResponse)) {
          if (keys.some((key) => !commit.hasOwnProperty(key))) continue;
          this.tracer.setOffset(commit);
        }
      }
      bindStart(ctx) {
        const { topic, messages, bootstrapServers, clusterId, disableHeaderInjection } = ctx;
        const span = this.startSpan({
          resource: topic,
          meta: {
            component: this.constructor.id,
            "kafka.topic": topic,
            "kafka.cluster_id": clusterId,
            [MESSAGING_DESTINATION_KEY]: topic
          },
          metrics: {
            "kafka.batch_size": messages.length
          }
        }, ctx);
        if (bootstrapServers) {
          span.setTag(BOOTSTRAP_SERVERS_KEY, bootstrapServers);
        }
        for (const message of messages) {
          if (message !== null && typeof message === "object") {
            if (!disableHeaderInjection) {
              message.headers ??= {};
              this.tracer.inject(span, "text_map", message.headers);
            }
            if (this.config.dsmEnabled) {
              const payloadSize = getMessageSize(message);
              const edgeTags = ["direction:out", `topic:${topic}`, "type:kafka"];
              if (clusterId) {
                edgeTags.push(`kafka_cluster_id:${clusterId}`);
              }
              const dataStreamsContext = this.tracer.setCheckpoint(edgeTags, span, payloadSize);
              if (!disableHeaderInjection) {
                DsmPathwayCodec.encode(dataStreamsContext, message.headers);
              }
            }
          }
        }
        return ctx.currentStore;
      }
    };
    module2.exports = KafkajsProducerPlugin;
  }
});

// ../../packages/datadog-plugin-kafkajs/src/utils.js
var require_utils8 = __commonJS({
  "../../packages/datadog-plugin-kafkajs/src/utils.js"(exports2, module2) {
    "use strict";
    function convertToTextMap(bufferMap) {
      if (!bufferMap) return null;
      if (Array.isArray(bufferMap)) {
        const headers = {};
        for (const headerMap of bufferMap) {
          for (const key of Object.keys(headerMap)) {
            headers[key] = headerMap[key].toString();
          }
        }
        return headers;
      }
      const textMap = {};
      for (const key of Object.keys(bufferMap)) {
        if (bufferMap[key] === null || bufferMap[key] === void 0) continue;
        textMap[key] = bufferMap[key].toString();
      }
      return textMap;
    }
    module2.exports = {
      convertToTextMap
    };
  }
});

// ../../packages/datadog-plugin-kafkajs/src/consumer.js
var require_consumer5 = __commonJS({
  "../../packages/datadog-plugin-kafkajs/src/consumer.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var { getMessageSize } = require_datastreams();
    var ConsumerPlugin = require_consumer();
    var { convertToTextMap } = require_utils8();
    var afterStartCh = dc.channel("dd-trace:kafkajs:consumer:afterStart");
    var beforeFinishCh = dc.channel("dd-trace:kafkajs:consumer:beforeFinish");
    var MESSAGING_DESTINATION_KEY = "messaging.destination.name";
    var KafkajsConsumerPlugin = class extends ConsumerPlugin {
      static id = "kafkajs";
      static operation = "consume";
      constructor() {
        super(...arguments);
        this.addSub(`apm:${this.constructor.id}:consume:commit`, (message) => this.commit(message));
      }
      /**
       * Transform individual commit details sent by kafkajs' event reporter
       * into actionable backlog items for DSM
       *
       * @typedef {object} ConsumerBacklog
       * @property {number} type
       * @property {string} consumer_group
       * @property {string} topic
       * @property {number} partition
       * @property {number} offset
       *
       * @typedef {object} CommitEventItem
       * @property {string} groupId
       * @property {string} topic
       * @property {number} partition
       * @property {import('kafkajs/utils/long').Long} offset
       *
       * @param {CommitEventItem} commit
       * @returns {ConsumerBacklog}
       */
      transformCommit(commit) {
        const { groupId, partition, offset, topic } = commit;
        return {
          partition,
          topic,
          type: "kafka_commit",
          offset: Number(offset),
          consumer_group: groupId
        };
      }
      commit(commitList) {
        if (!this.config.dsmEnabled) return;
        const keys = [
          "consumer_group",
          "type",
          "partition",
          "offset",
          "topic"
        ];
        for (const commit of commitList.map(this.transformCommit)) {
          if (keys.some((key) => !commit.hasOwnProperty(key))) continue;
          this.tracer.setOffset(commit);
        }
      }
      bindStart(ctx) {
        const { topic, partition, message, groupId, clusterId } = ctx.extractedArgs || ctx;
        let childOf;
        const headers = convertToTextMap(message?.headers);
        if (headers) {
          childOf = this.tracer.extract("text_map", headers);
        }
        const span = this.startSpan({
          childOf,
          resource: topic,
          type: "worker",
          meta: {
            component: this.constructor.id,
            "kafka.topic": topic,
            "kafka.cluster_id": clusterId,
            [MESSAGING_DESTINATION_KEY]: topic
          },
          metrics: {
            "kafka.partition": partition
          }
        }, ctx);
        if (message?.offset) span.setTag("kafka.message.offset", message?.offset);
        if (this.config.dsmEnabled && headers) {
          const payloadSize = getMessageSize(message);
          this.tracer.decodeDataStreamsContext(headers);
          const edgeTags = ["direction:in", `group:${groupId}`, `topic:${topic}`, "type:kafka"];
          if (clusterId) {
            edgeTags.push(`kafka_cluster_id:${clusterId}`);
          }
          this.tracer.setCheckpoint(edgeTags, span, payloadSize);
        }
        if (afterStartCh.hasSubscribers) {
          afterStartCh.publish({ topic, partition, message, groupId, currentStore: ctx.currentStore });
        }
        return ctx.currentStore;
      }
      finish(ctx) {
        if (beforeFinishCh.hasSubscribers) {
          beforeFinishCh.publish();
        }
        super.finish(ctx);
      }
    };
    module2.exports = KafkajsConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-kafkajs/src/batch-consumer.js
var require_batch_consumer = __commonJS({
  "../../packages/datadog-plugin-kafkajs/src/batch-consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var { getMessageSize } = require_datastreams();
    var { convertToTextMap } = require_utils8();
    var KafkajsBatchConsumerPlugin = class extends ConsumerPlugin {
      static id = "kafkajs";
      static operation = "consume-batch";
      start(ctx) {
        const { topic, messages, groupId, clusterId } = ctx.extractedArgs || ctx;
        if (!this.config.dsmEnabled) return;
        for (const message of messages) {
          if (!message || !message.headers) continue;
          const payloadSize = getMessageSize(message);
          this.tracer.decodeDataStreamsContext(convertToTextMap(message.headers));
          const edgeTags = ["direction:in", `group:${groupId}`, `topic:${topic}`, "type:kafka"];
          if (clusterId) {
            edgeTags.push(`kafka_cluster_id:${clusterId}`);
          }
          this.tracer.setCheckpoint(edgeTags, null, payloadSize);
        }
      }
    };
    module2.exports = KafkajsBatchConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-kafkajs/src/index.js
var require_src47 = __commonJS({
  "../../packages/datadog-plugin-kafkajs/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer7();
    var ConsumerPlugin = require_consumer5();
    var BatchConsumerPlugin = require_batch_consumer();
    var CompositePlugin = require_composite2();
    var KafkajsPlugin = class extends CompositePlugin {
      static id = "kafkajs";
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          batchConsumer: BatchConsumerPlugin
        };
      }
    };
    module2.exports = KafkajsPlugin;
  }
});

// ../../packages/datadog-plugin-confluentinc-kafka-javascript/src/producer.js
var require_producer8 = __commonJS({
  "../../packages/datadog-plugin-confluentinc-kafka-javascript/src/producer.js"(exports2, module2) {
    "use strict";
    var KafkajsProducerPlugin = require_producer7();
    var ConfluentKafkaJsProducerPlugin = class extends KafkajsProducerPlugin {
      static id = "confluentinc-kafka-javascript";
    };
    module2.exports = ConfluentKafkaJsProducerPlugin;
  }
});

// ../../packages/datadog-plugin-confluentinc-kafka-javascript/src/consumer.js
var require_consumer6 = __commonJS({
  "../../packages/datadog-plugin-confluentinc-kafka-javascript/src/consumer.js"(exports2, module2) {
    "use strict";
    var KafkajsConsumerPlugin = require_consumer5();
    var ConfluentKafkaJsConsumerPlugin = class extends KafkajsConsumerPlugin {
      static id = "confluentinc-kafka-javascript";
    };
    module2.exports = ConfluentKafkaJsConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-confluentinc-kafka-javascript/src/batch-consumer.js
var require_batch_consumer2 = __commonJS({
  "../../packages/datadog-plugin-confluentinc-kafka-javascript/src/batch-consumer.js"(exports2, module2) {
    "use strict";
    var KafkajsBatchConsumerPlugin = require_batch_consumer();
    var ConfluentKafkaJsBatchConsumerPlugin = class extends KafkajsBatchConsumerPlugin {
      static id = "confluentinc-kafka-javascript";
    };
    module2.exports = ConfluentKafkaJsBatchConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-confluentinc-kafka-javascript/src/index.js
var require_src48 = __commonJS({
  "../../packages/datadog-plugin-confluentinc-kafka-javascript/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer8();
    var ConsumerPlugin = require_consumer6();
    var BatchConsumerPlugin = require_batch_consumer2();
    var KafkajsPlugin = require_src47();
    var ConfluentKafkaJsPlugin = class extends KafkajsPlugin {
      /**
       * @override
       */
      static id = "confluentinc-kafka-javascript";
      /**
       * @override
       */
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin,
          batchConsumer: BatchConsumerPlugin
        };
      }
    };
    module2.exports = ConfluentKafkaJsPlugin;
  }
});

// ../../packages/datadog-plugin-mysql/src/index.js
var require_src49 = __commonJS({
  "../../packages/datadog-plugin-mysql/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var CLIENT_PORT_KEY = require_constants3();
    var DatabasePlugin = require_database();
    var MySQLPlugin = class extends DatabasePlugin {
      static id = "mysql";
      static system = "mysql";
      constructor() {
        super(...arguments);
        this.addSub(`apm:${this.component}:connection:start`, (ctx) => {
          ctx.parentStore = storage("legacy").getStore();
        });
        this.addBind(`apm:${this.component}:connection:finish`, (ctx) => ctx.parentStore);
      }
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config, dbConfig: ctx.conf, system: this.system });
        const span = this.startSpan(this.operationName(), {
          service,
          resource: ctx.sql,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": this.system,
            "db.user": ctx.conf.user,
            "db.name": ctx.conf.database,
            "out.host": ctx.conf.host,
            [CLIENT_PORT_KEY]: ctx.conf.port
          }
        }, ctx);
        ctx.sql = this.injectDbmQuery(span, ctx.sql, service);
        return ctx.currentStore;
      }
    };
    module2.exports = MySQLPlugin;
  }
});

// ../../packages/datadog-plugin-mariadb/src/index.js
var require_src50 = __commonJS({
  "../../packages/datadog-plugin-mariadb/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var MySQLPlugin = require_src49();
    var MariadbPlugin = class extends MySQLPlugin {
      static id = "mariadb";
      static system = "mariadb";
      constructor(...args) {
        super(...args);
        this.addBind(`apm:${this.component}:pool:skip`, () => ({ noop: true }));
        this.addSub(`apm:${this.component}:command:add`, (ctx) => {
          ctx.parentStore = storage("legacy").getStore();
        });
      }
    };
    module2.exports = MariadbPlugin;
  }
});

// ../../packages/datadog-plugin-memcached/src/index.js
var require_src51 = __commonJS({
  "../../packages/datadog-plugin-memcached/src/index.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var CachePlugin = require_cache();
    var MemcachedPlugin = class extends CachePlugin {
      static id = "memcached";
      bindStart(ctx) {
        const { client, server: server2, query } = ctx;
        const address = getAddress(client, server2, query);
        const meta = {
          "out.host": address[0],
          [CLIENT_PORT_KEY]: address[1]
        };
        if (this.config.memcachedCommandEnabled) {
          meta["memcached.command"] = query.command;
        }
        this.startSpan({
          service: this.serviceName({ pluginConfig: this.config, system: this.system }),
          resource: query.type,
          type: "memcached",
          meta
        }, ctx);
        return ctx.currentStore;
      }
    };
    function getAddress(client, server2, query) {
      if (!server2) {
        if (client.servers.length === 1) {
          server2 = client.servers[0];
        } else {
          let redundancy = client.redundancy && client.redundancy < client.servers.length;
          const queryRedundancy = query.redundancyEnabled;
          if (redundancy && queryRedundancy) {
            redundancy = client.HashRing.range(query.key, client.redundancy + 1, true);
            server2 = redundancy.shift();
          } else {
            server2 = client.HashRing.get(query.key);
          }
        }
      }
      return server2 && server2.split(":");
    }
    module2.exports = MemcachedPlugin;
  }
});

// ../../packages/datadog-plugin-microgateway-core/src/index.js
var require_src52 = __commonJS({
  "../../packages/datadog-plugin-microgateway-core/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var web = require_web3();
    var MicrogatewayCorePlugin = class extends RouterPlugin {
      static id = "microgateway-core";
      constructor(...args) {
        super(...args);
        this.addSub("apm:microgateway-core:request:handle", ({ req }) => {
          this.setFramework(req, "microgateway", this.config);
        });
        this.addSub("apm:microgateway-core:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
        this.addSub("apm:microgateway-core:request:error", ({ error }) => {
          this.addError(error);
        });
      }
    };
    module2.exports = MicrogatewayCorePlugin;
  }
});

// ../../packages/datadog-plugin-mocha/src/index.js
var require_src53 = __commonJS({
  "../../packages/datadog-plugin-mocha/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      TEST_STATUS,
      TEST_PARAMETERS,
      finishAllTraceSpans,
      getTestSuitePath,
      getTestParametersString,
      getTestSuiteCommonTags,
      addIntelligentTestRunnerSpanTags,
      TEST_SOURCE_START,
      TEST_ITR_UNSKIPPABLE,
      TEST_ITR_FORCED_RUN,
      TEST_CODE_OWNERS,
      ITR_CORRELATION_ID,
      TEST_SOURCE_FILE,
      TEST_IS_NEW,
      TEST_IS_RETRY,
      TEST_EARLY_FLAKE_ENABLED,
      TEST_EARLY_FLAKE_ABORT_REASON,
      MOCHA_IS_PARALLEL,
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TEST_RETRY_REASON,
      TEST_MANAGEMENT_ENABLED,
      TEST_MANAGEMENT_IS_QUARANTINED,
      TEST_MANAGEMENT_IS_DISABLED,
      TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX,
      TEST_HAS_FAILED_ALL_RETRIES,
      TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED,
      TEST_RETRY_REASON_TYPES,
      TEST_IS_MODIFIED,
      isModifiedTest
    } = require_test();
    var { COMPONENT } = require_constants3();
    var {
      TELEMETRY_EVENT_CREATED,
      TELEMETRY_EVENT_FINISHED,
      TELEMETRY_CODE_COVERAGE_STARTED,
      TELEMETRY_CODE_COVERAGE_FINISHED,
      TELEMETRY_ITR_FORCED_TO_RUN,
      TELEMETRY_CODE_COVERAGE_EMPTY,
      TELEMETRY_ITR_UNSKIPPABLE,
      TELEMETRY_CODE_COVERAGE_NUM_FILES,
      TELEMETRY_TEST_SESSION
    } = require_telemetry();
    var BREAKPOINT_SET_GRACE_PERIOD_MS = 200;
    var MochaPlugin = class extends CiPlugin {
      static id = "mocha";
      constructor(...args) {
        super(...args);
        this._testTitleToParams = {};
        this.sourceRoot = process.cwd();
        this.addSub("ci:mocha:test-suite:code-coverage", ({ coverageFiles, suiteFile }) => {
          if (!this.libraryConfig?.isCodeCoverageEnabled) {
            return;
          }
          const testSuite = getTestSuitePath(suiteFile, this.sourceRoot);
          const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite);
          if (!coverageFiles.length) {
            this.telemetry.count(TELEMETRY_CODE_COVERAGE_EMPTY);
          }
          const relativeCoverageFiles = [...coverageFiles, suiteFile].map((filename) => getTestSuitePath(filename, this.repositoryRoot || this.sourceRoot));
          const { _traceId, _spanId } = testSuiteSpan.context();
          const formattedCoverage = {
            sessionId: _traceId,
            suiteId: _spanId,
            files: relativeCoverageFiles
          };
          this.tracer._exporter.exportCoverage(formattedCoverage);
          this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_FINISHED, "suite", { library: "istanbul" });
          this.telemetry.distribution(TELEMETRY_CODE_COVERAGE_NUM_FILES, {}, relativeCoverageFiles.length);
        });
        this.addBind("ci:mocha:test-suite:start", (ctx) => {
          const { testSuiteAbsolutePath, isUnskippable, isForcedToRun, itrCorrelationId } = ctx;
          if (!this.testModuleSpan) {
            return;
          }
          const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.sourceRoot);
          const testSuiteMetadata = getTestSuiteCommonTags(
            this.command,
            this.frameworkVersion,
            testSuite,
            "mocha"
          );
          if (isUnskippable) {
            testSuiteMetadata[TEST_ITR_UNSKIPPABLE] = "true";
            this.telemetry.count(TELEMETRY_ITR_UNSKIPPABLE, { testLevel: "suite" });
          }
          if (isForcedToRun) {
            testSuiteMetadata[TEST_ITR_FORCED_RUN] = "true";
            this.telemetry.count(TELEMETRY_ITR_FORCED_TO_RUN, { testLevel: "suite" });
          }
          testSuiteMetadata[TEST_SOURCE_FILE] = this.repositoryRoot !== this.sourceRoot && !!this.repositoryRoot ? getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot) : testSuite;
          if (testSuiteMetadata[TEST_SOURCE_FILE]) {
            testSuiteMetadata[TEST_SOURCE_START] = 1;
          }
          const codeOwners = this.getCodeOwners(testSuiteMetadata);
          if (codeOwners) {
            testSuiteMetadata[TEST_CODE_OWNERS] = codeOwners;
          }
          const testSuiteSpan = this.tracer.startSpan("mocha.test_suite", {
            childOf: this.testModuleSpan,
            tags: {
              [COMPONENT]: this.constructor.id,
              ...this.testEnvironmentMetadata,
              ...testSuiteMetadata
            },
            integrationName: this.constructor.id
          });
          this.telemetry.ciVisEvent(TELEMETRY_EVENT_CREATED, "suite");
          if (this.libraryConfig?.isCodeCoverageEnabled) {
            this.telemetry.ciVisEvent(TELEMETRY_CODE_COVERAGE_STARTED, "suite", { library: "istanbul" });
          }
          if (itrCorrelationId) {
            testSuiteSpan.setTag(ITR_CORRELATION_ID, itrCorrelationId);
          }
          const store = storage("legacy").getStore();
          ctx.parentStore = store;
          ctx.currentStore = { ...store, testSuiteSpan };
          this._testSuiteSpansByTestSuite.set(testSuite, testSuiteSpan);
        });
        this.addSub("ci:mocha:test-suite:finish", ({ testSuiteSpan, status }) => {
          if (testSuiteSpan) {
            if (!testSuiteSpan.context()._tags[TEST_STATUS]) {
              testSuiteSpan.setTag(TEST_STATUS, status);
            }
            testSuiteSpan.finish();
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "suite");
          }
        });
        this.addBind("ci:mocha:test-suite:error", (ctx) => {
          const { error } = ctx;
          const testSuiteSpan = ctx.currentStore?.testSuiteSpan;
          if (testSuiteSpan) {
            testSuiteSpan.setTag("error", error);
            testSuiteSpan.setTag(TEST_STATUS, "fail");
            ctx.parentStore = ctx.currentStore;
            ctx.currentStore = { ...ctx.currentStore, testSuiteSpan };
          }
          return ctx.currentStore;
        });
        this.addSub("ci:mocha:test:is-modified", ({ modifiedFiles, file, onDone }) => {
          const testPath = getTestSuitePath(file, this.repositoryRoot);
          const isModified = isModifiedTest(
            testPath,
            null,
            null,
            modifiedFiles,
            this.constructor.id
          );
          onDone(isModified);
        });
        this.addBind("ci:mocha:test:fn", (ctx) => {
          return ctx.currentStore;
        });
        this.addBind("ci:mocha:test:start", (ctx) => {
          const store = storage("legacy").getStore();
          const span = this.startTestSpan(ctx);
          ctx.parentStore = store;
          ctx.currentStore = { ...store, span };
          this.activeTestSpan = span;
          return ctx.currentStore;
        });
        this.addSub("ci:mocha:worker:finish", () => {
          this.tracer._exporter.flush();
        });
        this.addSub("ci:mocha:test:finish", ({
          span,
          status,
          hasBeenRetried,
          isLastRetry,
          hasFailedAllRetries,
          attemptToFixPassed,
          attemptToFixFailed,
          isAttemptToFixRetry,
          isAtrRetry
        }) => {
          if (span) {
            span.setTag(TEST_STATUS, status);
            if (hasBeenRetried) {
              span.setTag(TEST_IS_RETRY, "true");
              if (isAtrRetry) {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
              } else {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext);
              }
            }
            if (hasFailedAllRetries) {
              span.setTag(TEST_HAS_FAILED_ALL_RETRIES, "true");
            }
            if (attemptToFixPassed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "true");
            } else if (attemptToFixFailed) {
              span.setTag(TEST_MANAGEMENT_ATTEMPT_TO_FIX_PASSED, "false");
            }
            if (isAttemptToFixRetry) {
              span.setTag(TEST_IS_RETRY, "true");
              span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atf);
            }
            const spanTags = span.context()._tags;
            this.telemetry.ciVisEvent(
              TELEMETRY_EVENT_FINISHED,
              "test",
              {
                hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
                isNew: spanTags[TEST_IS_NEW] === "true",
                isRum: spanTags[TEST_IS_RUM_ACTIVE] === "true",
                browserDriver: spanTags[TEST_BROWSER_DRIVER]
              }
            );
            span.finish();
            finishAllTraceSpans(span);
            this.activeTestSpan = null;
            if (this.di && this.libraryConfig?.isDiEnabled && this.runningTestProbe && isLastRetry) {
              this.removeDiProbe(this.runningTestProbe);
              this.runningTestProbe = null;
            }
          }
        });
        this.addBind("ci:mocha:test:skip", (ctx) => {
          const store = storage("legacy").getStore();
          if (!store) {
            const span = this.startTestSpan(ctx);
            ctx.parentStore = store;
            ctx.currentStore = { ...store, span };
            this.activeTestSpan = span;
          }
          return ctx.currentStore;
        });
        this.addBind("ci:mocha:test:error", (ctx) => {
          const { err } = ctx;
          const span = ctx.currentStore?.span;
          if (err && span) {
            if (err.constructor.name === "Pending" && !this.forbidPending) {
              span.setTag(TEST_STATUS, "skip");
            } else {
              span.setTag(TEST_STATUS, "fail");
              span.setTag("error", err);
            }
            ctx.parentStore = ctx.currentStore;
            ctx.currentStore = { ...ctx.currentStore, span };
            this.activeTestSpan = span;
          }
          return ctx.currentStore;
        });
        this.addSub("ci:mocha:test:retry", ({ span, isFirstAttempt, willBeRetried, err, test, isAtrRetry }) => {
          if (span) {
            span.setTag(TEST_STATUS, "fail");
            if (!isFirstAttempt) {
              span.setTag(TEST_IS_RETRY, "true");
              if (isAtrRetry) {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.atr);
              } else {
                span.setTag(TEST_RETRY_REASON, TEST_RETRY_REASON_TYPES.ext);
              }
            }
            if (err) {
              span.setTag("error", err);
            }
            const spanTags = span.context()._tags;
            this.telemetry.ciVisEvent(
              TELEMETRY_EVENT_FINISHED,
              "test",
              {
                hasCodeOwners: !!spanTags[TEST_CODE_OWNERS],
                isNew: spanTags[TEST_IS_NEW] === "true",
                isRum: spanTags[TEST_IS_RUM_ACTIVE] === "true",
                browserDriver: spanTags[TEST_BROWSER_DRIVER]
              }
            );
            if (isFirstAttempt && willBeRetried && this.di && this.libraryConfig?.isDiEnabled) {
              const probeInformation = this.addDiProbe(err);
              if (probeInformation) {
                const { file, line, stackIndex } = probeInformation;
                this.runningTestProbe = { file, line };
                this.testErrorStackIndex = stackIndex;
                test._ddShouldWaitForHitProbe = true;
                const waitUntil = Date.now() + BREAKPOINT_SET_GRACE_PERIOD_MS;
                while (Date.now() < waitUntil) {
                }
              }
            }
            span.finish();
            finishAllTraceSpans(span);
          }
        });
        this.addSub("ci:mocha:test:parameterize", ({ title, params }) => {
          this._testTitleToParams[title] = params;
        });
        this.addSub("ci:mocha:session:finish", ({
          status,
          isSuitesSkipped,
          testCodeCoverageLinesTotal,
          numSkippedSuites,
          hasForcedToRunSuites,
          hasUnskippableSuites,
          error,
          isEarlyFlakeDetectionEnabled,
          isEarlyFlakeDetectionFaulty,
          isTestManagementEnabled,
          isParallel
        }) => {
          if (this.testSessionSpan) {
            const { isSuitesSkippingEnabled, isCodeCoverageEnabled } = this.libraryConfig || {};
            this.testSessionSpan.setTag(TEST_STATUS, status);
            this.testModuleSpan.setTag(TEST_STATUS, status);
            if (error) {
              this.testSessionSpan.setTag("error", error);
              this.testModuleSpan.setTag("error", error);
            }
            if (isParallel) {
              this.testSessionSpan.setTag(MOCHA_IS_PARALLEL, "true");
            }
            if (isTestManagementEnabled) {
              this.testSessionSpan.setTag(TEST_MANAGEMENT_ENABLED, "true");
            }
            addIntelligentTestRunnerSpanTags(
              this.testSessionSpan,
              this.testModuleSpan,
              {
                isSuitesSkipped,
                isSuitesSkippingEnabled,
                isCodeCoverageEnabled,
                testCodeCoverageLinesTotal,
                skippingCount: numSkippedSuites,
                skippingType: "suite",
                hasForcedToRunSuites,
                hasUnskippableSuites
              }
            );
            if (isEarlyFlakeDetectionEnabled) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ENABLED, "true");
            }
            if (isEarlyFlakeDetectionFaulty) {
              this.testSessionSpan.setTag(TEST_EARLY_FLAKE_ABORT_REASON, "faulty");
            }
            this.testModuleSpan.finish();
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "module");
            this.testSessionSpan.finish();
            this.telemetry.ciVisEvent(TELEMETRY_EVENT_FINISHED, "session");
            finishAllTraceSpans(this.testSessionSpan);
            this.telemetry.count(TELEMETRY_TEST_SESSION, {
              provider: this.ciProviderName,
              autoInjected: !!getEnvironmentVariable("DD_CIVISIBILITY_AUTO_INSTRUMENTATION_PROVIDER")
            });
          }
          this.libraryConfig = null;
          this.tracer._exporter.flush();
        });
        this.addBind("ci:mocha:global:run", (ctx) => {
          return ctx.currentStore;
        });
      }
      startTestSpan(testInfo) {
        const {
          testName,
          testSuiteAbsolutePath,
          title,
          isNew,
          isEfdRetry,
          testStartLine,
          isParallel,
          isAttemptToFix,
          isDisabled,
          isQuarantined,
          isModified
        } = testInfo;
        const extraTags = {};
        const testParametersString = getTestParametersString(this._testTitleToParams, title);
        if (testParametersString) {
          extraTags[TEST_PARAMETERS] = testParametersString;
        }
        if (testStartLine) {
          extraTags[TEST_SOURCE_START] = testStartLine;
        }
        if (isParallel) {
          extraTags[MOCHA_IS_PARALLEL] = "true";
        }
        if (isAttemptToFix) {
          extraTags[TEST_MANAGEMENT_IS_ATTEMPT_TO_FIX] = "true";
        }
        if (isDisabled) {
          extraTags[TEST_MANAGEMENT_IS_DISABLED] = "true";
        }
        if (isQuarantined) {
          extraTags[TEST_MANAGEMENT_IS_QUARANTINED] = "true";
        }
        if (isModified) {
          extraTags[TEST_IS_MODIFIED] = "true";
          if (isEfdRetry) {
            extraTags[TEST_IS_RETRY] = "true";
            extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd;
          }
        }
        const testSuite = getTestSuitePath(testSuiteAbsolutePath, this.sourceRoot);
        const testSuiteSpan = this._testSuiteSpansByTestSuite.get(testSuite);
        extraTags[TEST_SOURCE_FILE] = this.repositoryRoot !== this.sourceRoot && !!this.repositoryRoot ? getTestSuitePath(testSuiteAbsolutePath, this.repositoryRoot) : testSuite;
        if (isNew) {
          extraTags[TEST_IS_NEW] = "true";
          if (isEfdRetry) {
            extraTags[TEST_IS_RETRY] = "true";
            extraTags[TEST_RETRY_REASON] = TEST_RETRY_REASON_TYPES.efd;
          }
        }
        return super.startTestSpan(testName, testSuite, testSuiteSpan, extraTags);
      }
    };
    module2.exports = MochaPlugin;
  }
});

// ../../packages/datadog-plugin-moleculer/src/util.js
var require_util12 = __commonJS({
  "../../packages/datadog-plugin-moleculer/src/util.js"(exports2, module2) {
    "use strict";
    function moleculerTags(broker, ctx, config) {
      const service = ctx.service || {};
      const action = ctx.action || {};
      const meta = config.meta && ctx.meta;
      return {
        "moleculer.context.action": action.name,
        "moleculer.context.meta": meta,
        "moleculer.context.node_id": ctx.nodeID,
        "moleculer.context.request_id": ctx.requestID,
        "moleculer.context.service": service.name,
        "moleculer.namespace": broker.namespace,
        "moleculer.node_id": broker.nodeID
      };
    }
    module2.exports = { moleculerTags };
  }
});

// ../../packages/datadog-plugin-moleculer/src/server.js
var require_server9 = __commonJS({
  "../../packages/datadog-plugin-moleculer/src/server.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server5();
    var { moleculerTags } = require_util12();
    var MoleculerServerPlugin = class extends ServerPlugin {
      static id = "moleculer";
      static operation = "action";
      bindStart(ctx) {
        const { action, middlewareCtx, broker } = ctx;
        const followsFrom = this.tracer.extract("text_map", middlewareCtx.meta);
        this.startSpan(this.operationName(), {
          childOf: followsFrom || ctx?.currentStore?.span || this.activeSpan,
          service: this.config.service || this.serviceName(),
          resource: action.name,
          kind: "server",
          type: "web",
          meta: {
            "resource.name": action.name,
            ...moleculerTags(broker, middlewareCtx, this.config)
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = MoleculerServerPlugin;
  }
});

// ../../packages/datadog-plugin-moleculer/src/client.js
var require_client12 = __commonJS({
  "../../packages/datadog-plugin-moleculer/src/client.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var { moleculerTags } = require_util12();
    var MoleculerClientPlugin = class extends ClientPlugin {
      static id = "moleculer";
      static operation = "call";
      bindStart(ctx) {
        const { actionName, opts } = ctx;
        const span = this.startSpan(this.operationName(), {
          service: this.config.service || this.serviceName(),
          resource: actionName,
          kind: "client"
        }, ctx);
        this.tracer.inject(span, "text_map", opts.meta);
        return ctx.currentStore;
      }
      finish(ctx) {
        const { promiseCtx, broker } = ctx;
        const span = ctx.currentStore.span || this.activeSpan;
        if (promiseCtx) {
          const endpoint = promiseCtx.endpoint || {};
          const node = endpoint.node || {};
          this.addHost({ hostname: node.hostname, port: node.port });
          span.addTags(moleculerTags(broker, promiseCtx, this.config));
        }
        super.finish(ctx);
      }
    };
    module2.exports = MoleculerClientPlugin;
  }
});

// ../../packages/datadog-plugin-moleculer/src/index.js
var require_src54 = __commonJS({
  "../../packages/datadog-plugin-moleculer/src/index.js"(exports2, module2) {
    "use strict";
    var MoleculerServerPlugin = require_server9();
    var MoleculerClientPlugin = require_client12();
    var CompositePlugin = require_composite2();
    var MoleculerPlugin = class extends CompositePlugin {
      static id = "moleculer";
      static get plugins() {
        return {
          server: MoleculerServerPlugin,
          client: MoleculerClientPlugin
        };
      }
    };
    module2.exports = MoleculerPlugin;
  }
});

// ../../packages/datadog-plugin-mongodb-core/src/index.js
var require_src55 = __commonJS({
  "../../packages/datadog-plugin-mongodb-core/src/index.js"(exports2, module2) {
    "use strict";
    var { isTrue } = require_util();
    var DatabasePlugin = require_database();
    var { getEnvironmentVariable } = require_config_helper();
    var MongodbCorePlugin = class extends DatabasePlugin {
      static id = "mongodb-core";
      static component = "mongodb";
      // avoid using db.name for peer.service since it includes the collection name
      // should be removed if one day this will be fixed
      /**
       * @override
       */
      static peerServicePrecursors = [];
      /**
       * @override
       */
      configure(config) {
        super.configure(config);
        const heartbeatFromEnv = getEnvironmentVariable("DD_TRACE_MONGODB_HEARTBEAT_ENABLED");
        this.config.heartbeatEnabled = config.heartbeatEnabled ?? (heartbeatFromEnv && isTrue(heartbeatFromEnv)) ?? true;
      }
      bindStart(ctx) {
        const { ns, ops, options = {}, name } = ctx;
        if (!this.config.heartbeatEnabled && isHeartbeat(ops, this.config)) {
          return;
        }
        const query = getQuery(ops);
        const resource = truncate(getResource(this, ns, query, name));
        const service = this.serviceName({ pluginConfig: this.config });
        const span = this.startSpan(this.operationName(), {
          service,
          resource,
          type: "mongodb",
          kind: "client",
          meta: {
            // this is not technically correct since it includes the collection but we changing will break customer stuff
            "db.name": ns,
            "mongodb.query": query,
            "out.host": options.host,
            "out.port": options.port
          }
        }, ctx);
        const comment = this.injectDbmComment(span, ops.comment, service);
        if (comment) {
          ops.comment = comment;
        }
        return ctx.currentStore;
      }
      /**
       * @override
       */
      getPeerService(tags) {
        let ns = tags["db.name"];
        if (ns && tags["peer.service"] === void 0) {
          const dotIndex = ns.indexOf(".");
          if (dotIndex !== -1) {
            ns = ns.slice(0, dotIndex);
          }
          tags["peer.service"] = ns;
        }
        return super.getPeerService(tags);
      }
      injectDbmComment(span, comment, serviceName) {
        const dbmTraceComment = this.createDbmComment(span, serviceName);
        if (!dbmTraceComment) {
          return comment;
        }
        if (comment) {
          if (typeof comment === "string") {
            comment += `,${dbmTraceComment}`;
          } else if (Array.isArray(comment)) {
            comment.push(dbmTraceComment);
          }
        } else {
          comment = dbmTraceComment;
        }
        return comment;
      }
    };
    function sanitizeBigInt(data) {
      return JSON.stringify(data, (_key, value) => typeof value === "bigint" ? value.toString() : value);
    }
    function extractQuery(statements) {
      if (statements.length === 1 && statements[0].q) return statements[0].q;
      const extractedQueries = [];
      for (let i = 0; i < statements.length; i++) {
        if (statements[i].q) {
          extractedQueries.push(limitDepth(statements[i].q));
        }
      }
      return extractedQueries;
    }
    function getQuery(cmd) {
      if (!cmd || typeof cmd !== "object" && !Array.isArray(cmd)) return;
      if (Array.isArray(cmd)) return sanitizeBigInt(extractQuery(cmd));
      if (cmd.query) return sanitizeBigInt(limitDepth(cmd.query));
      if (cmd.filter) return sanitizeBigInt(limitDepth(cmd.filter));
      if (cmd.pipeline) return sanitizeBigInt(limitDepth(cmd.pipeline));
      if (cmd.deletes) return sanitizeBigInt(extractQuery(cmd.deletes));
      if (cmd.updates) return sanitizeBigInt(extractQuery(cmd.updates));
    }
    function getResource(plugin, ns, query, operationName) {
      let resource = `${operationName} ${ns}`;
      if (plugin.config.queryInResourceName && query) {
        resource += ` ${query}`;
      }
      return resource;
    }
    function truncate(input) {
      return input.slice(0, Math.min(input.length, 1e4));
    }
    function shouldSimplify(input) {
      return !isObject(input) || typeof input.toJSON === "function";
    }
    function shouldHide(input) {
      return Buffer.isBuffer(input) || typeof input === "function" || isBinary(input);
    }
    function limitDepth(input) {
      if (isBSON(input)) {
        input = input.toJSON();
      }
      if (shouldHide(input)) return "?";
      if (shouldSimplify(input)) return input;
      const output = {};
      const queue = [{
        input,
        output,
        depth: 0
      }];
      while (queue.length) {
        const {
          input: input2,
          output: output2,
          depth
        } = queue.pop();
        const nextDepth = depth + 1;
        for (const key in input2) {
          if (typeof input2[key] === "function") continue;
          let child = input2[key];
          if (isBSON(child)) {
            child = typeof child.toJSON === "function" ? child.toJSON() : "?";
          }
          if (depth >= 10 || shouldHide(child)) {
            output2[key] = "?";
          } else if (shouldSimplify(child)) {
            output2[key] = child;
          } else {
            queue.push({
              input: child,
              output: output2[key] = {},
              depth: nextDepth
            });
          }
        }
      }
      return output;
    }
    function isObject(val) {
      return val !== null && typeof val === "object" && !Array.isArray(val);
    }
    function isBSON(val) {
      return val && val._bsontype && !isBinary(val);
    }
    function isBinary(val) {
      return val && val._bsontype === "Binary";
    }
    function isHeartbeat(ops, config) {
      return ops && typeof ops === "object" && (ops.hello === 1 || ops.helloOk === true);
    }
    module2.exports = MongodbCorePlugin;
  }
});

// ../../packages/datadog-plugin-mongoose/src/index.js
var require_src56 = __commonJS({
  "../../packages/datadog-plugin-mongoose/src/index.js"(exports2, module2) {
    "use strict";
    var DatabasePlugin = require_database();
    var { storage } = require_datadog_core();
    var MongoosePlugin = class extends DatabasePlugin {
      static id = "mongoose";
      static operation = "exec";
      bindStart(ctx) {
        ctx.parentStore = storage("legacy").getStore();
        return ctx.parentStore;
      }
      bindFinish(ctx) {
        return ctx.parentStore;
      }
    };
    module2.exports = MongoosePlugin;
  }
});

// ../../packages/datadog-plugin-mysql2/src/index.js
var require_src57 = __commonJS({
  "../../packages/datadog-plugin-mysql2/src/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var MySQLPlugin = require_src49();
    var MySQL2Plugin = class extends MySQLPlugin {
      static id = "mysql2";
      constructor() {
        super(...arguments);
        this.addSub(`apm:${this.component}:command:add`, (ctx) => {
          ctx.parentStore = storage("legacy").getStore();
        });
        this.addBind(`apm:${this.component}:command:start`, (ctx) => ctx.parentStore);
        this.addBind(`apm:${this.component}:command:finish`, (ctx) => ctx.parentStore);
      }
      bindStart(ctx) {
        return storage("legacy").run(ctx.parentStore, () => super.bindStart(ctx));
      }
    };
    module2.exports = MySQL2Plugin;
  }
});

// ../../packages/datadog-plugin-net/src/ipc.js
var require_ipc = __commonJS({
  "../../packages/datadog-plugin-net/src/ipc.js"(exports2, module2) {
    "use strict";
    var ClientPlugin = require_client5();
    var NetIPCPlugin = class extends ClientPlugin {
      static id = "net";
      static operation = "ipc";
      bindStart(ctx) {
        this.startSpan("ipc.connect", {
          service: this.config.service,
          resource: ctx.options.path,
          kind: "client",
          meta: {
            "ipc.path": ctx.options.path
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = NetIPCPlugin;
  }
});

// ../../packages/datadog-plugin-net/src/tcp.js
var require_tcp = __commonJS({
  "../../packages/datadog-plugin-net/src/tcp.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var ClientPlugin = require_client5();
    var NetTCPPlugin = class extends ClientPlugin {
      static id = "net";
      static operation = "tcp";
      constructor(...args) {
        super(...args);
        this.addTraceBind("ready", (ctx) => {
          return ctx.parentStore;
        });
        this.addTraceSub("connection", (ctx) => {
          const span = ctx.currentStore.span;
          span.addTags({
            "tcp.local.address": ctx.socket.localAddress,
            "tcp.local.port": ctx.socket.localPort
          });
        });
      }
      bindStart(ctx) {
        const host = ctx.options.host || "localhost";
        const port = ctx.options.port || 0;
        const family = ctx.options.family || 4;
        this.startSpan("tcp.connect", {
          service: this.config.service,
          resource: [host, port].filter(Boolean).join(":"),
          kind: "client",
          meta: {
            "tcp.remote.host": host,
            "tcp.family": `IPv${family}`,
            "tcp.local.address": "",
            "out.host": host
          },
          metrics: {
            "tcp.remote.port": port,
            "tcp.local.port": 0,
            [CLIENT_PORT_KEY]: port
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = NetTCPPlugin;
  }
});

// ../../packages/datadog-plugin-net/src/index.js
var require_src58 = __commonJS({
  "../../packages/datadog-plugin-net/src/index.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var NetIPCPlugin = require_ipc();
    var NetTCPPlugin = require_tcp();
    var NetPlugin = class extends Plugin {
      static id = "net";
      constructor(...args) {
        super(...args);
        this._ipc = new NetIPCPlugin(...args);
        this._tcp = new NetTCPPlugin(...args);
      }
      configure(config) {
        this._ipc.configure(config);
        this._tcp.configure(config);
      }
    };
    module2.exports = NetPlugin;
  }
});

// ../../packages/datadog-plugin-next/src/index.js
var require_src59 = __commonJS({
  "../../packages/datadog-plugin-next/src/index.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server5();
    var { storage } = require_datadog_core();
    var analyticsSampler = require_analytics_sampler();
    var { COMPONENT } = require_constants3();
    var web = require_web3();
    var errorPages = /* @__PURE__ */ new Set(["/404", "/500", "/_error", "/_not-found", "/_not-found/page"]);
    var NextPlugin = class extends ServerPlugin {
      static id = "next";
      constructor(...args) {
        super(...args);
        this._requests = /* @__PURE__ */ new WeakMap();
        this.addSub("apm:next:page:load", (message) => this.pageLoad(message));
      }
      bindStart({ req, res }) {
        const store = storage("legacy").getStore();
        const childOf = store ? store.span : store;
        const span = this.tracer.startSpan(this.operationName(), {
          childOf,
          tags: {
            [COMPONENT]: this.constructor.id,
            "service.name": this.config.service || this.serviceName(),
            "resource.name": req.method,
            "span.type": "web",
            "span.kind": "server",
            "http.method": req.method
          },
          integrationName: this.constructor.id
        });
        analyticsSampler.sample(span, this.config.measured, true);
        this._requests.set(span, req);
        return { ...store, span };
      }
      error({ span, error }) {
        if (!span) {
          const store = storage("legacy").getStore();
          if (!store) return;
          span = store.span;
        }
        this.addError(error, span);
      }
      finish({ req, res, nextRequest = {} }) {
        const store = storage("legacy").getStore();
        if (!store) return;
        const span = store.span;
        const error = span.context()._tags.error;
        const requestError = req.error || nextRequest.error;
        if (requestError) {
          span.setTag("error", requestError);
          web.addError(req, requestError);
        } else if (error) {
          span.setTag("error", error);
          web.addError(req, requestError || error);
        } else if (!this.config.validateStatus(res.statusCode)) {
          span.setTag("error", true);
          web.addError(req, true);
        }
        span.addTags({
          "http.status_code": res.statusCode
        });
        this.config.hooks.request(span, req, res);
        span.finish();
      }
      pageLoad({ page, isAppPath = false, isStatic = false }) {
        const store = storage("legacy").getStore();
        if (!store) return;
        const span = store.span;
        const req = this._requests.get(span);
        if (!req) return;
        const current = span.context()._tags["next.page"];
        const isErrorPage = errorPages.has(page);
        if (current && isErrorPage) {
          return;
        }
        if (isAppPath && !isErrorPage) page = page.slice(0, Math.max(0, page.lastIndexOf("/")));
        if (isStatic) {
          page = req.url.includes("_next/static") ? "/_next/static/*" : "/public/*";
        }
        span.addTags({
          [COMPONENT]: this.constructor.id,
          "resource.name": `${req.method} ${page}`.trim(),
          "next.page": page
        });
        web.setRoute(req, page);
      }
      configure(config) {
        return super.configure(normalizeConfig(config));
      }
    };
    function normalizeConfig(config) {
      const hooks = getHooks(config);
      const validateStatus = typeof config.validateStatus === "function" ? config.validateStatus : (code) => code < 500;
      return { ...config, hooks, validateStatus };
    }
    var noop = () => {
    };
    function getHooks(config) {
      const request2 = config.hooks?.request ?? noop;
      return { request: request2 };
    }
    module2.exports = NextPlugin;
  }
});

// ../../packages/datadog-plugin-nyc/src/index.js
var require_src60 = __commonJS({
  "../../packages/datadog-plugin-nyc/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var NycPlugin = class extends CiPlugin {
      static id = "nyc";
      constructor(...args) {
        super(...args);
        this.addSub("ci:nyc:wrap", (nyc) => {
          if (nyc?.config?.all) {
            this.nyc = nyc;
          }
        });
        this.addSub("ci:nyc:get-coverage", ({ onDone }) => {
          if (this.nyc?.getCoverageMapFromAllCoverageFiles) {
            this.nyc.getCoverageMapFromAllCoverageFiles().then((untestedCoverageMap) => {
              this.nyc = null;
              onDone(untestedCoverageMap);
            }).catch((e) => {
              this.nyc = null;
              onDone();
            });
          } else {
            this.nyc = null;
            onDone();
          }
        });
      }
    };
    module2.exports = NycPlugin;
  }
});

// ../../packages/datadog-plugin-oracledb/src/connection-parser.js
var require_connection_parser = __commonJS({
  "../../packages/datadog-plugin-oracledb/src/connection-parser.js"(exports2, module2) {
    "use strict";
    var { URL: URL2 } = __require("url");
    var log = require_log2();
    function parseOracleDescriptor(descriptor) {
      const hostnameMatch = descriptor.match(/HOST\s*=\s*([^)]+)/i);
      const hostname = hostnameMatch?.[1] || "localhost";
      const portMatch = descriptor.match(/PORT\s*=\s*([^)]+)/i);
      const port = portMatch?.[1] || "1521";
      const sidMatch = descriptor.match(/SID\s*=\s*([^)]+)/i);
      const dbInstance = sidMatch?.[1] || descriptor.match(/SERVICE_NAME\s*=\s*([^)]+)/i)?.[1] || "XEPDB1";
      return { hostname, port, dbInstance };
    }
    module2.exports = function getDBInformation(connAttrs) {
      const connectString = ((connAttrs.connectString || connAttrs.connectionString) ?? "").trim();
      if (connectString.startsWith("(")) {
        return parseOracleDescriptor(connectString);
      }
      try {
        const url = new URL2(`oracle://${connectString}`);
        return {
          hostname: url.hostname || "localhost",
          // Default Oracle hostname
          port: url.port || "1521",
          // Default Oracle port
          dbInstance: url.pathname && url.pathname.slice(1) || "XEPDB1"
          // Default Oracle service name
        };
      } catch (error) {
        log.error("Invalid oracle connection string", error);
        return {};
      }
    };
  }
});

// ../../packages/datadog-plugin-oracledb/src/index.js
var require_src61 = __commonJS({
  "../../packages/datadog-plugin-oracledb/src/index.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var DatabasePlugin = require_database();
    var parser;
    var OracledbPlugin = class extends DatabasePlugin {
      static id = "oracledb";
      static system = "oracle";
      static peerServicePrecursors = ["db.instance", "db.hostname"];
      bindStart(ctx) {
        let { query, connAttrs, port, hostname, dbInstance } = ctx;
        const service = this.serviceName({ pluginConfig: this.config, params: connAttrs });
        if (hostname === void 0) {
          parser ??= require_connection_parser();
          const dbInfo = parser(connAttrs);
          hostname = dbInfo.hostname;
          port ??= dbInfo.port;
          dbInstance ??= dbInfo.dbInstance;
        }
        this.startSpan(this.operationName(), {
          service,
          resource: query,
          type: "sql",
          kind: "client",
          meta: {
            "db.user": this.config.user,
            "db.instance": dbInstance,
            "db.hostname": hostname,
            [CLIENT_PORT_KEY]: port
          }
        }, ctx);
        return ctx.currentStore;
      }
    };
    module2.exports = OracledbPlugin;
  }
});

// ../../packages/dd-trace/src/external-logger/src/index.js
var require_src62 = __commonJS({
  "../../packages/dd-trace/src/external-logger/src/index.js"(exports2, module2) {
    "use strict";
    var tracerLogger = require_log2();
    var https = __require("https");
    var ExternalLogger = class _ExternalLogger {
      // Note: these attribute names match the corresponding entry in the JSON payload.
      constructor({
        ddsource,
        hostname,
        service,
        apiKey,
        site = "datadoghq.com",
        interval = 1e4,
        timeout = 2e3,
        limit = 1e3
      }) {
        this.enabled = !!apiKey;
        this.ddsource = ddsource;
        this.hostname = hostname;
        this.service = service;
        this.interval = interval;
        this.timeout = timeout;
        this.queue = [];
        this.limit = limit;
        this.endpoint = "/api/v2/logs";
        this.site = site;
        this.intake = `http-intake.logs.${this.site}`;
        this.headers = {
          "DD-API-KEY": apiKey,
          "Content-Type": "application/json"
        };
        this.timer = setInterval(() => {
          this.flush();
        }, this.interval).unref();
        tracerLogger.debug(`started log writer to https://${this.intake}${this.endpoint}`);
      }
      static tagString(tags) {
        const tagArray = [];
        for (const key in tags) {
          tagArray.push(key + ":" + tags[key]);
        }
        return tagArray.join(",");
      }
      // Parses and enqueues a log
      log(log, span, tags) {
        if (!this.enabled) return;
        const logTags = _ExternalLogger.tagString(tags);
        if (span) {
          log["dd.trace_id"] = String(span.trace_id);
          log["dd.span_id"] = String(span.span_id);
        }
        const payload = {
          ...log,
          timestamp: Date.now(),
          hostname: log.hostname || this.hostname,
          ddsource: log.ddsource || this.ddsource,
          service: log.service || this.service,
          ddtags: logTags || void 0
        };
        this.enqueue(payload);
      }
      // Enqueues a raw, non-formatted log object
      enqueue(log) {
        if (this.queue.length >= this.limit) {
          this.flush();
        }
        this.queue.push(log);
      }
      shutdown() {
        clearInterval(this.timer);
        this.flush();
      }
      // Flushes logs with optional callback for when the call is complete
      flush(cb = () => {
      }) {
        let logs;
        let numLogs;
        let encodedLogs;
        if (!this.queue.length) {
          setImmediate(() => cb());
          return;
        }
        try {
          logs = this.queue;
          this.queue = [];
          numLogs = logs.length;
          encodedLogs = JSON.stringify(logs);
        } catch (error) {
          tracerLogger.error(`failed to encode ${numLogs} logs`);
          setImmediate(() => cb(error));
          return;
        }
        const options = {
          hostname: this.intake,
          port: 443,
          path: this.endpoint,
          method: "POST",
          headers: this.headers,
          timeout: this.timeout
        };
        const req = https.request(options, (res) => {
          tracerLogger.info(`statusCode: ${res.statusCode}`);
        });
        req.once("error", (e) => {
          tracerLogger.error(`failed to send ${numLogs} log(s), with error ${e.message}`);
          cb(e);
        });
        req.write(encodedLogs);
        req.end();
        req.once("response", (res) => {
          if (res.statusCode >= 400) {
            const error = new Error(`failed to send ${numLogs} logs, received response code ${res.statusCode}`);
            tracerLogger.error(error.message);
            cb(error);
            return;
          }
          cb();
        });
      }
    };
    var NoopExternalLogger = class {
      log() {
      }
      enqueue() {
      }
      shutdown() {
      }
      flush() {
      }
    };
    module2.exports.ExternalLogger = ExternalLogger;
    module2.exports.NoopExternalLogger = NoopExternalLogger;
  }
});

// ../../packages/datadog-plugin-openai/src/services.js
var require_services2 = __commonJS({
  "../../packages/datadog-plugin-openai/src/services.js"(exports2, module2) {
    "use strict";
    var { DogStatsDClient } = require_dogstatsd2();
    var NoopDogStatsDClient = require_dogstatsd();
    var { ExternalLogger, NoopExternalLogger } = require_src62();
    var FLUSH_INTERVAL = 10 * 1e3;
    var metrics2 = null;
    var logger = null;
    var interval = null;
    module2.exports.init = function(tracerConfig) {
      metrics2 = tracerConfig && tracerConfig.dogstatsd ? new DogStatsDClient({
        host: tracerConfig.dogstatsd.hostname,
        port: tracerConfig.dogstatsd.port,
        tags: [
          `service:${tracerConfig.tags.service}`,
          `env:${tracerConfig.tags.env}`,
          `version:${tracerConfig.tags.version}`
        ]
      }) : new NoopDogStatsDClient();
      logger = tracerConfig && tracerConfig.apiKey ? new ExternalLogger({
        ddsource: "openai",
        hostname: tracerConfig.hostname,
        service: tracerConfig.service,
        apiKey: tracerConfig.apiKey,
        interval: FLUSH_INTERVAL
      }) : new NoopExternalLogger();
      interval = setInterval(() => {
        metrics2.flush();
      }, FLUSH_INTERVAL).unref();
      return { metrics: metrics2, logger };
    };
    module2.exports.shutdown = function() {
      clearInterval(interval);
      metrics2 = null;
      logger = null;
      interval = null;
    };
  }
});

// ../../packages/datadog-plugin-openai/src/stream-helpers.js
var require_stream_helpers = __commonJS({
  "../../packages/datadog-plugin-openai/src/stream-helpers.js"(exports2, module2) {
    "use strict";
    function convertBuffersToObjects(chunks) {
      return Buffer.concat(chunks).toString().split(/(?=data:)/).map((chunk) => chunk.replaceAll("\n", "").slice(6)).slice(0, -1).map(JSON.parse);
    }
    function constructResponseFromStreamedChunks(chunks, n, onChoice) {
      const body = { ...chunks[0], choices: Array.from({ length: n }) };
      for (const chunk of chunks) {
        body.usage = chunk.usage;
        for (const choice of chunk.choices) {
          const choiceIdx = choice.index;
          const oldChoice = body.choices.find((choice2) => choice2?.index === choiceIdx);
          if (!oldChoice) {
            body.choices[choiceIdx] = choice;
            continue;
          }
          if (!oldChoice.finish_reason) {
            oldChoice.finish_reason = choice.finish_reason;
          }
          onChoice(choice, oldChoice);
        }
      }
      return body;
    }
    function constructCompletionResponseFromStreamedChunks(chunks, n) {
      return constructResponseFromStreamedChunks(chunks, n, (choice, oldChoice) => {
        const text = choice.text;
        if (text) {
          if (oldChoice.text) {
            oldChoice.text += text;
          } else {
            oldChoice.text = text;
          }
        }
      });
    }
    function constructChatCompletionResponseFromStreamedChunks(chunks, n) {
      return constructResponseFromStreamedChunks(chunks, n, (choice, oldChoice) => {
        const delta = choice.delta;
        if (!delta) return;
        const content = delta.content;
        if (content) {
          if (oldChoice.delta.content) {
            oldChoice.delta.content += content;
          } else {
            oldChoice.delta.content = content;
          }
        }
        const tools = delta.tool_calls;
        if (!tools) return;
        oldChoice.delta.tool_calls = tools.map((newTool, toolIdx) => {
          const oldTool = oldChoice.delta.tool_calls?.[toolIdx];
          if (oldTool) {
            oldTool.function.arguments += newTool.function.arguments;
            return oldTool;
          }
          return newTool;
        });
      });
    }
    module2.exports = {
      convertBuffersToObjects,
      constructCompletionResponseFromStreamedChunks,
      constructChatCompletionResponseFromStreamedChunks
    };
  }
});

// ../../packages/datadog-plugin-openai/src/tracing.js
var require_tracing9 = __commonJS({
  "../../packages/datadog-plugin-openai/src/tracing.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var TracingPlugin = require_tracing();
    var { storage } = require_datadog_core();
    var services = require_services2();
    var Sampler = require_sampler2();
    var { MEASURED } = require_tags();
    var {
      convertBuffersToObjects,
      constructCompletionResponseFromStreamedChunks,
      constructChatCompletionResponseFromStreamedChunks
    } = require_stream_helpers();
    var { DD_MAJOR } = require_version2();
    var OpenAiTracingPlugin = class extends TracingPlugin {
      static id = "openai";
      static operation = "request";
      static system = "openai";
      static prefix = "tracing:apm:openai:request";
      constructor(...args) {
        super(...args);
        const { metrics: metrics2, logger } = services.init(this._tracerConfig);
        this.metrics = metrics2;
        this.logger = logger;
        this.sampler = new Sampler(0.1);
        this.addSub("apm:openai:request:chunk", ({ ctx, chunk, done }) => {
          if (!ctx.chunks) ctx.chunks = [];
          if (chunk) ctx.chunks.push(chunk);
          if (!done) return;
          let chunks = ctx.chunks;
          if (chunks.length === 0) return;
          const firstChunk = chunks[0];
          if (firstChunk instanceof Buffer) {
            chunks = convertBuffersToObjects(chunks);
          }
          const methodName = ctx.currentStore.normalizedMethodName;
          let n = 1;
          const prompt = ctx.args[0].prompt;
          if (Array.isArray(prompt) && typeof prompt[0] !== "number") {
            n *= prompt.length;
          }
          let response = {};
          if (methodName === "createCompletion") {
            response = constructCompletionResponseFromStreamedChunks(chunks, n);
          } else if (methodName === "createChatCompletion") {
            response = constructChatCompletionResponseFromStreamedChunks(chunks, n);
          }
          ctx.result = { data: response };
        });
      }
      configure(config) {
        if (config.enabled === false) {
          services.shutdown();
        }
        super.configure(config);
      }
      bindStart(ctx) {
        const { methodName, args } = ctx;
        const payload = normalizeRequestPayload(methodName, args);
        const normalizedMethodName = normalizeMethodName(methodName);
        const store = storage("legacy").getStore() || {};
        store.originalMethodName = methodName;
        store.normalizedMethodName = normalizedMethodName;
        const span = this.startSpan("openai.request", {
          service: this.config.service,
          resource: DD_MAJOR >= 6 ? normalizedMethodName : methodName,
          type: "openai",
          kind: "client",
          meta: {
            [MEASURED]: 1,
            // Only model is added to all requests
            "openai.request.model": payload.model
          }
        }, false);
        const openaiStore = /* @__PURE__ */ Object.create(null);
        const tags = {};
        if (payload.stream) {
          tags["openai.request.stream"] = payload.stream;
        }
        switch (normalizedMethodName) {
          case "createImage":
          case "createImageEdit":
          case "createImageVariation":
            commonCreateImageRequestExtraction(tags, payload, openaiStore);
            break;
          case "createChatCompletion":
            createChatCompletionRequestExtraction(tags, payload, openaiStore);
            break;
          case "createFile":
          case "retrieveFile":
            commonFileRequestExtraction(tags, payload);
            break;
          case "createTranscription":
          case "createTranslation":
            commonCreateAudioRequestExtraction(tags, payload, openaiStore);
            break;
          case "retrieveModel":
            retrieveModelRequestExtraction(tags, payload);
            break;
          case "createEdit":
            createEditRequestExtraction(tags, payload, openaiStore);
            break;
        }
        span.addTags(tags);
        ctx.currentStore = { ...store, span, openai: openaiStore };
        return ctx.currentStore;
      }
      asyncEnd(ctx) {
        const { result } = ctx;
        const store = ctx.currentStore;
        const span = store?.span;
        if (!span) return;
        const error = !!span.context()._tags.error;
        let headers, body, method, path2;
        if (!error) {
          headers = result.headers;
          body = result.data;
          method = result.request.method;
          path2 = result.request.path;
        }
        if (!error && headers?.constructor.name === "Headers") {
          headers = Object.fromEntries(headers);
        }
        const resource = span._spanContext._tags["resource.name"];
        const normalizedMethodName = store.normalizedMethodName;
        body = coerceResponseBody(body, normalizedMethodName);
        const openaiStore = store.openai;
        if (!error && (path2?.startsWith("https://") || path2?.startsWith("http://"))) {
          path2 = new URL(path2).pathname;
        }
        const originalMethodName = store.originalMethodName;
        const endpoint = lookupOperationEndpoint(normalizedMethodName, originalMethodName, path2);
        const tags = error ? {} : {
          "openai.request.endpoint": endpoint,
          "openai.request.method": method.toUpperCase(),
          "openai.response.model": headers["openai-model"] || body.model,
          // specific model, often undefined
          "openai.response.id": body.id,
          // common creation value, numeric epoch
          "openai.response.deleted": body.deleted,
          // common boolean field in delete responses
          // The OpenAI API appears to use both created and created_at in different places
          // Here we're conciously choosing to surface this inconsistency instead of normalizing
          "openai.response.created": body.created,
          "openai.response.created_at": body.created_at
        };
        responseDataExtractionByMethod(normalizedMethodName, tags, body, openaiStore);
        span.addTags(tags);
        span.finish();
        this.sendLog(resource, span, tags, openaiStore, error);
        this.sendMetrics(headers, body, endpoint, span._duration, error, tags);
      }
      sendMetrics(headers, body, endpoint, duration, error, spanTags) {
        const tags = [`error:${Number(!!error)}`];
        if (error) {
          this.metrics.increment("openai.request.error", 1, tags);
        } else {
          tags.push(
            `org:${headers["openai-organization"]}`,
            `endpoint:${endpoint}`,
            `model:${headers["openai-model"] || body.model}`
          );
        }
        this.metrics.distribution("openai.request.duration", duration * 1e3, tags);
        const promptTokens = spanTags["openai.response.usage.prompt_tokens"];
        const promptTokensEstimated = spanTags["openai.response.usage.prompt_tokens_estimated"];
        const completionTokens = spanTags["openai.response.usage.completion_tokens"];
        const completionTokensEstimated = spanTags["openai.response.usage.completion_tokens_estimated"];
        const totalTokens = spanTags["openai.response.usage.total_tokens"];
        if (!error) {
          if (promptTokens != null) {
            if (promptTokensEstimated) {
              this.metrics.distribution(
                "openai.tokens.prompt",
                promptTokens,
                [...tags, "openai.estimated:true"]
              );
            } else {
              this.metrics.distribution("openai.tokens.prompt", promptTokens, tags);
            }
          }
          if (completionTokens != null) {
            if (completionTokensEstimated) {
              this.metrics.distribution(
                "openai.tokens.completion",
                completionTokens,
                [...tags, "openai.estimated:true"]
              );
            } else {
              this.metrics.distribution("openai.tokens.completion", completionTokens, tags);
            }
          }
          if (totalTokens != null) {
            if (promptTokensEstimated || completionTokensEstimated) {
              this.metrics.distribution(
                "openai.tokens.total",
                totalTokens,
                [...tags, "openai.estimated:true"]
              );
            } else {
              this.metrics.distribution("openai.tokens.total", totalTokens, tags);
            }
          }
        }
        if (headers) {
          if (headers["x-ratelimit-limit-requests"]) {
            this.metrics.gauge("openai.ratelimit.requests", Number(headers["x-ratelimit-limit-requests"]), tags);
          }
          if (headers["x-ratelimit-remaining-requests"]) {
            this.metrics.gauge(
              "openai.ratelimit.remaining.requests",
              Number(headers["x-ratelimit-remaining-requests"]),
              tags
            );
          }
          if (headers["x-ratelimit-limit-tokens"]) {
            this.metrics.gauge("openai.ratelimit.tokens", Number(headers["x-ratelimit-limit-tokens"]), tags);
          }
          if (headers["x-ratelimit-remaining-tokens"]) {
            this.metrics.gauge("openai.ratelimit.remaining.tokens", Number(headers["x-ratelimit-remaining-tokens"]), tags);
          }
        }
      }
      sendLog(methodName, span, tags, openaiStore, error) {
        if (!openaiStore) return;
        if (!Object.keys(openaiStore).length) return;
        if (!this.sampler.isSampled(span)) return;
        const log = {
          status: error ? "error" : "info",
          message: `sampled ${methodName}`,
          ...openaiStore
        };
        this.logger.log(log, span, tags);
      }
    };
    function normalizeMethodName(methodName) {
      switch (methodName) {
        // moderations
        case "moderations.create":
          return "createModeration";
        // completions
        case "completions.create":
          return "createCompletion";
        // chat completions
        case "chat.completions.create":
          return "createChatCompletion";
        // edits
        case "edits.create":
          return "createEdit";
        // embeddings
        case "embeddings.create":
          return "createEmbedding";
        // files
        case "files.create":
          return "createFile";
        case "files.retrieve":
          return "retrieveFile";
        case "files.del":
        case "files.delete":
          return "deleteFile";
        case "files.retrieveContent":
        case "files.content":
          return "downloadFile";
        case "files.list":
          return "listFiles";
        // fine-tuning
        case "fine_tuning.jobs.list":
        case "fine-tune.list":
          return "listFineTunes";
        case "fine_tuning.jobs.listEvents":
        case "fine-tune.listEvents":
          return "listFineTuneEvents";
        case "fine_tuning.jobs.create":
        case "fine-tune.create":
          return "createFineTune";
        case "fine_tuning.jobs.retrieve":
        case "fine-tune.retrieve":
          return "retrieveFineTune";
        case "fine_tuning.jobs.cancel":
        case "fine-tune.cancel":
          return "cancelFineTune";
        // audio
        case "audio.transcriptions.create":
          return "createTranscription";
        case "audio.translations.create":
          return "createTranslation";
        // images
        case "images.generate":
          return "createImage";
        case "images.edit":
          return "createImageEdit";
        case "images.createVariation":
          return "createImageVariation";
        // models
        case "models.list":
          return "listModels";
        case "models.retrieve":
          return "retrieveModel";
        case "models.del":
        case "models.delete":
          return "deleteModel";
        default:
          return methodName;
      }
    }
    function createEditRequestExtraction(tags, payload, openaiStore) {
      const instruction = payload.instruction;
      openaiStore.instruction = instruction;
    }
    function retrieveModelRequestExtraction(tags, payload) {
      tags["openai.request.id"] = payload.id;
    }
    function createChatCompletionRequestExtraction(tags, payload, openaiStore) {
      const messages = payload.messages;
      if (!defensiveArrayLength(messages)) return;
      openaiStore.messages = payload.messages;
    }
    function commonCreateImageRequestExtraction(tags, payload, openaiStore) {
      const img = payload.file || payload.image;
      if (img !== null && typeof img === "object" && img.path) {
        const file = path.basename(img.path);
        openaiStore.file = file;
      }
      if (payload.mask !== null && typeof payload.mask === "object" && payload.mask.path) {
        const mask = path.basename(payload.mask.path);
        openaiStore.mask = mask;
      }
    }
    function responseDataExtractionByMethod(methodName, tags, body, openaiStore) {
      switch (methodName) {
        case "createCompletion":
        case "createChatCompletion":
        case "createEdit":
          commonCreateResponseExtraction(tags, body, openaiStore, methodName);
          break;
        case "listFiles":
        case "listFineTunes":
        case "listFineTuneEvents":
          commonListCountResponseExtraction(tags, body);
          break;
        case "createFile":
        case "retrieveFile":
          createRetrieveFileResponseExtraction(tags, body);
          break;
        case "deleteFile":
          deleteFileResponseExtraction(tags, body);
          break;
        case "downloadFile":
          downloadFileResponseExtraction(tags, body);
          break;
        case "listModels":
          listModelsResponseExtraction(tags, body);
          break;
        case "retrieveModel":
          retrieveModelResponseExtraction(tags, body);
          break;
      }
    }
    function retrieveModelResponseExtraction(tags, body) {
      tags["openai.response.owned_by"] = body.owned_by;
      tags["openai.response.parent"] = body.parent;
      tags["openai.response.root"] = body.root;
      if (!body.permission) return;
      tags["openai.response.permission.id"] = body.permission[0].id;
      tags["openai.response.permission.created"] = body.permission[0].created;
      tags["openai.response.permission.allow_create_engine"] = body.permission[0].allow_create_engine;
      tags["openai.response.permission.allow_sampling"] = body.permission[0].allow_sampling;
      tags["openai.response.permission.allow_logprobs"] = body.permission[0].allow_logprobs;
      tags["openai.response.permission.allow_search_indices"] = body.permission[0].allow_search_indices;
      tags["openai.response.permission.allow_view"] = body.permission[0].allow_view;
      tags["openai.response.permission.allow_fine_tuning"] = body.permission[0].allow_fine_tuning;
      tags["openai.response.permission.organization"] = body.permission[0].organization;
      tags["openai.response.permission.group"] = body.permission[0].group;
      tags["openai.response.permission.is_blocking"] = body.permission[0].is_blocking;
    }
    function listModelsResponseExtraction(tags, body) {
      if (!body.data) return;
      tags["openai.response.count"] = body.data.length;
    }
    function downloadFileResponseExtraction(tags, body) {
      if (typeof body.file !== "string") return;
      tags["openai.response.total_bytes"] = Buffer.byteLength(body.file);
    }
    function deleteFileResponseExtraction(tags, body) {
      tags["openai.response.id"] = body.id;
    }
    function commonCreateAudioRequestExtraction(tags, body, openaiStore) {
      if (body.file !== null && typeof body.file === "object" && body.file.path) {
        const filename = path.basename(body.file.path);
        openaiStore.file = filename;
      }
    }
    function commonFileRequestExtraction(tags, body) {
      tags["openai.request.purpose"] = body.purpose;
      if (body.file !== null && typeof body.file === "object" && body.file.path) {
        tags["openai.request.filename"] = path.basename(body.file.path);
      }
    }
    function createRetrieveFileResponseExtraction(tags, body) {
      tags["openai.response.filename"] = body.filename;
      tags["openai.response.purpose"] = body.purpose;
      tags["openai.response.bytes"] = body.bytes;
      tags["openai.response.status"] = body.status;
      tags["openai.response.status_details"] = body.status_details;
    }
    function commonListCountResponseExtraction(tags, body) {
      if (!body.data) return;
      tags["openai.response.count"] = body.data.length;
    }
    function commonCreateResponseExtraction(tags, body, openaiStore, methodName) {
      if (!body.choices) return;
      openaiStore.choices = body.choices;
    }
    function coerceResponseBody(body, methodName) {
      switch (methodName) {
        case "downloadFile":
          return { file: body };
      }
      const type = typeof body;
      if (type === "string") {
        try {
          return JSON.parse(body);
        } catch {
          return body;
        }
      } else if (type === "object") {
        return body;
      } else {
        return {};
      }
    }
    function lookupOperationEndpoint(operationId, methodName, url) {
      switch (operationId) {
        case "deleteModel":
        case "retrieveModel":
          return "/v1/models/*";
        case "deleteFile":
        case "retrieveFile":
          return "/v1/files/*";
        case "downloadFile":
          return "/v1/files/*/content";
        case "retrieveFineTune":
          switch (methodName) {
            case "fine_tuning.jobs.retrieve":
              return "/v1/fine_tuning/jobs/*";
            default:
              return "/v1/fine-tunes/*";
          }
        case "listFineTuneEvents":
          switch (methodName) {
            case "fine_tuning.jobs.listEvents":
              return "/v1/fine_tuning/jobs/*/events";
            default:
              return "/v1/fine-tunes/*/events";
          }
        case "cancelFineTune":
          switch (methodName) {
            case "fine_tuning.jobs.cancel":
              return "/v1/fine_tuning/jobs/*/cancel";
            default:
              return "/v1/fine-tunes/*/cancel";
          }
      }
      return url;
    }
    function normalizeRequestPayload(methodName, args) {
      switch (methodName) {
        case "listModels":
        case "models.list":
        case "listFiles":
        case "files.list":
        case "listFineTunes":
        case "fine_tuning.jobs.list":
        case "fine-tune.list":
          return {};
        case "retrieveModel":
        case "models.retrieve":
          return { id: args[0] };
        case "createFile":
          return {
            file: args[0],
            purpose: args[1]
          };
        case "deleteFile":
        case "files.del":
        case "files.delete":
        case "retrieveFile":
        case "files.retrieve":
        case "downloadFile":
        case "files.retrieveContent":
        case "files.content":
          return { file_id: args[0] };
        case "listFineTuneEvents":
        case "fine_tuning.jobs.listEvents":
        case "fine-tune.listEvents":
          return {
            fine_tune_id: args[0],
            stream: args[1]
            // undocumented
          };
        case "retrieveFineTune":
        case "fine_tuning.jobs.retrieve":
        case "fine-tune.retrieve":
        case "deleteModel":
        case "models.del":
        case "models.delete":
        case "cancelFineTune":
        case "fine_tuning.jobs.cancel":
        case "fine-tune.cancel":
          return { fine_tune_id: args[0] };
        case "createImageEdit":
          return {
            file: args[0],
            prompt: args[1],
            // Note: order of prompt/mask in Node.js lib differs from public docs
            mask: args[2],
            n: args[3],
            size: args[4],
            response_format: args[5],
            user: args[6]
          };
        case "createImageVariation":
          return {
            file: args[0],
            n: args[1],
            size: args[2],
            response_format: args[3],
            user: args[4]
          };
        case "createTranscription":
        case "createTranslation":
          return {
            file: args[0],
            model: args[1],
            prompt: args[2],
            response_format: args[3],
            temperature: args[4],
            language: args[5]
            // only used for createTranscription
          };
      }
      return args[0];
    }
    function defensiveArrayLength(maybeArray) {
      if (maybeArray) {
        return Array.isArray(maybeArray) ? maybeArray.length : 1;
      }
    }
    module2.exports = OpenAiTracingPlugin;
  }
});

// ../../packages/dd-trace/src/llmobs/plugins/openai.js
var require_openai2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/plugins/openai.js"(exports2, module2) {
    "use strict";
    var LLMObsPlugin = require_base();
    function isIterable(obj) {
      if (obj == null) {
        return false;
      }
      return typeof obj[Symbol.iterator] === "function";
    }
    var OpenAiLLMObsPlugin = class extends LLMObsPlugin {
      static id = "openai";
      static integration = "openai";
      static prefix = "tracing:apm:openai:request";
      getLLMObsSpanRegisterOptions(ctx) {
        const resource = ctx.methodName;
        const methodName = gateResource(normalizeOpenAIResourceName(resource));
        if (!methodName) return;
        const inputs = ctx.args[0];
        const operation = getOperation(methodName);
        const kind = operation === "embedding" ? "embedding" : "llm";
        const { modelProvider, client } = this._getModelProviderAndClient(ctx.basePath);
        const name = `${client}.${methodName}`;
        return {
          modelProvider,
          modelName: inputs.model,
          kind,
          name
        };
      }
      setLLMObsTags(ctx) {
        const span = ctx.currentStore?.span;
        const resource = ctx.methodName;
        const methodName = gateResource(normalizeOpenAIResourceName(resource));
        if (!methodName) return;
        const inputs = ctx.args[0];
        const response = ctx.result?.data;
        const error = !!span.context()._tags.error;
        const operation = getOperation(methodName);
        if (operation === "completion") {
          this._tagCompletion(span, inputs, response, error);
        } else if (operation === "chat") {
          this._tagChatCompletion(span, inputs, response, error);
        } else if (operation === "embedding") {
          this._tagEmbedding(span, inputs, response, error);
        }
        if (!error) {
          const metrics2 = this._extractMetrics(response);
          this._tagger.tagMetrics(span, metrics2);
        }
      }
      _getModelProviderAndClient(baseUrl = "") {
        if (baseUrl.includes("azure")) {
          return { modelProvider: "azure_openai", client: "AzureOpenAI" };
        } else if (baseUrl.includes("deepseek")) {
          return { modelProvider: "deepseek", client: "DeepSeek" };
        }
        return { modelProvider: "openai", client: "OpenAI" };
      }
      _extractMetrics(response) {
        const metrics2 = {};
        const tokenUsage = response.usage;
        if (tokenUsage) {
          const inputTokens = tokenUsage.prompt_tokens;
          if (inputTokens) metrics2.inputTokens = inputTokens;
          const outputTokens = tokenUsage.completion_tokens;
          if (outputTokens) metrics2.outputTokens = outputTokens;
          const totalTokens = tokenUsage.total_tokens || inputTokens + outputTokens;
          if (totalTokens) metrics2.totalTokens = totalTokens;
          const promptTokensDetails = tokenUsage.prompt_tokens_details;
          if (promptTokensDetails) {
            const cacheReadTokens = promptTokensDetails.cached_tokens;
            if (cacheReadTokens) metrics2.cacheReadTokens = cacheReadTokens;
          }
        }
        return metrics2;
      }
      _tagEmbedding(span, inputs, response, error) {
        const { model, ...parameters } = inputs;
        const metadata = {
          encoding_format: parameters.encoding_format || "float"
        };
        if (inputs.dimensions) metadata.dimensions = inputs.dimensions;
        this._tagger.tagMetadata(span, metadata);
        let embeddingInputs = inputs.input;
        if (!Array.isArray(embeddingInputs)) embeddingInputs = [embeddingInputs];
        const embeddingInput = embeddingInputs.map((input) => ({ text: input }));
        if (error) {
          this._tagger.tagEmbeddingIO(span, embeddingInput);
          return;
        }
        const float = Array.isArray(response.data[0].embedding);
        let embeddingOutput;
        if (float) {
          const embeddingDim = response.data[0].embedding.length;
          embeddingOutput = `[${response.data.length} embedding(s) returned with size ${embeddingDim}]`;
        } else {
          embeddingOutput = `[${response.data.length} embedding(s) returned]`;
        }
        this._tagger.tagEmbeddingIO(span, embeddingInput, embeddingOutput);
      }
      _tagCompletion(span, inputs, response, error) {
        let { prompt, model, ...parameters } = inputs;
        if (!Array.isArray(prompt)) prompt = [prompt];
        const completionInput = prompt.map((p) => ({ content: p }));
        const completionOutput = error ? [{ content: "" }] : response.choices.map((choice) => ({ content: choice.text }));
        this._tagger.tagLLMIO(span, completionInput, completionOutput);
        this._tagger.tagMetadata(span, parameters);
      }
      _tagChatCompletion(span, inputs, response, error) {
        const { messages, model, ...parameters } = inputs;
        if (error) {
          this._tagger.tagLLMIO(span, messages, [{ content: "" }]);
          return;
        }
        const outputMessages = [];
        const { choices } = response;
        if (!isIterable(choices)) {
          this._tagger.tagLLMIO(span, messages, [{ content: "" }]);
          return;
        }
        for (const choice of choices) {
          const message = choice.message || choice.delta;
          const content = message.content || "";
          const role = message.role;
          if (message.function_call) {
            const functionCallInfo = {
              name: message.function_call.name,
              arguments: JSON.parse(message.function_call.arguments)
            };
            outputMessages.push({ content, role, toolCalls: [functionCallInfo] });
          } else if (message.tool_calls) {
            const toolCallsInfo = [];
            for (const toolCall of message.tool_calls) {
              const toolCallInfo = {
                arguments: JSON.parse(toolCall.function.arguments),
                name: toolCall.function.name,
                toolId: toolCall.id,
                type: toolCall.type
              };
              toolCallsInfo.push(toolCallInfo);
            }
            outputMessages.push({ content, role, toolCalls: toolCallsInfo });
          } else {
            outputMessages.push({ content, role });
          }
        }
        this._tagger.tagLLMIO(span, messages, outputMessages);
        const metadata = Object.entries(parameters).reduce((obj, [key, value]) => {
          if (!["tools", "functions"].includes(key)) {
            obj[key] = value;
          }
          return obj;
        }, {});
        this._tagger.tagMetadata(span, metadata);
      }
    };
    function normalizeOpenAIResourceName(resource) {
      switch (resource) {
        // completions
        case "completions.create":
          return "createCompletion";
        // chat completions
        case "chat.completions.create":
          return "createChatCompletion";
        // embeddings
        case "embeddings.create":
          return "createEmbedding";
        default:
          return resource;
      }
    }
    function gateResource(resource) {
      return ["createCompletion", "createChatCompletion", "createEmbedding"].includes(resource) ? resource : void 0;
    }
    function getOperation(resource) {
      switch (resource) {
        case "createCompletion":
          return "completion";
        case "createChatCompletion":
          return "chat";
        case "createEmbedding":
          return "embedding";
        default:
          return "unknown";
      }
    }
    module2.exports = OpenAiLLMObsPlugin;
  }
});

// ../../packages/datadog-plugin-openai/src/index.js
var require_src63 = __commonJS({
  "../../packages/datadog-plugin-openai/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var OpenAiTracingPlugin = require_tracing9();
    var OpenAiLLMObsPlugin = require_openai2();
    var OpenAiPlugin = class extends CompositePlugin {
      static id = "openai";
      static get plugins() {
        return {
          llmobs: OpenAiLLMObsPlugin,
          tracing: OpenAiTracingPlugin
        };
      }
    };
    module2.exports = OpenAiPlugin;
  }
});

// ../../packages/datadog-plugin-pg/src/index.js
var require_src64 = __commonJS({
  "../../packages/datadog-plugin-pg/src/index.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var DatabasePlugin = require_database();
    var PGPlugin = class extends DatabasePlugin {
      static id = "pg";
      static operation = "query";
      static system = "postgres";
      bindStart(ctx) {
        const { params = {}, query, processId, stream } = ctx;
        const service = this.serviceName({ pluginConfig: this.config, params });
        const originalStatement = this.maybeTruncate(query.text);
        const span = this.startSpan(this.operationName(), {
          service,
          resource: originalStatement,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": "postgres",
            "db.pid": processId,
            "db.name": params.database,
            "db.user": params.user,
            "out.host": params.host,
            [CLIENT_PORT_KEY]: params.port
          }
        }, ctx);
        if (stream) {
          span.setTag("db.stream", 1);
        }
        query.__ddInjectableQuery = this.injectDbmQuery(span, query.text, service, !!query.name);
        return ctx.currentStore;
      }
    };
    module2.exports = PGPlugin;
  }
});

// ../../packages/datadog-plugin-pino/src/index.js
var require_src65 = __commonJS({
  "../../packages/datadog-plugin-pino/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var PinoPlugin = class extends LogPlugin {
      static id = "pino";
    };
    module2.exports = PinoPlugin;
  }
});

// ../../packages/datadog-plugin-protobufjs/src/schema_iterator.js
var require_schema_iterator2 = __commonJS({
  "../../packages/datadog-plugin-protobufjs/src/schema_iterator.js"(exports2, module2) {
    "use strict";
    var PROTOBUF = "protobuf";
    var {
      SCHEMA_DEFINITION,
      SCHEMA_ID,
      SCHEMA_NAME,
      SCHEMA_OPERATION,
      SCHEMA_WEIGHT,
      SCHEMA_TYPE
    } = require_constants3();
    var log = require_log2();
    var {
      SchemaBuilder
    } = require_datastreams();
    var SchemaExtractor = class _SchemaExtractor {
      constructor(schema) {
        this.schema = schema;
      }
      static getTypeAndFormat(type) {
        const typeFormatMapping = {
          int32: ["integer", "int32"],
          int64: ["integer", "int64"],
          uint32: ["integer", "uint32"],
          uint64: ["integer", "uint64"],
          sint32: ["integer", "sint32"],
          sint64: ["integer", "sint64"],
          fixed32: ["integer", "fixed32"],
          fixed64: ["integer", "fixed64"],
          sfixed32: ["integer", "sfixed32"],
          sfixed64: ["integer", "sfixed64"],
          float: ["number", "float"],
          double: ["number", "double"],
          bool: ["boolean", null],
          string: ["string", null],
          bytes: ["string", "byte"],
          Enum: ["enum", null],
          Type: ["type", null],
          map: ["map", null],
          repeated: ["array", null]
        };
        return typeFormatMapping[type] || ["string", null];
      }
      static extractProperty(field, schemaName, fieldName, builder, depth) {
        let array = false;
        let description;
        let ref;
        let enumValues;
        const resolvedType = field.resolvedType ? field.resolvedType.constructor.name : field.type;
        const isRepeatedField = field.rule === "repeated";
        let typeFormat = this.getTypeAndFormat(isRepeatedField ? "repeated" : resolvedType);
        let type = typeFormat[0];
        let format = typeFormat[1];
        if (type === "array") {
          array = true;
          typeFormat = this.getTypeAndFormat(resolvedType);
          type = typeFormat[0];
          format = typeFormat[1];
        }
        if (type === "type") {
          format = null;
          ref = `#/components/schemas/${removeLeadingPeriod(field.resolvedType.fullName)}`;
          const originalSchemaExtractor = builder.iterator;
          if (!this.extractSchema(field.resolvedType, builder, depth, this)) {
            return false;
          }
          type = "object";
          builder.iterator = originalSchemaExtractor;
        } else if (type === "enum") {
          enumValues = [];
          let i = 0;
          while (field.resolvedType.valuesById[i]) {
            enumValues.push(field.resolvedType.valuesById[i]);
            i += 1;
          }
        }
        return builder.addProperty(schemaName, fieldName, array, type, description, ref, format, enumValues);
      }
      static extractSchema(schema, builder, depth, extractor) {
        depth += 1;
        const schemaName = removeLeadingPeriod(schema.resolvedType ? schema.resolvedType.fullName : schema.fullName);
        if (extractor) {
          const nestedSchemaExtractor = new _SchemaExtractor(schema);
          builder.iterator = nestedSchemaExtractor;
          const nestedSchema = SchemaBuilder.getSchema(schemaName, nestedSchemaExtractor, builder);
          for (const nestedSubSchemaName in nestedSchema.components.schemas) {
            if (nestedSchema.components.schemas.hasOwnProperty(nestedSubSchemaName)) {
              builder.schema.components.schemas[nestedSubSchemaName] = nestedSchema.components.schemas[nestedSubSchemaName];
            }
          }
          return true;
        }
        if (!builder.shouldExtractSchema(schemaName, depth)) {
          return false;
        }
        for (const field of schema.fieldsArray) {
          if (!this.extractProperty(field, schemaName, field.name, builder, depth)) {
            log.warn("DSM: Unable to extract field with name: %s from Avro schema with name:", field.name, schemaName);
          }
        }
        return true;
      }
      static extractSchemas(descriptor, dataStreamsProcessor) {
        const schemaName = removeLeadingPeriod(
          descriptor.resolvedType ? descriptor.resolvedType.fullName : descriptor.fullName
        );
        return dataStreamsProcessor.getSchema(schemaName, new _SchemaExtractor(descriptor));
      }
      iterateOverSchema(builder) {
        this.constructor.extractSchema(this.schema, builder, 0);
      }
      static attachSchemaOnSpan(args, span, operation, tracer2) {
        const { messageClass } = args;
        const descriptor = messageClass.$type ?? messageClass;
        if (!descriptor || !span) {
          return;
        }
        if (span.context()._tags[SCHEMA_TYPE] && operation === "serialization") {
          return;
        }
        span.setTag(SCHEMA_TYPE, PROTOBUF);
        span.setTag(SCHEMA_NAME, removeLeadingPeriod(descriptor.fullName));
        span.setTag(SCHEMA_OPERATION, operation);
        if (!tracer2._dataStreamsProcessor.canSampleSchema(operation)) {
          return;
        }
        if (!tracer2._prioritySampler.isSampled(span)) {
          return;
        }
        const weight = tracer2._dataStreamsProcessor.trySampleSchema(operation);
        if (weight === 0) {
          return;
        }
        const schemaData = SchemaBuilder.getSchemaDefinition(
          this.extractSchemas(descriptor, tracer2._dataStreamsProcessor)
        );
        span.setTag(SCHEMA_DEFINITION, schemaData.definition);
        span.setTag(SCHEMA_WEIGHT, weight);
        span.setTag(SCHEMA_ID, schemaData.id);
      }
    };
    function removeLeadingPeriod(str) {
      if (str.charAt(0) === ".") {
        return str.slice(1);
      }
      return str;
    }
    module2.exports = SchemaExtractor;
  }
});

// ../../packages/datadog-plugin-protobufjs/src/index.js
var require_src66 = __commonJS({
  "../../packages/datadog-plugin-protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var SchemaPlugin = require_schema2();
    var SchemaExtractor = require_schema_iterator2();
    var ProtobufjsPlugin = class extends SchemaPlugin {
      static id = "protobufjs";
      static schemaExtractor = SchemaExtractor;
    };
    module2.exports = ProtobufjsPlugin;
  }
});

// ../../packages/datadog-plugin-restify/src/index.js
var require_src67 = __commonJS({
  "../../packages/datadog-plugin-restify/src/index.js"(exports2, module2) {
    "use strict";
    var RouterPlugin = require_src15();
    var web = require_web3();
    var RestifyPlugin = class extends RouterPlugin {
      static id = "restify";
      constructor(...args) {
        super(...args);
        this.addSub("apm:restify:request:handle", ({ req }) => {
          this.setFramework(req, "restify", this.config);
        });
        this.addSub("apm:restify:request:route", ({ req, route }) => {
          web.setRoute(req, route);
        });
      }
      configure(config) {
        return super.configure({
          ...config,
          middleware: false
          // not supported
        });
      }
    };
    module2.exports = RestifyPlugin;
  }
});

// ../../packages/datadog-plugin-rhea/src/producer.js
var require_producer9 = __commonJS({
  "../../packages/datadog-plugin-rhea/src/producer.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var ProducerPlugin = require_producer();
    var { getAmqpMessageSize, DsmPathwayCodec } = require_datastreams();
    var RheaProducerPlugin = class extends ProducerPlugin {
      static id = "rhea";
      static operation = "send";
      constructor(...args) {
        super(...args);
        this.addTraceSub("encode", this.encode.bind(this));
      }
      bindStart(ctx) {
        const { targetAddress, host, port } = ctx;
        const name = targetAddress || "amq.topic";
        this.startSpan({
          resource: name,
          meta: {
            component: "rhea",
            "amqp.link.target.address": name,
            "amqp.link.role": "sender",
            "out.host": host,
            [CLIENT_PORT_KEY]: port
          }
        }, ctx);
        return ctx.currentStore;
      }
      encode(msg) {
        addDeliveryAnnotations(msg, this.tracer, this.activeSpan);
      }
    };
    function addDeliveryAnnotations(msg, tracer2, span) {
      if (msg) {
        msg.delivery_annotations = msg.delivery_annotations || {};
        tracer2.inject(span, "text_map", msg.delivery_annotations);
        if (tracer2._config.dsmEnabled) {
          const targetName = span.context()._tags["amqp.link.target.address"];
          const payloadSize = getAmqpMessageSize({ content: msg.body, headers: msg.delivery_annotations });
          const dataStreamsContext = tracer2.setCheckpoint(["direction:out", `exchange:${targetName}`, "type:rabbitmq"], span, payloadSize);
          DsmPathwayCodec.encode(dataStreamsContext, msg.delivery_annotations);
        }
      }
    }
    module2.exports = RheaProducerPlugin;
  }
});

// ../../packages/datadog-plugin-rhea/src/consumer.js
var require_consumer7 = __commonJS({
  "../../packages/datadog-plugin-rhea/src/consumer.js"(exports2, module2) {
    "use strict";
    var ConsumerPlugin = require_consumer();
    var { getAmqpMessageSize } = require_datastreams();
    var RheaConsumerPlugin = class extends ConsumerPlugin {
      static id = "rhea";
      constructor(...args) {
        super(...args);
        this.addTraceSub("dispatch", (ctx) => {
          const span = ctx.currentStore.span;
          span.setTag("amqp.delivery.state", ctx.state);
        });
      }
      bindStart(ctx) {
        const { msgObj } = ctx;
        const name = getResourceNameFromMessage(msgObj);
        const childOf = extractTextMap(msgObj, this.tracer);
        const span = this.startSpan({
          childOf,
          resource: name,
          type: "worker",
          meta: {
            component: "rhea",
            "amqp.link.source.address": name,
            "amqp.link.role": "receiver"
          }
        }, ctx);
        if (this.config.dsmEnabled && msgObj?.message?.delivery_annotations) {
          const payloadSize = getAmqpMessageSize(
            { headers: msgObj.message.delivery_annotations, content: msgObj.message.body }
          );
          this.tracer.decodeDataStreamsContext(msgObj.message.delivery_annotations);
          this.tracer.setCheckpoint(["direction:in", `topic:${name}`, "type:rabbitmq"], span, payloadSize);
        }
        return ctx.currentStore;
      }
    };
    function getResourceNameFromMessage(msgObj) {
      let resourceName = "amq.topic";
      let options = {};
      if (msgObj.receiver && msgObj.receiver.options) {
        options = msgObj.receiver.options;
      }
      if (options.source && options.source.address) {
        resourceName = options.source.address;
      }
      return resourceName;
    }
    function extractTextMap(msgObj, tracer2) {
      if (msgObj.message) {
        return tracer2.extract("text_map", msgObj.message.delivery_annotations);
      }
    }
    module2.exports = RheaConsumerPlugin;
  }
});

// ../../packages/datadog-plugin-rhea/src/index.js
var require_src68 = __commonJS({
  "../../packages/datadog-plugin-rhea/src/index.js"(exports2, module2) {
    "use strict";
    var ProducerPlugin = require_producer9();
    var ConsumerPlugin = require_consumer7();
    var CompositePlugin = require_composite2();
    var RheaPlugin = class extends CompositePlugin {
      static id = "rhea";
      static get plugins() {
        return {
          producer: ProducerPlugin,
          consumer: ConsumerPlugin
        };
      }
    };
    module2.exports = RheaPlugin;
  }
});

// ../../packages/datadog-plugin-selenium/src/index.js
var require_src69 = __commonJS({
  "../../packages/datadog-plugin-selenium/src/index.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var { storage } = require_datadog_core();
    var {
      TEST_IS_RUM_ACTIVE,
      TEST_BROWSER_DRIVER,
      TEST_BROWSER_DRIVER_VERSION,
      TEST_BROWSER_NAME,
      TEST_BROWSER_VERSION,
      TEST_TYPE
    } = require_test();
    var { SPAN_TYPE } = require_tags();
    function isTestSpan(span) {
      return span.context()._tags[SPAN_TYPE] === "test";
    }
    function getTestSpanFromTrace(trace2) {
      for (const span of trace2.started) {
        if (isTestSpan(span)) {
          return span;
        }
      }
      return null;
    }
    var SeleniumPlugin = class extends CiPlugin {
      static id = "selenium";
      constructor(...args) {
        super(...args);
        this.addSub("ci:selenium:driver:get", ({
          setTraceId,
          seleniumVersion,
          browserName,
          browserVersion,
          isRumActive
        }) => {
          const store = storage("legacy").getStore();
          const span = store?.span;
          if (!span) {
            return;
          }
          const testSpan = isTestSpan(span) ? span : getTestSpanFromTrace(span.context()._trace);
          if (!testSpan) {
            return;
          }
          if (setTraceId) {
            setTraceId(testSpan.context().toTraceId());
          }
          if (isRumActive) {
            testSpan.setTag(TEST_IS_RUM_ACTIVE, "true");
          }
          testSpan.setTag(TEST_BROWSER_DRIVER, "selenium");
          testSpan.setTag(TEST_BROWSER_DRIVER_VERSION, seleniumVersion);
          testSpan.setTag(TEST_BROWSER_NAME, browserName);
          testSpan.setTag(TEST_BROWSER_VERSION, browserVersion);
          testSpan.setTag(TEST_TYPE, "browser");
        });
      }
    };
    module2.exports = SeleniumPlugin;
  }
});

// ../../packages/datadog-plugin-sharedb/src/index.js
var require_src70 = __commonJS({
  "../../packages/datadog-plugin-sharedb/src/index.js"(exports2, module2) {
    "use strict";
    var ServerPlugin = require_server5();
    var SharedbPlugin = class extends ServerPlugin {
      static id = "sharedb";
      bindStart(ctx) {
        const { actionName, request: request2 } = ctx;
        const span = this.startSpan("sharedb.request", {
          service: this.config.service,
          resource: getReadableResourceName(actionName, request2.c, request2.q),
          kind: "server",
          meta: {
            "sharedb.action": actionName
          }
        }, ctx);
        if (this.config.hooks && this.config.hooks.receive) {
          this.config.hooks.receive(span, request2);
        }
        return ctx.currentStore;
      }
      bindFinish(ctx) {
        const { request: request2, res } = ctx;
        const span = ctx.currentStore.span;
        if (this.config.hooks && this.config.hooks.reply) {
          this.config.hooks.reply(span, request2, res);
        }
        super.finish(ctx);
        return ctx.parentStore;
      }
    };
    function getReadableResourceName(readableActionName, collection, query) {
      if (collection) {
        readableActionName += " " + collection;
      }
      if (query) {
        readableActionName += " " + JSON.stringify(sanitize(query));
      }
      return readableActionName;
    }
    function sanitize(input) {
      const output = {};
      if (!isObject(input) || Buffer.isBuffer(input)) return "?";
      for (const key in input) {
        if (typeof input[key] === "function") continue;
        output[key] = sanitize(input[key]);
      }
      return output;
    }
    function isObject(val) {
      return val !== null && typeof val === "object" && !Array.isArray(val);
    }
    module2.exports = SharedbPlugin;
  }
});

// ../../packages/datadog-plugin-tedious/src/index.js
var require_src71 = __commonJS({
  "../../packages/datadog-plugin-tedious/src/index.js"(exports2, module2) {
    "use strict";
    var { CLIENT_PORT_KEY } = require_constants3();
    var DatabasePlugin = require_database();
    var TediousPlugin = class extends DatabasePlugin {
      static id = "tedious";
      static operation = "request";
      // TODO: change to match other database plugins
      static system = "mssql";
      bindStart(ctx) {
        const service = this.serviceName({ pluginConfig: this.config, system: this.system });
        const span = this.startSpan(this.operationName(), {
          service,
          resource: ctx.queryOrProcedure,
          type: "sql",
          kind: "client",
          meta: {
            "db.type": "mssql",
            component: "tedious",
            "out.host": ctx.connectionConfig.server,
            [CLIENT_PORT_KEY]: ctx.connectionConfig.options.port,
            "db.user": ctx.connectionConfig.userName || ctx.connectionConfig.authentication.options.userName,
            "db.name": ctx.connectionConfig.options.database,
            "db.instance": ctx.connectionConfig.options.instanceName
          }
        }, ctx);
        ctx.sql = this.injectDbmQuery(span, ctx.queryOrProcedure, service, true);
        return ctx.currentStore;
      }
    };
    module2.exports = TediousPlugin;
  }
});

// ../../packages/datadog-plugin-undici/src/index.js
var require_src72 = __commonJS({
  "../../packages/datadog-plugin-undici/src/index.js"(exports2, module2) {
    "use strict";
    var FetchPlugin = require_src40();
    var UndiciPlugin = class extends FetchPlugin {
      static id = "undici";
      static prefix = "tracing:apm:undici:fetch";
    };
    module2.exports = UndiciPlugin;
  }
});

// ../../packages/datadog-plugin-winston/src/index.js
var require_src73 = __commonJS({
  "../../packages/datadog-plugin-winston/src/index.js"(exports2, module2) {
    "use strict";
    var LogPlugin = require_log_plugin();
    var WinstonPlugin = class extends LogPlugin {
      static id = "winston";
    };
    module2.exports = WinstonPlugin;
  }
});

// ../../packages/datadog-plugin-ws/src/server.js
var require_server10 = __commonJS({
  "../../packages/datadog-plugin-ws/src/server.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var tags = require_tags();
    var HTTP_STATUS_CODE = tags.HTTP_STATUS_CODE;
    var WSServerPlugin = class extends TracingPlugin {
      static get id() {
        return "ws";
      }
      static get prefix() {
        return "tracing:ws:server:connect";
      }
      static get type() {
        return "websocket";
      }
      static get kind() {
        return "request";
      }
      bindStart(ctx) {
        const req = ctx.req;
        const options = {};
        const headers = Object.entries(req.headers);
        options.headers = Object.fromEntries(headers);
        options.method = req.method;
        const protocol = `${getRequestProtocol(req)}:`;
        const host = options.headers.host;
        const url = req.url;
        const indexOfParam = url.indexOf("?");
        const route = indexOfParam === -1 ? url : url.slice(0, indexOfParam);
        const uri = `${protocol}//${host}${route}`;
        ctx.args = { options };
        const service = this.serviceName({ pluginConfig: this.config });
        const span = this.startSpan(this.operationName(), {
          service,
          meta: {
            "span.type": "websocket",
            "http.upgraded": "websocket",
            "http.method": options.method,
            "http.url": uri,
            "resource.name": `${options.method} ${route}`,
            "span.kind": "server"
          }
        }, ctx);
        ctx.span = span;
        ctx.socket.spanContext = ctx.span._spanContext;
        ctx.socket.spanContext.spanTags = ctx.span._spanContext._tags;
        return ctx.currentStore;
      }
      bindAsyncStart(ctx) {
        ctx.span.setTag(HTTP_STATUS_CODE, ctx.req.resStatus);
        return ctx.parentStore;
      }
      asyncStart(ctx) {
        ctx.span.finish();
      }
    };
    function getRequestProtocol(req, fallback = "ws") {
      if (req.socket && req.socket.encrypted) {
        return "wss";
      }
      if (req.headers && req.headers["x-forwarded-proto"]) {
        const proto = req.headers["x-forwarded-proto"].split(",")[0].trim();
        if (proto === "https") return "wss";
        if (proto === "http") return "ws";
      }
      return fallback;
    }
    module2.exports = WSServerPlugin;
  }
});

// ../../packages/datadog-plugin-ws/src/producer.js
var require_producer10 = __commonJS({
  "../../packages/datadog-plugin-ws/src/producer.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var WSProducerPlugin = class extends TracingPlugin {
      static get id() {
        return "ws";
      }
      static get prefix() {
        return "tracing:ws:send";
      }
      static get type() {
        return "websocket";
      }
      static get kind() {
        return "producer";
      }
      bindStart(ctx) {
        const messagesEnabled = this.config.traceWebsocketMessagesEnabled;
        if (!messagesEnabled) return;
        const { byteLength, socket, binary } = ctx;
        if (!socket.spanContext) return;
        const spanTags = socket.spanContext.spanTags;
        const path = spanTags["resource.name"].split(" ")[1];
        const opCode = binary ? "binary" : "text";
        const service = this.serviceName({ pluginConfig: this.config });
        const span = this.startSpan(this.operationName(), {
          service,
          meta: {
            "span.type": "websocket",
            "span.kind": "producer",
            "resource.name": `websocket ${path}`,
            "websocket.message.type": opCode
          },
          metrics: {
            "websocket.message.length": byteLength
          }
        }, ctx);
        ctx.span = span;
        return ctx.currentStore;
      }
      bindAsyncStart(ctx) {
        ctx.span.finish();
        return ctx.parentStore;
      }
      asyncStart(ctx) {
        ctx.span.finish();
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, "result") || !ctx.span) return;
        if (ctx.socket.spanContext) {
          ctx.span.addLink({
            context: ctx.socket.spanContext,
            attributes: { "dd.kind": "resuming" }
          });
        }
        ctx.span.finish();
        return ctx.parentStore;
      }
    };
    module2.exports = WSProducerPlugin;
  }
});

// ../../packages/datadog-plugin-ws/src/receiver.js
var require_receiver = __commonJS({
  "../../packages/datadog-plugin-ws/src/receiver.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var WSReceiverPlugin = class extends TracingPlugin {
      static get id() {
        return "ws";
      }
      static get prefix() {
        return "tracing:ws:receive";
      }
      static get type() {
        return "websocket";
      }
      static get kind() {
        return "consumer";
      }
      bindStart(ctx) {
        const {
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces
        } = this.config;
        if (!traceWebsocketMessagesEnabled) return;
        const { byteLength, socket, binary } = ctx;
        if (!socket.spanContext) return;
        const spanTags = socket.spanContext.spanTags;
        const path = spanTags["resource.name"].split(" ")[1];
        const opCode = binary ? "binary" : "text";
        const service = this.serviceName({ pluginConfig: this.config });
        const span = this.startSpan(this.operationName(), {
          service,
          meta: {
            "span.type": "websocket",
            "span.kind": "consumer",
            "resource.name": `websocket ${path}`,
            "websocket.duration.style": "handler",
            "websocket.message.type": opCode
          },
          metrics: {
            "websocket.message.length": byteLength
          }
        }, ctx);
        if (traceWebsocketMessagesInheritSampling && traceWebsocketMessagesSeparateTraces) {
          span.setTag("_dd.dm.service", spanTags["service.name"] || service);
          span.setTag("_dd.dm.resource", spanTags["resource.name"] || `websocket ${path}`);
          span.setTag("_dd.dm.inherited", 1);
        }
        ctx.span = span;
        return ctx.currentStore;
      }
      bindAsyncStart(ctx) {
        return ctx.parentStore;
      }
      asyncStart(ctx) {
        ctx.span.finish();
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, "result") || !ctx.span) return;
        if (ctx.socket.spanContext) {
          ctx.span.addLink({
            context: ctx.socket.spanContext,
            attributes: { "dd.kind": "executed_by" }
          });
        }
        ctx.span.finish();
        return ctx.parentStore;
      }
    };
    module2.exports = WSReceiverPlugin;
  }
});

// ../../packages/datadog-plugin-ws/src/close.js
var require_close = __commonJS({
  "../../packages/datadog-plugin-ws/src/close.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var WSClosePlugin = class extends TracingPlugin {
      static get id() {
        return "ws";
      }
      static get prefix() {
        return "tracing:ws:close";
      }
      static get type() {
        return "websocket";
      }
      static get kind() {
        return "close";
      }
      bindStart(ctx) {
        const {
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces
        } = this.config;
        if (!traceWebsocketMessagesEnabled) return;
        const { code, data, socket, isPeerClose } = ctx;
        if (!socket?.spanContext) return;
        const spanKind = isPeerClose ? "consumer" : "producer";
        const spanTags = socket.spanContext.spanTags;
        const path = spanTags["resource.name"].split(" ")[1];
        const service = this.serviceName({ pluginConfig: this.config });
        const span = this.startSpan(this.operationName(), {
          service,
          meta: {
            "resource.name": `websocket ${path}`,
            "span.type": "websocket",
            "span.kind": spanKind,
            "websocket.close.code": code
          }
        }, ctx);
        if (data?.toString().length > 0) {
          span.setTag("websocket.close.reason", data.toString());
        }
        if (isPeerClose && traceWebsocketMessagesInheritSampling && traceWebsocketMessagesSeparateTraces) {
          span.setTag("_dd.dm.service", spanTags["service.name"] || service);
          span.setTag("_dd.dm.resource", spanTags["resource.name"] || `websocket ${path}`);
          span.setTag("_dd.dm.inherited", 1);
        }
        ctx.span = span;
        return ctx.currentStore;
      }
      bindAsyncStart(ctx) {
        if (!ctx.isPeerClose) ctx.span.finish();
        return ctx.parentStore;
      }
      asyncStart(ctx) {
        ctx.span.finish();
      }
      end(ctx) {
        if (!Object.hasOwn(ctx, "result") || !ctx.span) return;
        if (ctx.socket.spanContext) ctx.span.addLink({ context: ctx.socket.spanContext });
        ctx.span.finish();
      }
    };
    module2.exports = WSClosePlugin;
  }
});

// ../../packages/datadog-plugin-ws/src/index.js
var require_src74 = __commonJS({
  "../../packages/datadog-plugin-ws/src/index.js"(exports2, module2) {
    "use strict";
    var CompositePlugin = require_composite2();
    var WSServerPlugin = require_server10();
    var WSProducerPlugin = require_producer10();
    var WSReceiverPlugin = require_receiver();
    var WSClosePlugin = require_close();
    var WSPlugin = class extends CompositePlugin {
      static get id() {
        return "ws";
      }
      static get plugins() {
        return {
          server: WSServerPlugin,
          producer: WSProducerPlugin,
          receiver: WSReceiverPlugin,
          close: WSClosePlugin
        };
      }
      configure(config) {
        return super.configure(config);
      }
    };
    module2.exports = WSPlugin;
  }
});

// ../../packages/dd-trace/src/plugins/index.js
var require_plugins = __commonJS({
  "../../packages/dd-trace/src/plugins/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      get "@anthropic-ai/sdk"() {
        return require_src2();
      },
      get "@apollo/gateway"() {
        return require_src3();
      },
      get "@aws-sdk/smithy-client"() {
        return require_src4();
      },
      get "@azure/event-hubs"() {
        return require_src5();
      },
      get "@azure/functions"() {
        return require_src6();
      },
      get "@azure/service-bus"() {
        return require_src7();
      },
      get "@cucumber/cucumber"() {
        return require_src8();
      },
      get "@playwright/test"() {
        return require_src9();
      },
      get "@elastic/elasticsearch"() {
        return require_src10();
      },
      get "@elastic/transport"() {
        return require_src10();
      },
      get "@google-cloud/pubsub"() {
        return require_src11();
      },
      get "@google-cloud/vertexai"() {
        return require_src12();
      },
      get "@grpc/grpc-js"() {
        return require_src13();
      },
      get "@hapi/hapi"() {
        return require_src16();
      },
      get "@happy-dom/jest-environment"() {
        return require_src17();
      },
      get "@jest/core"() {
        return require_src17();
      },
      get "@jest/test-sequencer"() {
        return require_src17();
      },
      get "@jest/transform"() {
        return require_src17();
      },
      get "@koa/router"() {
        return require_src18();
      },
      get "@langchain/core"() {
        return require_src19();
      },
      get "@langchain/openai"() {
        return require_src19();
      },
      get "@node-redis/client"() {
        return require_src20();
      },
      get "@opensearch-project/opensearch"() {
        return require_src21();
      },
      get "@prisma/client"() {
        return require_src22();
      },
      get "@redis/client"() {
        return require_src20();
      },
      get "@smithy/smithy-client"() {
        return require_src4();
      },
      get "@vitest/runner"() {
        return require_src23();
      },
      get aerospike() {
        return require_src24();
      },
      get ai() {
        return require_src25();
      },
      get amqp10() {
        return require_src26();
      },
      get amqplib() {
        return require_src27();
      },
      get avsc() {
        return require_src28();
      },
      get "aws-sdk"() {
        return require_src4();
      },
      get bunyan() {
        return require_src29();
      },
      get "cassandra-driver"() {
        return require_src30();
      },
      get child_process() {
        return require_src31();
      },
      get connect() {
        return require_src32();
      },
      get couchbase() {
        return require_src33();
      },
      get cypress() {
        return require_src34();
      },
      get dns() {
        return require_src35();
      },
      get "dd-trace-api"() {
        return require_src36();
      },
      get elasticsearch() {
        return require_src10();
      },
      get express() {
        return require_src37();
      },
      get fastify() {
        return require_src38();
      },
      get "find-my-way"() {
        return require_src39();
      },
      get "global:fetch"() {
        return require_src40();
      },
      get graphql() {
        return require_src41();
      },
      get grpc() {
        return require_src13();
      },
      get hapi() {
        return require_src16();
      },
      get hono() {
        return require_src42();
      },
      get http() {
        return require_src43();
      },
      get http2() {
        return require_src44();
      },
      get https() {
        return require_src43();
      },
      get ioredis() {
        return require_src45();
      },
      get iovalkey() {
        return require_src46();
      },
      get "jest-circus"() {
        return require_src17();
      },
      get "jest-config"() {
        return require_src17();
      },
      get "jest-environment-node"() {
        return require_src17();
      },
      get "jest-environment-jsdom"() {
        return require_src17();
      },
      get "jest-runtime"() {
        return require_src17();
      },
      get "jest-worker"() {
        return require_src17();
      },
      get koa() {
        return require_src18();
      },
      get "koa-router"() {
        return require_src18();
      },
      get kafkajs() {
        return require_src47();
      },
      get "@confluentinc/kafka-javascript"() {
        return require_src48();
      },
      get langchain() {
        return require_src19();
      },
      get mariadb() {
        return require_src50();
      },
      get memcached() {
        return require_src51();
      },
      get "microgateway-core"() {
        return require_src52();
      },
      get mocha() {
        return require_src53();
      },
      get "mocha-each"() {
        return require_src53();
      },
      get vitest() {
        return require_src23();
      },
      get workerpool() {
        return require_src53();
      },
      get tinypool() {
        return require_src23();
      },
      get moleculer() {
        return require_src54();
      },
      get mongodb() {
        return require_src55();
      },
      get "mongodb-core"() {
        return require_src55();
      },
      get mongoose() {
        return require_src56();
      },
      get mysql() {
        return require_src49();
      },
      get mysql2() {
        return require_src57();
      },
      get net() {
        return require_src58();
      },
      get next() {
        return require_src59();
      },
      get "node:dns"() {
        return require_src35();
      },
      get "node:http"() {
        return require_src43();
      },
      get "node:http2"() {
        return require_src44();
      },
      get "node:https"() {
        return require_src43();
      },
      get "node:net"() {
        return require_src58();
      },
      get nyc() {
        return require_src60();
      },
      get oracledb() {
        return require_src61();
      },
      get openai() {
        return require_src63();
      },
      get pg() {
        return require_src64();
      },
      get pino() {
        return require_src65();
      },
      get "pino-pretty"() {
        return require_src65();
      },
      get playwright() {
        return require_src9();
      },
      get protobufjs() {
        return require_src66();
      },
      get redis() {
        return require_src20();
      },
      get restify() {
        return require_src67();
      },
      get rhea() {
        return require_src68();
      },
      get router() {
        return require_src15();
      },
      get "selenium-webdriver"() {
        return require_src69();
      },
      get sharedb() {
        return require_src70();
      },
      get tedious() {
        return require_src71();
      },
      get undici() {
        return require_src72();
      },
      get winston() {
        return require_src73();
      },
      get ws() {
        return require_src74();
      }
    };
  }
});

// ../../node_modules/import-in-the-middle/lib/register.js
var require_register = __commonJS({
  "../../node_modules/import-in-the-middle/lib/register.js"(exports2) {
    var importHooks = [];
    var setters = /* @__PURE__ */ new WeakMap();
    var getters = /* @__PURE__ */ new WeakMap();
    var specifiers = /* @__PURE__ */ new Map();
    var toHook = [];
    var proxyHandler = {
      set(target, name, value) {
        return setters.get(target)[name](value);
      },
      get(target, name) {
        if (name === Symbol.toStringTag) {
          return "Module";
        }
        const getter = getters.get(target)[name];
        if (typeof getter === "function") {
          return getter();
        }
      },
      defineProperty(target, property, descriptor) {
        if (!("value" in descriptor)) {
          throw new Error("Getters/setters are not supported for exports property descriptors.");
        }
        return setters.get(target)[property](descriptor.value);
      }
    };
    function register2(name, namespace2, set2, get3, specifier) {
      specifiers.set(name, specifier);
      setters.set(namespace2, set2);
      getters.set(namespace2, get3);
      const proxy = new Proxy(namespace2, proxyHandler);
      importHooks.forEach((hook) => hook(name, proxy));
      toHook.push([name, proxy]);
    }
    var experimentalPatchInternals = false;
    function getExperimentalPatchInternals() {
      return experimentalPatchInternals;
    }
    function setExperimentalPatchInternals(value) {
      experimentalPatchInternals = value;
    }
    exports2.register = register2;
    exports2.importHooks = importHooks;
    exports2.specifiers = specifiers;
    exports2.toHook = toHook;
    exports2.getExperimentalPatchInternals = getExperimentalPatchInternals;
    exports2.setExperimentalPatchInternals = setExperimentalPatchInternals;
  }
});

// ../../node_modules/import-in-the-middle/index.js
var require_import_in_the_middle = __commonJS({
  "../../node_modules/import-in-the-middle/index.js"(exports2, module2) {
    var path = __require("path");
    var parse = require_module_details_from_path();
    var { fileURLToPath } = __require("url");
    var { MessageChannel: MessageChannel2 } = __require("worker_threads");
    var {
      importHooks,
      specifiers,
      toHook,
      getExperimentalPatchInternals
    } = require_register();
    function addHook(hook) {
      importHooks.push(hook);
      toHook.forEach(([name, namespace2]) => hook(name, namespace2));
    }
    function removeHook(hook) {
      const index = importHooks.indexOf(hook);
      if (index > -1) {
        importHooks.splice(index, 1);
      }
    }
    function callHookFn(hookFn, namespace2, name, baseDir) {
      const newDefault = hookFn(namespace2, name, baseDir);
      if (newDefault && newDefault !== namespace2) {
        namespace2.default = newDefault;
      }
    }
    var sendModulesToLoader;
    function createAddHookMessageChannel() {
      const { port1, port2 } = new MessageChannel2();
      let pendingAckCount = 0;
      let resolveFn;
      sendModulesToLoader = (modules) => {
        pendingAckCount++;
        port1.postMessage(modules);
      };
      port1.on("message", () => {
        pendingAckCount--;
        if (resolveFn && pendingAckCount <= 0) {
          resolveFn();
        }
      }).unref();
      function waitForAllMessagesAcknowledged() {
        const timer = setInterval(() => {
        }, 1e3);
        const promise = new Promise((resolve) => {
          resolveFn = resolve;
        }).then(() => {
          clearInterval(timer);
        });
        if (pendingAckCount === 0) {
          resolveFn();
        }
        return promise;
      }
      const addHookMessagePort = port2;
      const registerOptions = { data: { addHookMessagePort, include: [] }, transferList: [addHookMessagePort] };
      return { registerOptions, addHookMessagePort, waitForAllMessagesAcknowledged };
    }
    function Hook(modules, options, hookFn) {
      if (this instanceof Hook === false) return new Hook(modules, options, hookFn);
      if (typeof modules === "function") {
        hookFn = modules;
        modules = null;
        options = null;
      } else if (typeof options === "function") {
        hookFn = options;
        options = null;
      }
      const internals = options ? options.internals === true : false;
      if (sendModulesToLoader && Array.isArray(modules)) {
        sendModulesToLoader(modules);
      }
      this._iitmHook = (name, namespace2) => {
        const filename = name;
        const isBuiltin = name.startsWith("node:");
        let baseDir;
        if (isBuiltin) {
          name = name.replace(/^node:/, "");
        } else {
          if (name.startsWith("file://")) {
            try {
              name = fileURLToPath(name);
            } catch (e) {
            }
          }
          const details = parse(name);
          if (details) {
            name = details.name;
            baseDir = details.basedir;
          }
        }
        if (modules) {
          for (const moduleName2 of modules) {
            if (moduleName2 === name) {
              if (baseDir) {
                if (internals) {
                  name = name + path.sep + path.relative(baseDir, fileURLToPath(filename));
                } else {
                  if (!getExperimentalPatchInternals() && !baseDir.endsWith(specifiers.get(filename))) continue;
                }
              }
              callHookFn(hookFn, namespace2, name, baseDir);
            }
          }
        } else {
          callHookFn(hookFn, namespace2, name, baseDir);
        }
      };
      addHook(this._iitmHook);
    }
    Hook.prototype.unhook = function() {
      removeHook(this._iitmHook);
    };
    module2.exports = Hook;
    module2.exports.Hook = Hook;
    module2.exports.addHook = addHook;
    module2.exports.removeHook = removeHook;
    module2.exports.createAddHookMessageChannel = createAddHookMessageChannel;
  }
});

// ../../packages/dd-trace/src/iitm.js
var require_iitm = __commonJS({
  "../../packages/dd-trace/src/iitm.js"(exports2, module2) {
    "use strict";
    var { addHook } = require_import_in_the_middle();
    var dc = require_dc_polyfill();
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    addHook((name, namespace2) => {
      if (moduleLoadStartChannel.hasSubscribers) {
        moduleLoadStartChannel.publish({
          filename: name,
          module: namespace2
        });
      }
    });
    module2.exports = require_import_in_the_middle();
  }
});

// ../../packages/dd-trace/src/ritm.js
var require_ritm = __commonJS({
  "../../packages/dd-trace/src/ritm.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var Module = __require("module");
    var parse = require_module_details_from_path();
    var dc = require_dc_polyfill();
    var { getEnvironmentVariable } = require_config_helper();
    var origRequire = Module.prototype.require;
    module2.exports = Hook;
    var moduleHooks = /* @__PURE__ */ Object.create(null);
    var cache = /* @__PURE__ */ Object.create(null);
    var patching = /* @__PURE__ */ Object.create(null);
    var patchedRequire = null;
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var moduleLoadEndChannel = dc.channel("dd-trace:moduleLoadEnd");
    function Hook(modules, options, onrequire) {
      if (!(this instanceof Hook)) return new Hook(modules, options, onrequire);
      if (typeof modules === "function") {
        onrequire = modules;
        modules = null;
        options = {};
      } else if (typeof options === "function") {
        onrequire = options;
        options = {};
      }
      modules = modules || [];
      options = options || {};
      this.modules = modules;
      this.options = options;
      this.onrequire = onrequire;
      if (Array.isArray(modules)) {
        for (const mod2 of modules) {
          const hooks = moduleHooks[mod2];
          if (hooks) {
            hooks.push(onrequire);
          } else {
            moduleHooks[mod2] = [onrequire];
          }
        }
      }
      if (patchedRequire) return;
      const _origRequire = Module.prototype.require;
      patchedRequire = Module.prototype.require = function(request2) {
        let filename;
        try {
          filename = Module._resolveFilename(request2, this);
        } catch {
          return _origRequire.apply(this, arguments);
        }
        const core = !filename.includes(path.sep);
        let name, basedir, hooks;
        if (cache[filename]) {
          if (__require.cache[filename] && __require.cache[filename].exports !== cache[filename].original) {
            return __require.cache[filename].exports;
          }
          return cache[filename].exports;
        }
        const patched = patching[filename];
        if (patched) {
          return origRequire.apply(this, arguments);
        }
        patching[filename] = true;
        const payload = {
          filename,
          request: request2
        };
        if (moduleLoadStartChannel.hasSubscribers) {
          moduleLoadStartChannel.publish(payload);
        }
        let exports3 = origRequire.apply(this, arguments);
        payload.module = exports3;
        if (moduleLoadEndChannel.hasSubscribers) {
          moduleLoadEndChannel.publish(payload);
          exports3 = payload.module;
        }
        delete patching[filename];
        if (core) {
          hooks = moduleHooks[filename];
          if (!hooks) return exports3;
          name = filename;
        } else {
          const inAWSLambda = getEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") !== void 0;
          const hasLambdaHandler = getEnvironmentVariable("DD_LAMBDA_HANDLER") !== void 0;
          const segments = filename.split(path.sep);
          const filenameFromNodeModule = segments.includes("node_modules");
          const stat = inAWSLambda && hasLambdaHandler && !filenameFromNodeModule ? { name: filename } : parse(filename);
          if (!stat) return exports3;
          name = stat.name;
          basedir = stat.basedir;
          hooks = moduleHooks[name];
          if (!hooks) return exports3;
          const paths = Module._resolveLookupPaths(name, this, true);
          if (!paths) {
            return exports3;
          }
          let res;
          try {
            res = Module._findPath(name, [basedir, ...paths]);
          } catch {
          }
          if (!res || res !== filename) {
            name = name + path.sep + path.relative(basedir, filename);
          }
        }
        cache[filename] = { exports: exports3 };
        cache[filename].original = exports3;
        for (const hook of hooks) {
          cache[filename].exports = hook(cache[filename].exports, name, basedir);
        }
        return cache[filename].exports;
      };
    }
    Hook.reset = function() {
      Module.prototype.require = origRequire;
      patchedRequire = null;
      patching = /* @__PURE__ */ Object.create(null);
      cache = /* @__PURE__ */ Object.create(null);
      moduleHooks = /* @__PURE__ */ Object.create(null);
    };
    Hook.prototype.unhook = function() {
      for (const mod2 of this.modules) {
        const hooks = (moduleHooks[mod2] || []).filter((hook) => hook !== this.onrequire);
        if (hooks.length > 0) {
          moduleHooks[mod2] = hooks;
        } else {
          delete moduleHooks[mod2];
        }
      }
      if (Object.keys(moduleHooks).length === 0) {
        Hook.reset();
      }
    };
  }
});

// ../../packages/datadog-instrumentations/src/helpers/hook.js
var require_hook = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/hook.js"(exports2, module2) {
    "use strict";
    var iitm = require_iitm();
    var path = __require("path");
    var ritm = require_ritm();
    function Hook(modules, hookOptions, onrequire) {
      if (!(this instanceof Hook)) return new Hook(modules, hookOptions, onrequire);
      if (typeof hookOptions === "function") {
        onrequire = hookOptions;
        hookOptions = {};
      }
      this._patched = /* @__PURE__ */ Object.create(null);
      const patched = /* @__PURE__ */ new WeakMap();
      const safeHook = (moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm) => {
        const parts = [moduleBaseDir, moduleName2].filter(Boolean);
        const filename = path.join(...parts);
        if (this._patched[filename] && patched.has(moduleExports)) {
          return patched.get(moduleExports);
        }
        let defaultWrapResult;
        if (isIitm && moduleExports.default && (typeof moduleExports.default === "object" || typeof moduleExports.default === "function")) {
          defaultWrapResult = onrequire(moduleExports.default, moduleName2, moduleBaseDir, moduleVersion, isIitm);
        }
        const newExports = onrequire(moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm);
        if (defaultWrapResult) newExports.default = defaultWrapResult;
        this._patched[filename] = true;
        if (newExports && (typeof newExports === "object" || typeof newExports === "function")) {
          patched.set(moduleExports, newExports);
        }
        return newExports;
      };
      this._ritmHook = ritm(modules, {}, safeHook);
      this._iitmHook = iitm(modules, hookOptions, (moduleExports, moduleName2, moduleBaseDir) => {
        return safeHook(moduleExports, moduleName2, moduleBaseDir, null, true);
      });
    }
    Hook.prototype.unhook = function() {
      this._ritmHook.unhook();
      this._iitmHook.unhook();
      this._patched = /* @__PURE__ */ Object.create(null);
    };
    module2.exports = Hook;
  }
});

// ../../packages/dd-trace/src/guardrails/util.js
var require_util13 = __commonJS({
  "../../packages/dd-trace/src/guardrails/util.js"(exports2, module2) {
    "use strict";
    function isTrue(str) {
      str = String(str).toLowerCase();
      return str === "true" || str === "1";
    }
    module2.exports = { isTrue };
  }
});

// ../../packages/dd-trace/src/guardrails/log.js
var require_log5 = __commonJS({
  "../../packages/dd-trace/src/guardrails/log.js"(exports2, module2) {
    "use strict";
    var isTrue = require_util13().isTrue;
    var DD_TRACE_DEBUG = process.env.DD_TRACE_DEBUG;
    var DD_TRACE_LOG_LEVEL = process.env.DD_TRACE_LOG_LEVEL;
    var logLevels = {
      trace: 20,
      debug: 20,
      info: 30,
      warn: 40,
      error: 50,
      critical: 50,
      off: 100
    };
    var logLevel = isTrue(DD_TRACE_DEBUG) ? Number(DD_TRACE_LOG_LEVEL) || logLevels.debug : logLevels.off;
    var log = {
      /* eslint n/no-unsupported-features/node-builtins: ['error', { ignores: ['console.debug'] }] */
      debug: logLevel <= 20 ? (console.debug || console.log).bind(console) : function() {
      },
      info: logLevel <= 30 ? console.info.bind(console) : function() {
      },
      warn: logLevel <= 40 ? console.warn.bind(console) : function() {
      },
      error: logLevel <= 50 ? console.error.bind(console) : function() {
      }
    };
    module2.exports = log;
  }
});

// ../../packages/dd-trace/src/guardrails/telemetry.js
var require_telemetry5 = __commonJS({
  "../../packages/dd-trace/src/guardrails/telemetry.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var spawn = __require("child_process").spawn;
    var tracerVersion = require_package().version;
    var log = require_log5();
    module2.exports = sendTelemetry;
    if (!process.env.DD_INJECTION_ENABLED) {
      module2.exports = function noop() {
      };
    }
    var telemetryForwarderPath = process.env.DD_TELEMETRY_FORWARDER_PATH;
    if (typeof telemetryForwarderPath !== "string" || !fs.existsSync(telemetryForwarderPath)) {
      module2.exports = function noop() {
      };
    }
    var metadata = {
      language_name: "nodejs",
      language_version: process.versions.node,
      runtime_name: "nodejs",
      runtime_version: process.versions.node,
      tracer_version: tracerVersion,
      pid: process.pid,
      result: "unknown",
      result_reason: "unknown",
      result_class: "unknown"
    };
    var seen = {};
    function shouldSend(point) {
      if (point.name === "abort") {
        if (seen.abort) {
          return false;
        }
        seen.abort = true;
      } else if (point.name === "abort.integration") {
        var compiledPoint = point.name + point.tags.join("");
        if (seen[compiledPoint]) {
          return false;
        }
        seen[compiledPoint] = true;
      }
      return true;
    }
    function sendTelemetry(name, tags, resultMetadata) {
      var points = name;
      if (typeof name === "string") {
        points = [{ name, tags: tags || [] }];
      }
      if (["1", "true", "True"].indexOf(process.env.DD_INJECT_FORCE) !== -1) {
        points = points.filter(function(p) {
          return ["error", "complete"].indexOf(p.name) !== -1;
        });
      }
      points = points.filter(function(p) {
        return shouldSend(p);
      });
      for (var i = 0; i < points.length; i++) {
        points[i].name = "library_entrypoint." + points[i].name;
      }
      if (points.length === 0) {
        return;
      }
      var currentMetadata = {};
      for (var key in metadata) {
        currentMetadata[key] = metadata[key];
      }
      if (resultMetadata) {
        for (var resultKey in resultMetadata) {
          currentMetadata[resultKey] = resultMetadata[resultKey];
        }
      }
      var proc = spawn(process.env.DD_TELEMETRY_FORWARDER_PATH, ["library_entrypoint"], {
        stdio: "pipe"
      });
      proc.on("error", function() {
        log.error("Failed to spawn telemetry forwarder");
      });
      proc.on("exit", function(code) {
        if (code !== 0) {
          log.error("Telemetry forwarder exited with code", code);
        }
      });
      proc.stdin.on("error", function() {
        log.error("Failed to write telemetry data to telemetry forwarder");
      });
      proc.stdin.end(JSON.stringify({ metadata: currentMetadata, points }));
    }
  }
});

// ../../packages/datadog-instrumentations/src/fetch.js
var require_fetch3 = __commonJS({
  "../../packages/datadog-instrumentations/src/fetch.js"() {
    "use strict";
    var { isInServerlessEnvironment } = require_serverless();
    if (globalThis.fetch) {
      let wrapRealFetch = function() {
        const { channel, tracingChannel } = require_dc_polyfill();
        const { createWrapFetch } = require_fetch();
        const ch = tracingChannel("apm:fetch:request");
        const wrapFetch = createWrapFetch(globalThis.Request, ch, () => {
          channel("dd-trace:instrumentation:load").publish({ name: "global:fetch" });
        });
        fetch2 = wrapFetch(globalFetch);
      };
      const globalFetch = globalThis.fetch;
      let fetch2 = (input, init) => {
        wrapRealFetch();
        return fetch2(input, init);
      };
      if (!isInServerlessEnvironment()) {
        wrapRealFetch();
      }
      globalThis.fetch = function value(input, init) {
        return fetch2(input, init);
      };
    }
  }
});

// ../../packages/datadog-instrumentations/src/process.js
var require_process = __commonJS({
  "../../packages/datadog-instrumentations/src/process.js"() {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { channel } = require_dc_polyfill();
    var startSetUncaughtExceptionCaptureCallback = channel("datadog:process:setUncaughtExceptionCaptureCallback:start");
    if (process.setUncaughtExceptionCaptureCallback) {
      let currentCallback;
      shimmer.wrap(
        process,
        "setUncaughtExceptionCaptureCallback",
        function wrapSetUncaughtExceptionCaptureCallback(originalSetUncaughtExceptionCaptureCallback) {
          return function setUncaughtExceptionCaptureCallback(newCallback) {
            if (startSetUncaughtExceptionCaptureCallback.hasSubscribers) {
              const abortController = new AbortController();
              startSetUncaughtExceptionCaptureCallback.publish({ newCallback, currentCallback, abortController });
              if (abortController.signal.aborted) {
                return;
              }
            }
            const result = originalSetUncaughtExceptionCaptureCallback.apply(this, arguments);
            currentCallback = newCallback;
            return result;
          };
        }
      );
    }
  }
});

// ../../packages/datadog-instrumentations/src/helpers/register.js
var require_register2 = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/register.js"(exports2, module2) {
    "use strict";
    var { channel } = require_dc_polyfill();
    var path = __require("path");
    var satisfies = require_semifies();
    var Hook = require_hook();
    var requirePackageJson = require_require_package_json();
    var log = require_log2();
    var checkRequireCache = require_check_require_cache();
    var telemetry = require_telemetry5();
    var { isInServerlessEnvironment } = require_serverless();
    var { getEnvironmentVariables } = require_config_helper();
    var envs = getEnvironmentVariables();
    var {
      DD_TRACE_DISABLED_INSTRUMENTATIONS = "",
      DD_TRACE_DEBUG = ""
    } = envs;
    var hooks = require_hooks();
    var instrumentations = require_instrumentations();
    var names = Object.keys(hooks);
    var pathSepExpr = new RegExp(`\\${path.sep}`, "g");
    var disabledInstrumentations = new Set(
      DD_TRACE_DISABLED_INSTRUMENTATIONS?.split(",")
    );
    var loadChannel = channel("dd-trace:instrumentation:load");
    if (!disabledInstrumentations.has("fetch")) {
      require_fetch3();
    }
    if (!disabledInstrumentations.has("process")) {
      require_process();
    }
    var HOOK_SYMBOL = Symbol("hookExportsSet");
    if (DD_TRACE_DEBUG && DD_TRACE_DEBUG.toLowerCase() !== "false") {
      checkRequireCache.checkForRequiredModules();
      setImmediate(checkRequireCache.checkForPotentialConflicts);
    }
    var seenCombo = /* @__PURE__ */ new Set();
    var allInstrumentations = {};
    for (const packageName of names) {
      if (disabledInstrumentations.has(packageName)) continue;
      const hookOptions = {};
      let hook = hooks[packageName];
      if (hook !== null && typeof hook === "object") {
        if (hook.serverless === false && isInServerlessEnvironment()) continue;
        hookOptions.internals = hook.esmFirst;
        hook = hook.fn;
      }
      const instrumentationFileName = parseHookInstrumentationFileName(packageName);
      Hook([packageName], hookOptions, (moduleExports, moduleName2, moduleBaseDir, moduleVersion, isIitm) => {
        moduleName2 = moduleName2.replace(pathSepExpr, "/");
        hook();
        if (!instrumentations[packageName]) {
          return moduleExports;
        }
        const namesAndSuccesses = {};
        for (const { name, file, versions, hook: hook2, filePattern, patchDefault } of instrumentations[packageName]) {
          if (patchDefault === false && !moduleExports.default && isIitm) {
            return moduleExports;
          } else if (patchDefault === true && moduleExports.default && isIitm) {
            moduleExports = moduleExports.default;
          }
          let fullFilePattern = filePattern;
          const fullFilename = filename(name, file);
          if (fullFilePattern) {
            fullFilePattern = filename(name, fullFilePattern);
          }
          hook2[HOOK_SYMBOL] ??= /* @__PURE__ */ new WeakSet();
          let matchesFile = moduleName2 === fullFilename;
          if (fullFilePattern) {
            matchesFile = matchesFile || new RegExp(fullFilePattern).test(moduleName2);
          }
          if (matchesFile) {
            let version = moduleVersion;
            try {
              version = version || getVersion(moduleBaseDir);
              allInstrumentations[instrumentationFileName] = allInstrumentations[instrumentationFileName] || false;
            } catch (e) {
              log.error('Error getting version for "%s": %s', name, e.message, e);
              continue;
            }
            if (namesAndSuccesses[`${name}@${version}`] === void 0 && !file) {
              namesAndSuccesses[`${name}@${version}`] = false;
            }
            if (matchVersion(version, versions)) {
              allInstrumentations[instrumentationFileName] = true;
              if (hook2[HOOK_SYMBOL].has(moduleExports)) {
                namesAndSuccesses[`${name}@${version}`] = true;
                return moduleExports;
              }
              try {
                loadChannel.publish({ name, version, file });
                moduleExports = hook2(moduleExports, version, name, isIitm) ?? moduleExports;
                hook2[HOOK_SYMBOL].add(moduleExports);
              } catch (e) {
                log.info("Error during ddtrace instrumentation of application, aborting.", e);
                telemetry("error", [
                  `error_type:${e.constructor.name}`,
                  `integration:${name}`,
                  `integration_version:${version}`
                ], {
                  result: "error",
                  result_class: "internal_error",
                  result_reason: `Error during instrumentation of ${name}@${version}: ${e.message}`
                });
              }
              namesAndSuccesses[`${name}@${version}`] = true;
            }
          }
        }
        for (const nameVersion of Object.keys(namesAndSuccesses)) {
          const [name, version] = nameVersion.split("@");
          const success = namesAndSuccesses[nameVersion];
          if (!success && !seenCombo.has(nameVersion) && !allInstrumentations[instrumentationFileName]) {
            telemetry("abort.integration", [
              `integration:${name}`,
              `integration_version:${version}`
            ], {
              result: "abort",
              result_class: "incompatible_library",
              result_reason: `Incompatible integration version: ${name}@${version}`
            });
            log.info("Found incompatible integration version: %s", nameVersion);
            seenCombo.add(nameVersion);
          }
        }
        return moduleExports;
      });
    }
    function matchVersion(version, ranges) {
      return !version || !ranges || ranges.some((range) => satisfies(version, range));
    }
    function getVersion(moduleBaseDir) {
      if (moduleBaseDir) {
        return requirePackageJson(moduleBaseDir, module2).version;
      }
    }
    function filename(name, file) {
      return [name, file].filter(Boolean).join("/");
    }
    function parseHookInstrumentationFileName(packageName) {
      let hook = hooks[packageName];
      if (hook.fn) {
        hook = hook.fn;
      }
      const hookString = hook.toString();
      const regex = /require\('([^']*)'\)/;
      const match = hookString.match(regex);
      if (match && match[1]) {
        let moduleName2 = match[1];
        if (moduleName2.startsWith("../")) {
          moduleName2 = moduleName2.slice(3);
        }
        return moduleName2;
      }
      return null;
    }
    module2.exports = {
      filename,
      pathSepExpr,
      loadChannel,
      matchVersion
    };
  }
});

// ../../packages/datadog-instrumentations/src/helpers/bundler-register.js
var require_bundler_register = __commonJS({
  "../../packages/datadog-instrumentations/src/helpers/bundler-register.js"() {
    "use strict";
    var dc = require_dc_polyfill();
    var {
      filename,
      loadChannel,
      matchVersion
    } = require_register2();
    var hooks = require_hooks();
    var instrumentations = require_instrumentations();
    var log = require_log2();
    var CHANNEL = "dd-trace:bundler:load";
    if (!dc.subscribe) {
      dc.subscribe = (channel, cb) => {
        dc.channel(channel).subscribe(cb);
      };
    }
    if (!dc.unsubscribe) {
      dc.unsubscribe = (channel, cb) => {
        if (dc.channel(channel).hasSubscribers) {
          dc.channel(channel).unsubscribe(cb);
        }
      };
    }
    function doHook(payload) {
      const hook = hooks[payload.package];
      if (!hook) {
        log.error("esbuild-wrapped %s missing in list of hooks", payload.package);
        return;
      }
      const hookFn = hook.fn ?? hook;
      if (typeof hookFn !== "function") {
        log.error("esbuild-wrapped hook %s is not a function", payload.package);
        return;
      }
      try {
        hookFn();
      } catch {
        log.error("esbuild-wrapped %s hook failed", payload.package);
      }
    }
    dc.subscribe(CHANNEL, (payload) => {
      doHook(payload);
      if (!instrumentations[payload.package]) {
        log.error("esbuild-wrapped %s missing in list of instrumentations", payload.package);
        return;
      }
      for (const { name, file, versions, hook } of instrumentations[payload.package]) {
        if (payload.path !== filename(name, file)) continue;
        if (!matchVersion(payload.version, versions)) continue;
        try {
          loadChannel.publish({ name, version: payload.version, file });
          payload.module = hook(payload.module, payload.version);
        } catch (e) {
          log.error("Error executing bundler hook", e);
        }
      }
    });
  }
});

// ../../packages/datadog-instrumentations/index.js
var require_datadog_instrumentations = __commonJS({
  "../../packages/datadog-instrumentations/index.js"() {
    "use strict";
    require_bundler_register();
    require_register2();
  }
});

// ../../packages/dd-trace/src/lambda/runtime/errors.js
var require_errors2 = __commonJS({
  "../../packages/dd-trace/src/lambda/runtime/errors.js"(exports2, module2) {
    "use strict";
    var ExtendedError = class extends Error {
      constructor(reason) {
        super(reason);
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    var ImpendingTimeout = class extends ExtendedError {
    };
    ImpendingTimeout.prototype.name = "Impending Timeout";
    module2.exports = {
      ImpendingTimeout
    };
  }
});

// ../../packages/dd-trace/src/lambda/handler.js
var require_handler = __commonJS({
  "../../packages/dd-trace/src/lambda/handler.js"(exports2) {
    "use strict";
    var log = require_log2();
    var { channel } = require_instrument();
    var { ERROR_MESSAGE, ERROR_TYPE } = require_constants3();
    var { ImpendingTimeout } = require_errors2();
    var { getEnvironmentVariable } = require_config_helper();
    var globalTracer = global._ddtrace;
    var tracer2 = globalTracer._tracer;
    var timeoutChannel = channel("apm:aws:lambda:timeout");
    timeoutChannel.subscribe((_2) => {
      crashFlush();
    });
    var __lambdaTimeout;
    function checkTimeout(context2) {
      const remainingTimeInMillis = context2.getRemainingTimeInMillis();
      let apmFlushDeadline = Number.parseInt(getEnvironmentVariable("DD_APM_FLUSH_DEADLINE_MILLISECONDS")) || 100;
      apmFlushDeadline = apmFlushDeadline < 0 ? 100 : apmFlushDeadline;
      __lambdaTimeout = setTimeout(() => {
        timeoutChannel.publish();
      }, remainingTimeInMillis - apmFlushDeadline);
    }
    function crashFlush() {
      const activeSpan = tracer2.scope().active();
      if (activeSpan === null) {
        log.debug("An impending timeout was reached, but no root span was found. No error will be tagged.");
      } else {
        const error = new ImpendingTimeout("Datadog detected an impending timeout");
        activeSpan.addTags({
          [ERROR_MESSAGE]: error.message,
          [ERROR_TYPE]: error.name
        });
      }
      tracer2._processor.killAll();
      if (activeSpan !== null) {
        activeSpan.finish();
      }
    }
    function extractContext(args) {
      let context2 = args.length > 1 ? args[1] : void 0;
      if (context2 === void 0 || context2.getRemainingTimeInMillis === void 0) {
        context2 = args.length > 2 ? args[2] : void 0;
        if (context2 === void 0 || context2.getRemainingTimeInMillis === void 0) {
          throw new Error("Could not extract context");
        }
      }
      return context2;
    }
    exports2.datadog = function datadog(lambdaHandler) {
      return (...args) => {
        const context2 = extractContext(args);
        checkTimeout(context2);
        const result = lambdaHandler.apply(this, args);
        if (result && typeof result.then === "function") {
          return result.then((res) => {
            clearTimeout(__lambdaTimeout);
            return res;
          });
        }
        clearTimeout(__lambdaTimeout);
        return result;
      };
    };
  }
});

// ../../packages/dd-trace/src/lambda/runtime/patch.js
var require_patch = __commonJS({
  "../../packages/dd-trace/src/lambda/runtime/patch.js"() {
    "use strict";
    var path = __require("path");
    var { _extractModuleNameAndHandlerPath, _extractModuleRootAndHandler, _getLambdaFilePaths } = require_ritm2();
    var { datadog } = require_handler();
    var { addHook } = require_instrument();
    var shimmer = require_datadog_shimmer();
    var { getEnvironmentVariable } = require_config_helper();
    var patchDatadogLambdaModule = (datadogLambdaModule) => {
      shimmer.wrap(datadogLambdaModule, "datadog", patchDatadogLambdaHandler);
      return datadogLambdaModule;
    };
    function patchDatadogLambdaHandler(datadogHandler) {
      return (userHandler) => {
        return datadogHandler(datadog(userHandler));
      };
    }
    var patchLambdaModule = (handlerPath) => (lambdaModule) => {
      shimmer.wrap(lambdaModule, handlerPath, patchLambdaHandler);
      return lambdaModule;
    };
    function patchLambdaHandler(lambdaHandler) {
      return datadog(lambdaHandler);
    }
    var lambdaTaskRoot = getEnvironmentVariable("LAMBDA_TASK_ROOT");
    var originalLambdaHandler = getEnvironmentVariable("DD_LAMBDA_HANDLER");
    if (originalLambdaHandler === void 0) {
      addHook({ name: "datadog-lambda-js" }, patchDatadogLambdaModule);
    } else {
      const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler);
      const [_module, handlerPath] = _extractModuleNameAndHandlerPath(moduleAndHandler);
      const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module);
      const lambdaFilePaths = _getLambdaFilePaths(lambdaStylePath);
      for (const lambdaFilePath of lambdaFilePaths) {
        addHook({ name: lambdaFilePath }, patchLambdaModule(handlerPath));
      }
    }
  }
});

// ../../packages/dd-trace/src/lambda/runtime/ritm.js
var require_ritm2 = __commonJS({
  "../../packages/dd-trace/src/lambda/runtime/ritm.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var Hook = require_hook();
    var instrumentations = require_instrumentations();
    var {
      filename,
      pathSepExpr
    } = require_register2();
    function _extractModuleRootAndHandler(fullHandler) {
      const handlerString = path.basename(fullHandler);
      const moduleRoot = fullHandler.slice(0, Math.max(0, fullHandler.indexOf(handlerString)));
      return [moduleRoot, handlerString];
    }
    function _extractModuleNameAndHandlerPath(handler) {
      const FUNCTION_EXPR = /^([^.]*)\.(.*)$/;
      const match = handler.match(FUNCTION_EXPR);
      if (!match || match.length !== 3) {
        return;
      }
      return [match[1], match[2]];
    }
    function _getLambdaFilePaths(lambdaStylePath) {
      return [
        `${lambdaStylePath}.js`,
        `${lambdaStylePath}.mjs`,
        `${lambdaStylePath}.cjs`
      ];
    }
    var registerLambdaHook = () => {
      const lambdaTaskRoot = getEnvironmentVariable("LAMBDA_TASK_ROOT");
      const originalLambdaHandler = getEnvironmentVariable("DD_LAMBDA_HANDLER");
      if (originalLambdaHandler !== void 0 && lambdaTaskRoot !== void 0) {
        const [moduleRoot, moduleAndHandler] = _extractModuleRootAndHandler(originalLambdaHandler);
        const [_module] = _extractModuleNameAndHandlerPath(moduleAndHandler);
        const lambdaStylePath = path.resolve(lambdaTaskRoot, moduleRoot, _module);
        const lambdaFilePaths = _getLambdaFilePaths(lambdaStylePath);
        Hook(lambdaFilePaths, (moduleExports, name) => {
          require_patch();
          for (const { hook } of instrumentations[name]) {
            try {
              moduleExports = hook(moduleExports);
            } catch (e) {
              log.error("Error executing lambda hook", e);
            }
          }
          return moduleExports;
        });
      } else {
        const moduleToPatch = "datadog-lambda-js";
        Hook([moduleToPatch], (moduleExports, moduleName2, _2) => {
          moduleName2 = moduleName2.replace(pathSepExpr, "/");
          require_patch();
          for (const { name, file, hook } of instrumentations[moduleToPatch]) {
            const fullFilename = filename(name, file);
            if (moduleName2 === fullFilename) {
              try {
                moduleExports = hook(moduleExports);
              } catch (e) {
                log.error("Error executing lambda hook for datadog-lambda-js", e);
              }
            }
          }
          return moduleExports;
        });
      }
    };
    module2.exports = {
      _extractModuleRootAndHandler,
      _extractModuleNameAndHandlerPath,
      _getLambdaFilePaths,
      registerLambdaHook
    };
  }
});

// ../../packages/dd-trace/src/lambda/index.js
var require_lambda2 = __commonJS({
  "../../packages/dd-trace/src/lambda/index.js"() {
    "use strict";
    var { registerLambdaHook } = require_ritm2();
    var { getEnvironmentVariable } = require_config_helper();
    var _DD_TRACE_DISABLED_INSTRUMENTATIONS = getEnvironmentVariable("DD_TRACE_DISABLED_INSTRUMENTATIONS") || "";
    var _disabledInstrumentations = new Set(
      _DD_TRACE_DISABLED_INSTRUMENTATIONS ? _DD_TRACE_DISABLED_INSTRUMENTATIONS.split(",") : []
    );
    if (!_disabledInstrumentations.has("lambda")) {
      registerLambdaHook();
    }
  }
});

// ../../packages/dd-trace/src/plugin_manager.js
var require_plugin_manager = __commonJS({
  "../../packages/dd-trace/src/plugin_manager.js"(exports2, module2) {
    "use strict";
    var { channel } = require_dc_polyfill();
    var { isFalse, isTrue, normalizePluginEnvName } = require_util();
    var plugins = require_plugins();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var TEST_OPTIMIZATION_PLUGINS = /* @__PURE__ */ new Set([
      "jest",
      "vitest",
      "cucumber",
      "mocha",
      "playwright"
    ]);
    var loadChannel = channel("dd-trace:instrumentation:load");
    require_datadog_instrumentations();
    if (getEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") !== void 0) {
      require_lambda2();
    }
    var DD_TRACE_DISABLED_PLUGINS = getEnvironmentVariable("DD_TRACE_DISABLED_PLUGINS");
    var disabledPlugins = new Set(
      DD_TRACE_DISABLED_PLUGINS && DD_TRACE_DISABLED_PLUGINS.split(",").map((plugin) => plugin.trim())
    );
    var pluginClasses = {};
    loadChannel.subscribe(({ name }) => {
      maybeEnable(plugins[name]);
    });
    function maybeEnable(Plugin) {
      if (!Plugin || typeof Plugin !== "function") return;
      if (!pluginClasses[Plugin.id]) {
        const enabled = getEnvEnabled(Plugin);
        if (isFalse(enabled) || disabledPlugins.has(Plugin.id)) {
          log.debug('Plugin "%s" was disabled via configuration option.', Plugin.id);
          pluginClasses[Plugin.id] = null;
        } else {
          pluginClasses[Plugin.id] = Plugin;
        }
      }
    }
    function getEnvEnabled(Plugin) {
      const envName = `DD_TRACE_${Plugin.id.toUpperCase()}_ENABLED`;
      return getEnvironmentVariable(normalizePluginEnvName(envName));
    }
    module2.exports = class PluginManager {
      constructor(tracer2) {
        this._tracer = tracer2;
        this._tracerConfig = null;
        this._pluginsByName = {};
        this._configsByName = {};
        this._loadedSubscriber = ({ name }) => {
          const Plugin = plugins[name];
          if (!Plugin || typeof Plugin !== "function") return;
          this.loadPlugin(Plugin.id);
        };
        loadChannel.subscribe(this._loadedSubscriber);
      }
      loadPlugin(name) {
        const Plugin = pluginClasses[name];
        if (!Plugin) return;
        if (!this._tracerConfig) return;
        if (TEST_OPTIMIZATION_PLUGINS.has(name) && !this._tracerConfig.isCiVisibility) {
          log.debug('Plugin "%s" is not initialized because Test Optimization mode is not enabled.', name);
          return;
        }
        if (!this._pluginsByName[name]) {
          this._pluginsByName[name] = new Plugin(this._tracer, this._tracerConfig);
        }
        const pluginConfig = this._configsByName[name] || {
          enabled: this._tracerConfig.plugins !== false && (!Plugin.experimental || isTrue(getEnvEnabled(Plugin)))
        };
        this._pluginsByName[name].configure({
          ...this._getSharedConfig(name),
          ...pluginConfig
        });
      }
      // TODO: merge config instead of replacing
      configurePlugin(name, pluginConfig) {
        const enabled = this._isEnabled(pluginConfig);
        this._configsByName[name] = {
          ...pluginConfig,
          enabled
        };
        this.loadPlugin(name);
      }
      // like instrumenter.enable()
      configure(config = {}) {
        this._tracerConfig = config;
        this._tracer._nomenclature.configure(config);
        for (const name in pluginClasses) {
          this.loadPlugin(name);
        }
      }
      // This is basically just for testing. like intrumenter.disable()
      destroy() {
        for (const name in this._pluginsByName) {
          this._pluginsByName[name].configure({ enabled: false });
        }
        loadChannel.unsubscribe(this._loadedSubscriber);
      }
      _isEnabled(pluginConfig) {
        if (typeof pluginConfig === "boolean") return pluginConfig;
        if (!pluginConfig) return true;
        return pluginConfig.enabled !== false;
      }
      // TODO: figure out a better way to handle this
      _getSharedConfig(name) {
        const {
          logInjection,
          serviceMapping,
          queryStringObfuscation,
          site,
          url,
          headerTags,
          codeOriginForSpans,
          dbmPropagationMode,
          dsmEnabled,
          clientIpEnabled,
          clientIpHeader,
          memcachedCommandEnabled,
          ciVisibilityTestSessionName,
          ciVisAgentlessLogSubmissionEnabled,
          isTestDynamicInstrumentationEnabled,
          isServiceUserProvided,
          middlewareTracingEnabled,
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
          experimental
        } = this._tracerConfig;
        const sharedConfig = {
          codeOriginForSpans,
          dbmPropagationMode,
          dsmEnabled,
          memcachedCommandEnabled,
          site,
          url,
          headers: headerTags || [],
          clientIpHeader,
          ciVisibilityTestSessionName,
          ciVisAgentlessLogSubmissionEnabled,
          isTestDynamicInstrumentationEnabled,
          isServiceUserProvided,
          traceWebsocketMessagesEnabled,
          traceWebsocketMessagesInheritSampling,
          traceWebsocketMessagesSeparateTraces,
          experimental
        };
        if (logInjection !== void 0) {
          sharedConfig.logInjection = logInjection;
        }
        if (queryStringObfuscation !== void 0) {
          sharedConfig.queryStringObfuscation = queryStringObfuscation;
        }
        if (serviceMapping && serviceMapping[name]) {
          sharedConfig.service = serviceMapping[name];
        }
        if (clientIpEnabled !== void 0) {
          sharedConfig.clientIpEnabled = clientIpEnabled;
        }
        if (middlewareTracingEnabled !== void 0) {
          sharedConfig.middleware = middlewareTracingEnabled;
        }
        return sharedConfig;
      }
    };
  }
});

// ../../packages/dd-trace/src/flare/file.js
var require_file = __commonJS({
  "../../packages/dd-trace/src/flare/file.js"(exports2, module2) {
    "use strict";
    var { Writable } = __require("stream");
    var INITIAL_SIZE = 64 * 1024;
    var FlareFile = class extends Writable {
      constructor() {
        super();
        this.length = 0;
        this._buffer = Buffer.alloc(INITIAL_SIZE);
      }
      get data() {
        return this._buffer.subarray(0, this.length);
      }
      _write(chunk, encoding, callback) {
        const length = Buffer.byteLength(chunk);
        this._reserve(length);
        this.length += Buffer.isBuffer(chunk) ? chunk.copy(this._buffer, this.length) : this._buffer.write(chunk, encoding);
        callback();
      }
      _reserve(length) {
        while (this.length + length > this._buffer.length) {
          const buffer = Buffer.alloc(this.length * 2);
          this._buffer.copy(buffer);
          this._buffer = buffer;
        }
      }
    };
    module2.exports = FlareFile;
  }
});

// ../../packages/dd-trace/src/flare/index.js
var require_flare = __commonJS({
  "../../packages/dd-trace/src/flare/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var startupLog = require_startup_log();
    var FlareFile = require_file();
    var { LogChannel } = require_channels();
    var request2 = require_request();
    var FormData = require_form_data();
    var MAX_LOG_SIZE = 12 * 1024 * 1024;
    var TIMEOUT = 20 * 1e3 * 60;
    var logChannel = null;
    var tracerLogs = null;
    var timer;
    var tracerConfig = null;
    var logger = {
      debug: (msg) => recordLog(msg),
      info: (msg) => recordLog(msg),
      warn: (msg) => recordLog(msg),
      error: (err) => recordLog(err.stack)
    };
    var flare = {
      enable(tracerConfig_) {
        tracerConfig = tracerConfig_;
      },
      disable() {
        tracerConfig = null;
        flare.cleanup();
      },
      prepare(logLevel) {
        if (!tracerConfig) return;
        logChannel?.unsubscribe(logger);
        logChannel = new LogChannel(logLevel);
        logChannel.subscribe(logger);
        tracerLogs = tracerLogs || new FlareFile();
        timer = timer || setTimeout(flare.cleanup, TIMEOUT);
      },
      send(task) {
        if (!tracerConfig) return;
        const tracerInfo = new FlareFile();
        tracerInfo.write(JSON.stringify(startupLog.tracerInfo(), null, 2));
        flare._sendFile(task, tracerInfo, "tracer_info.txt");
        flare._sendFile(task, tracerLogs, "tracer_logs.txt");
        flare.cleanup();
      },
      cleanup() {
        logChannel?.unsubscribe(logger);
        timer = clearTimeout(timer);
        logChannel = null;
        tracerLogs = null;
      },
      _sendFile(task, file, filename) {
        if (!file) return;
        const form = new FormData();
        form.append("case_id", task.case_id);
        form.append("hostname", task.hostname);
        form.append("email", task.user_handle);
        form.append("source", "tracer_nodejs");
        form.append("flare_file", file.data, { filename });
        request2(form, {
          url: tracerConfig.url,
          hostname: tracerConfig.hostname,
          port: tracerConfig.port,
          method: "POST",
          path: "/tracer_flare/v1",
          headers: form.getHeaders()
        }, (err) => {
          if (err) {
            log.error("Error sending flare payload", err);
          }
        });
      }
    };
    function recordLog(msg) {
      if (tracerLogs.length > MAX_LOG_SIZE) return;
      if (msg && typeof msg === "object") {
        msg = JSON.stringify(msg);
      }
      tracerLogs.write(`${msg}
`);
    }
    module2.exports = flare;
  }
});

// ../../packages/dd-trace/src/appsec/telemetry/common.js
var require_common2 = __commonJS({
  "../../packages/dd-trace/src/appsec/telemetry/common.js"(exports2, module2) {
    "use strict";
    var DD_TELEMETRY_REQUEST_METRICS = Symbol("_dd.appsec.telemetry.request.metrics");
    var tags = {
      BLOCK_FAILURE: "block_failure",
      EVENT_RULES_VERSION: "event_rules_version",
      INPUT_TRUNCATED: "input_truncated",
      RATE_LIMITED: "rate_limited",
      REQUEST_BLOCKED: "request_blocked",
      RULE_TRIGGERED: "rule_triggered",
      WAF_ERROR: "waf_error",
      WAF_TIMEOUT: "waf_timeout",
      WAF_VERSION: "waf_version"
    };
    function getVersionsTags(wafVersion, rulesVersion) {
      return {
        [tags.WAF_VERSION]: wafVersion,
        [tags.EVENT_RULES_VERSION]: rulesVersion || "unknown"
      };
    }
    module2.exports = {
      tags,
      getVersionsTags,
      DD_TELEMETRY_REQUEST_METRICS
    };
  }
});

// ../../packages/dd-trace/src/appsec/telemetry/user.js
var require_user = __commonJS({
  "../../packages/dd-trace/src/appsec/telemetry/user.js"(exports2, module2) {
    "use strict";
    var telemetryMetrics = require_metrics();
    var appsecMetrics = telemetryMetrics.manager.namespace("appsec");
    function incrementMissingUserLogin(framework, eventType) {
      appsecMetrics.count("instrum.user_auth.missing_user_login", {
        framework,
        event_type: eventType
      }).inc();
    }
    function incrementMissingUserId(framework, eventType) {
      appsecMetrics.count("instrum.user_auth.missing_user_id", {
        framework,
        event_type: eventType
      }).inc();
    }
    function incrementSdkEvent(eventType, sdkVersion = "v1") {
      appsecMetrics.count("sdk.event", {
        event_type: eventType,
        sdk_version: sdkVersion
      }).inc();
    }
    module2.exports = {
      incrementMissingUserLogin,
      incrementMissingUserId,
      incrementSdkEvent
    };
  }
});

// ../../packages/dd-trace/src/appsec/telemetry/rasp.js
var require_rasp = __commonJS({
  "../../packages/dd-trace/src/appsec/telemetry/rasp.js"(exports2, module2) {
    "use strict";
    var telemetryMetrics = require_metrics();
    var { DD_TELEMETRY_REQUEST_METRICS, getVersionsTags } = require_common2();
    var appsecMetrics = telemetryMetrics.manager.namespace("appsec");
    var BLOCKING_STATUS = {
      FAILURE: "failure",
      IRRELEVANT: "irrelevant",
      SUCCESS: "success"
    };
    function addRaspRequestMetrics(store, { duration, durationExt, wafTimeout, errorCode }) {
      store[DD_TELEMETRY_REQUEST_METRICS].raspDuration += duration || 0;
      store[DD_TELEMETRY_REQUEST_METRICS].raspDurationExt += durationExt || 0;
      store[DD_TELEMETRY_REQUEST_METRICS].raspEvalCount++;
      if (wafTimeout) {
        store[DD_TELEMETRY_REQUEST_METRICS].raspTimeouts++;
      }
      if (errorCode) {
        store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode = store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode ? Math.max(
          errorCode,
          store[DD_TELEMETRY_REQUEST_METRICS].raspErrorCode
        ) : errorCode;
      }
    }
    function trackRaspMetrics(store, metrics2, raspRule) {
      const versionsTags = getVersionsTags(metrics2.wafVersion, metrics2.rulesVersion);
      const tags = { rule_type: raspRule.type, ...versionsTags };
      const telemetryMetrics2 = store[DD_TELEMETRY_REQUEST_METRICS];
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant;
      }
      if (metrics2.wafVersion) {
        telemetryMetrics2.wafVersion = metrics2.wafVersion;
      }
      if (metrics2.rulesVersion) {
        telemetryMetrics2.rulesVersion = metrics2.rulesVersion;
      }
      appsecMetrics.count("rasp.rule.eval", tags).inc(1);
      if (metrics2.errorCode) {
        const errorTags = { ...tags, waf_error: metrics2.errorCode };
        appsecMetrics.count("rasp.error", errorTags).inc(1);
      }
      if (metrics2.wafTimeout) {
        appsecMetrics.count("rasp.timeout", tags).inc(1);
      }
    }
    function trackRaspRuleMatch(store, raspRule, blockTriggered, blocked) {
      const telemetryMetrics2 = store[DD_TELEMETRY_REQUEST_METRICS];
      const tags = {
        waf_version: telemetryMetrics2.wafVersion,
        event_rules_version: telemetryMetrics2.rulesVersion,
        rule_type: raspRule.type,
        block: getRuleMatchBlockingStatus(blockTriggered, blocked)
      };
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant;
      }
      appsecMetrics.count("rasp.rule.match", tags).inc(1);
    }
    function trackRaspRuleSkipped(raspRule, reason) {
      const tags = { reason, rule_type: raspRule.type };
      if (raspRule.variant) {
        tags.rule_variant = raspRule.variant;
      }
      appsecMetrics.count("rasp.rule.skipped", tags).inc(1);
    }
    function getRuleMatchBlockingStatus(blockTriggered, blocked) {
      if (!blockTriggered) {
        return BLOCKING_STATUS.IRRELEVANT;
      }
      return blocked ? BLOCKING_STATUS.SUCCESS : BLOCKING_STATUS.FAILURE;
    }
    module2.exports = {
      addRaspRequestMetrics,
      trackRaspMetrics,
      trackRaspRuleMatch,
      trackRaspRuleSkipped
    };
  }
});

// ../../packages/dd-trace/src/appsec/telemetry/waf.js
var require_waf = __commonJS({
  "../../packages/dd-trace/src/appsec/telemetry/waf.js"(exports2, module2) {
    "use strict";
    var telemetryMetrics = require_metrics();
    var { tags, getVersionsTags, DD_TELEMETRY_REQUEST_METRICS } = require_common2();
    var appsecMetrics = telemetryMetrics.manager.namespace("appsec");
    var DD_TELEMETRY_WAF_RESULT_TAGS = Symbol("_dd.appsec.telemetry.waf.result.tags");
    var TRUNCATION_FLAGS = {
      STRING: 1,
      CONTAINER_SIZE: 2,
      CONTAINER_DEPTH: 4
    };
    function addWafRequestMetrics(store, { duration, durationExt, wafTimeout, errorCode }) {
      store[DD_TELEMETRY_REQUEST_METRICS].duration += duration || 0;
      store[DD_TELEMETRY_REQUEST_METRICS].durationExt += durationExt || 0;
      if (wafTimeout) {
        store[DD_TELEMETRY_REQUEST_METRICS].wafTimeouts++;
      }
      if (errorCode) {
        store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode = store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode ? Math.max(
          errorCode,
          store[DD_TELEMETRY_REQUEST_METRICS].wafErrorCode
        ) : errorCode;
      }
    }
    function trackWafMetrics(store, metrics2) {
      const versionsTags = getVersionsTags(metrics2.wafVersion, metrics2.rulesVersion);
      const metricTags = getOrCreateMetricTags(store, versionsTags);
      if (metrics2.blockFailed) {
        metricTags[tags.BLOCK_FAILURE] = true;
      }
      if (metrics2.blockTriggered) {
        metricTags[tags.REQUEST_BLOCKED] = true;
      }
      if (metrics2.rateLimited) {
        metricTags[tags.RATE_LIMITED] = true;
      }
      if (metrics2.ruleTriggered) {
        metricTags[tags.RULE_TRIGGERED] = true;
      }
      if (metrics2.errorCode) {
        metricTags[tags.WAF_ERROR] = true;
        appsecMetrics.count("waf.error", { ...versionsTags, waf_error: metrics2.errorCode }).inc();
      }
      if (metrics2.wafTimeout) {
        metricTags[tags.WAF_TIMEOUT] = true;
      }
      const truncationReason = getTruncationReason(metrics2);
      if (truncationReason > 0) {
        metricTags[tags.INPUT_TRUNCATED] = true;
        incrementTruncatedMetrics(metrics2, truncationReason);
      }
      return metricTags;
    }
    function getOrCreateMetricTags(store, versionsTags) {
      let metricTags = store[DD_TELEMETRY_WAF_RESULT_TAGS];
      if (!metricTags) {
        metricTags = {
          [tags.BLOCK_FAILURE]: false,
          [tags.INPUT_TRUNCATED]: false,
          [tags.RATE_LIMITED]: false,
          [tags.REQUEST_BLOCKED]: false,
          [tags.RULE_TRIGGERED]: false,
          [tags.WAF_ERROR]: false,
          [tags.WAF_TIMEOUT]: false,
          ...versionsTags
        };
        store[DD_TELEMETRY_WAF_RESULT_TAGS] = metricTags;
      }
      return metricTags;
    }
    function incrementWafInit(wafVersion, rulesVersion, success) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion);
      appsecMetrics.count("waf.init", { ...versionsTags, success }).inc();
      if (!success) {
        appsecMetrics.count("waf.config_errors", { ...versionsTags, action: "init" }).inc();
      }
    }
    function incrementWafUpdates(wafVersion, rulesVersion, success) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion);
      appsecMetrics.count("waf.updates", { ...versionsTags, success }).inc();
    }
    function incrementWafConfigErrors(wafVersion, rulesVersion) {
      const versionsTags = getVersionsTags(wafVersion, rulesVersion);
      appsecMetrics.count("waf.config_errors", { ...versionsTags, action: "update" }).inc();
    }
    function incrementWafRequests(store) {
      const metricTags = store[DD_TELEMETRY_WAF_RESULT_TAGS];
      if (metricTags) {
        appsecMetrics.count("waf.requests", metricTags).inc();
      }
    }
    function incrementTruncatedMetrics(metrics2, truncationReason) {
      const truncationTags = { truncation_reason: truncationReason };
      appsecMetrics.count("waf.input_truncated", truncationTags).inc(1);
    }
    function getTruncationReason({ maxTruncatedString, maxTruncatedContainerSize, maxTruncatedContainerDepth }) {
      let reason = 0;
      if (maxTruncatedString) reason |= TRUNCATION_FLAGS.STRING;
      if (maxTruncatedContainerSize) reason |= TRUNCATION_FLAGS.CONTAINER_SIZE;
      if (maxTruncatedContainerDepth) reason |= TRUNCATION_FLAGS.CONTAINER_DEPTH;
      return reason;
    }
    module2.exports = {
      addWafRequestMetrics,
      trackWafMetrics,
      incrementWafInit,
      incrementWafUpdates,
      incrementWafConfigErrors,
      incrementWafRequests
    };
  }
});

// ../../packages/dd-trace/src/appsec/telemetry/index.js
var require_telemetry6 = __commonJS({
  "../../packages/dd-trace/src/appsec/telemetry/index.js"(exports2, module2) {
    "use strict";
    var { DD_TELEMETRY_REQUEST_METRICS } = require_common2();
    var { incrementMissingUserId, incrementMissingUserLogin, incrementSdkEvent } = require_user();
    var {
      addRaspRequestMetrics,
      trackRaspMetrics,
      trackRaspRuleMatch,
      trackRaspRuleSkipped
    } = require_rasp();
    var {
      addWafRequestMetrics,
      trackWafMetrics,
      incrementWafInit,
      incrementWafUpdates,
      incrementWafConfigErrors,
      incrementWafRequests
    } = require_waf();
    var telemetryMetrics = require_metrics();
    var metricsStoreMap = /* @__PURE__ */ new WeakMap();
    var appsecMetrics = telemetryMetrics.manager.namespace("appsec");
    var enabled = false;
    var interval;
    var SUPPORTED_ORIGINS = /* @__PURE__ */ new Set(["env_var", "code", "remote_config", "unknown"]);
    function enable(config) {
      const telemetryConfig = config.telemetry;
      enabled = telemetryConfig?.enabled && telemetryConfig.metrics;
      if (enabled) {
        let origin = "remote_config";
        if (config.appsec.enabled) {
          origin = config.getOrigin("appsec.enabled");
          if (!SUPPORTED_ORIGINS.has(origin)) {
            origin = "unknown";
          }
        }
        const gauge = appsecMetrics.gauge("enabled", { origin });
        gauge.track();
        interval = setInterval(() => {
          gauge.track();
        }, telemetryConfig.heartbeatInterval);
        interval.unref?.();
      }
    }
    function disable() {
      enabled = false;
      if (interval) {
        clearInterval(interval);
        interval = void 0;
      }
    }
    function newStore() {
      return {
        [DD_TELEMETRY_REQUEST_METRICS]: {
          duration: 0,
          durationExt: 0,
          raspDuration: 0,
          raspDurationExt: 0,
          raspEvalCount: 0,
          wafTimeouts: 0,
          raspTimeouts: 0,
          wafErrorCode: null,
          raspErrorCode: null,
          wafVersion: null,
          rulesVersion: null
        }
      };
    }
    function getStore(req) {
      let store = metricsStoreMap.get(req);
      if (!store) {
        store = newStore();
        metricsStoreMap.set(req, store);
      }
      return store;
    }
    function updateRaspRequestsMetricTags(metrics2, req, raspRule) {
      if (!req) return;
      const store = getStore(req);
      addRaspRequestMetrics(store, metrics2);
      if (!enabled) return;
      trackRaspMetrics(store, metrics2, raspRule);
    }
    function updateRaspRuleMatchMetricTags(req, raspRule, blockTriggered, blocked) {
      if (!enabled || !req) return;
      const store = getStore(req);
      trackRaspRuleMatch(store, raspRule, blockTriggered, blocked);
    }
    function updateRaspRuleSkippedMetricTags(raspRule, reason) {
      if (!enabled) return;
      trackRaspRuleSkipped(raspRule, reason);
    }
    function updateWafRequestsMetricTags(metrics2, req) {
      if (!req) return;
      const store = getStore(req);
      addWafRequestMetrics(store, metrics2);
      if (!enabled) return;
      return trackWafMetrics(store, metrics2);
    }
    function updateRateLimitedMetric(req) {
      if (!enabled) return;
      const store = getStore(req);
      trackWafMetrics(store, { rateLimited: true });
    }
    function updateBlockFailureMetric(req) {
      if (!enabled) return;
      const store = getStore(req);
      trackWafMetrics(store, { blockFailed: true });
    }
    function incrementWafInitMetric(wafVersion, rulesVersion, success) {
      if (!enabled) return;
      incrementWafInit(wafVersion, rulesVersion, success);
    }
    function incrementWafUpdatesMetric(wafVersion, rulesVersion, success) {
      if (!enabled) return;
      incrementWafUpdates(wafVersion, rulesVersion, success);
    }
    function incrementWafConfigErrorsMetric(wafVersion, rulesVersion) {
      if (!enabled) return;
      incrementWafConfigErrors(wafVersion, rulesVersion);
    }
    function incrementWafRequestsMetric(req) {
      if (!req || !enabled) return;
      const store = getStore(req);
      incrementWafRequests(store);
      metricsStoreMap.delete(req);
    }
    function incrementMissingUserLoginMetric(framework, eventType) {
      if (!enabled) return;
      incrementMissingUserLogin(framework, eventType);
    }
    function incrementMissingUserIdMetric(framework, eventType) {
      if (!enabled) return;
      incrementMissingUserId(framework, eventType);
    }
    function incrementSdkEventMetric(eventType, sdkVersion) {
      if (!enabled) return;
      incrementSdkEvent(eventType, sdkVersion);
    }
    function getRequestMetrics(req) {
      if (req) {
        const store = getStore(req);
        return store?.[DD_TELEMETRY_REQUEST_METRICS];
      }
    }
    module2.exports = {
      enable,
      disable,
      updateWafRequestsMetricTags,
      updateRateLimitedMetric,
      updateBlockFailureMetric,
      updateRaspRequestsMetricTags,
      updateRaspRuleMatchMetricTags,
      updateRaspRuleSkippedMetricTags,
      incrementWafInitMetric,
      incrementWafUpdatesMetric,
      incrementWafConfigErrorsMetric,
      incrementWafRequestsMetric,
      incrementMissingUserLoginMetric,
      incrementMissingUserIdMetric,
      incrementSdkEventMetric,
      getRequestMetrics
    };
  }
});

// ../../packages/dd-trace/src/standalone/product.js
var require_product = __commonJS({
  "../../packages/dd-trace/src/standalone/product.js"(exports2, module2) {
    "use strict";
    var { SAMPLING_MECHANISM_APPSEC } = require_constants3();
    var RateLimiter = require_rate_limiter();
    function getProductRateLimiter(config) {
      if (config?.appsec?.enabled || config?.iast?.enabled) {
        return new RateLimiter(1, "minute");
      }
      return new RateLimiter(0);
    }
    var PRODUCTS = {
      APM: { id: 1 << 0 },
      ASM: { id: 1 << 1, mechanism: SAMPLING_MECHANISM_APPSEC },
      DSM: { id: 1 << 2 },
      DJM: { id: 1 << 3 },
      DBM: { id: 1 << 4 }
    };
    module2.exports = {
      ...PRODUCTS,
      getProductRateLimiter
    };
  }
});

// ../../packages/dd-trace/src/appsec/waf/diagnostics.js
var require_diagnostics = __commonJS({
  "../../packages/dd-trace/src/appsec/waf/diagnostics.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DIAGNOSTIC_KEYS: [
        "rules",
        "custom_rules",
        "exclusions",
        "actions",
        "processors",
        "scanners",
        "rules_override",
        "rules_data",
        "exclusion_data"
      ]
    };
  }
});

// ../../packages/dd-trace/src/appsec/reporter.js
var require_reporter = __commonJS({
  "../../packages/dd-trace/src/appsec/reporter.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var zlib = __require("zlib");
    var { storage } = require_datadog_core();
    var web = require_web3();
    var { ipHeaderList } = require_ip_extractor();
    var {
      incrementWafInitMetric,
      incrementWafUpdatesMetric,
      incrementWafConfigErrorsMetric,
      incrementWafRequestsMetric,
      updateWafRequestsMetricTags,
      updateRaspRequestsMetricTags,
      updateRaspRuleSkippedMetricTags,
      getRequestMetrics
    } = require_telemetry6();
    var { keepTrace } = require_priority_sampler();
    var { ASM } = require_product();
    var { DIAGNOSTIC_KEYS } = require_diagnostics();
    var REQUEST_HEADER_TAG_PREFIX = "http.request.headers.";
    var RESPONSE_HEADER_TAG_PREFIX = "http.response.headers.";
    var COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH = 4096;
    var COLLECTED_REQUEST_BODY_MAX_DEPTH = 20;
    var COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE = 256;
    var telemetryLogCh = dc.channel("datadog:telemetry:log");
    var config = {
      headersExtendedCollectionEnabled: false,
      maxHeadersCollected: 0,
      headersRedaction: false,
      raspBodyCollection: false
    };
    var metricsQueue = /* @__PURE__ */ new Map();
    var extendedDataCollectionRequest = /* @__PURE__ */ new WeakMap();
    var contentHeaderList = [
      "content-length",
      "content-encoding",
      "content-language"
    ];
    var responseHeaderList = [
      ...contentHeaderList,
      "content-type"
    ];
    var identificationHeaders = [
      "x-amzn-trace-id",
      "cloudfront-viewer-ja3-fingerprint",
      "cf-ray",
      "x-cloud-trace-context",
      "x-appgw-trace-id",
      "x-sigsci-requestid",
      "x-sigsci-tags",
      "akamai-user-risk"
    ];
    var eventHeadersList = [
      ...ipHeaderList,
      "x-forwarded",
      "forwarded",
      "via",
      ...contentHeaderList,
      "host",
      "accept-encoding",
      "accept-language"
    ];
    var requestHeadersList = [
      "content-type",
      "user-agent",
      "accept",
      ...identificationHeaders
    ];
    var redactedHeadersList = [
      "authorization",
      "proxy-authorization",
      "www-authenticate",
      "proxy-authenticate",
      "authentication-info",
      "proxy-authentication-info",
      "cookie",
      "set-cookie"
    ];
    var REQUEST_HEADERS_MAP = mapHeaderAndTags(requestHeadersList, REQUEST_HEADER_TAG_PREFIX);
    var EVENT_HEADERS_MAP = mapHeaderAndTags(eventHeadersList, REQUEST_HEADER_TAG_PREFIX);
    var RESPONSE_HEADERS_MAP = mapHeaderAndTags(responseHeaderList, RESPONSE_HEADER_TAG_PREFIX);
    var NON_EXTENDED_REQUEST_HEADERS = /* @__PURE__ */ new Set([...requestHeadersList, ...eventHeadersList]);
    var NON_EXTENDED_RESPONSE_HEADERS = new Set(responseHeaderList);
    var REDACTED_HEADERS = new Set(redactedHeadersList);
    function init(_config) {
      config.headersExtendedCollectionEnabled = _config.extendedHeadersCollection.enabled;
      config.maxHeadersCollected = _config.extendedHeadersCollection.maxHeaders;
      config.headersRedaction = _config.extendedHeadersCollection.redaction;
      config.raspBodyCollection = _config.rasp.bodyCollection;
    }
    function formatHeaderName(name) {
      return name.trim().slice(0, 200).replaceAll(/[^a-zA-Z0-9_\-:/]/g, "_").toLowerCase();
    }
    function getHeaderTag(tagPrefix, headerName) {
      return `${tagPrefix}${formatHeaderName(headerName)}`;
    }
    function mapHeaderAndTags(headerList, tagPrefix) {
      return new Map(headerList.map((headerName) => [headerName, getHeaderTag(tagPrefix, headerName)]));
    }
    function filterHeaders(headers, map) {
      const result = {};
      if (!headers) return result;
      for (const [headerName, tagName] of map) {
        const headerValue = headers[headerName];
        if (headerValue) {
          result[tagName] = String(headerValue);
        }
      }
      return result;
    }
    function filterExtendedHeaders(headers, excludedHeaderNames, tagPrefix, limit = 0) {
      const result = {};
      if (!headers) return result;
      let counter = 0;
      for (const [headerName, headerValue] of Object.entries(headers)) {
        if (counter >= limit) break;
        if (!excludedHeaderNames.has(headerName)) {
          result[getHeaderTag(tagPrefix, headerName)] = REDACTED_HEADERS.has(headerName) ? "<redacted>" : String(headerValue);
          counter++;
        }
      }
      return result;
    }
    function getCollectedHeaders(req, res, shouldCollectEventHeaders2, storedResponseHeaders = {}, extendedDataCollection) {
      const mandatoryCollectedHeaders = filterHeaders(req.headers, REQUEST_HEADERS_MAP);
      if (!shouldCollectEventHeaders2) return mandatoryCollectedHeaders;
      const responseHeaders = Object.keys(storedResponseHeaders).length === 0 ? res.getHeaders() : { ...storedResponseHeaders, ...res.getHeaders() };
      const requestEventCollectedHeaders = filterHeaders(req.headers, EVENT_HEADERS_MAP);
      const responseEventCollectedHeaders = filterHeaders(responseHeaders, RESPONSE_HEADERS_MAP);
      if ((!config.headersExtendedCollectionEnabled || config.headersRedaction) && !extendedDataCollection) {
        return Object.assign(
          mandatoryCollectedHeaders,
          requestEventCollectedHeaders,
          responseEventCollectedHeaders
        );
      }
      const maxHeadersCollected = extendedDataCollection?.max_collected_headers ?? config.maxHeadersCollected;
      const collectedHeadersCount = Object.keys(mandatoryCollectedHeaders).length + Object.keys(requestEventCollectedHeaders).length;
      const requestExtendedHeadersAvailableCount = maxHeadersCollected - collectedHeadersCount;
      const requestEventExtendedCollectedHeaders = filterExtendedHeaders(
        req.headers,
        NON_EXTENDED_REQUEST_HEADERS,
        REQUEST_HEADER_TAG_PREFIX,
        requestExtendedHeadersAvailableCount
      );
      const responseExtendedHeadersAvailableCount = maxHeadersCollected - Object.keys(responseEventCollectedHeaders).length;
      const responseEventExtendedCollectedHeaders = filterExtendedHeaders(
        responseHeaders,
        NON_EXTENDED_RESPONSE_HEADERS,
        RESPONSE_HEADER_TAG_PREFIX,
        responseExtendedHeadersAvailableCount
      );
      const headersTags = Object.assign(
        mandatoryCollectedHeaders,
        requestEventCollectedHeaders,
        requestEventExtendedCollectedHeaders,
        responseEventCollectedHeaders,
        responseEventExtendedCollectedHeaders
      );
      const requestHeadersCount = Object.keys(req.headers).length;
      if (requestHeadersCount > maxHeadersCollected) {
        headersTags["_dd.appsec.request.header_collection.discarded"] = requestHeadersCount - maxHeadersCollected;
      }
      const responseHeadersCount = Object.keys(responseHeaders).length;
      if (responseHeadersCount > maxHeadersCollected) {
        headersTags["_dd.appsec.response.header_collection.discarded"] = responseHeadersCount - maxHeadersCollected;
      }
      return headersTags;
    }
    function reportWafInit(wafVersion, rulesVersion, diagnosticsRules = {}, success = false) {
      if (success) {
        metricsQueue.set("_dd.appsec.waf.version", wafVersion);
      }
      incrementWafInitMetric(wafVersion, rulesVersion, success);
    }
    function logWafDiagnosticMessage(product, rcConfigId, configKey, message, level) {
      const tags = `log_type:rc::${product.toLowerCase()}::diagnostic,appsec_config_key:${configKey},rc_config_id:${rcConfigId}`;
      telemetryLogCh.publish({
        message,
        level,
        tags
      });
    }
    function reportWafConfigUpdate(product, rcConfigId, diagnostics, wafVersion) {
      if (diagnostics.error) {
        logWafDiagnosticMessage(product, rcConfigId, "", diagnostics.error, "ERROR");
        incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version);
      }
      for (const configKey of DIAGNOSTIC_KEYS) {
        const configDiagnostics = diagnostics[configKey];
        if (!configDiagnostics) continue;
        if (configDiagnostics.error) {
          logWafDiagnosticMessage(product, rcConfigId, configKey, configDiagnostics.error, "ERROR");
          incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version);
          continue;
        }
        if (configDiagnostics.errors) {
          for (const [errorMessage, errorIds] of Object.entries(configDiagnostics.errors)) {
            logWafDiagnosticMessage(
              product,
              rcConfigId,
              configKey,
              `"${errorMessage}": ${JSON.stringify(errorIds)}`,
              "ERROR"
            );
            incrementWafConfigErrorsMetric(wafVersion, diagnostics.ruleset_version);
          }
        }
        if (configDiagnostics.warnings) {
          for (const [warningMessage, warningIds] of Object.entries(configDiagnostics.warnings)) {
            logWafDiagnosticMessage(
              product,
              rcConfigId,
              configKey,
              `"${warningMessage}": ${JSON.stringify(warningIds)}`,
              "WARN"
            );
          }
        }
      }
    }
    function reportMetrics(metrics2, raspRule) {
      const store = storage("legacy").getStore();
      const rootSpan = store?.req && web.root(store.req);
      if (!rootSpan) return;
      if (metrics2.rulesVersion) {
        rootSpan.setTag("_dd.appsec.event_rules.version", metrics2.rulesVersion);
      }
      if (raspRule) {
        updateRaspRequestsMetricTags(metrics2, store.req, raspRule);
      } else {
        updateWafRequestsMetricTags(metrics2, store.req);
      }
      reportTruncationMetrics(rootSpan, metrics2);
    }
    function reportTruncationMetrics(rootSpan, metrics2) {
      if (metrics2.maxTruncatedString) {
        rootSpan.setTag("_dd.appsec.truncated.string_length", metrics2.maxTruncatedString);
      }
      if (metrics2.maxTruncatedContainerSize) {
        rootSpan.setTag("_dd.appsec.truncated.container_size", metrics2.maxTruncatedContainerSize);
      }
      if (metrics2.maxTruncatedContainerDepth) {
        rootSpan.setTag("_dd.appsec.truncated.container_depth", metrics2.maxTruncatedContainerDepth);
      }
    }
    function reportAttack({ events: attackData, actions }) {
      const store = storage("legacy").getStore();
      const req = store?.req;
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      const currentTags = rootSpan.context()._tags;
      const newTags = {
        "appsec.event": "true"
      };
      if (!currentTags["_dd.origin"]) {
        newTags["_dd.origin"] = "appsec";
      }
      const currentJson = currentTags["_dd.appsec.json"];
      const attackDataStr = JSON.stringify(attackData);
      newTags["_dd.appsec.json"] = currentJson ? currentJson.slice(0, -2) + "," + attackDataStr.slice(1) + "}" : '{"triggers":' + attackDataStr + "}";
      if (req.socket) {
        newTags["network.client.ip"] = req.socket.remoteAddress;
      }
      rootSpan.addTags(newTags);
      if (config.raspBodyCollection && isRaspAttack(attackData)) {
        reportRequestBody(rootSpan, req.body, true);
      }
      const extendedDataCollection = actions?.extended_data_collection;
      if (extendedDataCollection) {
        extendedDataCollectionRequest.set(req, extendedDataCollection);
      }
    }
    function truncateRequestBody(target, depth = 0) {
      switch (typeof target) {
        case "string":
          if (target.length > COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH) {
            return { value: target.slice(0, COLLECTED_REQUEST_BODY_MAX_STRING_LENGTH), truncated: true };
          }
          return { value: target, truncated: false };
        case "object": {
          if (target === null) {
            return { value: target, truncated: false };
          }
          if (depth >= COLLECTED_REQUEST_BODY_MAX_DEPTH) {
            return { truncated: true };
          }
          if (typeof target.toJSON === "function") {
            try {
              return truncateRequestBody(target.toJSON(), depth + 1);
            } catch {
              return { truncated: false };
            }
          }
          if (Array.isArray(target)) {
            const maxArrayLength = Math.min(target.length, COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE);
            let wasTruncated2 = target.length > COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE;
            const truncatedArray = new Array(maxArrayLength);
            for (let i = 0; i < maxArrayLength; i++) {
              const { value, truncated } = truncateRequestBody(target[i], depth + 1);
              if (truncated) wasTruncated2 = true;
              truncatedArray[i] = value;
            }
            return { value: truncatedArray, truncated: wasTruncated2 };
          }
          const keys = Object.keys(target);
          const maxKeysLength = Math.min(keys.length, COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE);
          let wasTruncated = keys.length > COLLECTED_REQUEST_BODY_MAX_ELEMENTS_PER_NODE;
          const truncatedObject = {};
          for (let i = 0; i < maxKeysLength; i++) {
            const key = keys[i];
            const { value, truncated } = truncateRequestBody(target[key], depth + 1);
            if (truncated) wasTruncated = true;
            truncatedObject[key] = value;
          }
          return { value: truncatedObject, truncated: wasTruncated };
        }
        default:
          return { value: target, truncated: false };
      }
    }
    function reportRequestBody(rootSpan, requestBody, comesFromRaspAction = false) {
      if (!requestBody || Object.keys(requestBody).length === 0) return;
      if (!rootSpan.meta_struct) {
        rootSpan.meta_struct = {};
      }
      if (rootSpan.meta_struct["http.request.body"]) {
        const currentTags = rootSpan.context()._tags;
        const sizeExceedTagValue = currentTags["_dd.appsec.rasp.request_body_size.exceeded"];
        if (sizeExceedTagValue) {
          rootSpan.setTag("_dd.appsec.request_body_size.exceeded", sizeExceedTagValue);
        }
      } else {
        const { truncated, value } = truncateRequestBody(requestBody);
        rootSpan.meta_struct["http.request.body"] = value;
        if (truncated) {
          const sizeExceedTagKey = comesFromRaspAction ? "_dd.appsec.rasp.request_body_size.exceeded" : "_dd.appsec.request_body_size.exceeded";
          rootSpan.setTag(sizeExceedTagKey, "true");
        }
      }
    }
    function isRaspAttack(events) {
      return events.some((e) => e.rule?.tags?.module === "rasp");
    }
    function isSchemaAttribute(attribute) {
      return attribute.startsWith("_dd.appsec.s.");
    }
    function reportAttributes(attributes) {
      if (!attributes) return;
      const req = storage("legacy").getStore()?.req;
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      const tags = {};
      for (let [tag, value] of Object.entries(attributes)) {
        if (isSchemaAttribute(tag)) {
          const gzippedValue = zlib.gzipSync(JSON.stringify(value));
          value = gzippedValue.toString("base64");
        }
        tags[tag] = value;
      }
      rootSpan.addTags(tags);
    }
    function finishRequest(req, res, storedResponseHeaders, requestBody) {
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      if (metricsQueue.size) {
        rootSpan.addTags(Object.fromEntries(metricsQueue));
        keepTrace(rootSpan, ASM);
        metricsQueue.clear();
      }
      const metrics2 = getRequestMetrics(req);
      if (metrics2?.duration) {
        rootSpan.setTag("_dd.appsec.waf.duration", metrics2.duration);
      }
      if (metrics2?.durationExt) {
        rootSpan.setTag("_dd.appsec.waf.duration_ext", metrics2.durationExt);
      }
      if (metrics2?.wafErrorCode) {
        rootSpan.setTag("_dd.appsec.waf.error", metrics2.wafErrorCode);
      }
      if (metrics2?.wafTimeouts) {
        rootSpan.setTag("_dd.appsec.waf.timeouts", metrics2.wafTimeouts);
      }
      if (metrics2?.raspDuration) {
        rootSpan.setTag("_dd.appsec.rasp.duration", metrics2.raspDuration);
      }
      if (metrics2?.raspDurationExt) {
        rootSpan.setTag("_dd.appsec.rasp.duration_ext", metrics2.raspDurationExt);
      }
      if (metrics2?.raspErrorCode) {
        rootSpan.setTag("_dd.appsec.rasp.error", metrics2.raspErrorCode);
      }
      if (metrics2?.raspTimeouts) {
        rootSpan.setTag("_dd.appsec.rasp.timeout", metrics2.raspTimeouts);
      }
      if (metrics2?.raspEvalCount) {
        rootSpan.setTag("_dd.appsec.rasp.rule.eval", metrics2.raspEvalCount);
      }
      incrementWafRequestsMetric(req);
      const tags = rootSpan.context()._tags;
      const extendedDataCollection = extendedDataCollectionRequest.get(req);
      const newTags = getCollectedHeaders(
        req,
        res,
        shouldCollectEventHeaders(tags),
        storedResponseHeaders,
        extendedDataCollection
      );
      if (extendedDataCollection) {
        reportRequestBody(rootSpan, requestBody);
      }
      if (tags["appsec.event"] === "true" && typeof req.route?.path === "string") {
        newTags["http.endpoint"] = req.route.path;
      }
      rootSpan.addTags(newTags);
    }
    function shouldCollectEventHeaders(tags = {}) {
      if (tags["appsec.event"] === "true") {
        return true;
      }
      for (const tagName of Object.keys(tags)) {
        if (tagName.startsWith("appsec.events.")) {
          return true;
        }
      }
      return false;
    }
    module2.exports = {
      metricsQueue,
      init,
      filterHeaders,
      filterExtendedHeaders,
      formatHeaderName,
      reportWafInit,
      reportWafConfigUpdate,
      reportMetrics,
      reportAttack,
      reportWafUpdate: incrementWafUpdatesMetric,
      reportRaspRuleSkipped: updateRaspRuleSkippedMetricTags,
      reportAttributes,
      finishRequest,
      mapHeaderAndTags,
      truncateRequestBody
    };
  }
});

// ../../packages/dd-trace/src/appsec/addresses.js
var require_addresses = __commonJS({
  "../../packages/dd-trace/src/appsec/addresses.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      HTTP_INCOMING_BODY: "server.request.body",
      HTTP_INCOMING_QUERY: "server.request.query",
      HTTP_INCOMING_HEADERS: "server.request.headers.no_cookies",
      // TODO: 'server.request.trailers',
      HTTP_INCOMING_URL: "server.request.uri.raw",
      HTTP_INCOMING_METHOD: "server.request.method",
      HTTP_INCOMING_PARAMS: "server.request.path_params",
      HTTP_INCOMING_COOKIES: "server.request.cookies",
      HTTP_INCOMING_RESPONSE_CODE: "server.response.status",
      HTTP_INCOMING_RESPONSE_HEADERS: "server.response.headers.no_cookies",
      // TODO: 'server.response.trailers',
      HTTP_INCOMING_GRAPHQL_RESOLVERS: "graphql.server.all_resolvers",
      HTTP_INCOMING_GRAPHQL_RESOLVER: "graphql.server.resolver",
      HTTP_INCOMING_RESPONSE_BODY: "server.response.body",
      HTTP_CLIENT_IP: "http.client_ip",
      USER_ID: "usr.id",
      USER_LOGIN: "usr.login",
      USER_SESSION_ID: "usr.session_id",
      WAF_CONTEXT_PROCESSOR: "waf.context.processor",
      HTTP_OUTGOING_URL: "server.io.net.url",
      FS_OPERATION_PATH: "server.io.fs.file",
      DB_STATEMENT: "server.db.statement",
      DB_SYSTEM: "server.db.system",
      EXEC_COMMAND: "server.sys.exec.cmd",
      SHELL_COMMAND: "server.sys.shell.cmd",
      LOGIN_SUCCESS: "server.business_logic.users.login.success",
      LOGIN_FAILURE: "server.business_logic.users.login.failure"
    };
  }
});

// ../../packages/dd-trace/src/appsec/blocked_templates.js
var require_blocked_templates = __commonJS({
  "../../packages/dd-trace/src/appsec/blocked_templates.js"(exports2, module2) {
    "use strict";
    var html = `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>You've been blocked</title><style>a,body,div,html,span{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}body{background:-webkit-radial-gradient(26% 19%,circle,#fff,#f4f7f9);background:radial-gradient(circle at 26% 19%,#fff,#f4f7f9);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:center;align-content:center;width:100%;min-height:100vh;line-height:1;flex-direction:column}p{display:block}main{text-align:center;flex:1;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-ms-flex-line-pack:center;align-content:center;flex-direction:column}p{font-size:18px;line-height:normal;color:#646464;font-family:sans-serif;font-weight:400}a{color:#4842b7}footer{width:100%;text-align:center}footer p{font-size:16px}</style></head><body><main><p>Sorry, you cannot access this page. Please contact the customer service team.</p></main><footer><p>Security provided by <a href="https://www.datadoghq.com/product/security-platform/application-security-monitoring/" target="_blank">Datadog</a></p></footer></body></html>`;
    var json = `{"errors":[{"title":"You've been blocked","detail":"Sorry, you cannot access this page. Please contact the customer service team. Security provided by Datadog."}]}`;
    var graphqlJson = `{"errors":[{"message":"You've been blocked","extensions":{"detail":"Sorry, you cannot perform this operation. Please contact the customer service team. Security provided by Datadog."}}]}`;
    module2.exports = {
      html,
      json,
      graphqlJson
    };
  }
});

// ../../packages/dd-trace/src/appsec/blocking.js
var require_blocking = __commonJS({
  "../../packages/dd-trace/src/appsec/blocking.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var blockedTemplates = require_blocked_templates();
    var { updateBlockFailureMetric } = require_telemetry6();
    var detectedSpecificEndpoints = {};
    var templateHtml = blockedTemplates.html;
    var templateJson = blockedTemplates.json;
    var templateGraphqlJson = blockedTemplates.graphqlJson;
    var defaultBlockingActionParameters;
    var responseBlockedSet = /* @__PURE__ */ new WeakSet();
    var blockDelegations = /* @__PURE__ */ new WeakMap();
    var specificBlockingTypes = {
      GRAPHQL: "graphql"
    };
    function getSpecificKey(method, url) {
      return `${method}+${url}`;
    }
    function addSpecificEndpoint(method, url, type) {
      detectedSpecificEndpoints[getSpecificKey(method, url)] = type;
    }
    function getBlockWithRedirectData(actionParameters) {
      let statusCode = actionParameters.status_code;
      if (!statusCode || statusCode < 300 || statusCode >= 400) {
        statusCode = 303;
      }
      const headers = {
        Location: actionParameters.location
      };
      return { headers, statusCode };
    }
    function getSpecificBlockingData(type) {
      switch (type) {
        case specificBlockingTypes.GRAPHQL:
          return {
            type: "application/json",
            body: templateGraphqlJson
          };
      }
    }
    function getBlockWithContentData(req, specificType, actionParameters) {
      let type;
      let body;
      const specificBlockingType = specificType || detectedSpecificEndpoints[getSpecificKey(req.method, req.url)];
      if (specificBlockingType) {
        const specificBlockingContent = getSpecificBlockingData(specificBlockingType);
        type = specificBlockingContent?.type;
        body = specificBlockingContent?.body;
      }
      if (!type) {
        const accept = req.headers.accept?.split(",").map((str) => str.split(";", 1)[0].trim());
        if (!actionParameters || actionParameters.type === "auto") {
          if (accept?.includes("text/html") && !accept.includes("application/json")) {
            type = "text/html; charset=utf-8";
            body = templateHtml;
          } else {
            type = "application/json";
            body = templateJson;
          }
        } else {
          if (actionParameters.type === "html") {
            type = "text/html; charset=utf-8";
            body = templateHtml;
          } else {
            type = "application/json";
            body = templateJson;
          }
        }
      }
      const statusCode = actionParameters?.status_code || 403;
      const headers = {
        "Content-Type": type,
        "Content-Length": Buffer.byteLength(body)
      };
      return { body, statusCode, headers };
    }
    function getBlockingData(req, specificType, actionParameters) {
      return actionParameters?.location ? getBlockWithRedirectData(actionParameters) : getBlockWithContentData(req, specificType, actionParameters);
    }
    function block(req, res, rootSpan, abortController, actionParameters = defaultBlockingActionParameters) {
      blockDelegations.delete(res);
      try {
        if (res.headersSent) {
          log.warn("[ASM] Cannot send blocking response when headers have already been sent");
          throw new Error("Headers have already been sent");
        }
        const { body, headers, statusCode } = getBlockingData(req, null, actionParameters);
        for (const headerName of res.getHeaderNames()) {
          res.removeHeader(headerName);
        }
        res.writeHead(statusCode, headers);
        res.constructor.prototype.end.call(res, body);
        rootSpan.setTag("appsec.blocked", "true");
        responseBlockedSet.add(res);
        abortController?.abort();
        return true;
      } catch (err) {
        rootSpan?.setTag("_dd.appsec.block.failed", 1);
        log.error("[ASM] Blocking error", err);
        updateBlockFailureMetric(req);
        return false;
      }
    }
    function registerBlockDelegation(req, res) {
      const args = arguments;
      return new Promise((resolve) => {
        if (blockDelegations.has(res)) return;
        blockDelegations.set(res, { args, resolve });
      });
    }
    function callBlockDelegation(res) {
      const delegation = blockDelegations.get(res);
      if (delegation) {
        const result = block.apply(this, delegation.args);
        delegation.resolve(result);
        return result;
      }
    }
    function getBlockingAction(actions) {
      return actions?.redirect_request || actions?.block_request;
    }
    function setTemplates(config) {
      templateHtml = config.appsec.blockedTemplateHtml || blockedTemplates.html;
      templateJson = config.appsec.blockedTemplateJson || blockedTemplates.json;
      templateGraphqlJson = config.appsec.blockedTemplateGraphql || blockedTemplates.graphqlJson;
    }
    function isBlocked(res) {
      return responseBlockedSet.has(res);
    }
    function setDefaultBlockingActionParameters(actions) {
      const blockAction = actions?.find((action) => action.id === "block");
      defaultBlockingActionParameters = blockAction?.parameters;
    }
    module2.exports = {
      addSpecificEndpoint,
      block,
      registerBlockDelegation,
      callBlockDelegation,
      specificBlockingTypes,
      getBlockingData,
      getBlockingAction,
      setTemplates,
      isBlocked,
      setDefaultBlockingActionParameters
    };
  }
});

// ../../packages/dd-trace/src/appsec/waf/waf_context_wrapper.js
var require_waf_context_wrapper = __commonJS({
  "../../packages/dd-trace/src/appsec/waf/waf_context_wrapper.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var Reporter = require_reporter();
    var addresses = require_addresses();
    var { getBlockingAction } = require_blocking();
    var { wafRunFinished } = require_channels2();
    var preventDuplicateAddresses = /* @__PURE__ */ new Set([
      addresses.HTTP_INCOMING_QUERY
    ]);
    var WAFContextWrapper = class {
      constructor(ddwafContext, wafTimeout, wafVersion, rulesVersion, knownAddresses) {
        this.ddwafContext = ddwafContext;
        this.wafTimeout = wafTimeout;
        this.wafVersion = wafVersion;
        this.rulesVersion = rulesVersion;
        this.knownAddresses = knownAddresses;
        this.addressesToSkip = /* @__PURE__ */ new Set();
        this.cachedUserIdResults = /* @__PURE__ */ new Map();
      }
      run({ persistent, ephemeral }, raspRule) {
        if (this.ddwafContext.disposed) {
          log.warn("[ASM] Calling run on a disposed context");
          if (raspRule) {
            Reporter.reportRaspRuleSkipped(raspRule, "after-request");
          }
          return;
        }
        const userId = persistent?.[addresses.USER_ID] || ephemeral?.[addresses.USER_ID];
        if (userId) {
          const cachedResults = this.cachedUserIdResults.get(userId);
          if (cachedResults) {
            return cachedResults;
          }
        }
        const payload = {};
        let payloadHasData = false;
        const newAddressesToSkip = new Set(this.addressesToSkip);
        if (persistent !== null && typeof persistent === "object") {
          const persistentInputs = {};
          let hasPersistentInputs = false;
          for (const key of Object.keys(persistent)) {
            if (!this.addressesToSkip.has(key) && this.knownAddresses.has(key)) {
              hasPersistentInputs = true;
              persistentInputs[key] = persistent[key];
              if (preventDuplicateAddresses.has(key)) {
                newAddressesToSkip.add(key);
              }
            }
          }
          if (hasPersistentInputs) {
            payload.persistent = persistentInputs;
            payloadHasData = true;
          }
        }
        if (ephemeral !== null && typeof ephemeral === "object") {
          const ephemeralInputs = {};
          let hasEphemeral = false;
          for (const key of Object.keys(ephemeral)) {
            if (this.knownAddresses.has(key)) {
              hasEphemeral = true;
              ephemeralInputs[key] = ephemeral[key];
            }
          }
          if (hasEphemeral) {
            payload.ephemeral = ephemeralInputs;
            payloadHasData = true;
          }
        }
        if (!payloadHasData) return;
        const metrics2 = {
          rulesVersion: this.rulesVersion,
          wafVersion: this.wafVersion,
          wafTimeout: false,
          duration: 0,
          durationExt: 0,
          blockTriggered: false,
          ruleTriggered: false,
          errorCode: null,
          maxTruncatedString: null,
          maxTruncatedContainerSize: null,
          maxTruncatedContainerDepth: null
        };
        try {
          const start = process.hrtime.bigint();
          const result = this.ddwafContext.run(payload, this.wafTimeout);
          const end = process.hrtime.bigint();
          metrics2.durationExt = Number.parseInt(end - start) / 1e3;
          if (typeof result.errorCode === "number" && result.errorCode < 0) {
            const error = new Error("WAF code error");
            error.errorCode = result.errorCode;
            throw error;
          }
          if (result.metrics) {
            const { maxTruncatedString, maxTruncatedContainerSize, maxTruncatedContainerDepth } = result.metrics;
            if (maxTruncatedString) metrics2.maxTruncatedString = maxTruncatedString;
            if (maxTruncatedContainerSize) metrics2.maxTruncatedContainerSize = maxTruncatedContainerSize;
            if (maxTruncatedContainerDepth) metrics2.maxTruncatedContainerDepth = maxTruncatedContainerDepth;
          }
          this.addressesToSkip = newAddressesToSkip;
          const ruleTriggered = !!result.events?.length;
          const blockTriggered = !!getBlockingAction(result.actions);
          if (userId && ruleTriggered && blockTriggered) {
            this.setUserIdCache(userId, result);
          }
          metrics2.duration = result.duration / 1e3;
          metrics2.blockTriggered = blockTriggered;
          metrics2.ruleTriggered = ruleTriggered;
          metrics2.wafTimeout = result.timeout;
          if (ruleTriggered) {
            Reporter.reportAttack(result);
          }
          Reporter.reportAttributes(result.attributes);
          return result;
        } catch (err) {
          log.error("[ASM] Error while running the AppSec WAF", err);
          metrics2.errorCode = err.errorCode ?? -127;
        } finally {
          if (wafRunFinished.hasSubscribers) {
            wafRunFinished.publish({ payload });
          }
          Reporter.reportMetrics(metrics2, raspRule);
        }
      }
      setUserIdCache(userId, result) {
        for (let i = 0; i < result.events.length; i++) {
          const event = result.events[i];
          for (let j = 0; j < event?.rule_matches?.length; j++) {
            const match = event.rule_matches[j];
            for (let k = 0; k < match?.parameters?.length; k++) {
              const parameter = match.parameters[k];
              if (parameter?.address === addresses.USER_ID) {
                this.cachedUserIdResults.set(userId, result);
                return;
              }
            }
          }
        }
      }
      dispose() {
        this.ddwafContext.dispose();
      }
    };
    module2.exports = WAFContextWrapper;
  }
});

// ../../packages/dd-trace/src/appsec/waf/waf_manager.js
var require_waf_manager = __commonJS({
  "../../packages/dd-trace/src/appsec/waf/waf_manager.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var Reporter = require_reporter();
    var WAFContextWrapper = require_waf_context_wrapper();
    var contexts = /* @__PURE__ */ new WeakMap();
    var WAFManager = class _WAFManager {
      static defaultWafConfigPath = "datadog/00/ASM_DD/default/config";
      constructor(rules, config) {
        this.config = config;
        this.wafTimeout = config.wafTimeout;
        this.ddwaf = this._loadDDWAF(rules);
        this.rulesVersion = this.ddwaf.diagnostics.ruleset_version;
        this.defaultRules = rules;
        Reporter.reportWafInit(this.ddwafVersion, this.rulesVersion, this.ddwaf.diagnostics.rules, true);
      }
      _loadDDWAF(rules) {
        try {
          const { DDWAF } = __require("@datadog/native-appsec");
          this.ddwafVersion = DDWAF.version();
          const { obfuscatorKeyRegex, obfuscatorValueRegex } = this.config;
          return new DDWAF(rules, _WAFManager.defaultWafConfigPath, { obfuscatorKeyRegex, obfuscatorValueRegex });
        } catch (err) {
          this.ddwafVersion = this.ddwafVersion || "unknown";
          Reporter.reportWafInit(this.ddwafVersion, "unknown");
          log.error("[ASM] AppSec could not load native package. In-app WAF features will not be available.");
          throw err;
        }
      }
      getWAFContext(req) {
        let wafContext = contexts.get(req);
        if (!wafContext) {
          wafContext = new WAFContextWrapper(
            this.ddwaf.createContext(),
            this.wafTimeout,
            this.ddwafVersion,
            this.rulesVersion,
            this.ddwaf.knownAddresses
          );
          contexts.set(req, wafContext);
        }
        return wafContext;
      }
      setRulesVersion() {
        if (this.ddwaf.diagnostics.ruleset_version) {
          this.rulesVersion = this.ddwaf.diagnostics.ruleset_version;
        }
      }
      setAsmDdFallbackConfig() {
        if (!this.ddwaf.configPaths.some((cp) => cp.includes("ASM_DD"))) {
          this.updateConfig(_WAFManager.defaultWafConfigPath, this.defaultRules);
        }
      }
      updateConfig(path, rules) {
        const updateResult = this.ddwaf.createOrUpdateConfig(rules, path);
        this.setRulesVersion();
        return updateResult;
      }
      removeConfig(path) {
        this.ddwaf.removeConfig(path);
        this.setRulesVersion();
      }
      destroy() {
        if (this.ddwaf) {
          this.ddwaf.dispose();
        }
      }
    };
    module2.exports = WAFManager;
  }
});

// ../../packages/dd-trace/src/appsec/waf/index.js
var require_waf2 = __commonJS({
  "../../packages/dd-trace/src/appsec/waf/index.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var log = require_log2();
    var Reporter = require_reporter();
    var Limiter = require_rate_limiter();
    var { keepTrace } = require_priority_sampler();
    var { ASM } = require_product();
    var web = require_web3();
    var { updateRateLimitedMetric } = require_telemetry6();
    var WafUpdateError = class extends Error {
      constructor(diagnosticErrors) {
        super("WafUpdateError");
        this.name = "WafUpdateError";
        this.diagnosticErrors = diagnosticErrors;
      }
    };
    var limiter = new Limiter(100);
    var waf = {
      wafManager: null,
      init,
      destroy,
      updateConfig,
      removeConfig,
      checkAsmDdFallback,
      run: noop,
      disposeContext: noop,
      WafUpdateError
    };
    function init(rules, config) {
      destroy();
      limiter = new Limiter(config.rateLimit);
      const WAFManager = require_waf_manager();
      waf.wafManager = new WAFManager(rules, config);
      waf.run = run;
      waf.disposeContext = disposeContext;
    }
    function destroy() {
      if (waf.wafManager) {
        waf.wafManager.destroy();
        waf.wafManager = null;
      }
      waf.run = noop;
      waf.disposeContext = noop;
    }
    function checkAsmDdFallback() {
      if (!waf.wafManager) throw new Error("Cannot update disabled WAF");
      try {
        waf.wafManager.setAsmDdFallbackConfig();
      } catch {
        log.error("[ASM] Could not apply default ruleset back as fallback");
      }
    }
    function updateConfig(product, configId, configPath, config) {
      if (!waf.wafManager) throw new Error("Cannot update disabled WAF");
      try {
        if (product === "ASM_DD") {
          waf.wafManager.removeConfig(waf.wafManager.constructor.defaultWafConfigPath);
        }
        const updateSucceeded = waf.wafManager.updateConfig(configPath, config);
        Reporter.reportWafConfigUpdate(product, configId, waf.wafManager.ddwaf.diagnostics, waf.wafManager.ddwafVersion);
        if (!updateSucceeded) {
          throw new WafUpdateError(waf.wafManager.ddwaf.diagnostics);
        }
      } catch (err) {
        log.error("[ASM] Could not update config from RC");
        throw err;
      }
    }
    function removeConfig(configPath) {
      if (!waf.wafManager) throw new Error("Cannot update disabled WAF");
      try {
        waf.wafManager.removeConfig(configPath);
      } catch (err) {
        log.error("[ASM] Could not remove config from RC");
        throw err;
      }
    }
    function run(data, req, raspRule) {
      if (!req) {
        const store = storage("legacy").getStore();
        if (!store || !store.req) {
          log.warn("[ASM] Request object not available in waf.run");
          return;
        }
        req = store.req;
      }
      const wafContext = waf.wafManager.getWAFContext(req);
      const result = wafContext.run(data, raspRule);
      if (result?.keep) {
        if (limiter.isAllowed()) {
          const rootSpan = web.root(req);
          keepTrace(rootSpan, ASM);
        } else {
          updateRateLimitedMetric(req);
        }
      }
      return result;
    }
    function disposeContext(req) {
      const wafContext = waf.wafManager.getWAFContext(req);
      if (wafContext && !wafContext.ddwafContext.disposed) {
        wafContext.dispose();
      }
    }
    function noop() {
    }
    module2.exports = waf;
  }
});

// ../../packages/dd-trace/src/remote_config/apply_states.js
var require_apply_states = __commonJS({
  "../../packages/dd-trace/src/remote_config/apply_states.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      UNACKNOWLEDGED: 1,
      ACKNOWLEDGED: 2,
      ERROR: 3
    };
  }
});

// ../../packages/dd-trace/src/appsec/recommended.json
var require_recommended = __commonJS({
  "../../packages/dd-trace/src/appsec/recommended.json"(exports2, module2) {
    module2.exports = {
      version: "2.2",
      metadata: {
        rules_version: "1.15.1"
      },
      rules: [
        {
          id: "blk-001-001",
          name: "Block IP Addresses",
          tags: {
            type: "block_ip",
            category: "security_response",
            module: "network-acl"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "http.client_ip"
                  }
                ],
                data: "blocked_ips"
              },
              operator: "ip_match"
            }
          ],
          transformers: [],
          on_match: [
            "block"
          ]
        },
        {
          id: "blk-001-002",
          name: "Block User Addresses",
          tags: {
            type: "block_user",
            category: "security_response",
            module: "authentication-acl"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "usr.id"
                  }
                ],
                data: "blocked_users"
              },
              operator: "exact_match"
            }
          ],
          transformers: [],
          on_match: [
            "block"
          ]
        },
        {
          id: "crs-913-110",
          name: "Acunetix",
          tags: {
            type: "commercial_scanner",
            crs_id: "913110",
            category: "attack_attempt",
            tool_name: "Acunetix",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                list: [
                  "acunetix-product",
                  "(acunetix web vulnerability scanner",
                  "acunetix-scanning-agreement",
                  "acunetix-user-agreement",
                  "md5(acunetix_wvs_security_test)"
                ]
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-913-120",
          name: "Known security scanner filename/argument",
          tags: {
            type: "security_scanner",
            crs_id: "913120",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                list: [
                  "/.adsensepostnottherenonobook",
                  "/<invalid>hello.html",
                  "/actsensepostnottherenonotive",
                  "/acunetix-wvs-test-for-some-inexistent-file",
                  "/antidisestablishmentarianism",
                  "/appscan_fingerprint/mac_address",
                  "/arachni-",
                  "/cybercop",
                  "/nessus_is_probing_you_",
                  "/nessustest",
                  "/netsparker-",
                  "/rfiinc.txt",
                  "/thereisnowaythat-you-canbethere",
                  "/w3af/remotefileinclude.html",
                  "appscan_fingerprint",
                  "w00tw00t.at.isc.sans.dfind",
                  "w00tw00t.at.blackhats.romanian.anti-sec"
                ],
                options: {
                  enforce_word_boundary: true
                }
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-920-260",
          name: "Unicode Full/Half Width Abuse Attack Attempt",
          tags: {
            type: "http_protocol_violation",
            crs_id: "920260",
            category: "attack_attempt",
            cwe: "176",
            capec: "1000/255/153/267/71",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "\\%u[fF]{2}[0-9a-fA-F]{2}",
                options: {
                  case_sensitive: true,
                  min_length: 6
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-921-110",
          name: "HTTP Request Smuggling Attack",
          tags: {
            type: "http_protocol_violation",
            crs_id: "921110",
            category: "attack_attempt",
            cwe: "444",
            capec: "1000/210/272/220/33",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  }
                ],
                regex: "(?:get|post|head|options|connect|put|delete|trace|track|patch|propfind|propatch|mkcol|copy|move|lock|unlock)\\s+[^\\s]+\\s+http/\\d",
                options: {
                  case_sensitive: true,
                  min_length: 12
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-921-160",
          name: "HTTP Header Injection Attack via payload (CR/LF and header-name detected)",
          tags: {
            type: "http_protocol_violation",
            crs_id: "921160",
            category: "attack_attempt",
            cwe: "113",
            capec: "1000/210/272/220/105",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.path_params"
                  }
                ],
                regex: "[\\n\\r]+(?:refresh|(?:set-)?cookie|(?:x-)?(?:forwarded-(?:for|host|server)|via|remote-ip|remote-addr|originating-IP))\\s*:",
                options: {
                  case_sensitive: true,
                  min_length: 3
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-930-100",
          name: "Obfuscated Path Traversal Attack (/../)",
          tags: {
            type: "lfi",
            crs_id: "930100",
            category: "attack_attempt",
            cwe: "22",
            capec: "1000/255/153/126",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                regex: "(?:%(?:c(?:0%(?:[2aq]f|5c|9v)|1%(?:[19p]c|8s|af))|2(?:5(?:c(?:0%25af|1%259c)|2f|5c)|%46|f)|(?:(?:f(?:8%8)?0%8|e)0%80%a|bg%q)f|%3(?:2(?:%(?:%6|4)6|F)|5%%63)|u(?:221[56]|002f|EFC8|F025)|1u|5c)|0x(?:2f|5c)|\\/|\\x5c)(?:%(?:(?:f(?:(?:c%80|8)%8)?0%8|e)0%80%ae|2(?:(?:5(?:c0%25a|2))?e|%45)|u(?:(?:002|ff0)e|2024)|%32(?:%(?:%6|4)5|E)|c0(?:%[256aef]e|\\.))|\\.(?:%0[01])?|0x2e){2,3}(?:%(?:c(?:0%(?:[2aq]f|5c|9v)|1%(?:[19p]c|8s|af))|2(?:5(?:c(?:0%25af|1%259c)|2f|5c)|%46|f)|(?:(?:f(?:8%8)?0%8|e)0%80%a|bg%q)f|%3(?:2(?:%(?:%6|4)6|F)|5%%63)|u(?:221[56]|002f|EFC8|F025)|1u|5c)|0x(?:2f|5c)|\\/|\\x5c)",
                options: {
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "normalizePath"
          ]
        },
        {
          id: "crs-930-110",
          name: "Simple Path Traversal Attack (/../)",
          tags: {
            type: "lfi",
            crs_id: "930110",
            category: "attack_attempt",
            cwe: "22",
            capec: "1000/255/153/126",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                regex: "(?:(?:^|[\\x5c/])\\.{2,3}[\\x5c/]|[\\x5c/]\\.{2,3}(?:[\\x5c/]|$))",
                options: {
                  case_sensitive: true,
                  min_length: 3
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-930-120",
          name: "OS File Access Attempt",
          tags: {
            type: "lfi",
            crs_id: "930120",
            category: "attack_attempt",
            cwe: "22",
            capec: "1000/255/153/126",
            confidence: "1"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                list: [
                  "/.htaccess",
                  "/.htdigest",
                  "/.htpasswd",
                  "/.addressbook",
                  "/.aptitude/config",
                  ".aws/config",
                  ".aws/credentials",
                  "/.bash_config",
                  "/.bash_history",
                  "/.bash_logout",
                  "/.bash_profile",
                  "/.bashrc",
                  ".cache/notify-osd.log",
                  ".config/odesk/odesk team.conf",
                  "/.cshrc",
                  "/.dockerignore",
                  ".drush/",
                  "/.eslintignore",
                  "/.fbcindex",
                  "/.forward",
                  "/.git",
                  ".git/",
                  "/.gitattributes",
                  "/.gitconfig",
                  ".gnupg/",
                  ".hplip/hplip.conf",
                  "/.ksh_history",
                  "/.lesshst",
                  ".lftp/",
                  "/.lhistory",
                  "/.lldb-history",
                  ".local/share/mc/",
                  "/.lynx_cookies",
                  "/.my.cnf",
                  "/.mysql_history",
                  "/.nano_history",
                  "/.node_repl_history",
                  "/.pearrc",
                  "/.pgpass",
                  "/.php_history",
                  "/.pinerc",
                  ".pki/",
                  "/.proclog",
                  "/.procmailrc",
                  "/.psql_history",
                  "/.python_history",
                  "/.rediscli_history",
                  "/.rhistory",
                  "/.rhosts",
                  "/.sh_history",
                  "/.sqlite_history",
                  ".ssh/authorized_keys",
                  ".ssh/config",
                  ".ssh/id_dsa",
                  ".ssh/id_dsa.pub",
                  ".ssh/id_rsa",
                  ".ssh/id_rsa.pub",
                  ".ssh/identity",
                  ".ssh/identity.pub",
                  ".ssh/id_ecdsa",
                  ".ssh/id_ecdsa.pub",
                  ".ssh/known_hosts",
                  ".subversion/auth",
                  ".subversion/config",
                  ".subversion/servers",
                  ".tconn/tconn.conf",
                  "/.tcshrc",
                  ".vidalia/vidalia.conf",
                  "/.viminfo",
                  "/.vimrc",
                  "/.www_acl",
                  "/.wwwacl",
                  "/.xauthority",
                  "/.zhistory",
                  "/.zshrc",
                  "/.zsh_history",
                  "/.nsconfig",
                  "data/elasticsearch",
                  "data/kafka",
                  "etc/ansible",
                  "etc/bind",
                  "etc/centos-release",
                  "etc/centos-release-upstream",
                  "etc/clam.d",
                  "etc/elasticsearch",
                  "etc/freshclam.conf",
                  "etc/gshadow",
                  "etc/gshadow-",
                  "etc/httpd",
                  "etc/kafka",
                  "etc/kibana",
                  "etc/logstash",
                  "etc/lvm",
                  "etc/mongod.conf",
                  "etc/my.cnf",
                  "etc/nuxeo.conf",
                  "etc/pki",
                  "etc/postfix",
                  "etc/scw-release",
                  "etc/subgid",
                  "etc/subgid-",
                  "etc/sudoers.d",
                  "etc/sysconfig",
                  "etc/system-release-cpe",
                  "opt/nuxeo",
                  "opt/tomcat",
                  "tmp/kafka-logs",
                  "usr/lib/rpm/rpm.log",
                  "var/data/elasticsearch",
                  "var/lib/elasticsearch",
                  "etc/.java",
                  "etc/acpi",
                  "etc/alsa",
                  "etc/alternatives",
                  "etc/apache2",
                  "etc/apm",
                  "etc/apparmor",
                  "etc/apparmor.d",
                  "etc/apport",
                  "etc/apt",
                  "etc/asciidoc",
                  "etc/avahi",
                  "etc/bash_completion.d",
                  "etc/binfmt.d",
                  "etc/bluetooth",
                  "etc/bonobo-activation",
                  "etc/brltty",
                  "etc/ca-certificates",
                  "etc/calendar",
                  "etc/chatscripts",
                  "etc/chromium-browser",
                  "etc/clamav",
                  "etc/cni",
                  "etc/console-setup",
                  "etc/coraza-waf",
                  "etc/cracklib",
                  "etc/cron.d",
                  "etc/cron.daily",
                  "etc/cron.hourly",
                  "etc/cron.monthly",
                  "etc/cron.weekly",
                  "etc/cups",
                  "etc/cups.save",
                  "etc/cupshelpers",
                  "etc/dbus-1",
                  "etc/dconf",
                  "etc/default",
                  "etc/depmod.d",
                  "etc/dhcp",
                  "etc/dictionaries-common",
                  "etc/dkms",
                  "etc/dnsmasq.d",
                  "etc/dockeretc/dpkg",
                  "etc/emacs",
                  "etc/environment.d",
                  "etc/fail2ban",
                  "etc/firebird",
                  "etc/firefox",
                  "etc/fonts",
                  "etc/fwupd",
                  "etc/gconf",
                  "etc/gdb",
                  "etc/gdm3",
                  "etc/geoclue",
                  "etc/ghostscript",
                  "etc/gimp",
                  "etc/glvnd",
                  "etc/gnome",
                  "etc/gnome-vfs-2.0",
                  "etc/gnucash",
                  "etc/gnustep",
                  "etc/groff",
                  "etc/grub.d",
                  "etc/gss",
                  "etc/gtk-2.0",
                  "etc/gtk-3.0",
                  "etc/hp",
                  "etc/ifplugd",
                  "etc/imagemagick-6",
                  "etc/init",
                  "etc/init.d",
                  "etc/initramfs-tools",
                  "etc/insserv.conf.d",
                  "etc/iproute2",
                  "etc/iptables",
                  "etc/java",
                  "etc/java-11-openjdk",
                  "etc/java-17-oracle",
                  "etc/java-8-openjdk",
                  "etc/kernel",
                  "etc/ld.so.conf.d",
                  "etc/ldap",
                  "etc/libblockdev",
                  "etc/libibverbs.d",
                  "etc/libnl-3",
                  "etc/libpaper.d",
                  "etc/libreoffice",
                  "etc/lighttpd",
                  "etc/logcheck",
                  "etc/logrotate.d",
                  "etc/lynx",
                  "etc/mail",
                  "etc/mc",
                  "etc/menu",
                  "etc/menu-methods",
                  "etc/modprobe.d",
                  "etc/modsecurity",
                  "etc/modules-load.d",
                  "etc/monit",
                  "etc/mono",
                  "etc/mplayer",
                  "etc/mpv",
                  "etc/muttrc.d",
                  "etc/mysql",
                  "etc/netplan",
                  "etc/network",
                  "etc/networkd-dispatcher",
                  "etc/networkmanager",
                  "etc/newt",
                  "etc/nghttpx",
                  "etc/nikto",
                  "etc/odbcdatasources",
                  "etc/openal",
                  "etc/openmpi",
                  "etc/opt",
                  "etc/osync",
                  "etc/packagekit",
                  "etc/pam.d",
                  "etc/pcmcia",
                  "etc/perl",
                  "etc/php",
                  "etc/pki",
                  "etc/pm",
                  "etc/polkit-1",
                  "etc/postfix",
                  "etc/ppp",
                  "etc/profile.d",
                  "etc/proftpd",
                  "etc/pulse",
                  "etc/python",
                  "etc/rc0.d",
                  "etc/rc1.d",
                  "etc/rc2.d",
                  "etc/rc3.d",
                  "etc/rc4.d",
                  "etc/rc5.d",
                  "etc/rc6.d",
                  "etc/rcs.d",
                  "etc/resolvconf",
                  "etc/rsyslog.d",
                  "etc/samba",
                  "etc/sane.d",
                  "etc/security",
                  "etc/selinux",
                  "etc/sensors.d",
                  "etc/sgml",
                  "etc/signon-ui",
                  "etc/skel",
                  "etc/snmp",
                  "etc/sound",
                  "etc/spamassassin",
                  "etc/speech-dispatcher",
                  "etc/ssh",
                  "etc/ssl",
                  "etc/sudoers.d",
                  "etc/sysctl.d",
                  "etc/sysstat",
                  "etc/systemd",
                  "etc/terminfo",
                  "etc/texmf",
                  "etc/thermald",
                  "etc/thnuclnt",
                  "etc/thunderbird",
                  "etc/timidity",
                  "etc/tmpfiles.d",
                  "etc/ubuntu-advantage",
                  "etc/udev",
                  "etc/udisks2",
                  "etc/ufw",
                  "etc/update-manager",
                  "etc/update-motd.d",
                  "etc/update-notifier",
                  "etc/upower",
                  "etc/urlview",
                  "etc/usb_modeswitch.d",
                  "etc/vim",
                  "etc/vmware",
                  "etc/vmware-installer",
                  "etc/vmware-vix",
                  "etc/vulkan",
                  "etc/w3m",
                  "etc/wireshark",
                  "etc/wpa_supplicant",
                  "etc/x11",
                  "etc/xdg",
                  "etc/xml",
                  "etc/redis.conf",
                  "etc/redis-sentinel.conf",
                  "etc/php.ini",
                  "bin/php.ini",
                  "etc/httpd/php.ini",
                  "usr/lib/php.ini",
                  "usr/lib/php/php.ini",
                  "usr/local/etc/php.ini",
                  "usr/local/lib/php.ini",
                  "usr/local/php/lib/php.ini",
                  "usr/local/php4/lib/php.ini",
                  "usr/local/php5/lib/php.ini",
                  "usr/local/apache/conf/php.ini",
                  "etc/php4.4/fcgi/php.ini",
                  "etc/php4/apache/php.ini",
                  "etc/php4/apache2/php.ini",
                  "etc/php5/apache/php.ini",
                  "etc/php5/apache2/php.ini",
                  "etc/php/php.ini",
                  "etc/php/php4/php.ini",
                  "etc/php/apache/php.ini",
                  "etc/php/apache2/php.ini",
                  "web/conf/php.ini",
                  "usr/local/zend/etc/php.ini",
                  "opt/xampp/etc/php.ini",
                  "var/local/www/conf/php.ini",
                  "etc/php/cgi/php.ini",
                  "etc/php4/cgi/php.ini",
                  "etc/php5/cgi/php.ini",
                  "home2/bin/stable/apache/php.ini",
                  "home/bin/stable/apache/php.ini",
                  "etc/httpd/conf.d/php.conf",
                  "php5/php.ini",
                  "php4/php.ini",
                  "php/php.ini",
                  "windows/php.ini",
                  "winnt/php.ini",
                  "apache/php/php.ini",
                  "xampp/apache/bin/php.ini",
                  "netserver/bin/stable/apache/php.ini",
                  "volumes/macintosh_hd1/usr/local/php/lib/php.ini",
                  "etc/mono/1.0/machine.config",
                  "etc/mono/2.0/machine.config",
                  "etc/mono/2.0/web.config",
                  "etc/mono/config",
                  "usr/local/cpanel/logs/stats_log",
                  "usr/local/cpanel/logs/access_log",
                  "usr/local/cpanel/logs/error_log",
                  "usr/local/cpanel/logs/license_log",
                  "usr/local/cpanel/logs/login_log",
                  "var/cpanel/cpanel.config",
                  "usr/local/psa/admin/logs/httpsd_access_log",
                  "usr/local/psa/admin/logs/panel.log",
                  "usr/local/psa/admin/conf/php.ini",
                  "etc/sw-cp-server/applications.d/plesk.conf",
                  "usr/local/psa/admin/conf/site_isolation_settings.ini",
                  "usr/local/sb/config",
                  "etc/sw-cp-server/applications.d/00-sso-cpserver.conf",
                  "etc/sso/sso_config.ini",
                  "etc/mysql/conf.d/old_passwords.cnf",
                  "var/mysql.log",
                  "var/mysql-bin.index",
                  "var/data/mysql-bin.index",
                  "program files/mysql/mysql server 5.0/data/{host}.err",
                  "program files/mysql/mysql server 5.0/data/mysql.log",
                  "program files/mysql/mysql server 5.0/data/mysql.err",
                  "program files/mysql/mysql server 5.0/data/mysql-bin.log",
                  "program files/mysql/mysql server 5.0/data/mysql-bin.index",
                  "program files/mysql/data/{host}.err",
                  "program files/mysql/data/mysql.log",
                  "program files/mysql/data/mysql.err",
                  "program files/mysql/data/mysql-bin.log",
                  "program files/mysql/data/mysql-bin.index",
                  "mysql/data/{host}.err",
                  "mysql/data/mysql.log",
                  "mysql/data/mysql.err",
                  "mysql/data/mysql-bin.log",
                  "mysql/data/mysql-bin.index",
                  "usr/local/mysql/data/mysql.log",
                  "usr/local/mysql/data/mysql.err",
                  "usr/local/mysql/data/mysql-bin.log",
                  "usr/local/mysql/data/mysql-slow.log",
                  "usr/local/mysql/data/mysqlderror.log",
                  "usr/local/mysql/data/{host}.err",
                  "usr/local/mysql/data/mysql-bin.index",
                  "var/lib/mysql/my.cnf",
                  "etc/mysql/my.cnf",
                  "etc/my.cnf",
                  "program files/mysql/mysql server 5.0/my.ini",
                  "program files/mysql/mysql server 5.0/my.cnf",
                  "program files/mysql/my.ini",
                  "program files/mysql/my.cnf",
                  "mysql/my.ini",
                  "mysql/my.cnf",
                  "mysql/bin/my.ini",
                  "var/postgresql/log/postgresql.log",
                  "usr/internet/pgsql/data/postmaster.log",
                  "usr/local/pgsql/data/postgresql.log",
                  "usr/local/pgsql/data/pg_log",
                  "postgresql/log/pgadmin.log",
                  "var/lib/pgsql/data/postgresql.conf",
                  "var/postgresql/db/postgresql.conf",
                  "var/nm2/postgresql.conf",
                  "usr/local/pgsql/data/postgresql.conf",
                  "usr/local/pgsql/data/pg_hba.conf",
                  "usr/internet/pgsql/data/pg_hba.conf",
                  "usr/local/pgsql/data/passwd",
                  "usr/local/pgsql/bin/pg_passwd",
                  "etc/postgresql/postgresql.conf",
                  "etc/postgresql/pg_hba.conf",
                  "home/postgres/data/postgresql.conf",
                  "home/postgres/data/pg_version",
                  "home/postgres/data/pg_ident.conf",
                  "home/postgres/data/pg_hba.conf",
                  "program files/postgresql/8.3/data/pg_hba.conf",
                  "program files/postgresql/8.3/data/pg_ident.conf",
                  "program files/postgresql/8.3/data/postgresql.conf",
                  "program files/postgresql/8.4/data/pg_hba.conf",
                  "program files/postgresql/8.4/data/pg_ident.conf",
                  "program files/postgresql/8.4/data/postgresql.conf",
                  "program files/postgresql/9.0/data/pg_hba.conf",
                  "program files/postgresql/9.0/data/pg_ident.conf",
                  "program files/postgresql/9.0/data/postgresql.conf",
                  "program files/postgresql/9.1/data/pg_hba.conf",
                  "program files/postgresql/9.1/data/pg_ident.conf",
                  "program files/postgresql/9.1/data/postgresql.conf",
                  "wamp/logs/access.log",
                  "wamp/logs/apache_error.log",
                  "wamp/logs/genquery.log",
                  "wamp/logs/mysql.log",
                  "wamp/logs/slowquery.log",
                  "wamp/bin/apache/apache2.2.22/logs/access.log",
                  "wamp/bin/apache/apache2.2.22/logs/error.log",
                  "wamp/bin/apache/apache2.2.21/logs/access.log",
                  "wamp/bin/apache/apache2.2.21/logs/error.log",
                  "wamp/bin/mysql/mysql5.5.24/data/mysql-bin.index",
                  "wamp/bin/mysql/mysql5.5.16/data/mysql-bin.index",
                  "wamp/bin/apache/apache2.2.21/conf/httpd.conf",
                  "wamp/bin/apache/apache2.2.22/conf/httpd.conf",
                  "wamp/bin/apache/apache2.2.21/wampserver.conf",
                  "wamp/bin/apache/apache2.2.22/wampserver.conf",
                  "wamp/bin/apache/apache2.2.22/conf/wampserver.conf",
                  "wamp/bin/mysql/mysql5.5.24/my.ini",
                  "wamp/bin/mysql/mysql5.5.24/wampserver.conf",
                  "wamp/bin/mysql/mysql5.5.16/my.ini",
                  "wamp/bin/mysql/mysql5.5.16/wampserver.conf",
                  "wamp/bin/php/php5.3.8/php.ini",
                  "wamp/bin/php/php5.4.3/php.ini",
                  "xampp/apache/logs/access.log",
                  "xampp/apache/logs/error.log",
                  "xampp/mysql/data/mysql-bin.index",
                  "xampp/mysql/data/mysql.err",
                  "xampp/mysql/data/{host}.err",
                  "xampp/sendmail/sendmail.log",
                  "xampp/apache/conf/httpd.conf",
                  "xampp/filezillaftp/filezilla server.xml",
                  "xampp/mercurymail/mercury.ini",
                  "xampp/php/php.ini",
                  "xampp/phpmyadmin/config.inc.php",
                  "xampp/sendmail/sendmail.ini",
                  "xampp/webalizer/webalizer.conf",
                  "opt/lampp/etc/httpd.conf",
                  "xampp/htdocs/aca.txt",
                  "xampp/htdocs/admin.php",
                  "xampp/htdocs/leer.txt",
                  "usr/local/apache/logs/audit_log",
                  "usr/local/apache2/logs/audit_log",
                  "logs/security_debug_log",
                  "logs/security_log",
                  "usr/local/apache/conf/modsec.conf",
                  "usr/local/apache2/conf/modsec.conf",
                  "winnt/system32/logfiles/msftpsvc",
                  "winnt/system32/logfiles/msftpsvc1",
                  "winnt/system32/logfiles/msftpsvc2",
                  "windows/system32/logfiles/msftpsvc",
                  "windows/system32/logfiles/msftpsvc1",
                  "windows/system32/logfiles/msftpsvc2",
                  "etc/logrotate.d/proftpd",
                  "www/logs/proftpd.system.log",
                  "etc/pam.d/proftpd",
                  "etc/proftp.conf",
                  "etc/protpd/proftpd.conf",
                  "etc/vhcs2/proftpd/proftpd.conf",
                  "etc/proftpd/modules.conf",
                  "etc/vsftpd.chroot_list",
                  "etc/logrotate.d/vsftpd.log",
                  "etc/vsftpd/vsftpd.conf",
                  "etc/vsftpd.conf",
                  "etc/chrootusers",
                  "var/adm/log/xferlog",
                  "etc/wu-ftpd/ftpaccess",
                  "etc/wu-ftpd/ftphosts",
                  "etc/wu-ftpd/ftpusers",
                  "logs/pure-ftpd.log",
                  "usr/sbin/pure-config.pl",
                  "usr/etc/pure-ftpd.conf",
                  "etc/pure-ftpd/pure-ftpd.conf",
                  "usr/local/etc/pure-ftpd.conf",
                  "usr/local/etc/pureftpd.pdb",
                  "usr/local/pureftpd/etc/pureftpd.pdb",
                  "usr/local/pureftpd/sbin/pure-config.pl",
                  "usr/local/pureftpd/etc/pure-ftpd.conf",
                  "etc/pure-ftpd.conf",
                  "etc/pure-ftpd/pure-ftpd.pdb",
                  "etc/pureftpd.pdb",
                  "etc/pureftpd.passwd",
                  "etc/pure-ftpd/pureftpd.pdb",
                  "usr/ports/ftp/pure-ftpd/pure-ftpd.conf",
                  "usr/ports/ftp/pure-ftpd/pureftpd.pdb",
                  "usr/ports/ftp/pure-ftpd/pureftpd.passwd",
                  "usr/ports/net/pure-ftpd/pure-ftpd.conf",
                  "usr/ports/net/pure-ftpd/pureftpd.pdb",
                  "usr/ports/net/pure-ftpd/pureftpd.passwd",
                  "usr/pkgsrc/net/pureftpd/pure-ftpd.conf",
                  "usr/pkgsrc/net/pureftpd/pureftpd.pdb",
                  "usr/pkgsrc/net/pureftpd/pureftpd.passwd",
                  "usr/ports/contrib/pure-ftpd/pure-ftpd.conf",
                  "usr/ports/contrib/pure-ftpd/pureftpd.pdb",
                  "usr/ports/contrib/pure-ftpd/pureftpd.passwd",
                  "usr/sbin/mudlogd",
                  "etc/muddleftpd/mudlog",
                  "etc/muddleftpd.com",
                  "etc/muddleftpd/mudlogd.conf",
                  "etc/muddleftpd/muddleftpd.conf",
                  "usr/sbin/mudpasswd",
                  "etc/muddleftpd/muddleftpd.passwd",
                  "etc/muddleftpd/passwd",
                  "etc/logrotate.d/ftp",
                  "etc/ftpchroot",
                  "etc/ftphosts",
                  "etc/ftpusers",
                  "winnt/system32/logfiles/smtpsvc",
                  "winnt/system32/logfiles/smtpsvc1",
                  "winnt/system32/logfiles/smtpsvc2",
                  "winnt/system32/logfiles/smtpsvc3",
                  "winnt/system32/logfiles/smtpsvc4",
                  "winnt/system32/logfiles/smtpsvc5",
                  "windows/system32/logfiles/smtpsvc",
                  "windows/system32/logfiles/smtpsvc1",
                  "windows/system32/logfiles/smtpsvc2",
                  "windows/system32/logfiles/smtpsvc3",
                  "windows/system32/logfiles/smtpsvc4",
                  "windows/system32/logfiles/smtpsvc5",
                  "etc/osxhttpd/osxhttpd.conf",
                  "system/library/webobjects/adaptors/apache2.2/apache.conf",
                  "etc/apache2/sites-available/default",
                  "etc/apache2/sites-available/default-ssl",
                  "etc/apache2/sites-enabled/000-default",
                  "etc/apache2/sites-enabled/default",
                  "etc/apache2/apache2.conf",
                  "etc/apache2/ports.conf",
                  "usr/local/etc/apache/httpd.conf",
                  "usr/pkg/etc/httpd/httpd.conf",
                  "usr/pkg/etc/httpd/httpd-default.conf",
                  "usr/pkg/etc/httpd/httpd-vhosts.conf",
                  "etc/httpd/mod_php.conf",
                  "etc/httpd/extra/httpd-ssl.conf",
                  "etc/rc.d/rc.httpd",
                  "usr/local/apache/conf/httpd.conf.default",
                  "usr/local/apache/conf/access.conf",
                  "usr/local/apache22/conf/httpd.conf",
                  "usr/local/apache22/httpd.conf",
                  "usr/local/etc/apache22/conf/httpd.conf",
                  "usr/local/apps/apache22/conf/httpd.conf",
                  "etc/apache22/conf/httpd.conf",
                  "etc/apache22/httpd.conf",
                  "opt/apache22/conf/httpd.conf",
                  "usr/local/etc/apache2/vhosts.conf",
                  "usr/local/apache/conf/vhosts.conf",
                  "usr/local/apache2/conf/vhosts.conf",
                  "usr/local/apache/conf/vhosts-custom.conf",
                  "usr/local/apache2/conf/vhosts-custom.conf",
                  "etc/apache/default-server.conf",
                  "etc/apache2/default-server.conf",
                  "usr/local/apache2/conf/extra/httpd-ssl.conf",
                  "usr/local/apache2/conf/ssl.conf",
                  "etc/httpd/conf.d",
                  "usr/local/etc/apache22/httpd.conf",
                  "usr/local/etc/apache2/httpd.conf",
                  "etc/apache2/httpd2.conf",
                  "etc/apache2/ssl-global.conf",
                  "etc/apache2/vhosts.d/00_default_vhost.conf",
                  "apache/conf/httpd.conf",
                  "etc/apache/httpd.conf",
                  "etc/httpd/conf",
                  "http/httpd.conf",
                  "usr/local/apache1.3/conf/httpd.conf",
                  "usr/local/etc/httpd/conf",
                  "var/apache/conf/httpd.conf",
                  "var/www/conf",
                  "www/apache/conf/httpd.conf",
                  "www/conf/httpd.conf",
                  "etc/init.d",
                  "etc/apache/access.conf",
                  "etc/rc.conf",
                  "www/logs/freebsddiary-error.log",
                  "www/logs/freebsddiary-access_log",
                  "library/webserver/documents/index.html",
                  "library/webserver/documents/index.htm",
                  "library/webserver/documents/default.html",
                  "library/webserver/documents/default.htm",
                  "library/webserver/documents/index.php",
                  "library/webserver/documents/default.php",
                  "usr/local/etc/webmin/miniserv.conf",
                  "etc/webmin/miniserv.conf",
                  "usr/local/etc/webmin/miniserv.users",
                  "etc/webmin/miniserv.users",
                  "winnt/system32/logfiles/w3svc/inetsvn1.log",
                  "winnt/system32/logfiles/w3svc1/inetsvn1.log",
                  "winnt/system32/logfiles/w3svc2/inetsvn1.log",
                  "winnt/system32/logfiles/w3svc3/inetsvn1.log",
                  "windows/system32/logfiles/w3svc/inetsvn1.log",
                  "windows/system32/logfiles/w3svc1/inetsvn1.log",
                  "windows/system32/logfiles/w3svc2/inetsvn1.log",
                  "windows/system32/logfiles/w3svc3/inetsvn1.log",
                  "apache/logs/error.log",
                  "apache/logs/access.log",
                  "apache2/logs/error.log",
                  "apache2/logs/access.log",
                  "logs/error.log",
                  "logs/access.log",
                  "etc/httpd/logs/access_log",
                  "etc/httpd/logs/access.log",
                  "etc/httpd/logs/error_log",
                  "etc/httpd/logs/error.log",
                  "usr/local/apache/logs/access_log",
                  "usr/local/apache/logs/access.log",
                  "usr/local/apache/logs/error_log",
                  "usr/local/apache/logs/error.log",
                  "usr/local/apache2/logs/access_log",
                  "usr/local/apache2/logs/access.log",
                  "usr/local/apache2/logs/error_log",
                  "usr/local/apache2/logs/error.log",
                  "var/www/logs/access_log",
                  "var/www/logs/access.log",
                  "var/www/logs/error_log",
                  "var/www/logs/error.log",
                  "opt/lampp/logs/access_log",
                  "opt/lampp/logs/error_log",
                  "opt/xampp/logs/access_log",
                  "opt/xampp/logs/error_log",
                  "opt/lampp/logs/access.log",
                  "opt/lampp/logs/error.log",
                  "opt/xampp/logs/access.log",
                  "opt/xampp/logs/error.log",
                  "program files/apache group/apache/logs/access.log",
                  "program files/apache group/apache/logs/error.log",
                  "program files/apache software foundation/apache2.2/logs/error.log",
                  "program files/apache software foundation/apache2.2/logs/access.log",
                  "opt/apache/apache.conf",
                  "opt/apache/conf/apache.conf",
                  "opt/apache2/apache.conf",
                  "opt/apache2/conf/apache.conf",
                  "opt/httpd/apache.conf",
                  "opt/httpd/conf/apache.conf",
                  "etc/httpd/apache.conf",
                  "etc/apache2/apache.conf",
                  "etc/httpd/conf/apache.conf",
                  "usr/local/apache/apache.conf",
                  "usr/local/apache/conf/apache.conf",
                  "usr/local/apache2/apache.conf",
                  "usr/local/apache2/conf/apache.conf",
                  "usr/local/php/apache.conf.php",
                  "usr/local/php4/apache.conf.php",
                  "usr/local/php5/apache.conf.php",
                  "usr/local/php/apache.conf",
                  "usr/local/php4/apache.conf",
                  "usr/local/php5/apache.conf",
                  "private/etc/httpd/apache.conf",
                  "opt/apache/apache2.conf",
                  "opt/apache/conf/apache2.conf",
                  "opt/apache2/apache2.conf",
                  "opt/apache2/conf/apache2.conf",
                  "opt/httpd/apache2.conf",
                  "opt/httpd/conf/apache2.conf",
                  "etc/httpd/apache2.conf",
                  "etc/httpd/conf/apache2.conf",
                  "usr/local/apache/apache2.conf",
                  "usr/local/apache/conf/apache2.conf",
                  "usr/local/apache2/apache2.conf",
                  "usr/local/apache2/conf/apache2.conf",
                  "usr/local/php/apache2.conf.php",
                  "usr/local/php4/apache2.conf.php",
                  "usr/local/php5/apache2.conf.php",
                  "usr/local/php/apache2.conf",
                  "usr/local/php4/apache2.conf",
                  "usr/local/php5/apache2.conf",
                  "private/etc/httpd/apache2.conf",
                  "usr/local/apache/conf/httpd.conf",
                  "usr/local/apache2/conf/httpd.conf",
                  "etc/httpd/conf/httpd.conf",
                  "etc/apache/apache.conf",
                  "etc/apache/conf/httpd.conf",
                  "etc/apache2/httpd.conf",
                  "usr/apache2/conf/httpd.conf",
                  "usr/apache/conf/httpd.conf",
                  "usr/local/etc/apache/conf/httpd.conf",
                  "usr/local/apache/httpd.conf",
                  "usr/local/apache2/httpd.conf",
                  "usr/local/httpd/conf/httpd.conf",
                  "usr/local/etc/apache2/conf/httpd.conf",
                  "usr/local/etc/httpd/conf/httpd.conf",
                  "usr/local/apps/apache2/conf/httpd.conf",
                  "usr/local/apps/apache/conf/httpd.conf",
                  "usr/local/php/httpd.conf.php",
                  "usr/local/php4/httpd.conf.php",
                  "usr/local/php5/httpd.conf.php",
                  "usr/local/php/httpd.conf",
                  "usr/local/php4/httpd.conf",
                  "usr/local/php5/httpd.conf",
                  "etc/apache2/conf/httpd.conf",
                  "etc/http/conf/httpd.conf",
                  "etc/httpd/httpd.conf",
                  "etc/http/httpd.conf",
                  "etc/httpd.conf",
                  "opt/apache/conf/httpd.conf",
                  "opt/apache2/conf/httpd.conf",
                  "var/www/conf/httpd.conf",
                  "private/etc/httpd/httpd.conf",
                  "private/etc/httpd/httpd.conf.default",
                  "etc/apache2/vhosts.d/default_vhost.include",
                  "etc/apache2/conf.d/charset",
                  "etc/apache2/conf.d/security",
                  "etc/apache2/envvars",
                  "etc/apache2/mods-available/autoindex.conf",
                  "etc/apache2/mods-available/deflate.conf",
                  "etc/apache2/mods-available/dir.conf",
                  "etc/apache2/mods-available/mem_cache.conf",
                  "etc/apache2/mods-available/mime.conf",
                  "etc/apache2/mods-available/proxy.conf",
                  "etc/apache2/mods-available/setenvif.conf",
                  "etc/apache2/mods-available/ssl.conf",
                  "etc/apache2/mods-enabled/alias.conf",
                  "etc/apache2/mods-enabled/deflate.conf",
                  "etc/apache2/mods-enabled/dir.conf",
                  "etc/apache2/mods-enabled/mime.conf",
                  "etc/apache2/mods-enabled/negotiation.conf",
                  "etc/apache2/mods-enabled/php5.conf",
                  "etc/apache2/mods-enabled/status.conf",
                  "program files/apache group/apache/conf/httpd.conf",
                  "program files/apache group/apache2/conf/httpd.conf",
                  "program files/xampp/apache/conf/apache.conf",
                  "program files/xampp/apache/conf/apache2.conf",
                  "program files/xampp/apache/conf/httpd.conf",
                  "program files/apache group/apache/apache.conf",
                  "program files/apache group/apache/conf/apache.conf",
                  "program files/apache group/apache2/conf/apache.conf",
                  "program files/apache group/apache/apache2.conf",
                  "program files/apache group/apache/conf/apache2.conf",
                  "program files/apache group/apache2/conf/apache2.conf",
                  "program files/apache software foundation/apache2.2/conf/httpd.conf",
                  "volumes/macintosh_hd1/opt/httpd/conf/httpd.conf",
                  "volumes/macintosh_hd1/opt/apache/conf/httpd.conf",
                  "volumes/macintosh_hd1/opt/apache2/conf/httpd.conf",
                  "volumes/macintosh_hd1/usr/local/php/httpd.conf.php",
                  "volumes/macintosh_hd1/usr/local/php4/httpd.conf.php",
                  "volumes/macintosh_hd1/usr/local/php5/httpd.conf.php",
                  "volumes/webbackup/opt/apache2/conf/httpd.conf",
                  "volumes/webbackup/private/etc/httpd/httpd.conf",
                  "volumes/webbackup/private/etc/httpd/httpd.conf.default",
                  "usr/local/etc/apache/vhosts.conf",
                  "usr/local/jakarta/tomcat/conf/jakarta.conf",
                  "usr/local/jakarta/tomcat/conf/server.xml",
                  "usr/local/jakarta/tomcat/conf/context.xml",
                  "usr/local/jakarta/tomcat/conf/workers.properties",
                  "usr/local/jakarta/tomcat/conf/logging.properties",
                  "usr/local/jakarta/dist/tomcat/conf/jakarta.conf",
                  "usr/local/jakarta/dist/tomcat/conf/server.xml",
                  "usr/local/jakarta/dist/tomcat/conf/context.xml",
                  "usr/local/jakarta/dist/tomcat/conf/workers.properties",
                  "usr/local/jakarta/dist/tomcat/conf/logging.properties",
                  "usr/share/tomcat6/conf/server.xml",
                  "usr/share/tomcat6/conf/context.xml",
                  "usr/share/tomcat6/conf/workers.properties",
                  "usr/share/tomcat6/conf/logging.properties",
                  "var/cpanel/tomcat.options",
                  "usr/local/jakarta/tomcat/logs/catalina.out",
                  "usr/local/jakarta/tomcat/logs/catalina.err",
                  "opt/tomcat/logs/catalina.out",
                  "opt/tomcat/logs/catalina.err",
                  "usr/share/logs/catalina.out",
                  "usr/share/logs/catalina.err",
                  "usr/share/tomcat/logs/catalina.out",
                  "usr/share/tomcat/logs/catalina.err",
                  "usr/share/tomcat6/logs/catalina.out",
                  "usr/share/tomcat6/logs/catalina.err",
                  "usr/local/apache/logs/mod_jk.log",
                  "usr/local/jakarta/tomcat/logs/mod_jk.log",
                  "usr/local/jakarta/dist/tomcat/logs/mod_jk.log",
                  "opt/[jboss]/server/default/conf/jboss-minimal.xml",
                  "opt/[jboss]/server/default/conf/jboss-service.xml",
                  "opt/[jboss]/server/default/conf/jndi.properties",
                  "opt/[jboss]/server/default/conf/log4j.xml",
                  "opt/[jboss]/server/default/conf/login-config.xml",
                  "opt/[jboss]/server/default/conf/standardjaws.xml",
                  "opt/[jboss]/server/default/conf/standardjboss.xml",
                  "opt/[jboss]/server/default/conf/server.log.properties",
                  "opt/[jboss]/server/default/deploy/jboss-logging.xml",
                  "usr/local/[jboss]/server/default/conf/jboss-minimal.xml",
                  "usr/local/[jboss]/server/default/conf/jboss-service.xml",
                  "usr/local/[jboss]/server/default/conf/jndi.properties",
                  "usr/local/[jboss]/server/default/conf/log4j.xml",
                  "usr/local/[jboss]/server/default/conf/login-config.xml",
                  "usr/local/[jboss]/server/default/conf/standardjaws.xml",
                  "usr/local/[jboss]/server/default/conf/standardjboss.xml",
                  "usr/local/[jboss]/server/default/conf/server.log.properties",
                  "usr/local/[jboss]/server/default/deploy/jboss-logging.xml",
                  "private/tmp/[jboss]/server/default/conf/jboss-minimal.xml",
                  "private/tmp/[jboss]/server/default/conf/jboss-service.xml",
                  "private/tmp/[jboss]/server/default/conf/jndi.properties",
                  "private/tmp/[jboss]/server/default/conf/log4j.xml",
                  "private/tmp/[jboss]/server/default/conf/login-config.xml",
                  "private/tmp/[jboss]/server/default/conf/standardjaws.xml",
                  "private/tmp/[jboss]/server/default/conf/standardjboss.xml",
                  "private/tmp/[jboss]/server/default/conf/server.log.properties",
                  "private/tmp/[jboss]/server/default/deploy/jboss-logging.xml",
                  "tmp/[jboss]/server/default/conf/jboss-minimal.xml",
                  "tmp/[jboss]/server/default/conf/jboss-service.xml",
                  "tmp/[jboss]/server/default/conf/jndi.properties",
                  "tmp/[jboss]/server/default/conf/log4j.xml",
                  "tmp/[jboss]/server/default/conf/login-config.xml",
                  "tmp/[jboss]/server/default/conf/standardjaws.xml",
                  "tmp/[jboss]/server/default/conf/standardjboss.xml",
                  "tmp/[jboss]/server/default/conf/server.log.properties",
                  "tmp/[jboss]/server/default/deploy/jboss-logging.xml",
                  "program files/[jboss]/server/default/conf/jboss-minimal.xml",
                  "program files/[jboss]/server/default/conf/jboss-service.xml",
                  "program files/[jboss]/server/default/conf/jndi.properties",
                  "program files/[jboss]/server/default/conf/log4j.xml",
                  "program files/[jboss]/server/default/conf/login-config.xml",
                  "program files/[jboss]/server/default/conf/standardjaws.xml",
                  "program files/[jboss]/server/default/conf/standardjboss.xml",
                  "program files/[jboss]/server/default/conf/server.log.properties",
                  "program files/[jboss]/server/default/deploy/jboss-logging.xml",
                  "[jboss]/server/default/conf/jboss-minimal.xml",
                  "[jboss]/server/default/conf/jboss-service.xml",
                  "[jboss]/server/default/conf/jndi.properties",
                  "[jboss]/server/default/conf/log4j.xml",
                  "[jboss]/server/default/conf/login-config.xml",
                  "[jboss]/server/default/conf/standardjaws.xml",
                  "[jboss]/server/default/conf/standardjboss.xml",
                  "[jboss]/server/default/conf/server.log.properties",
                  "[jboss]/server/default/deploy/jboss-logging.xml",
                  "opt/[jboss]/server/default/log/server.log",
                  "opt/[jboss]/server/default/log/boot.log",
                  "usr/local/[jboss]/server/default/log/server.log",
                  "usr/local/[jboss]/server/default/log/boot.log",
                  "private/tmp/[jboss]/server/default/log/server.log",
                  "private/tmp/[jboss]/server/default/log/boot.log",
                  "tmp/[jboss]/server/default/log/server.log",
                  "tmp/[jboss]/server/default/log/boot.log",
                  "program files/[jboss]/server/default/log/server.log",
                  "program files/[jboss]/server/default/log/boot.log",
                  "[jboss]/server/default/log/server.log",
                  "[jboss]/server/default/log/boot.log",
                  "var/lighttpd.log",
                  "var/logs/access.log",
                  "usr/local/apache2/logs/lighttpd.error.log",
                  "usr/local/apache2/logs/lighttpd.log",
                  "usr/local/apache/logs/lighttpd.error.log",
                  "usr/local/apache/logs/lighttpd.log",
                  "usr/local/lighttpd/log/lighttpd.error.log",
                  "usr/local/lighttpd/log/access.log",
                  "usr/home/user/var/log/lighttpd.error.log",
                  "usr/home/user/var/log/apache.log",
                  "home/user/lighttpd/lighttpd.conf",
                  "usr/home/user/lighttpd/lighttpd.conf",
                  "etc/lighttpd/lighthttpd.conf",
                  "usr/local/etc/lighttpd.conf",
                  "usr/local/lighttpd/conf/lighttpd.conf",
                  "usr/local/etc/lighttpd.conf.new",
                  "var/www/.lighttpdpassword",
                  "logs/access_log",
                  "logs/error_log",
                  "etc/nginx/nginx.conf",
                  "usr/local/etc/nginx/nginx.conf",
                  "usr/local/nginx/conf/nginx.conf",
                  "usr/local/zeus/web/global.cfg",
                  "usr/local/zeus/web/log/errors",
                  "opt/lsws/conf/httpd_conf.xml",
                  "usr/local/lsws/conf/httpd_conf.xml",
                  "opt/lsws/logs/error.log",
                  "opt/lsws/logs/access.log",
                  "usr/local/lsws/logs/error.log",
                  "usr/local/logs/access.log",
                  "usr/local/samba/lib/log.user",
                  "usr/local/logs/samba.log",
                  "etc/samba/netlogon",
                  "etc/smbpasswd",
                  "etc/smb.conf",
                  "etc/samba/dhcp.conf",
                  "etc/samba/smb.conf",
                  "etc/samba/samba.conf",
                  "etc/samba/smb.conf.user",
                  "etc/samba/smbpasswd",
                  "etc/samba/smbusers",
                  "etc/samba/private/smbpasswd",
                  "usr/local/etc/smb.conf",
                  "usr/local/samba/lib/smb.conf.user",
                  "etc/dhcp3/dhclient.conf",
                  "etc/dhcp3/dhcpd.conf",
                  "etc/dhcp/dhclient.conf",
                  "program files/vidalia bundle/polipo/polipo.conf",
                  "etc/tor/tor-tsocks.conf",
                  "etc/stunnel/stunnel.conf",
                  "etc/tsocks.conf",
                  "etc/tinyproxy/tinyproxy.conf",
                  "etc/miredo-server.conf",
                  "etc/miredo.conf",
                  "etc/miredo/miredo-server.conf",
                  "etc/miredo/miredo.conf",
                  "etc/wicd/dhclient.conf.template.default",
                  "etc/wicd/manager-settings.conf",
                  "etc/wicd/wired-settings.conf",
                  "etc/wicd/wireless-settings.conf",
                  "etc/ipfw.rules",
                  "etc/ipfw.conf",
                  "etc/firewall.rules",
                  "winnt/system32/logfiles/firewall/pfirewall.log",
                  "winnt/system32/logfiles/firewall/pfirewall.log.old",
                  "windows/system32/logfiles/firewall/pfirewall.log",
                  "windows/system32/logfiles/firewall/pfirewall.log.old",
                  "etc/clamav/clamd.conf",
                  "etc/clamav/freshclam.conf",
                  "etc/x11/xorg.conf",
                  "etc/x11/xorg.conf-vesa",
                  "etc/x11/xorg.conf-vmware",
                  "etc/x11/xorg.conf.beforevmwaretoolsinstall",
                  "etc/x11/xorg.conf.orig",
                  "etc/bluetooth/input.conf",
                  "etc/bluetooth/main.conf",
                  "etc/bluetooth/network.conf",
                  "etc/bluetooth/rfcomm.conf",
                  "etc/bash_completion.d/debconf",
                  "root/.bash_logout",
                  "root/.bash_history",
                  "root/.bash_config",
                  "root/.bashrc",
                  "etc/bash.bashrc",
                  "var/adm/syslog",
                  "var/adm/sulog",
                  "var/adm/utmp",
                  "var/adm/utmpx",
                  "var/adm/wtmp",
                  "var/adm/wtmpx",
                  "var/adm/lastlog/username",
                  "usr/spool/lp/log",
                  "var/adm/lp/lpd-errs",
                  "usr/lib/cron/log",
                  "var/adm/loginlog",
                  "var/adm/pacct",
                  "var/adm/dtmp",
                  "var/adm/acct/sum/loginlog",
                  "var/adm/x0msgs",
                  "var/adm/crash/vmcore",
                  "var/adm/crash/unix",
                  "etc/newsyslog.conf",
                  "var/adm/qacct",
                  "var/adm/ras/errlog",
                  "var/adm/ras/bootlog",
                  "var/adm/cron/log",
                  "etc/utmp",
                  "etc/security/lastlog",
                  "etc/security/failedlogin",
                  "usr/spool/mqueue/syslog",
                  "var/adm/messages",
                  "var/adm/aculogs",
                  "var/adm/aculog",
                  "var/adm/vold.log",
                  "var/adm/log/asppp.log",
                  "var/lp/logs/lpsched",
                  "var/lp/logs/lpnet",
                  "var/lp/logs/requests",
                  "var/cron/log",
                  "var/saf/_log",
                  "var/saf/port/log",
                  "tmp/access.log",
                  "etc/sensors.conf",
                  "etc/sensors3.conf",
                  "etc/host.conf",
                  "etc/pam.conf",
                  "etc/resolv.conf",
                  "etc/apt/apt.conf",
                  "etc/inetd.conf",
                  "etc/syslog.conf",
                  "etc/sysctl.conf",
                  "etc/sysctl.d/10-console-messages.conf",
                  "etc/sysctl.d/10-network-security.conf",
                  "etc/sysctl.d/10-process-security.conf",
                  "etc/sysctl.d/wine.sysctl.conf",
                  "etc/security/access.conf",
                  "etc/security/group.conf",
                  "etc/security/limits.conf",
                  "etc/security/namespace.conf",
                  "etc/security/pam_env.conf",
                  "etc/security/sepermit.conf",
                  "etc/security/time.conf",
                  "etc/ssh/sshd_config",
                  "etc/adduser.conf",
                  "etc/deluser.conf",
                  "etc/avahi/avahi-daemon.conf",
                  "etc/ca-certificates.conf",
                  "etc/ca-certificates.conf.dpkg-old",
                  "etc/casper.conf",
                  "etc/chkrootkit.conf",
                  "etc/debconf.conf",
                  "etc/dns2tcpd.conf",
                  "etc/e2fsck.conf",
                  "etc/esound/esd.conf",
                  "etc/etter.conf",
                  "etc/fuse.conf",
                  "etc/foremost.conf",
                  "etc/hdparm.conf",
                  "etc/kernel-img.conf",
                  "etc/kernel-pkg.conf",
                  "etc/ld.so.conf",
                  "etc/ltrace.conf",
                  "etc/mail/sendmail.conf",
                  "etc/manpath.config",
                  "etc/kbd/config",
                  "etc/ldap/ldap.conf",
                  "etc/logrotate.conf",
                  "etc/mtools.conf",
                  "etc/smi.conf",
                  "etc/updatedb.conf",
                  "etc/pulse/client.conf",
                  "usr/share/adduser/adduser.conf",
                  "etc/hostname",
                  "etc/networks",
                  "etc/timezone",
                  "etc/modules",
                  "etc/passwd",
                  "etc/shadow",
                  "etc/fstab",
                  "etc/motd",
                  "etc/hosts",
                  "etc/group",
                  "etc/alias",
                  "etc/crontab",
                  "etc/crypttab",
                  "etc/exports",
                  "etc/mtab",
                  "etc/hosts.allow",
                  "etc/hosts.deny",
                  "etc/os-release",
                  "etc/password.master",
                  "etc/profile",
                  "etc/default/grub",
                  "etc/resolvconf/update-libc.d/sendmail",
                  "etc/inittab",
                  "etc/issue",
                  "etc/issue.net",
                  "etc/login.defs",
                  "etc/sudoers",
                  "etc/sysconfig/network-scripts/ifcfg-eth0",
                  "etc/redhat-release",
                  "etc/scw-release",
                  "etc/system-release-cpe",
                  "etc/debian_version",
                  "etc/fedora-release",
                  "etc/mandrake-release",
                  "etc/slackware-release",
                  "etc/suse-release",
                  "etc/security/group",
                  "etc/security/passwd",
                  "etc/security/user",
                  "etc/security/environ",
                  "etc/security/limits",
                  "etc/security/opasswd",
                  "boot/grub/grub.cfg",
                  "boot/grub/menu.lst",
                  "root/.ksh_history",
                  "root/.xauthority",
                  "usr/lib/security/mkuser.default",
                  "var/lib/squirrelmail/prefs/squirrelmail.log",
                  "etc/squirrelmail/apache.conf",
                  "etc/squirrelmail/config_local.php",
                  "etc/squirrelmail/default_pref",
                  "etc/squirrelmail/index.php",
                  "etc/squirrelmail/config_default.php",
                  "etc/squirrelmail/config.php",
                  "etc/squirrelmail/filters_setup.php",
                  "etc/squirrelmail/sqspell_config.php",
                  "etc/squirrelmail/config/config.php",
                  "etc/httpd/conf.d/squirrelmail.conf",
                  "usr/share/squirrelmail/config/config.php",
                  "private/etc/squirrelmail/config/config.php",
                  "srv/www/htdos/squirrelmail/config/config.php",
                  "var/www/squirrelmail/config/config.php",
                  "var/www/html/squirrelmail/config/config.php",
                  "var/www/html/squirrelmail-1.2.9/config/config.php",
                  "usr/share/squirrelmail/plugins/squirrel_logger/setup.php",
                  "usr/local/squirrelmail/www/readme",
                  "windows/system32/drivers/etc/hosts",
                  "windows/system32/drivers/etc/lmhosts.sam",
                  "windows/system32/drivers/etc/networks",
                  "windows/system32/drivers/etc/protocol",
                  "windows/system32/drivers/etc/services",
                  "/boot.ini",
                  "windows/debug/netsetup.log",
                  "windows/comsetup.log",
                  "windows/repair/setup.log",
                  "windows/setupact.log",
                  "windows/setupapi.log",
                  "windows/setuperr.log",
                  "windows/updspapi.log",
                  "windows/wmsetup.log",
                  "windows/windowsupdate.log",
                  "windows/odbc.ini",
                  "usr/local/psa/admin/htdocs/domains/databases/phpmyadmin/libraries/config.default.php",
                  "etc/apache2/conf.d/phpmyadmin.conf",
                  "etc/phpmyadmin/config.inc.php",
                  "etc/openldap/ldap.conf",
                  "etc/cups/acroread.conf",
                  "etc/cups/cupsd.conf",
                  "etc/cups/cupsd.conf.default",
                  "etc/cups/pdftops.conf",
                  "etc/cups/printers.conf",
                  "windows/system32/macromed/flash/flashinstall.log",
                  "windows/system32/macromed/flash/install.log",
                  "etc/cvs-cron.conf",
                  "etc/cvs-pserver.conf",
                  "etc/subversion/config",
                  "etc/modprobe.d/vmware-tools.conf",
                  "etc/updatedb.conf.beforevmwaretoolsinstall",
                  "etc/vmware-tools/config",
                  "etc/vmware-tools/tpvmlp.conf",
                  "etc/vmware-tools/vmware-tools-libraries.conf",
                  "var/log",
                  "var/log/sw-cp-server/error_log",
                  "var/log/sso/sso.log",
                  "var/log/dpkg.log",
                  "var/log/btmp",
                  "var/log/utmp",
                  "var/log/wtmp",
                  "var/log/mysql/mysql-bin.log",
                  "var/log/mysql/mysql-bin.index",
                  "var/log/mysql/data/mysql-bin.index",
                  "var/log/mysql.log",
                  "var/log/mysql.err",
                  "var/log/mysqlderror.log",
                  "var/log/mysql/mysql.log",
                  "var/log/mysql/mysql-slow.log",
                  "var/log/mysql-bin.index",
                  "var/log/data/mysql-bin.index",
                  "var/log/postgresql/postgresql.log",
                  "var/log/postgres/pg_backup.log",
                  "var/log/postgres/postgres.log",
                  "var/log/postgresql.log",
                  "var/log/pgsql/pgsql.log",
                  "var/log/postgresql/postgresql-8.1-main.log",
                  "var/log/postgresql/postgresql-8.3-main.log",
                  "var/log/postgresql/postgresql-8.4-main.log",
                  "var/log/postgresql/postgresql-9.0-main.log",
                  "var/log/postgresql/postgresql-9.1-main.log",
                  "var/log/pgsql8.log",
                  "var/log/postgresql/postgres.log",
                  "var/log/pgsql_log",
                  "var/log/postgresql/main.log",
                  "var/log/cron",
                  "var/log/postgres.log",
                  "var/log/proftpd",
                  "var/log/proftpd/xferlog.legacy",
                  "var/log/proftpd.access_log",
                  "var/log/proftpd.xferlog",
                  "var/log/vsftpd.log",
                  "var/log/xferlog",
                  "var/log/pure-ftpd/pure-ftpd.log",
                  "var/log/pureftpd.log",
                  "var/log/muddleftpd",
                  "var/log/muddleftpd.conf",
                  "var/log/ftp-proxy/ftp-proxy.log",
                  "var/log/ftp-proxy",
                  "var/log/ftplog",
                  "var/log/exim_mainlog",
                  "var/log/exim/mainlog",
                  "var/log/maillog",
                  "var/log/exim_paniclog",
                  "var/log/exim/paniclog",
                  "var/log/exim/rejectlog",
                  "var/log/exim_rejectlog",
                  "var/log/webmin/miniserv.log",
                  "var/log/httpd/access_log",
                  "var/log/httpd/error_log",
                  "var/log/httpd/access.log",
                  "var/log/httpd/error.log",
                  "var/log/apache/access_log",
                  "var/log/apache/access.log",
                  "var/log/apache/error_log",
                  "var/log/apache/error.log",
                  "var/log/apache2/access_log",
                  "var/log/apache2/access.log",
                  "var/log/apache2/error_log",
                  "var/log/apache2/error.log",
                  "var/log/access_log",
                  "var/log/access.log",
                  "var/log/error_log",
                  "var/log/error.log",
                  "var/log/tomcat6/catalina.out",
                  "var/log/lighttpd.error.log",
                  "var/log/lighttpd.access.log",
                  "var/logs/access.log",
                  "var/log/lighttpd/",
                  "var/log/lighttpd/error.log",
                  "var/log/lighttpd/access.www.log",
                  "var/log/lighttpd/error.www.log",
                  "var/log/lighttpd/access.log",
                  "var/log/lighttpd/{domain}/access.log",
                  "var/log/lighttpd/{domain}/error.log",
                  "var/log/nginx/access_log",
                  "var/log/nginx/error_log",
                  "var/log/nginx/access.log",
                  "var/log/nginx/error.log",
                  "var/log/nginx.access_log",
                  "var/log/nginx.error_log",
                  "var/log/samba/log.smbd",
                  "var/log/samba/log.nmbd",
                  "var/log/samba.log",
                  "var/log/samba.log1",
                  "var/log/samba.log2",
                  "var/log/log.smb",
                  "var/log/ipfw.log",
                  "var/log/ipfw",
                  "var/log/ipfw/ipfw.log",
                  "var/log/ipfw.today",
                  "var/log/poplog",
                  "var/log/authlog",
                  "var/log/news.all",
                  "var/log/news/news.all",
                  "var/log/news/news.crit",
                  "var/log/news/news.err",
                  "var/log/news/news.notice",
                  "var/log/news/suck.err",
                  "var/log/news/suck.notice",
                  "var/log/messages",
                  "var/log/messages.1",
                  "var/log/user.log",
                  "var/log/user.log.1",
                  "var/log/auth.log",
                  "var/log/pm-powersave.log",
                  "var/log/xorg.0.log",
                  "var/log/daemon.log",
                  "var/log/daemon.log.1",
                  "var/log/kern.log",
                  "var/log/kern.log.1",
                  "var/log/mail.err",
                  "var/log/mail.info",
                  "var/log/mail.warn",
                  "var/log/ufw.log",
                  "var/log/boot.log",
                  "var/log/syslog",
                  "var/log/syslog.1",
                  "var/log/squirrelmail.log",
                  "var/log/apache2/squirrelmail.log",
                  "var/log/apache2/squirrelmail.err.log",
                  "var/log/mail.log",
                  "var/log/vmware/hostd.log",
                  "var/log/vmware/hostd-1.log",
                  "/wp-config.php",
                  "/wp-config.bak",
                  "/wp-config.old",
                  "/wp-config.temp",
                  "/wp-config.tmp",
                  "/wp-config.txt",
                  "/config.yml",
                  "/config_dev.yml",
                  "/config_prod.yml",
                  "/config_test.yml",
                  "/parameters.yml",
                  "/routing.yml",
                  "/security.yml",
                  "/services.yml",
                  "sites/default/default.settings.php",
                  "sites/default/settings.php",
                  "sites/default/settings.local.php",
                  "app/etc/local.xml",
                  "/sftp-config.json",
                  "/web.config",
                  "includes/config.php",
                  "includes/configure.php",
                  "/config.inc.php",
                  "/localsettings.php",
                  "inc/config.php",
                  "typo3conf/localconf.php",
                  "config/app.php",
                  "config/custom.php",
                  "config/database.php",
                  "/configuration.php",
                  "/config.php",
                  "var/mail/www-data",
                  "etc/network/",
                  "etc/init/",
                  "inetpub/wwwroot/global.asa",
                  "system32/inetsrv/config/applicationhost.config",
                  "system32/inetsrv/config/administration.config",
                  "system32/inetsrv/config/redirection.config",
                  "system32/config/default",
                  "system32/config/sam",
                  "system32/config/system",
                  "system32/config/software",
                  "winnt/repair/sam._",
                  "/package.json",
                  "/package-lock.json",
                  "/gruntfile.js",
                  "/npm-debug.log",
                  "/ormconfig.json",
                  "/tsconfig.json",
                  "/webpack.config.js",
                  "/yarn.lock",
                  "proc/0",
                  "proc/1",
                  "proc/2",
                  "proc/3",
                  "proc/4",
                  "proc/5",
                  "proc/6",
                  "proc/7",
                  "proc/8",
                  "proc/9",
                  "proc/acpi",
                  "proc/asound",
                  "proc/bootconfig",
                  "proc/buddyinfo",
                  "proc/bus",
                  "proc/cgroups",
                  "proc/cmdline",
                  "proc/config.gz",
                  "proc/consoles",
                  "proc/cpuinfo",
                  "proc/crypto",
                  "proc/devices",
                  "proc/diskstats",
                  "proc/dma",
                  "proc/docker",
                  "proc/driver",
                  "proc/dynamic_debug",
                  "proc/execdomains",
                  "proc/fb",
                  "proc/filesystems",
                  "proc/fs",
                  "proc/interrupts",
                  "proc/iomem",
                  "proc/ioports",
                  "proc/ipmi",
                  "proc/irq",
                  "proc/kallsyms",
                  "proc/kcore",
                  "proc/keys",
                  "proc/keys",
                  "proc/key-users",
                  "proc/kmsg",
                  "proc/kpagecgroup",
                  "proc/kpagecount",
                  "proc/kpageflags",
                  "proc/latency_stats",
                  "proc/loadavg",
                  "proc/locks",
                  "proc/mdstat",
                  "proc/meminfo",
                  "proc/misc",
                  "proc/modules",
                  "proc/mounts",
                  "proc/mpt",
                  "proc/mtd",
                  "proc/mtrr",
                  "proc/net",
                  "proc/net/tcp",
                  "proc/net/udp",
                  "proc/pagetypeinfo",
                  "proc/partitions",
                  "proc/pressure",
                  "proc/sched_debug",
                  "proc/schedstat",
                  "proc/scsi",
                  "proc/self",
                  "proc/self/cmdline",
                  "proc/self/environ",
                  "proc/self/fd/0",
                  "proc/self/fd/1",
                  "proc/self/fd/10",
                  "proc/self/fd/11",
                  "proc/self/fd/12",
                  "proc/self/fd/13",
                  "proc/self/fd/14",
                  "proc/self/fd/15",
                  "proc/self/fd/2",
                  "proc/self/fd/3",
                  "proc/self/fd/4",
                  "proc/self/fd/5",
                  "proc/self/fd/6",
                  "proc/self/fd/7",
                  "proc/self/fd/8",
                  "proc/self/fd/9",
                  "proc/self/mounts",
                  "proc/self/stat",
                  "proc/self/status",
                  "proc/slabinfo",
                  "proc/softirqs",
                  "proc/stat",
                  "proc/swaps",
                  "proc/sys",
                  "proc/sysrq-trigger",
                  "proc/sysvipc",
                  "proc/thread-self",
                  "proc/timer_list",
                  "proc/timer_stats",
                  "proc/tty",
                  "proc/uptime",
                  "proc/version",
                  "proc/version_signature",
                  "proc/vmallocinfo",
                  "proc/vmstat",
                  "proc/zoneinfo",
                  "sys/block",
                  "sys/bus",
                  "sys/class",
                  "sys/dev",
                  "sys/devices",
                  "sys/firmware",
                  "sys/fs",
                  "sys/hypervisor",
                  "sys/kernel",
                  "sys/module",
                  "sys/power",
                  "windows\\win.ini",
                  "default\\ntuser.dat",
                  "/var/run/secrets/kubernetes.io/serviceaccount"
                ],
                options: {
                  enforce_word_boundary: true
                }
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase",
            "normalizePath"
          ]
        },
        {
          id: "crs-931-110",
          name: "RFI: Common RFI Vulnerable Parameter Name used w/ URL Payload",
          tags: {
            type: "rfi",
            crs_id: "931110",
            category: "attack_attempt",
            cwe: "98",
            capec: "1000/152/175/253/193",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  }
                ],
                regex: "(?:\\binclude\\s*\\([^)]*|mosConfig_absolute_path|_CONF\\[path\\]|_SERVER\\[DOCUMENT_ROOT\\]|GALLERY_BASEDIR|path\\[docroot\\]|appserv_root|config\\[root_dir\\])=(?:file|ftps?|https?)://",
                options: {
                  min_length: 15
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-931-120",
          name: "RFI: URL Payload Used w/Trailing Question Mark Character (?)",
          tags: {
            type: "rfi",
            crs_id: "931120",
            category: "attack_attempt",
            cwe: "98",
            capec: "1000/152/175/253/193",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^(?i:file|ftps?)://.*?\\?+$",
                options: {
                  case_sensitive: true,
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-932-160",
          name: "Remote Command Execution: Unix Shell Code Found",
          tags: {
            type: "command_injection",
            crs_id: "932160",
            category: "attack_attempt",
            cwe: "77",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                options: {
                  enforce_word_boundary: true
                },
                list: [
                  "${cdpath}",
                  "${dirstack}",
                  "${home}",
                  "${hostname}",
                  "${ifs}",
                  "${oldpwd}",
                  "${ostype}",
                  "${path}",
                  "${pwd}",
                  "$cdpath",
                  "$dirstack",
                  "$home",
                  "$hostname",
                  "$ifs",
                  "$oldpwd",
                  "$ostype",
                  "$pwd",
                  "dev/fd/",
                  "dev/null",
                  "dev/stderr",
                  "dev/stdin",
                  "dev/stdout",
                  "dev/tcp/",
                  "dev/udp/",
                  "dev/zero",
                  "etc/master.passwd",
                  "etc/pwd.db",
                  "etc/shells",
                  "etc/spwd.db",
                  "proc/self/",
                  "bin/7z",
                  "bin/7za",
                  "bin/7zr",
                  "bin/ab",
                  "bin/agetty",
                  "bin/ansible-playbook",
                  "bin/apt",
                  "bin/apt-get",
                  "bin/ar",
                  "bin/aria2c",
                  "bin/arj",
                  "bin/arp",
                  "bin/as",
                  "bin/ascii-xfr",
                  "bin/ascii85",
                  "bin/ash",
                  "bin/aspell",
                  "bin/at",
                  "bin/atobm",
                  "bin/awk",
                  "bin/base32",
                  "bin/base64",
                  "bin/basenc",
                  "bin/bash",
                  "bin/bpftrace",
                  "bin/bridge",
                  "bin/bundler",
                  "bin/bunzip2",
                  "bin/busctl",
                  "bin/busybox",
                  "bin/byebug",
                  "bin/bzcat",
                  "bin/bzcmp",
                  "bin/bzdiff",
                  "bin/bzegrep",
                  "bin/bzexe",
                  "bin/bzfgrep",
                  "bin/bzgrep",
                  "bin/bzip2",
                  "bin/bzip2recover",
                  "bin/bzless",
                  "bin/bzmore",
                  "bin/bzz",
                  "bin/c89",
                  "bin/c99",
                  "bin/cancel",
                  "bin/capsh",
                  "bin/cat",
                  "bin/cc",
                  "bin/certbot",
                  "bin/check_by_ssh",
                  "bin/check_cups",
                  "bin/check_log",
                  "bin/check_memory",
                  "bin/check_raid",
                  "bin/check_ssl_cert",
                  "bin/check_statusfile",
                  "bin/chmod",
                  "bin/choom",
                  "bin/chown",
                  "bin/chroot",
                  "bin/clang",
                  "bin/clang++",
                  "bin/cmp",
                  "bin/cobc",
                  "bin/column",
                  "bin/comm",
                  "bin/composer",
                  "bin/core_perl/zipdetails",
                  "bin/cowsay",
                  "bin/cowthink",
                  "bin/cp",
                  "bin/cpan",
                  "bin/cpio",
                  "bin/cpulimit",
                  "bin/crash",
                  "bin/crontab",
                  "bin/csh",
                  "bin/csplit",
                  "bin/csvtool",
                  "bin/cupsfilter",
                  "bin/curl",
                  "bin/cut",
                  "bin/dash",
                  "bin/date",
                  "bin/dd",
                  "bin/dev/fd/",
                  "bin/dev/null",
                  "bin/dev/stderr",
                  "bin/dev/stdin",
                  "bin/dev/stdout",
                  "bin/dev/tcp/",
                  "bin/dev/udp/",
                  "bin/dev/zero",
                  "bin/dialog",
                  "bin/diff",
                  "bin/dig",
                  "bin/dmesg",
                  "bin/dmidecode",
                  "bin/dmsetup",
                  "bin/dnf",
                  "bin/docker",
                  "bin/dosbox",
                  "bin/dpkg",
                  "bin/du",
                  "bin/dvips",
                  "bin/easy_install",
                  "bin/eb",
                  "bin/echo",
                  "bin/ed",
                  "bin/efax",
                  "bin/emacs",
                  "bin/env",
                  "bin/eqn",
                  "bin/es",
                  "bin/esh",
                  "bin/etc/group",
                  "bin/etc/master.passwd",
                  "bin/etc/passwd",
                  "bin/etc/pwd.db",
                  "bin/etc/shadow",
                  "bin/etc/shells",
                  "bin/etc/spwd.db",
                  "bin/ex",
                  "bin/exiftool",
                  "bin/expand",
                  "bin/expect",
                  "bin/expr",
                  "bin/facter",
                  "bin/fetch",
                  "bin/file",
                  "bin/find",
                  "bin/finger",
                  "bin/fish",
                  "bin/flock",
                  "bin/fmt",
                  "bin/fold",
                  "bin/fping",
                  "bin/ftp",
                  "bin/gawk",
                  "bin/gcc",
                  "bin/gcore",
                  "bin/gdb",
                  "bin/gem",
                  "bin/genie",
                  "bin/genisoimage",
                  "bin/ghc",
                  "bin/ghci",
                  "bin/gimp",
                  "bin/ginsh",
                  "bin/git",
                  "bin/grc",
                  "bin/grep",
                  "bin/gtester",
                  "bin/gunzip",
                  "bin/gzexe",
                  "bin/gzip",
                  "bin/hd",
                  "bin/head",
                  "bin/hexdump",
                  "bin/highlight",
                  "bin/hping3",
                  "bin/iconv",
                  "bin/id",
                  "bin/iftop",
                  "bin/install",
                  "bin/ionice",
                  "bin/ip",
                  "bin/irb",
                  "bin/ispell",
                  "bin/jjs",
                  "bin/join",
                  "bin/journalctl",
                  "bin/jq",
                  "bin/jrunscript",
                  "bin/knife",
                  "bin/ksh",
                  "bin/ksshell",
                  "bin/latex",
                  "bin/ld",
                  "bin/ldconfig",
                  "bin/less",
                  "bin/lftp",
                  "bin/ln",
                  "bin/loginctl",
                  "bin/logsave",
                  "bin/look",
                  "bin/lp",
                  "bin/ls",
                  "bin/ltrace",
                  "bin/lua",
                  "bin/lualatex",
                  "bin/luatex",
                  "bin/lwp-download",
                  "bin/lwp-request",
                  "bin/lz",
                  "bin/lz4",
                  "bin/lz4c",
                  "bin/lz4cat",
                  "bin/lzcat",
                  "bin/lzcmp",
                  "bin/lzdiff",
                  "bin/lzegrep",
                  "bin/lzfgrep",
                  "bin/lzgrep",
                  "bin/lzless",
                  "bin/lzma",
                  "bin/lzmadec",
                  "bin/lzmainfo",
                  "bin/lzmore",
                  "bin/mail",
                  "bin/make",
                  "bin/man",
                  "bin/mawk",
                  "bin/mkfifo",
                  "bin/mknod",
                  "bin/more",
                  "bin/mosquitto",
                  "bin/mount",
                  "bin/msgattrib",
                  "bin/msgcat",
                  "bin/msgconv",
                  "bin/msgfilter",
                  "bin/msgmerge",
                  "bin/msguniq",
                  "bin/mtr",
                  "bin/mv",
                  "bin/mysql",
                  "bin/nano",
                  "bin/nasm",
                  "bin/nawk",
                  "bin/nc",
                  "bin/ncat",
                  "bin/neofetch",
                  "bin/nice",
                  "bin/nl",
                  "bin/nm",
                  "bin/nmap",
                  "bin/node",
                  "bin/nohup",
                  "bin/npm",
                  "bin/nroff",
                  "bin/nsenter",
                  "bin/octave",
                  "bin/od",
                  "bin/openssl",
                  "bin/openvpn",
                  "bin/openvt",
                  "bin/opkg",
                  "bin/paste",
                  "bin/pax",
                  "bin/pdb",
                  "bin/pdflatex",
                  "bin/pdftex",
                  "bin/pdksh",
                  "bin/perf",
                  "bin/perl",
                  "bin/pg",
                  "bin/php",
                  "bin/php-cgi",
                  "bin/php5",
                  "bin/php7",
                  "bin/pic",
                  "bin/pico",
                  "bin/pidstat",
                  "bin/pigz",
                  "bin/pip",
                  "bin/pkexec",
                  "bin/pkg",
                  "bin/pr",
                  "bin/printf",
                  "bin/proc/self/",
                  "bin/pry",
                  "bin/ps",
                  "bin/psed",
                  "bin/psftp",
                  "bin/psql",
                  "bin/ptx",
                  "bin/puppet",
                  "bin/pxz",
                  "bin/python",
                  "bin/python2",
                  "bin/python3",
                  "bin/rake",
                  "bin/rbash",
                  "bin/rc",
                  "bin/readelf",
                  "bin/red",
                  "bin/redcarpet",
                  "bin/restic",
                  "bin/rev",
                  "bin/rlogin",
                  "bin/rlwrap",
                  "bin/rpm",
                  "bin/rpmquery",
                  "bin/rsync",
                  "bin/ruby",
                  "bin/run-mailcap",
                  "bin/run-parts",
                  "bin/rview",
                  "bin/rvim",
                  "bin/sash",
                  "bin/sbin/capsh",
                  "bin/sbin/logsave",
                  "bin/sbin/service",
                  "bin/sbin/start-stop-daemon",
                  "bin/scp",
                  "bin/screen",
                  "bin/script",
                  "bin/sed",
                  "bin/service",
                  "bin/setarch",
                  "bin/sftp",
                  "bin/sg",
                  "bin/sh",
                  "bin/shuf",
                  "bin/sleep",
                  "bin/slsh",
                  "bin/smbclient",
                  "bin/snap",
                  "bin/socat",
                  "bin/soelim",
                  "bin/sort",
                  "bin/split",
                  "bin/sqlite3",
                  "bin/ss",
                  "bin/ssh",
                  "bin/ssh-keygen",
                  "bin/ssh-keyscan",
                  "bin/sshpass",
                  "bin/start-stop-daemon",
                  "bin/stdbuf",
                  "bin/strace",
                  "bin/strings",
                  "bin/su",
                  "bin/sysctl",
                  "bin/systemctl",
                  "bin/systemd-resolve",
                  "bin/tac",
                  "bin/tail",
                  "bin/tar",
                  "bin/task",
                  "bin/taskset",
                  "bin/tbl",
                  "bin/tclsh",
                  "bin/tcpdump",
                  "bin/tcsh",
                  "bin/tee",
                  "bin/telnet",
                  "bin/tex",
                  "bin/tftp",
                  "bin/tic",
                  "bin/time",
                  "bin/timedatectl",
                  "bin/timeout",
                  "bin/tmux",
                  "bin/top",
                  "bin/troff",
                  "bin/tshark",
                  "bin/ul",
                  "bin/uname",
                  "bin/uncompress",
                  "bin/unexpand",
                  "bin/uniq",
                  "bin/unlz4",
                  "bin/unlzma",
                  "bin/unpigz",
                  "bin/unrar",
                  "bin/unshare",
                  "bin/unxz",
                  "bin/unzip",
                  "bin/unzstd",
                  "bin/update-alternatives",
                  "bin/uudecode",
                  "bin/uuencode",
                  "bin/valgrind",
                  "bin/vi",
                  "bin/view",
                  "bin/vigr",
                  "bin/vim",
                  "bin/vimdiff",
                  "bin/vipw",
                  "bin/virsh",
                  "bin/volatility",
                  "bin/wall",
                  "bin/watch",
                  "bin/wc",
                  "bin/wget",
                  "bin/whiptail",
                  "bin/who",
                  "bin/whoami",
                  "bin/whois",
                  "bin/wireshark",
                  "bin/wish",
                  "bin/xargs",
                  "bin/xelatex",
                  "bin/xetex",
                  "bin/xmodmap",
                  "bin/xmore",
                  "bin/xpad",
                  "bin/xxd",
                  "bin/xz",
                  "bin/xzcat",
                  "bin/xzcmp",
                  "bin/xzdec",
                  "bin/xzdiff",
                  "bin/xzegrep",
                  "bin/xzfgrep",
                  "bin/xzgrep",
                  "bin/xzless",
                  "bin/xzmore",
                  "bin/yarn",
                  "bin/yelp",
                  "bin/yes",
                  "bin/yum",
                  "bin/zathura",
                  "bin/zip",
                  "bin/zipcloak",
                  "bin/zipcmp",
                  "bin/zipdetails",
                  "bin/zipgrep",
                  "bin/zipinfo",
                  "bin/zipmerge",
                  "bin/zipnote",
                  "bin/zipsplit",
                  "bin/ziptool",
                  "bin/zsh",
                  "bin/zsoelim",
                  "bin/zstd",
                  "bin/zstdcat",
                  "bin/zstdgrep",
                  "bin/zstdless",
                  "bin/zstdmt",
                  "bin/zypper"
                ]
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase",
            "cmdLine"
          ]
        },
        {
          id: "crs-932-171",
          name: "Remote Command Execution: Shellshock (CVE-2014-6271)",
          tags: {
            type: "command_injection",
            crs_id: "932171",
            category: "attack_attempt",
            cwe: "77",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^\\(\\s*\\)\\s+{",
                options: {
                  case_sensitive: true,
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-932-180",
          name: "Restricted File Upload Attempt",
          tags: {
            type: "command_injection",
            crs_id: "932180",
            category: "attack_attempt",
            cwe: "706",
            capec: "1000/225/122/17/177",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-filename"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x_filename"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-file-name"
                    ]
                  }
                ],
                list: [
                  ".htaccess",
                  ".htdigest",
                  ".htpasswd",
                  "wp-config.php",
                  "config.yml",
                  "config_dev.yml",
                  "config_prod.yml",
                  "config_test.yml",
                  "parameters.yml",
                  "routing.yml",
                  "security.yml",
                  "services.yml",
                  "default.settings.php",
                  "settings.php",
                  "settings.local.php",
                  "local.xml",
                  ".env"
                ],
                options: {
                  enforce_word_boundary: true
                }
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-933-111",
          name: "PHP Injection Attack: PHP Script File Upload Found",
          tags: {
            type: "unrestricted_file_upload",
            crs_id: "933111",
            category: "attack_attempt",
            cwe: "434",
            capec: "1000/225/122/17/650",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-filename"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x_filename"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x.filename"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-file-name"
                    ]
                  }
                ],
                regex: ".*\\.(?:php\\d*|phtml)\\..*$",
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-933-130",
          name: "PHP Injection Attack: Global Variables Found",
          tags: {
            type: "php_code_injection",
            crs_id: "933130",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/225/122/17/650",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                options: {
                  enforce_word_boundary: true
                },
                list: [
                  "$globals",
                  "$_cookie",
                  "$_env",
                  "$_files",
                  "$_get",
                  "$_post",
                  "$_request",
                  "$_server",
                  "$_session",
                  "$argc",
                  "$argv",
                  "$http_\\u200bresponse_\\u200bheader",
                  "$php_\\u200berrormsg",
                  "$http_cookie_vars",
                  "$http_env_vars",
                  "$http_get_vars",
                  "$http_post_files",
                  "$http_post_vars",
                  "$http_raw_post_data",
                  "$http_request_vars",
                  "$http_server_vars"
                ]
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-933-131",
          name: "PHP Injection Attack: HTTP Headers Values Found",
          tags: {
            type: "php_code_injection",
            crs_id: "933131",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/225/122/17/650",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:HTTP_(?:ACCEPT(?:_(?:ENCODING|LANGUAGE|CHARSET))?|(?:X_FORWARDED_FO|REFERE)R|(?:USER_AGEN|HOS)T|CONNECTION|KEEP_ALIVE)|PATH_(?:TRANSLATED|INFO)|ORIG_PATH_INFO|QUERY_STRING|REQUEST_URI|AUTH_TYPE)",
                options: {
                  case_sensitive: true,
                  min_length: 9
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-933-140",
          name: "PHP Injection Attack: I/O Stream Found",
          tags: {
            type: "php_code_injection",
            crs_id: "933140",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/225/122/17/650",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "php://(?:std(?:in|out|err)|(?:in|out)put|fd|memory|temp|filter)",
                options: {
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-933-150",
          name: "PHP Injection Attack: High-Risk PHP Function Name Found",
          tags: {
            type: "php_code_injection",
            crs_id: "933150",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/225/122/17/650",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                list: [
                  "__halt_compiler",
                  "apache_child_terminate",
                  "base64_decode",
                  "bzdecompress",
                  "call_user_func",
                  "call_user_func_array",
                  "call_user_method",
                  "call_user_method_array",
                  "convert_uudecode",
                  "file_get_contents",
                  "file_put_contents",
                  "fsockopen",
                  "get_class_methods",
                  "get_class_vars",
                  "get_defined_constants",
                  "get_defined_functions",
                  "get_defined_vars",
                  "gzdecode",
                  "gzinflate",
                  "gzuncompress",
                  "include_once",
                  "invokeargs",
                  "pcntl_exec",
                  "pcntl_fork",
                  "pfsockopen",
                  "posix_getcwd",
                  "posix_getpwuid",
                  "posix_getuid",
                  "posix_uname",
                  "reflectionfunction",
                  "require_once",
                  "shell_exec",
                  "str_rot13",
                  "sys_get_temp_dir",
                  "wp_remote_fopen",
                  "wp_remote_get",
                  "wp_remote_head",
                  "wp_remote_post",
                  "wp_remote_request",
                  "wp_safe_remote_get",
                  "wp_safe_remote_head",
                  "wp_safe_remote_post",
                  "wp_safe_remote_request",
                  "zlib_decode"
                ],
                options: {
                  enforce_word_boundary: true
                }
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-933-160",
          name: "PHP Injection Attack: High-Risk PHP Function Call Found",
          tags: {
            type: "php_code_injection",
            crs_id: "933160",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/225/122/17/650",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: `\\b(?:s(?:e(?:t(?:_(?:e(?:xception|rror)_handler|magic_quotes_runtime|include_path)|defaultstub)|ssion_s(?:et_save_handler|tart))|qlite_(?:(?:(?:unbuffered|single|array)_)?query|create_(?:aggregate|function)|p?open|exec)|tr(?:eam_(?:context_create|socket_client)|ipc?slashes|rev)|implexml_load_(?:string|file)|ocket_c(?:onnect|reate)|h(?:ow_sourc|a1_fil)e|pl_autoload_register|ystem)|p(?:r(?:eg_(?:replace(?:_callback(?:_array)?)?|match(?:_all)?|split)|oc_(?:(?:terminat|clos|nic)e|get_status|open)|int_r)|o(?:six_(?:get(?:(?:e[gu]|g)id|login|pwnam)|mk(?:fifo|nod)|ttyname|kill)|pen)|hp(?:_(?:strip_whitespac|unam)e|version|info)|g_(?:(?:execut|prepar)e|connect|query)|a(?:rse_(?:ini_file|str)|ssthru)|utenv)|r(?:unkit_(?:function_(?:re(?:defin|nam)e|copy|add)|method_(?:re(?:defin|nam)e|copy|add)|constant_(?:redefine|add))|e(?:(?:gister_(?:shutdown|tick)|name)_function|ad(?:(?:gz)?file|_exif_data|dir))|awurl(?:de|en)code)|i(?:mage(?:createfrom(?:(?:jpe|pn)g|x[bp]m|wbmp|gif)|(?:jpe|pn)g|g(?:d2?|if)|2?wbmp|xbm)|s_(?:(?:(?:execut|write?|read)ab|fi)le|dir)|ni_(?:get(?:_all)?|set)|terator_apply|ptcembed)|g(?:et(?:_(?:c(?:urrent_use|fg_va)r|meta_tags)|my(?:[gpu]id|inode)|(?:lastmo|cw)d|imagesize|env)|z(?:(?:(?:defla|wri)t|encod|fil)e|compress|open|read)|lob)|a(?:rray_(?:u(?:intersect(?:_u?assoc)?|diff(?:_u?assoc)?)|intersect_u(?:assoc|key)|diff_u(?:assoc|key)|filter|reduce|map)|ssert(?:_options)?|tob)|h(?:tml(?:specialchars(?:_decode)?|_entity_decode|entities)|(?:ash(?:_(?:update|hmac))?|ighlight)_file|e(?:ader_register_callback|x2bin))|f(?:i(?:le(?:(?:[acm]tim|inod)e|(?:_exist|perm)s|group)?|nfo_open)|tp_(?:nb_(?:ge|pu)|connec|ge|pu)t|(?:unction_exis|pu)ts|write|open)|o(?:b_(?:get_(?:c(?:ontents|lean)|flush)|end_(?:clean|flush)|clean|flush|start)|dbc_(?:result(?:_all)?|exec(?:ute)?|connect)|pendir)|m(?:b_(?:ereg(?:_(?:replace(?:_callback)?|match)|i(?:_replace)?)?|parse_str)|(?:ove_uploaded|d5)_file|ethod_exists|ysql_query|kdir)|e(?:x(?:if_(?:t(?:humbnail|agname)|imagetype|read_data)|ec)|scapeshell(?:arg|cmd)|rror_reporting|val)|c(?:url_(?:file_create|exec|init)|onvert_uuencode|reate_function|hr)|u(?:n(?:serialize|pack)|rl(?:de|en)code|[ak]?sort)|b(?:(?:son_(?:de|en)|ase64_en)code|zopen|toa)|(?:json_(?:de|en)cod|debug_backtrac|tmpfil)e|var_dump)(?:\\s|/\\*.*\\*/|//.*|#.*|\\"|')*\\((?:(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:\\$\\w+|[A-Z\\d]\\w*|\\w+\\(.*\\)|\\\\?"(?:[^"]|\\\\"|""|"\\+")*\\\\?"|\\\\?'(?:[^']|''|'\\+')*\\\\?')(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:(?:::|\\.|->)(?:\\s|/\\*.*\\*/|//.*|#.*)*\\w+(?:\\(.*\\))?)?,)*(?:(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:\\$\\w+|[A-Z\\d]\\w*|\\w+\\(.*\\)|\\\\?"(?:[^"]|\\\\"|""|"\\+")*\\\\?"|\\\\?'(?:[^']|''|'\\+')*\\\\?')(?:\\s|/\\*.*\\*/|//.*|#.*)*(?:(?:::|\\.|->)(?:\\s|/\\*.*\\*/|//.*|#.*)*\\w+(?:\\(.*\\))?)?)?\\)\\s*(?:[;\\.)}\\]|\\\\]|\\?>|%>|$)`,
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-933-170",
          name: "PHP Injection Attack: Serialized Object Injection",
          tags: {
            type: "php_code_injection",
            crs_id: "933170",
            category: "attack_attempt",
            cwe: "502",
            capec: "1000/152/586",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: '[oOcC]:\\d+:\\".+?\\":\\d+:{[\\W\\w]*}',
                options: {
                  case_sensitive: true,
                  min_length: 12
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-933-200",
          name: "PHP Injection Attack: Wrapper scheme detected",
          tags: {
            type: "php_code_injection",
            crs_id: "933200",
            category: "attack_attempt",
            cwe: "502",
            capec: "1000/152/586",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:(?:bzip|ssh)2|z(?:lib|ip)|(?:ph|r)ar|expect|glob|ogg)://",
                options: {
                  case_sensitive: true,
                  min_length: 6
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-934-100",
          name: "Node.js Injection Attack 1/2",
          tags: {
            type: "js_code_injection",
            crs_id: "934100",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:(?:l(?:(?:utimes|chmod)(?:Sync)?|(?:stat|ink)Sync)|w(?:rite(?:(?:File|v)(?:Sync)?|Sync)|atchFile)|u(?:n(?:watchFile|linkSync)|times(?:Sync)?)|s(?:(?:ymlink|tat)Sync|pawn(?:File|Sync))|ex(?:ec(?:File(?:Sync)?|Sync)|istsSync)|a(?:ppendFile|ccess)(?:Sync)?|(?:Caveat|Inode)s|open(?:dir)?Sync|new\\s+Function|Availability|\\beval)\\s*\\(|m(?:ain(?:Module\\s*(?:\\W*\\s*(?:constructor|require)|\\[)|\\s*(?:\\W*\\s*(?:constructor|require)|\\[))|kd(?:temp(?:Sync)?|irSync)\\s*\\(|odule\\.exports\\s*=)|c(?:(?:(?:h(?:mod|own)|lose)Sync|reate(?:Write|Read)Stream|p(?:Sync)?)\\s*\\(|o(?:nstructor\\s*(?:\\W*\\s*_load|\\[)|pyFile(?:Sync)?\\s*\\())|f(?:(?:(?:s(?:(?:yncS)?|tatS)|datas(?:yncS)?)ync|ch(?:mod|own)(?:Sync)?)\\s*\\(|u(?:nction\\s*\\(\\s*\\)\\s*{|times(?:Sync)?\\s*\\())|r(?:e(?:(?:ad(?:(?:File|link|dir)?Sync|v(?:Sync)?)|nameSync)\\s*\\(|quire\\s*(?:\\W*\\s*main\\b|\\[))|m(?:Sync)?\\s*\\()|process\\s*(?:\\W*\\s*(?:mainModule|binding)|\\[)|t(?:his\\.constructor|runcateSync\\s*\\()|_(?:\\$\\$ND_FUNC\\$\\$_|_js_function)|global\\s*(?:\\W*\\s*process|\\[)|String\\s*\\.\\s*fromCharCode|binding\\s*\\[)",
                options: {
                  case_sensitive: true,
                  min_length: 3
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-934-101",
          name: "Node.js Injection Attack 2/2",
          tags: {
            type: "js_code_injection",
            crs_id: "934101",
            category: "attack_attempt",
            confidence: "1",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:w(?:atch|rite)|(?:spaw|ope)n|exists|close|fork|read)\\s*\\(",
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-941-110",
          name: "XSS Filter - Category 1: Script Tag Vector",
          tags: {
            type: "xss",
            crs_id: "941110",
            category: "attack_attempt",
            cwe: "80",
            capec: "1000/152/242/63/591",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "referer"
                    ]
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<script[^>]*>[\\s\\S]*?",
                options: {
                  case_sensitive: false,
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls",
            "urlDecodeUni"
          ]
        },
        {
          id: "crs-941-120",
          name: "XSS Filter - Category 2: Event Handler Vector",
          tags: {
            type: "xss",
            crs_id: "941120",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "referer"
                    ]
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bon(?:d(?:r(?:ag(?:en(?:ter|d)|leave|start|over)?|op)|urationchange|blclick)|s(?:e(?:ek(?:ing|ed)|arch|lect)|u(?:spend|bmit)|talled|croll|how)|m(?:ouse(?:(?:lea|mo)ve|o(?:ver|ut)|enter|down|up)|essage)|p(?:a(?:ge(?:hide|show)|(?:st|us)e)|lay(?:ing)?|rogress|aste|ointer(?:cancel|down|enter|leave|move|out|over|rawupdate|up))|c(?:anplay(?:through)?|o(?:ntextmenu|py)|hange|lick|ut)|a(?:nimation(?:iteration|start|end)|(?:fterprin|bor)t|uxclick|fterscriptexecute)|t(?:o(?:uch(?:cancel|start|move|end)|ggle)|imeupdate)|f(?:ullscreen(?:change|error)|ocus(?:out|in)?|inish)|(?:(?:volume|hash)chang|o(?:ff|n)lin)e|b(?:efore(?:unload|print)|lur)|load(?:ed(?:meta)?data|start|end)?|r(?:es(?:ize|et)|atechange)|key(?:press|down|up)|w(?:aiting|heel)|in(?:valid|put)|e(?:nded|rror)|unload)[\\s\\x0B\\x09\\x0C\\x3B\\x2C\\x28\\x3B]*?=[^=]",
                options: {
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls",
            "urlDecodeUni"
          ]
        },
        {
          id: "crs-941-140",
          name: "XSS Filter - Category 4: Javascript URI Vector",
          tags: {
            type: "xss",
            crs_id: "941140",
            category: "attack_attempt",
            cwe: "84",
            capec: "1000/152/242/63/591/244",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "referer"
                    ]
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "[a-z]+=(?:[^:=]+:.+;)*?[^:=]+:url\\(javascript",
                options: {
                  min_length: 18
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls",
            "urlDecodeUni"
          ]
        },
        {
          id: "crs-941-170",
          name: "NoScript XSS InjectionChecker: Attribute Injection",
          tags: {
            type: "xss",
            crs_id: "941170",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "referer"
                    ]
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: `(?:\\W|^)(?:javascript:(?:[\\s\\S]+[=\\x5c\\(\\[\\.<]|[\\s\\S]*?(?:\\bname\\b|\\x5c[ux]\\d)))|@\\W*?i\\W*?m\\W*?p\\W*?o\\W*?r\\W*?t\\W*?(?:/\\*[\\s\\S]*?)?(?:[\\"']|\\W*?u\\W*?r\\W*?l[\\s\\S]*?\\()|[^-]*?-\\W*?m\\W*?o\\W*?z\\W*?-\\W*?b\\W*?i\\W*?n\\W*?d\\W*?i\\W*?n\\W*?g[^:]*?:\\W*?u\\W*?r\\W*?l[\\s\\S]*?\\(`,
                options: {
                  min_length: 6
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls",
            "urlDecodeUni"
          ]
        },
        {
          id: "crs-941-180",
          name: "Node-Validator Deny List Keywords",
          tags: {
            type: "xss",
            crs_id: "941180",
            category: "attack_attempt",
            cwe: "79",
            capec: "1000/152/242/63/591",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                options: {
                  enforce_word_boundary: true
                },
                list: [
                  "document.cookie",
                  "document.write",
                  ".parentnode",
                  ".innerhtml",
                  "window.location",
                  "-moz-binding"
                ]
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "removeNulls",
            "lowercase"
          ]
        },
        {
          id: "crs-941-200",
          name: "IE XSS Filters - Attack Detected via vmlframe tag",
          tags: {
            type: "xss",
            crs_id: "941200",
            category: "attack_attempt",
            cwe: "80",
            capec: "1000/152/242/63/591",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:<.*[:]?vmlframe.*?[\\s/+]*?src[\\s/+]*=)",
                options: {
                  case_sensitive: true,
                  min_length: 13
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-210",
          name: "IE XSS Filters - Obfuscated Attack Detected via javascript injection",
          tags: {
            type: "xss",
            crs_id: "941210",
            category: "attack_attempt",
            cwe: "80",
            capec: "1000/152/242/63/591",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:(?:j|&#x?0*(?:74|4A|106|6A);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:a|&#x?0*(?:65|41|97|61);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:v|&#x?0*(?:86|56|118|76);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:a|&#x?0*(?:65|41|97|61);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:s|&#x?0*(?:83|53|115|73);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:c|&#x?0*(?:67|43|99|63);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:r|&#x?0*(?:82|52|114|72);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:i|&#x?0*(?:73|49|105|69);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:p|&#x?0*(?:80|50|112|70);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:t|&#x?0*(?:84|54|116|74);?)(?:\\t|\\n|\\r|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?::|&(?:#x?0*(?:58|3A);?|colon;)).)",
                options: {
                  case_sensitive: true,
                  min_length: 12
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-220",
          name: "IE XSS Filters - Obfuscated Attack Detected via vbscript injection",
          tags: {
            type: "xss",
            crs_id: "941220",
            category: "attack_attempt",
            cwe: "80",
            capec: "1000/152/242/63/591",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:(?:v|&#x?0*(?:86|56|118|76);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:b|&#x?0*(?:66|42|98|62);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:s|&#x?0*(?:83|53|115|73);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:c|&#x?0*(?:67|43|99|63);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:r|&#x?0*(?:82|52|114|72);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:i|&#x?0*(?:73|49|105|69);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:p|&#x?0*(?:80|50|112|70);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?:t|&#x?0*(?:84|54|116|74);?)(?:\\t|&(?:#x?0*(?:9|13|10|A|D);?|tab;|newline;))*(?::|&(?:#x?0*(?:58|3A);?|colon;)).)",
                options: {
                  case_sensitive: true,
                  min_length: 10
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-230",
          name: "IE XSS Filters - Attack Detected via embed tag",
          tags: {
            type: "xss",
            crs_id: "941230",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<EMBED[\\s/+].*?(?:src|type).*?=",
                options: {
                  min_length: 11
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-240",
          name: "IE XSS Filters - Attack Detected via import tag",
          tags: {
            type: "xss",
            crs_id: "941240",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<[?]?import[\\s/+\\S]*?implementation[\\s/+]*?=",
                options: {
                  case_sensitive: true,
                  min_length: 22
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase",
            "removeNulls"
          ]
        },
        {
          id: "crs-941-270",
          name: "IE XSS Filters - Attack Detected via link tag",
          tags: {
            type: "xss",
            crs_id: "941270",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<LINK[\\s/+].*?href[\\s/+]*=",
                options: {
                  min_length: 11
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-280",
          name: "IE XSS Filters - Attack Detected via base tag",
          tags: {
            type: "xss",
            crs_id: "941280",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<BASE[\\s/+].*?href[\\s/+]*=",
                options: {
                  min_length: 11
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-290",
          name: "IE XSS Filters - Attack Detected via applet tag",
          tags: {
            type: "xss",
            crs_id: "941290",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<APPLET[\\s/+>]",
                options: {
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-300",
          name: "IE XSS Filters - Attack Detected via object tag",
          tags: {
            type: "xss",
            crs_id: "941300",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "<OBJECT[\\s/+].*?(?:type|codetype|classid|code|data)[\\s/+]*=",
                options: {
                  min_length: 13
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-941-350",
          name: "UTF-7 Encoding IE XSS - Attack Detected",
          tags: {
            type: "xss",
            crs_id: "941350",
            category: "attack_attempt",
            cwe: "87",
            capec: "1000/152/242/63/591/199",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\+ADw-.*(?:\\+AD4-|>)|<.*\\+AD4-",
                options: {
                  case_sensitive: true,
                  min_length: 6
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-941-360",
          name: "JSFuck / Hieroglyphy obfuscation detected",
          tags: {
            type: "xss",
            crs_id: "941360",
            category: "attack_attempt",
            cwe: "87",
            capec: "1000/152/242/63/591/199",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "![!+ ]\\[\\]",
                options: {
                  case_sensitive: true,
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-941-390",
          name: "Javascript method detected",
          tags: {
            type: "xss",
            crs_id: "941390",
            category: "attack_attempt",
            confidence: "1",
            cwe: "79",
            capec: "1000/152/242/63/591",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?i:eval|settimeout|setinterval|new\\s+Function|alert|prompt)[\\s+]*\\([^\\)]",
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-100",
          name: "SQL Injection Attack Detected via libinjection",
          tags: {
            type: "sql_injection",
            crs_id: "942100",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ]
              },
              operator: "is_sqli"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "crs-942-160",
          name: "Detects blind sqli tests using sleep() or benchmark()",
          tags: {
            type: "sql_injection",
            crs_id: "942160",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66/7",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:sleep\\(\\s*?\\d*?\\s*?\\)|benchmark\\(.*?\\,.*?\\))",
                options: {
                  case_sensitive: true,
                  min_length: 7
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-240",
          name: "Detects MySQL charset switch and MSSQL DoS attempts",
          tags: {
            type: "sql_injection",
            crs_id: "942240",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66/7",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:[\\\"'`](?:;*?\\s*?waitfor\\s+(?:delay|time)\\s+[\\\"'`]|;.*?:\\s*?goto)|alter\\s*?\\w+.*?cha(?:racte)?r\\s+set\\s+\\w+)",
                options: {
                  min_length: 7
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-250",
          name: "Detects MATCH AGAINST, MERGE and EXECUTE IMMEDIATE injections",
          tags: {
            type: "sql_injection",
            crs_id: "942250",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:merge.*?using\\s*?\\(|execute\\s*?immediate\\s*?[\\\"'`]|match\\s*?[\\w(?:),+-]+\\s*?against\\s*?\\()",
                options: {
                  case_sensitive: true,
                  min_length: 11
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-270",
          name: "Basic SQL injection",
          tags: {
            type: "sql_injection",
            crs_id: "942270",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "union.*?select.*?from",
                options: {
                  min_length: 15
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-280",
          name: "SQL Injection with delay functions",
          tags: {
            type: "sql_injection",
            crs_id: "942280",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66/7",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:;\\s*?shutdown\\s*?(?:[#;{]|\\/\\*|--)|waitfor\\s*?delay\\s?[\\\"'`]+\\s?\\d|select\\s*?pg_sleep)",
                options: {
                  min_length: 10
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-290",
          name: "Finds basic MongoDB SQL injection attempts",
          tags: {
            type: "nosql_injection",
            crs_id: "942290",
            category: "attack_attempt",
            cwe: "943",
            capec: "1000/152/248/676",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:(?:\\[?\\$(?:(?:s(?:lic|iz)|wher)e|e(?:lemMatch|xists|q)|n(?:o[rt]|in?|e)|l(?:ike|te?)|t(?:ext|ype)|a(?:ll|nd)|jsonSchema|between|regex|x?or|div|mod)\\]?)\\b)",
                options: {
                  case_sensitive: true,
                  min_length: 3
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "keys_only"
          ]
        },
        {
          id: "crs-942-360",
          name: "Detects concatenated basic SQL injection and SQLLFI attempts",
          tags: {
            type: "sql_injection",
            crs_id: "942360",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66/470",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:^[\\W\\d]+\\s*?(?:alter\\s*(?:a(?:(?:pplication\\s*rol|ggregat)e|s(?:ymmetric\\s*ke|sembl)y|u(?:thorization|dit)|vailability\\s*group)|c(?:r(?:yptographic\\s*provider|edential)|o(?:l(?:latio|um)|nversio)n|ertificate|luster)|s(?:e(?:rv(?:ice|er)|curity|quence|ssion|arch)|y(?:mmetric\\s*key|nonym)|togroup|chema)|m(?:a(?:s(?:ter\\s*key|k)|terialized)|e(?:ssage\\s*type|thod)|odule)|l(?:o(?:g(?:file\\s*group|in)|ckdown)|a(?:ngua|r)ge|ibrary)|t(?:(?:abl(?:espac)?|yp)e|r(?:igger|usted)|hreshold|ext)|p(?:a(?:rtition|ckage)|ro(?:cedur|fil)e|ermission)|d(?:i(?:mension|skgroup)|atabase|efault|omain)|r(?:o(?:l(?:lback|e)|ute)|e(?:sourc|mot)e)|f(?:u(?:lltext|nction)|lashback|oreign)|e(?:xte(?:nsion|rnal)|(?:ndpoi|ve)nt)|in(?:dex(?:type)?|memory|stance)|b(?:roker\\s*priority|ufferpool)|x(?:ml\\s*schema|srobject)|w(?:ork(?:load)?|rapper)|hi(?:erarchy|stogram)|o(?:perator|utline)|(?:nicknam|queu)e|us(?:age|er)|group|java|view)|union\\s*(?:(?:distin|sele)ct|all))\\b|\\b(?:(?:(?:trunc|cre|upd)at|renam)e|(?:inser|selec)t|de(?:lete|sc)|alter|load)\\s+(?:group_concat|load_file|char)\\b\\s*\\(?|[\\s(]load_file\\s*?\\(|[\\\"'`]\\s+regexp\\W)",
                options: {
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-942-500",
          name: "MySQL in-line comment detected",
          tags: {
            type: "sql_injection",
            crs_id: "942500",
            category: "attack_attempt",
            cwe: "89",
            capec: "1000/152/248/66",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:/\\*[!+](?:[\\w\\s=_\\-(?:)]+)?\\*/)",
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-943-100",
          name: "Possible Session Fixation Attack: Setting Cookie Values in HTML",
          tags: {
            type: "http_protocol_violation",
            crs_id: "943100",
            category: "attack_attempt",
            cwe: "384",
            capec: "1000/225/21/593/61",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i:\\.cookie\\b.*?;\\W*?(?:expires|domain)\\W*?=|\\bhttp-equiv\\W+set-cookie\\b)",
                options: {
                  case_sensitive: true,
                  min_length: 15
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-944-100",
          name: "Remote Command Execution: Suspicious Java class detected",
          tags: {
            type: "java_code_injection",
            crs_id: "944100",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "java\\.lang\\.(?:runtime|processbuilder)",
                options: {
                  case_sensitive: true,
                  min_length: 17
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-944-110",
          name: "Remote Command Execution: Java process spawn (CVE-2017-9805)",
          tags: {
            type: "java_code_injection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:unmarshaller|base64data|java\\.).*(?:runtime|processbuilder)",
                options: {
                  case_sensitive: false,
                  min_length: 13
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "crs-944-130",
          name: "Suspicious Java class detected",
          tags: {
            type: "java_code_injection",
            crs_id: "944130",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                list: [
                  "com.opensymphony.xwork2",
                  "com.sun.org.apache",
                  "java.io.bufferedinputstream",
                  "java.io.bufferedreader",
                  "java.io.bytearrayinputstream",
                  "java.io.bytearrayoutputstream",
                  "java.io.chararrayreader",
                  "java.io.datainputstream",
                  "java.io.file",
                  "java.io.fileoutputstream",
                  "java.io.filepermission",
                  "java.io.filewriter",
                  "java.io.filterinputstream",
                  "java.io.filteroutputstream",
                  "java.io.filterreader",
                  "java.io.inputstream",
                  "java.io.inputstreamreader",
                  "java.io.linenumberreader",
                  "java.io.objectoutputstream",
                  "java.io.outputstream",
                  "java.io.pipedoutputstream",
                  "java.io.pipedreader",
                  "java.io.printstream",
                  "java.io.pushbackinputstream",
                  "java.io.reader",
                  "java.io.stringreader",
                  "java.lang.class",
                  "java.lang.integer",
                  "java.lang.number",
                  "java.lang.object",
                  "java.lang.process",
                  "java.lang.reflect",
                  "java.lang.runtime",
                  "java.lang.string",
                  "java.lang.stringbuilder",
                  "java.lang.system",
                  "javax.script.scriptenginemanager",
                  "org.apache.commons",
                  "org.apache.struts",
                  "org.apache.struts2",
                  "org.omg.corba",
                  "java.beans.xmldecode"
                ],
                options: {
                  enforce_word_boundary: true
                }
              },
              operator: "phrase_match"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "crs-944-260",
          name: "Remote Command Execution: Malicious class-loading payload",
          tags: {
            type: "java_code_injection",
            crs_id: "944260",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            confidence: "1"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:class\\.module\\.classLoader\\.resources\\.context\\.parent\\.pipeline|springframework\\.context\\.support\\.FileSystemXmlApplicationContext)",
                options: {
                  case_sensitive: true,
                  min_length: 58
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-000-001",
          name: "Look for Cassandra injections",
          tags: {
            type: "nosql_injection",
            category: "attack_attempt",
            cwe: "943",
            capec: "1000/152/248/676",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                regex: "\\ballow\\s+filtering\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeComments"
          ]
        },
        {
          id: "dog-000-002",
          name: "OGNL - Look for formatting injection patterns",
          tags: {
            type: "java_code_injection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                regex: "[#%$]{(?:[^}]+[^\\w\\s}\\-_][^}]+|\\d+-\\d+)}",
                options: {
                  case_sensitive: true
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "dog-000-003",
          name: "OGNL - Detect OGNL exploitation primitives",
          tags: {
            type: "java_code_injection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "[@#]ognl",
                options: {
                  case_sensitive: true
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "dog-000-004",
          name: "Spring4Shell - Attempts to exploit the Spring4shell vulnerability",
          tags: {
            type: "exploit_detection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            confidence: "1"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.body"
                  }
                ],
                regex: "^class\\.module\\.classLoader\\.",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: [
            "keys_only"
          ]
        },
        {
          id: "dog-000-005",
          name: "Node.js: Prototype pollution through __proto__",
          tags: {
            type: "js_code_injection",
            category: "attack_attempt",
            cwe: "1321",
            capec: "1000/152/242",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  }
                ],
                regex: "^__proto__$"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "keys_only"
          ]
        },
        {
          id: "dog-000-006",
          name: "Node.js: Prototype pollution through constructor.prototype",
          tags: {
            type: "js_code_injection",
            category: "attack_attempt",
            cwe: "1321",
            capec: "1000/152/242",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  }
                ],
                regex: "^constructor$"
              },
              operator: "match_regex"
            },
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  }
                ],
                regex: "^prototype$"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "keys_only"
          ]
        },
        {
          id: "dog-000-007",
          name: "Server side template injection: Velocity & Freemarker",
          tags: {
            type: "java_code_injection",
            category: "attack_attempt",
            cwe: "1336",
            capec: "1000/152/242/19",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "#(?:set|foreach|macro|parse|if)\\(.*\\)|<#assign.*>"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-68x",
          name: "xorbot",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "xorbot",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bmasjesu\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-001",
          name: "BurpCollaborator OOB domain",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            tool_name: "BurpCollaborator",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:burpcollaborator\\.net|oastify\\.com)\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-002",
          name: "Qualys OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Qualys",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bqualysperiscope\\.com\\b|\\.oscomm\\."
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-003",
          name: "Probely OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Probely",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bprbly\\.win\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-004",
          name: "Known malicious out-of-band interaction domain",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:webhook\\.site|\\.canarytokens\\.com|vii\\.one|act1on3\\.ru|gdsburp\\.com|arcticwolf\\.net|oob\\.li|htbiw\\.com|h4\\.vc|mochan\\.cloud|imshopping\\.com|bootstrapnodejs\\.com|mooo-ng\\.com|securitytrails\\.com|canyouhackit\\.io|7bae\\.xyz)\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-005",
          name: "Known suspicious out-of-band interaction domain",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:\\.ngrok\\.io|requestbin\\.com|requestbin\\.net)\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-006",
          name: "Rapid7 OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Rapid7",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bappspidered\\.rapid7\\."
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-007",
          name: "Interact.sh OOB domain",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            tool_name: "interact.sh",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:interact\\.sh|oast\\.(?:pro|live|site|online|fun|me)|indusfacefinder\\.in|where\\.land|syhunt\\.net|tssrt\\.de|boardofcyber\\.io|assetnote-callback\\.com|praetorianlabs\\.dev|netspi\\.sh)\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-008",
          name: "Netsparker OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Netsparker",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)?r87(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)(?:me|com)\\b",
                options: {
                  case_sensitive: false,
                  min_length: 7
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-009",
          name: "WhiteHat Security OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "WhiteHatSecurity",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bwhsec(?:\\.|(?:\\\\|&#)(?:0*46|x0*2e);)us\\b",
                options: {
                  case_sensitive: false,
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-010",
          name: "Nessus OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Nessus",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\b\\.nessus\\.org\\b",
                options: {
                  case_sensitive: false,
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-011",
          name: "Watchtowr OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "Watchtowr",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bwatchtowr\\.com\\b",
                options: {
                  case_sensitive: false,
                  min_length: 8
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-012",
          name: "AppCheck NG OOB domain",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            tool_name: "AppCheckNG",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\bptst\\.io\\b",
                options: {
                  case_sensitive: false,
                  min_length: 7
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-013",
          name: "Public PoC for CVE-2025-24813",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "/iSee857/session",
                options: {
                  case_sensitive: false,
                  min_length: 16
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-913-014",
          name: "Exploit attempt for Next.js Middleware Exploit (CVE-2025-29927)",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-middleware-subrequest"
                    ]
                  }
                ],
                regex: ".*",
                options: {
                  min_length: 1
                }
              },
              operator: "match_regex"
            },
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "x-middleware-subrequest"
                    ]
                  }
                ],
                regex: "[0-9a-fA-F]{40}|\\[\\w+\\]"
              },
              operator: "!match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-920-001",
          name: "JWT authentication bypass",
          tags: {
            type: "http_protocol_violation",
            category: "attack_attempt",
            cwe: "287",
            capec: "1000/225/115",
            confidence: "0",
            module: "waf"
          },
          max_version: "1.24.9",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.cookies"
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "authorization"
                    ]
                  }
                ],
                regex: "^(?:Bearer )?ey[A-Za-z0-9+_\\-/]*([QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]IiA6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciIDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgOiJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ij([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IjogI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]IiA6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciIDogI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ciO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[QY][UW]x[Hn]IiA6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ID([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gI[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yIgO([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[\\x2b\\x2f-9A-Za-z]ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*ICJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]I([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*IDoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]A6I[km]5[Pv][Tb][km][U-X]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]y([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiJ[Ou][Tb][02]5[Fl]|[QY][UW]x[Hn]Ijoi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z]{2}[159BFJNRVZdhlptx][Bh][Tb][EG]ci([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[048AEIMQUYcgkosw]gOiAi[Tb][km]9[Ou][RZ][Q-Za-f]|[\\x2b\\x2f-9A-Za-z][02EGUWkm]F[Ms][RZ]yI6([048ACEIMQSUYcgikoswy]|[\\x2b\\x2f-9A-Za-z]I)*[CSiy]Ai[Tb][km]9[Ou][RZ][Q-Za-f])[A-Za-z0-9+-/]*\\.[A-Za-z0-9+_\\-/]+\\.(?:[A-Za-z0-9+_\\-/]+)?$",
                options: {
                  case_sensitive: true
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-931-001",
          name: "RFI: URL Payload to well known RFI target",
          tags: {
            type: "rfi",
            category: "attack_attempt",
            cwe: "98",
            capec: "1000/152/175/253/193",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^(?i:file|ftps?|https?).*/rfiinc\\.txt\\?+$",
                options: {
                  case_sensitive: true,
                  min_length: 17
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-932-100",
          name: "Shell spawn executing network command",
          tags: {
            type: "command_injection",
            category: "attack_attempt",
            cwe: "77",
            capec: "1000/152/248/88",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: `(?:(?:['"\\x60({|;&]|(?:^|['"\\x60({|;&])(?:cmd(?:\\.exe)?\\s+(?:/\\w(?::\\w+)?\\s+)*))(?:ping|curl|wget|telnet)|\\bnslookup)[\\s,]`,
                options: {
                  case_sensitive: true,
                  min_length: 5
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-932-110",
          name: "Python: Subprocess-based command injection",
          tags: {
            type: "command_injection",
            category: "attack_attempt",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?s)\\bsubprocess\\b.*\\b(?:check_output|run|Popen|call|check_call)\\b",
                options: {
                  case_sensitive: true,
                  min_length: 14
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-934-001",
          name: "XXE - XML file loads external entity",
          tags: {
            type: "xxe",
            category: "attack_attempt",
            cwe: "91",
            capec: "1000/152/248/250",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?:<\\?xml[^>]*>.*)<!ENTITY[^>]+SYSTEM\\s+[^>]+>",
                options: {
                  case_sensitive: false,
                  min_length: 24
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "dog-941-001",
          name: "XSS in source property",
          tags: {
            type: "xss",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "referer"
                    ]
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: `<(?:iframe|esi:include)(?:(?:\\s|/)*\\w+=["'\\w]+)*(?:\\s|/)*src(?:doc)?=["']?(?:data:|javascript:|http:|dns:|//)[^\\s'"]+['"]?`,
                options: {
                  min_length: 14
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls",
            "urlDecodeUni"
          ]
        },
        {
          id: "dog-942-001",
          name: "Blind XSS callback domains",
          tags: {
            type: "xss",
            category: "attack_attempt",
            cwe: "83",
            capec: "1000/152/242/63/591/243",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "https?:\\/\\/(?:.*\\.)?(?:bxss\\.(?:in|me)|xss\\.ht|js\\.rip)",
                options: {
                  case_sensitive: false
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-001",
          name: "Detect common directory discovery scans",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "phrase_match",
              parameters: {
                options: {
                  enforce_word_boundary: true
                },
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                list: [
                  "/wordpress/",
                  "/etc/",
                  "/login.php",
                  "/install.php",
                  "/administrator",
                  "/admin.php",
                  "/wp-config",
                  "/phpmyadmin",
                  "/fckeditor",
                  "/mysql",
                  "/manager/html",
                  ".htaccess",
                  "/config.php",
                  "/configuration",
                  "/cgi-bin/php",
                  "/search.php",
                  "/tinymce",
                  "/tiny_mce",
                  "/settings.php",
                  "../../..",
                  "/install/",
                  "/download.php",
                  "/webdav",
                  "/forum.php",
                  "/user.php",
                  "/style.php",
                  "/jmx-console",
                  "/modules.php",
                  "/include.php",
                  "/default.asp",
                  "/help.php",
                  "/database.yml",
                  "/database.yml.pgsql",
                  "/database.yml.sqlite3",
                  "/database.yml.sqlite",
                  "/database.yml.mysql",
                  ".%2e/",
                  "/view.php",
                  "/header.php",
                  "/search.asp",
                  "%5c%5c",
                  "/server/php/",
                  "/invoker/jmxinvokerservlet",
                  "/phpmyadmin/index.php",
                  "/data/admin/allowurl.txt",
                  "/verify.php",
                  "/misc/ajax.js",
                  "/.idea",
                  "/module.php",
                  "/backup.rar",
                  "/backup.tar",
                  "/backup.zip",
                  "/backup.7z",
                  "/backup.gz",
                  "/backup.tgz",
                  "/backup.tar.gz",
                  "waitfor%20delay",
                  "/calendar.php",
                  "/news.php",
                  "/dompdf.php",
                  "))))))))))))))))",
                  "/web.config",
                  "tree.php",
                  "/cgi-bin-sdb/printenv",
                  "/comments.php",
                  "/detail.asp",
                  "/license.txt",
                  "/admin.asp",
                  "/auth.php",
                  "/list.php",
                  "/content.php",
                  "/mod.php",
                  "/mini.php",
                  "/install.pgsql",
                  "/install.mysql",
                  "/install.sqlite",
                  "/install.sqlite3",
                  "/install.txt",
                  "/install.md",
                  "/doku.php",
                  "/main.asp",
                  "/myadmin",
                  "/force-download.php",
                  "/iisprotect/admin",
                  "/.gitignore",
                  "/print.php",
                  "/common.php",
                  "/mainfile.php",
                  "/functions.php",
                  "/scripts/setup.php",
                  "/faq.php",
                  "/op/op.login.php",
                  "/home.php",
                  "/includes/hnmain.inc.php3",
                  "/preview.php",
                  "/dump.rar",
                  "/dump.tar",
                  "/dump.zip",
                  "/dump.7z",
                  "/dump.gz",
                  "/dump.tgz",
                  "/dump.tar.gz",
                  "/thumbnail.php",
                  "/sendcard.php",
                  "/global.asax",
                  "/directory.php",
                  "/footer.php",
                  "/error.asp",
                  "/forum.asp",
                  "/save.php",
                  "/htmlsax3.php",
                  "/adm/krgourl.php",
                  "/includes/converter.inc.php",
                  "/nucleus/libs/pluginadmin.php",
                  "/base_qry_common.php",
                  "/fileadmin",
                  "/bitrix/admin/",
                  "/adm.php",
                  "/util/barcode.php",
                  "/action.php",
                  "/rss.asp",
                  "/downloads.php",
                  "/page.php",
                  "/snarf_ajax.php",
                  "/fck/editor",
                  "/sendmail.php",
                  "/detail.php",
                  "/iframe.php",
                  "/swfupload.swf",
                  "/jenkins/login",
                  "/phpmyadmin/main.php",
                  "/phpmyadmin/scripts/setup.php",
                  "/user/index.php",
                  "/checkout.php",
                  "/process.php",
                  "/ks_inc/ajax.js",
                  "/export.php",
                  "/register.php",
                  "/cart.php",
                  "/console.php",
                  "/friend.php",
                  "/readmsg.php",
                  "/install.asp",
                  "/dagent/downloadreport.asp",
                  "/system/index.php",
                  "/core/changelog.txt",
                  "/js/util.js",
                  "/interna.php",
                  "/gallery.php",
                  "/links.php",
                  "/data/admin/ver.txt",
                  "/language/zh-cn.xml",
                  "/productdetails.asp",
                  "/admin/template/article_more/config.htm",
                  "/components/com_moofaq/includes/file_includer.php",
                  "/licence.txt",
                  "/rss.xsl",
                  "/vtigerservice.php",
                  "/mysql/main.php",
                  "/passwiki.php",
                  "/scr/soustab.php",
                  "/global.php",
                  "/email.php",
                  "/user.asp",
                  "/msd",
                  "/products.php",
                  "/cultbooking.php",
                  "/cron.php",
                  "/static/js/admincp.js",
                  "/comment.php",
                  "/maintainers",
                  "/modules/plain/adminpart/addplain.php",
                  "/wp-content/plugins/ungallery/source_vuln.php",
                  "/upgrade.txt",
                  "/category.php",
                  "/index_logged.php",
                  "/members.asp",
                  "/script/html.js",
                  "/images/ad.js",
                  "/awstats/awstats.pl",
                  "/includes/esqueletos/skel_null.php",
                  "/modules/profile/user.php",
                  "/window_top.php",
                  "/openbrowser.php",
                  "/thread.php",
                  "tinfoil_xss",
                  "/includes/include.php",
                  "/urheber.php",
                  "/header.inc.php",
                  "/mysqldumper",
                  "/display.php",
                  "/website.php",
                  "/stats.php",
                  "/assets/plugins/mp3_id/mp3_id.php",
                  "/siteminderagent/forms/smpwservices.fcc",
                  "/eval-stdin.php"
                ]
              }
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "nfd-000-002",
          name: "Detect failed attempt to fetch readme files",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "readme\\.[\\.a-z0-9]+$",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-003",
          name: "Detect failed attempt to fetch Java EE resource files",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "^(?:.*web\\-inf)(?:.*web\\.xml).*$",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-004",
          name: "Detect failed attempt to fetch code files",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "\\.(java|pyc?|rb|class)\\b",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-005",
          name: "Detect failed attempt to fetch source code archives",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "\\.(sql|log|ndb|gz|zip|tar\\.gz|tar|regVV|reg|conf|bz2|ini|db|war|bat|inc|btr|server|ds|conf|config|admin|master|sln|bak)\\b(?:[^.]|$)",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-006",
          name: "Detect failed attempt to fetch sensitive files",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "\\.(cgi|bat|dll|exe|key|cert|crt|pem|der|pkcs|pkcs|pkcs[0-9]*|nsf|jsa|war|java|class|vb|vba|so|git|svn|hg|cvs)([?#&/]|$)",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-007",
          name: "Detect failed attempt to fetch archives",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "/[\\d\\-_]*\\.(rar|tar|zip|7z|gz|tgz|tar.gz)",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-008",
          name: "Detect failed attempt to trigger incorrect application behavior",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "(/(administrator/components/com.*\\.php|response\\.write\\(.+\\))|select\\(.+\\)from|\\(.*sleep\\(.+\\)|(%[a-zA-Z0-9]{2}[a-zA-Z]{0,1})+\\))",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-009",
          name: "Detect failed attempt to leak the structure of the application",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "/(login\\.rol|LICENSE|[\\w-]+\\.(plx|pwd))$",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "nfd-000-010",
          name: "Detect failed attempts to find API documentation",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.response.status"
                  }
                ],
                regex: "^404$",
                options: {
                  case_sensitive: true
                }
              }
            },
            {
              operator: "match_regex",
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                regex: "(?:^|/)(?:swagger|api[-/]?docs?|openapi)\\b",
                options: {
                  case_sensitive: false
                }
              }
            }
          ],
          transformers: []
        },
        {
          id: "rasp-930-100",
          name: "Local file inclusion exploit",
          tags: {
            type: "lfi",
            category: "vulnerability_trigger",
            cwe: "22",
            capec: "1000/255/153/126",
            confidence: "1",
            module: "rasp"
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: "server.io.fs.file"
                  }
                ],
                params: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ]
              },
              operator: "lfi_detector@v2"
            }
          ],
          transformers: [],
          on_match: [
            "stack_trace"
          ]
        },
        {
          id: "rasp-932-100",
          name: "Shell command injection exploit",
          tags: {
            type: "command_injection",
            category: "vulnerability_trigger",
            cwe: "77",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "rasp"
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: "server.sys.shell.cmd"
                  }
                ],
                params: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ]
              },
              operator: "shi_detector"
            }
          ],
          transformers: [],
          on_match: [
            "stack_trace"
          ]
        },
        {
          id: "rasp-932-110",
          name: "OS command injection exploit",
          tags: {
            type: "command_injection",
            category: "vulnerability_trigger",
            cwe: "77",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "rasp"
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: "server.sys.exec.cmd"
                  }
                ],
                params: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ]
              },
              operator: "cmdi_detector"
            }
          ],
          transformers: [],
          on_match: [
            "stack_trace"
          ]
        },
        {
          id: "rasp-934-100",
          name: "Server-side request forgery exploit",
          tags: {
            type: "ssrf",
            category: "vulnerability_trigger",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "0",
            module: "rasp"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.io.net.url"
                  }
                ],
                regex: "^(jar:)?https?:\\/\\/\\W*([0-9oq]{1,5}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|[0-9]{1,10}|(\\[)?[:0-9a-f\\.x]{2,}(\\])?|metadata\\.google\\.internal|(?:[a-z0-9:@\\.\\-]*\\.)?(?:burpcollaborator\\.net|localtest\\.me|mail\\.ebc\\.apple\\.com|bugbounty\\.dod\\.network|.*\\.[nx]ip\\.io|oastify\\.com|oast\\.(?:pro|live|site|online|fun|me)|sslip\\.io|requestbin\\.com|requestbin\\.net|hookbin\\.com|webhook\\.site|canarytokens\\.com|interact\\.sh|ngrok\\.io|bugbounty\\.click|prbly\\.win|qualysperiscope\\.com|vii\\.one|act1on3\\.ru|ifconfig\\.pro|dnslog\\.\\w+))(:[0-9]{1,5})?(\\/[^:@]*)?$",
                options: {
                  case_sensitive: false
                }
              },
              operator: "match_regex"
            },
            {
              parameters: {
                resource: [
                  {
                    address: "server.io.net.url"
                  }
                ],
                params: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                options: {
                  "path-inspection": true
                }
              },
              operator: "ssrf_detector"
            }
          ],
          transformers: [],
          on_match: [
            "stack_trace"
          ]
        },
        {
          id: "rasp-942-100",
          name: "SQL injection exploit",
          tags: {
            type: "sql_injection",
            category: "vulnerability_trigger",
            cwe: "89",
            capec: "1000/152/248/66",
            confidence: "1",
            module: "rasp"
          },
          conditions: [
            {
              parameters: {
                resource: [
                  {
                    address: "server.db.statement"
                  }
                ],
                params: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                db_type: [
                  {
                    address: "server.db.system"
                  }
                ]
              },
              operator: "sqli_detector@v2"
            }
          ],
          transformers: [],
          on_match: [
            "stack_trace"
          ]
        },
        {
          id: "sqr-000-001",
          name: "SSRF: Try to access the credential manager of the main cloud services",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i)^\\W*((http|ftp)s?://)?\\W*((::f{4}:)?(169|(0x)?0*a9|0+251)\\.?(254|(0x)?0*fe|0+376)[0-9a-fx\\.:]+|metadata\\.google\\.internal|metadata\\.goog)\\W*/",
                options: {
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "sqr-000-002",
          name: "Server-side Javascript injection: Try to detect obvious JS injection",
          tags: {
            type: "js_code_injection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: `require\\(['"][\\w\\.]+['"]\\)|process\\.\\w+\\([\\w\\.]*\\)|\\.toString\\(\\)`,
                options: {
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "removeNulls"
          ]
        },
        {
          id: "sqr-000-008",
          name: "Windows: Detect attempts to exfiltrate .ini files",
          tags: {
            type: "command_injection",
            category: "attack_attempt",
            cwe: "78",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i)[&|]\\s*type\\s+%\\w+%\\\\+\\w+\\.ini\\s*[&|]"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "sqr-000-009",
          name: "Linux: Detect attempts to exfiltrate passwd files",
          tags: {
            type: "command_injection",
            category: "attack_attempt",
            cwe: "78",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i)[&|]\\s*cat\\s*\\/etc\\/[\\w\\.\\/]*passwd\\s*[&|]"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "cmdLine"
          ]
        },
        {
          id: "sqr-000-010",
          name: "Windows: Detect attempts to timeout a shell",
          tags: {
            type: "command_injection",
            category: "attack_attempt",
            cwe: "78",
            capec: "1000/152/248/88",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(?i)[&|]\\s*timeout\\s+/t\\s+\\d+\\s*[&|]"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "sqr-000-011",
          name: "SSRF: Try to access internal OMI service (CVE-2021-38647)",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "http(s?):\\/\\/([A-Za-z0-9\\.\\-\\_]+|\\[[A-Fa-f0-9\\:]+\\]|):5986\\/wsman",
                options: {
                  min_length: 4
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "sqr-000-012",
          name: "SSRF: Detect SSRF attempt on internal service",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^(jar:)?(http|https):\\/\\/([0-9oq]{1,5}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}|[0-9]{1,10})(:[0-9]{1,5})?(\\/[^:@]*)?$"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "sqr-000-013",
          name: "SSRF: Detect SSRF attempts using IPv6 or octal/hexdecimal obfuscation",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^(jar:)?(http|https):\\/\\/((\\[)?[:0-9a-f\\.x]{2,}(\\])?)(:[0-9]{1,5})?(\\/[^:@]*)?$"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "sqr-000-014",
          name: "SSRF: Detect SSRF domain redirection bypass",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "grpc.server.request.message"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "(http|https):\\/\\/(?:.*\\.)?(?:burpcollaborator\\.net|localtest\\.me|mail\\.ebc\\.apple\\.com|bugbounty\\.dod\\.network|.*\\.[nx]ip\\.io|oastify\\.com|oast\\.(?:pro|live|site|online|fun|me)|sslip\\.io|requestbin\\.com|requestbin\\.net|hookbin\\.com|webhook\\.site|canarytokens\\.com|interact\\.sh|ngrok\\.io|bugbounty\\.click|prbly\\.win|qualysperiscope\\.com|vii\\.one|act1on3\\.ru|dnslog\\.\\w+)"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "sqr-000-015",
          name: "SSRF: Detect SSRF attempt using non HTTP protocol",
          tags: {
            type: "ssrf",
            category: "attack_attempt",
            cwe: "918",
            capec: "1000/225/115/664",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "^(jar:)?((file|netdoc):\\/\\/[\\\\\\/]+|(dict|gopher|ldap|sftp|tftp):\\/\\/.*:[0-9]{1,5})"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "lowercase"
          ]
        },
        {
          id: "sqr-000-017",
          name: "Log4shell: Attempt to exploit log4j CVE-2021-44228",
          tags: {
            type: "exploit_detection",
            category: "attack_attempt",
            cwe: "94",
            capec: "1000/152/242",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.uri.raw"
                  },
                  {
                    address: "server.request.query"
                  },
                  {
                    address: "server.request.body"
                  },
                  {
                    address: "server.request.path_params"
                  },
                  {
                    address: "server.request.headers.no_cookies"
                  },
                  {
                    address: "graphql.server.all_resolvers"
                  },
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                regex: "\\${[^j]*j[^n]*n[^d]*d[^i]*i[^:]*:[^}]*}"
              },
              operator: "match_regex"
            }
          ],
          transformers: [
            "unicode_normalize"
          ]
        },
        {
          id: "ua0-600-0xx",
          name: "Joomla exploitation tool",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Joomla exploitation tool",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "JDatabaseDriverMysqli"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-10x",
          name: "Nessus",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nessus",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)^Nessus(/|([ :]+SOAP))"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-12x",
          name: "Arachni",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Arachni",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^Arachni\\/v"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-13x",
          name: "Jorgee",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Jorgee",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bJorgee\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-14x",
          name: "Probely",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Probely",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bProbely\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-15x",
          name: "Metis",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Metis",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bmetis\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-16x",
          name: "SQL power injector",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "SQLPowerInjector",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "sql power injector"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-18x",
          name: "N-Stealth",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "N-Stealth",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bn-stealth\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-19x",
          name: "Brutus",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Brutus",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bbrutus\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-1xx",
          name: "Shellshock exploitation tool",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\(\\) \\{ :; *\\}"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-20x",
          name: "Netsparker",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Netsparker",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bnetsparker\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-22x",
          name: "JAASCois",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "JAASCois",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bjaascois\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-26x",
          name: "Nsauditor",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nsauditor",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bnsauditor\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-27x",
          name: "Paros",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Paros",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)Mozilla/.* Paros/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-28x",
          name: "DirBuster",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "DirBuster",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bdirbuster\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-29x",
          name: "Pangolin",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Pangolin",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bpangolin\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-2xx",
          name: "Qualys",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Qualys",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bqualys\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-30x",
          name: "SQLNinja",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "SQLNinja",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bsqlninja\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-31x",
          name: "Nikto",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nikto",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\(Nikto/[\\d\\.]+\\)"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-33x",
          name: "BlackWidow",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "BlackWidow",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bblack\\s?widow\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-34x",
          name: "Grendel-Scan",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Grendel-Scan",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bgrendel-scan\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-35x",
          name: "Havij",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Havij",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bhavij\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-36x",
          name: "w3af",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "w3af",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bw3af\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-37x",
          name: "Nmap",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nmap",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "nmap (nse|scripting engine|icap-client/)"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-39x",
          name: "Nessus Scripted",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nessus",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)^'?[a-z0-9_]+\\.nasl'?$"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-3xx",
          name: "Evil Scanner",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "EvilScanner",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bevilScanner\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-40x",
          name: "WebFuck",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "WebFuck",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bWebFuck\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-42x",
          name: "OpenVAS",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "OpenVAS",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)OpenVAS\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-43x",
          name: "Spider-Pig",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Spider-Pig",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "Powered by Spider-Pig by tinfoilsecurity\\.com"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-44x",
          name: "Zgrab",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Zgrab",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "Mozilla/\\d+.\\d+ zgrab"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-45x",
          name: "Zmeu",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Zmeu",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bZmEu\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-47x",
          name: "GoogleSecurityScanner",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "GoogleSecurityScanner",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bGoogleSecurityScanner\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-48x",
          name: "Commix",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Commix",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^commix\\/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-49x",
          name: "Gobuster",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Gobuster",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^gobuster\\/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-4xx",
          name: "CGIchk",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "CGIchk",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bcgichk\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-51x",
          name: "FFUF",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "FFUF",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)^Fuzz Faster U Fool\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-52x",
          name: "Nuclei",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nuclei",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)^Nuclei\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-53x",
          name: "Tsunami",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Tsunami",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bTsunamiSecurityScanner\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-54x",
          name: "Nimbostratus",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Nimbostratus",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bnimbostratus-bot\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-55x",
          name: "Datadog test scanner: user-agent",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Datadog Canary Test",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "grpc.server.request.metadata",
                    key_path: [
                      "dd-canary"
                    ]
                  }
                ],
                regex: "^dd-test-scanner-log(?:$|/|\\s)"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-56x",
          name: "Datadog test scanner - blocking version: user-agent",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Datadog Canary Test",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "grpc.server.request.metadata",
                    key_path: [
                      "dd-canary"
                    ]
                  }
                ],
                regex: "^dd-test-scanner-log-block(?:$|/|\\s)"
              },
              operator: "match_regex"
            }
          ],
          transformers: [],
          on_match: [
            "block"
          ]
        },
        {
          id: "ua0-600-57x",
          name: "AlertLogic",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "AlertLogic",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bAlertLogic-MDR-"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-58x",
          name: "wfuzz",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "wfuzz",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bwfuzz\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-59x",
          name: "Detectify",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Detectify",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bdetectify\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-5xx",
          name: "Blind SQL Injection Brute Forcer",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "BSQLBF",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)\\bbsqlbf\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-60x",
          name: "masscan",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "masscan",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^masscan/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-61x",
          name: "WPScan",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "WPScan",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^wpscan\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-62x",
          name: "Aon pentesting services",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Aon",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^Aon/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-63x",
          name: "FeroxBuster",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "feroxbuster",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^feroxbuster/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-64x",
          name: "ddg_win",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "ddg_win",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bddg_win\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-65x",
          name: "ISS",
          tags: {
            type: "commercial_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "iss",
            confidence: "0",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bisscyberriskcrawler/\\d\\.\\d"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-66x",
          name: "BountyBot",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "bountybot",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bbountybot\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-67x",
          name: "ZumBot",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "zumbot",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "\\bzumbot\\b"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-6xx",
          name: "Stealthy scanner",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "mozilla/4\\.0 \\(compatible(; msie (?:6\\.0; (?:win32|Windows NT 5\\.0)|4\\.0; Windows NT))?\\)",
                options: {
                  case_sensitive: false
                }
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-7xx",
          name: "SQLmap",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "SQLmap",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "^sqlmap/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        },
        {
          id: "ua0-600-9xx",
          name: "Skipfish",
          tags: {
            type: "attack_tool",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Skipfish",
            confidence: "1",
            module: "waf"
          },
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  }
                ],
                regex: "(?i)mozilla/5\\.0 sf/"
              },
              operator: "match_regex"
            }
          ],
          transformers: []
        }
      ],
      rules_compat: [
        {
          id: "api-001-100",
          name: "JWT: No expiry is present",
          tags: {
            type: "jwt",
            category: "api_security",
            confidence: "0",
            module: "business-logic"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.jwt",
                    key_path: [
                      "payload",
                      "exp"
                    ]
                  }
                ]
              },
              operator: "!exists"
            }
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              "_dd.appsec.api.jwt.no_expiry": {
                value: 1
              }
            }
          }
        },
        {
          id: "api-001-110",
          name: "JWT: Collect algorithm used",
          tags: {
            type: "jwt",
            category: "api_security",
            confidence: "0",
            module: "business-logic"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.jwt",
                    key_path: [
                      "header",
                      "alg"
                    ]
                  }
                ]
              },
              operator: "exists"
            }
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              "_dd.appsec.api.jwt_alg": {
                address: "server.request.jwt",
                key_path: [
                  "header",
                  "alg"
                ]
              }
            }
          }
        },
        {
          id: "api-001-120",
          name: "JWT: No audience is specified",
          tags: {
            type: "jwt",
            category: "api_security",
            confidence: "0",
            module: "business-logic"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.jwt",
                    key_path: [
                      "payload",
                      "aud"
                    ]
                  }
                ]
              },
              operator: "!exists"
            }
          ],
          transformers: [],
          output: {
            event: false,
            keep: false,
            attributes: {
              "_dd.appsec.api.jwt.no_audience": {
                value: 1
              }
            }
          }
        },
        {
          id: "api-001-130",
          name: "JWT: None algorithm used",
          tags: {
            type: "jwt",
            category: "api_security",
            confidence: "0",
            module: "business-logic"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.jwt",
                    key_path: [
                      "header",
                      "alg"
                    ]
                  }
                ],
                list: [
                  "none",
                  "nonE",
                  "noNe",
                  "noNE",
                  "nOne",
                  "nOnE",
                  "nONe",
                  "nONE",
                  "None",
                  "NonE",
                  "NoNe",
                  "NoNE",
                  "NOne",
                  "NOnE",
                  "NONe",
                  "NONE"
                ]
              },
              operator: "exact_match"
            }
          ],
          transformers: [],
          output: {
            event: false,
            keep: true,
            attributes: {
              "_dd.appsec.api.jwt.none_alg": {
                value: 1
              }
            }
          }
        },
        {
          id: "ua0-600-551",
          name: "Datadog test scanner - scalar trace-tagging version: user-agent",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Datadog Canary Test",
            confidence: "1",
            module: "waf"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "grpc.server.request.metadata",
                    key_path: [
                      "dd-canary"
                    ]
                  }
                ],
                regex: "^dd-test-scanner-tag-scalar(?:$|/|\\s)"
              },
              operator: "match_regex"
            }
          ],
          transformers: [],
          output: {
            event: false,
            attributes: {
              "_dd.appsec.test.scanner.scalar": {
                value: 1
              }
            }
          }
        },
        {
          id: "ua0-600-552",
          name: "Datadog test scanner - reference trace-tagging version: user-agent",
          tags: {
            type: "security_scanner",
            category: "attack_attempt",
            cwe: "200",
            capec: "1000/118/169",
            tool_name: "Datadog Canary Test",
            confidence: "1",
            module: "waf"
          },
          min_version: "1.25.0",
          conditions: [
            {
              parameters: {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "user-agent"
                    ]
                  },
                  {
                    address: "grpc.server.request.metadata",
                    key_path: [
                      "dd-canary"
                    ]
                  }
                ],
                regex: "^dd-test-scanner-tag-ref(?:$|/|\\s)"
              },
              operator: "match_regex"
            }
          ],
          transformers: [],
          output: {
            event: false,
            attributes: {
              "_dd.appsec.test.scanner.reference": {
                address: "server.request.headers.no_cookies",
                key_path: [
                  "user-agent"
                ]
              }
            }
          }
        }
      ],
      processors: [
        {
          id: "http-endpoint-fingerprint",
          generator: "http_endpoint_fingerprint",
          conditions: [],
          parameters: {
            mappings: [
              {
                method: [
                  {
                    address: "server.request.method"
                  }
                ],
                uri_raw: [
                  {
                    address: "server.request.uri.raw"
                  }
                ],
                body: [
                  {
                    address: "server.request.body"
                  }
                ],
                query: [
                  {
                    address: "server.request.query"
                  }
                ],
                output: "_dd.appsec.fp.http.endpoint"
              }
            ]
          },
          evaluate: true,
          output: true
        },
        {
          id: "extract-content",
          generator: "extract_schema",
          conditions: [
            {
              operator: "equals",
              parameters: {
                inputs: [
                  {
                    address: "waf.context.processor",
                    key_path: [
                      "extract-schema"
                    ]
                  }
                ],
                type: "boolean",
                value: true
              }
            }
          ],
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: "server.request.body"
                  }
                ],
                output: "_dd.appsec.s.req.body"
              },
              {
                inputs: [
                  {
                    address: "server.request.cookies"
                  }
                ],
                output: "_dd.appsec.s.req.cookies"
              },
              {
                inputs: [
                  {
                    address: "server.request.query"
                  }
                ],
                output: "_dd.appsec.s.req.query"
              },
              {
                inputs: [
                  {
                    address: "server.request.path_params"
                  }
                ],
                output: "_dd.appsec.s.req.params"
              },
              {
                inputs: [
                  {
                    address: "server.response.body"
                  }
                ],
                output: "_dd.appsec.s.res.body"
              },
              {
                inputs: [
                  {
                    address: "graphql.server.all_resolvers"
                  }
                ],
                output: "_dd.appsec.s.graphql.all_resolvers"
              },
              {
                inputs: [
                  {
                    address: "graphql.server.resolver"
                  }
                ],
                output: "_dd.appsec.s.graphql.resolver"
              }
            ],
            scanners: [
              {
                tags: {
                  category: "payment"
                }
              },
              {
                tags: {
                  category: "pii"
                }
              }
            ]
          },
          evaluate: false,
          output: true
        },
        {
          id: "extract-headers",
          generator: "extract_schema",
          conditions: [
            {
              operator: "equals",
              parameters: {
                inputs: [
                  {
                    address: "waf.context.processor",
                    key_path: [
                      "extract-schema"
                    ]
                  }
                ],
                type: "boolean",
                value: true
              }
            }
          ],
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                output: "_dd.appsec.s.req.headers"
              },
              {
                inputs: [
                  {
                    address: "server.response.headers.no_cookies"
                  }
                ],
                output: "_dd.appsec.s.res.headers"
              }
            ],
            scanners: [
              {
                tags: {
                  category: "credentials"
                }
              },
              {
                tags: {
                  category: "pii"
                }
              }
            ]
          },
          evaluate: false,
          output: true
        },
        {
          id: "http-header-fingerprint",
          generator: "http_header_fingerprint",
          conditions: [],
          parameters: {
            mappings: [
              {
                headers: [
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                output: "_dd.appsec.fp.http.header"
              }
            ]
          },
          evaluate: true,
          output: true
        },
        {
          id: "decode-auth-jwt",
          generator: "jwt_decode",
          min_version: "1.25.0",
          parameters: {
            mappings: [
              {
                inputs: [
                  {
                    address: "server.request.headers.no_cookies",
                    key_path: [
                      "authorization"
                    ]
                  }
                ],
                output: "server.request.jwt"
              }
            ]
          },
          evaluate: true,
          output: false
        },
        {
          id: "http-network-fingerprint",
          generator: "http_network_fingerprint",
          conditions: [],
          parameters: {
            mappings: [
              {
                headers: [
                  {
                    address: "server.request.headers.no_cookies"
                  }
                ],
                output: "_dd.appsec.fp.http.network"
              }
            ]
          },
          evaluate: true,
          output: true
        },
        {
          id: "session-fingerprint",
          generator: "session_fingerprint",
          conditions: [],
          parameters: {
            mappings: [
              {
                cookies: [
                  {
                    address: "server.request.cookies"
                  }
                ],
                session_id: [
                  {
                    address: "usr.session_id"
                  }
                ],
                user_id: [
                  {
                    address: "usr.id"
                  }
                ],
                output: "_dd.appsec.fp.session"
              }
            ]
          },
          evaluate: true,
          output: true
        }
      ],
      scanners: [
        {
          id: "406f8606-52c4-4663-8db9-df70f9e8766c",
          name: "ZIP Code",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:zip|postal)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "^[0-9]{5}(?:-[0-9]{4})?$",
              options: {
                case_sensitive: true,
                min_length: 5
              }
            }
          },
          tags: {
            type: "zipcode",
            category: "address"
          }
        },
        {
          id: "JU1sRk3mSzqSUJn6GrVn7g",
          name: "American Express Card Scanner (4+4+4+3 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b3[47]\\d{2}(?:(?:\\s\\d{4}\\s\\d{4}\\s\\d{3})|(?:\\,\\d{4}\\,\\d{4}\\,\\d{3})|(?:-\\d{4}-\\d{4}-\\d{3})|(?:\\.\\d{4}\\.\\d{4}\\.\\d{3}))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "amex",
            category: "payment"
          }
        },
        {
          id: "edmH513UTQWcRiQ9UnzHlw-mod",
          name: "American Express Card Scanner (4+6|5+5|6 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b3[47]\\d{2}(?:(?:\\s\\d{5,6}\\s\\d{5,6})|(?:\\.\\d{5,6}\\.\\d{5,6})|(?:-\\d{5,6}-\\d{5,6})|(?:,\\d{5,6},\\d{5,6}))\\b",
              options: {
                case_sensitive: false,
                min_length: 17
              }
            }
          },
          tags: {
            type: "card",
            card_type: "amex",
            category: "payment"
          }
        },
        {
          id: "e6K4h_7qTLaMiAbaNXoSZA",
          name: "American Express Card Scanner (8+7 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b3[47]\\d{6}(?:(?:\\s\\d{7})|(?:\\,\\d{7})|(?:-\\d{7})|(?:\\.\\d{7}))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "amex",
            category: "payment"
          }
        },
        {
          id: "K2rZflWzRhGM9HiTc6whyQ",
          name: "American Express Card Scanner (1x15 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b3[47]\\d{13}\\b",
              options: {
                case_sensitive: false,
                min_length: 15
              }
            }
          },
          tags: {
            type: "card",
            card_type: "amex",
            category: "payment"
          }
        },
        {
          id: "9d7756e343cefa22a5c098e1092590f806eb5446",
          name: "Basic Authentication Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bauthorization\\b",
              options: {
                case_sensitive: false,
                min_length: 13
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "^basic\\s+[A-Za-z0-9+/=]+",
              options: {
                case_sensitive: false,
                min_length: 7
              }
            }
          },
          tags: {
            type: "basic_auth",
            category: "credentials"
          }
        },
        {
          id: "mZy8XjZLReC9smpERXWnnw",
          name: "Bearer Authentication Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bauthorization\\b",
              options: {
                case_sensitive: false,
                min_length: 13
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "^bearer\\s+[-a-z0-9._~+/]{4,}",
              options: {
                case_sensitive: false,
                min_length: 11
              }
            }
          },
          tags: {
            type: "bearer_token",
            category: "credentials"
          }
        },
        {
          id: "450239afc250a19799b6c03dc0e16fd6a4b2a1af",
          name: "Canadian Social Insurance Number Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:social[\\s_]?(?:insurance(?:\\s+number)?)?|SIN|Canadian[\\s_]?(?:social[\\s_]?(?:insurance)?|insurance[\\s_]?number)?)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b\\d{3}-\\d{3}-\\d{3}\\b",
              options: {
                case_sensitive: false,
                min_length: 11
              }
            }
          },
          tags: {
            type: "canadian_sin",
            category: "pii"
          }
        },
        {
          id: "87a879ff33693b46c8a614d8211f5a2c289beca0",
          name: "Digest Authentication Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bauthorization\\b",
              options: {
                case_sensitive: false,
                min_length: 13
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "^digest\\s+",
              options: {
                case_sensitive: false,
                min_length: 7
              }
            }
          },
          tags: {
            type: "digest_auth",
            category: "credentials"
          }
        },
        {
          id: "qWumeP1GQUa_E4ffAnT-Yg",
          name: "American Express Card Scanner (1x14 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "(?:30[0-59]\\d|3[689]\\d{2})(?:\\d{10})",
              options: {
                case_sensitive: false,
                min_length: 14
              }
            }
          },
          tags: {
            type: "card",
            card_type: "diners",
            category: "payment"
          }
        },
        {
          id: "NlTWWM5LS6W0GSqBLuvtRw",
          name: "Diners Card Scanner (4+4+4+2 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:30[0-59]\\d|3[689]\\d{2})(?:(?:\\s\\d{4}\\s\\d{4}\\s\\d{2})|(?:\\,\\d{4}\\,\\d{4}\\,\\d{2})|(?:-\\d{4}-\\d{4}-\\d{2})|(?:\\.\\d{4}\\.\\d{4}\\.\\d{2}))\\b",
              options: {
                case_sensitive: false,
                min_length: 17
              }
            }
          },
          tags: {
            type: "card",
            card_type: "diners",
            category: "payment"
          }
        },
        {
          id: "Xr5VdbQSTXitYGGiTfxBpw",
          name: "Diners Card Scanner (4+6+4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:30[0-59]\\d|3[689]\\d{2})(?:(?:\\s\\d{6}\\s\\d{4})|(?:\\.\\d{6}\\.\\d{4})|(?:-\\d{6}-\\d{4})|(?:,\\d{6},\\d{4}))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "diners",
            category: "payment"
          }
        },
        {
          id: "gAbunN_WQNytxu54DjcbAA-mod",
          name: "Diners Card Scanner (8+6 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:30[0-59]\\d{5}|3[689]\\d{6})\\s?(?:(?:\\s\\d{6})|(?:\\,\\d{6})|(?:-\\d{6})|(?:\\.\\d{6}))\\b",
              options: {
                case_sensitive: false,
                min_length: 14
              }
            }
          },
          tags: {
            type: "card",
            card_type: "diners",
            category: "payment"
          }
        },
        {
          id: "9cs4qCfEQBeX17U7AepOvQ",
          name: "MasterCard Scanner (2x8 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:6221(?:2[6-9]|[3-9][0-9])\\d{2}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8})|6229(?:[01][0-9]|2[0-5])\\d{2}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8})|(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])\\d{4}(?:,\\d{8}|\\s\\d{8}|-\\d{8}|\\.\\d{8}))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "discover",
            category: "payment"
          }
        },
        {
          id: "YBIDWJIvQWW_TFOyU0CGJg",
          name: "Discover Card Scanner (4x4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:(?:(?:6221(?:2[6-9]|[3-9][0-9])\\d{2}(?:,\\d{4}){2})|(?:6221\\s(?:2[6-9]|[3-9][0-9])\\d{2}(?:\\s\\d{4}){2})|(?:6221\\.(?:2[6-9]|[3-9][0-9])\\d{2}(?:\\.\\d{4}){2})|(?:6221-(?:2[6-9]|[3-9][0-9])\\d{2}(?:-\\d{4}){2}))|(?:(?:6229(?:[01][0-9]|2[0-5])\\d{2}(?:,\\d{4}){2})|(?:6229\\s(?:[01][0-9]|2[0-5])\\d{2}(?:\\s\\d{4}){2})|(?:6229\\.(?:[01][0-9]|2[0-5])\\d{2}(?:\\.\\d{4}){2})|(?:6229-(?:[01][0-9]|2[0-5])\\d{2}(?:-\\d{4}){2}))|(?:(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "discover",
            category: "payment"
          }
        },
        {
          id: "12cpbjtVTMaMutFhh9sojQ",
          name: "Discover Card Scanner (1x16 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:6221(?:2[6-9]|[3-9][0-9])\\d{10}|6229(?:[01][0-9]|2[0-5])\\d{10}|(?:6011|65\\d{2}|64[4-9]\\d|622[2-8])\\d{12})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "discover",
            category: "payment"
          }
        },
        {
          id: "PuXiVTCkTHOtj0Yad1ppsw",
          name: "Standard E-mail Address",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:(?:e[-\\s]?)?mail|address|sender|\\bto\\b|from|recipient)\\b",
              options: {
                case_sensitive: false,
                min_length: 2
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b[\\w!#$%&'*+/=?`{|}~^-]+(?:\\.[\\w!#$%&'*+/=?`{|}~^-]+)*(%40|@)(?:[a-zA-Z0-9-]+\\.)+[a-zA-Z]{2,6}\\b",
              options: {
                case_sensitive: false,
                min_length: 5
              }
            }
          },
          tags: {
            type: "email",
            category: "pii"
          }
        },
        {
          id: "8VS2RKxzR8a_95L5fuwaXQ",
          name: "IBAN",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:iban|account|sender|receiver)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:NO\\d{2}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{3}|BE\\d{2}(?:[ \\-]?\\d{4}){3}|(?:DK|FO|FI|GL|SD)\\d{2}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|NL\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{2}|MK\\d{2}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]\\d{2}|SI\\d{17}|(?:AT|BA|EE|LT|XK)\\d{18}|(?:LU|KZ|EE|LT)\\d{5}[A-Z0-9]{13}|LV\\d{2}[A-Z]{4}[A-Z0-9]{13}|(?:LI|CH)\\d{2}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]|HR\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d|GE\\d{2}[ \\-]?[A-Z0-9]{2}\\d{2}\\d{14}|VA\\d{20}|BG\\d{2}[A-Z]{4}\\d{6}[A-Z0-9]{8}|BH\\d{2}[A-Z]{4}[A-Z0-9]{14}|GB\\d{2}[A-Z]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|IE\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{2}|(?:CR|DE|ME|RS)\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d{2}|(?:AE|TL|IL)\\d{2}(?:[ \\-]?\\d{4}){4}[ \\-]?\\d{3}|GI\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){3}[ \\-]?[A-Z0-9]{3}|IQ\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){3}[ \\-]?\\d{3}|MD\\d{2}(?:[ \\-]?[A-Z0-9]{4}){5}|SA\\d{2}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){4}|RO\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){4}|(?:PK|VG)\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){4}|AD\\d{2}(?:[ \\-]?\\d{4}){2}(?:[ \\-]?[A-Z0-9]{4}){3}|(?:CZ|SK|ES|SE|TN)\\d{2}(?:[ \\-]?\\d{4}){5}|(?:LY|PT|ST)\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d|TR\\d{2}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{4}){3}[ \\-]?[A-Z0-9]{2}|IS\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{2}|(?:IT|SM)\\d{2}[ \\-]?[A-Z]\\d{3}[ \\-]?\\d{4}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]{3}|GR\\d{2}[ \\-]?\\d{4}[ \\-]?\\d{3}[A-Z0-9](?:[ \\-]?[A-Z0-9]{4}){3}[A-Z0-9]{3}|(?:FR|MC)\\d{2}(?:[ \\-]?\\d{4}){2}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){2}[ \\-]?[A-Z0-9]\\d{2}|MR\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{3}|(?:SV|DO)\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){5}|BY\\d{2}[ \\-]?[A-Z]{4}[ \\-]?\\d{4}(?:[ \\-]?[A-Z0-9]{4}){4}|GT\\d{2}(?:[ \\-]?[A-Z0-9]{4}){6}|AZ\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{5}){4}|LB\\d{2}[ \\-]?\\d{4}(?:[ \\-]?[A-Z0-9]{5}){4}|(?:AL|CY)\\d{2}(?:[ \\-]?\\d{4}){2}(?:[ \\-]?[A-Z0-9]{4}){4}|(?:HU|PL)\\d{2}(?:[ \\-]?\\d{4}){6}|QA\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){5}[ \\-]?[A-Z0-9]|PS\\d{2}[ \\-]?[A-Z0-9]{4}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d|UA\\d{2}[ \\-]?\\d{4}[ \\-]?\\d{2}[A-Z0-9]{2}(?:[ \\-]?[A-Z0-9]{4}){4}[ \\-]?[A-Z0-9]|BR\\d{2}(?:[ \\-]?\\d{4}){5}[ \\-]?\\d{3}[A-Z0-9][ \\-]?[A-Z0-9]|EG\\d{2}(?:[ \\-]?\\d{4}){6}\\d|MU\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){4}\\d{3}[A-Z][ \\-]?[A-Z]{2}|(?:KW|JO)\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){5}[ \\-]?[A-Z0-9]{2}|MT\\d{2}[ \\-]?[A-Z]{4}[ \\-]?\\d{4}[ \\-]?\\d[A-Z0-9]{3}(?:[ \\-]?[A-Z0-9]{3}){4}[ \\-]?[A-Z0-9]{3}|SC\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?\\d{4}){5}[ \\-]?[A-Z]{3}|LC\\d{2}[ \\-]?[A-Z]{4}(?:[ \\-]?[A-Z0-9]{4}){6})\\b",
              options: {
                case_sensitive: false,
                min_length: 15
              }
            }
          },
          tags: {
            type: "iban",
            category: "payment"
          }
        },
        {
          id: "h6WJcecQTwqvN9KeEtwDvg",
          name: "JCB Card Scanner (1x16 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b35(?:2[89]|[3-9][0-9])(?:\\d{12})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "jcb",
            category: "payment"
          }
        },
        {
          id: "gcEaMu_VSJ2-bGCEkgyC0w",
          name: "JCB Card Scanner (2x8 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b35(?:2[89]|[3-9][0-9])\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))\\b",
              options: {
                case_sensitive: false,
                min_length: 17
              }
            }
          },
          tags: {
            type: "card",
            card_type: "jcb",
            category: "payment"
          }
        },
        {
          id: "imTliuhXT5GAeRNhqChXQQ",
          name: "JCB Card Scanner (4x4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b35(?:2[89]|[3-9][0-9])(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "jcb",
            category: "payment"
          }
        },
        {
          id: "9osY3xc9Q7ONAV0zw9Uz4A",
          name: "JSON Web Token",
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\bey[I-L][\\w=-]+\\.ey[I-L][\\w=-]+(\\.[\\w.+\\/=-]+)?\\b",
              options: {
                case_sensitive: false,
                min_length: 20
              }
            }
          },
          tags: {
            type: "json_web_token",
            category: "credentials"
          }
        },
        {
          id: "d1Q9D3YMRxuVKf6CZInJPw",
          name: "Maestro Card Scanner (1x16 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:5[06-9]\\d{2}|6\\d{3})(?:\\d{12})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "maestro",
            category: "payment"
          }
        },
        {
          id: "M3YIQKKjRVmoeQuM3pjzrw",
          name: "Maestro Card Scanner (2x8 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:5[06-9]\\d{6}|6\\d{7})(?:\\s\\d{8}|\\.\\d{8}|-\\d{8}|,\\d{8})\\b",
              options: {
                case_sensitive: false,
                min_length: 17
              }
            }
          },
          tags: {
            type: "card",
            card_type: "maestro",
            category: "payment"
          }
        },
        {
          id: "hRxiQBlSSVKcjh5U7LZYLA",
          name: "Maestro Card Scanner (4x4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:5[06-9]\\d{2}|6\\d{3})(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "maestro",
            category: "payment"
          }
        },
        {
          id: "NwhIYNS4STqZys37WlaIKA",
          name: "MasterCard Scanner (2x8 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:(?:\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "mastercard",
            category: "payment"
          }
        },
        {
          id: "axxJkyjhRTOuhjwlsA35Vw",
          name: "MasterCard Scanner (4x4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3}|(?:,\\d{4}){3})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "mastercard",
            category: "payment"
          }
        },
        {
          id: "76EhmoK3TPqJcpM-fK0pLw",
          name: "MasterCard Scanner (1x16 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:(?:5[1-5]\\d{2})|(?:222[1-9])|(?:22[3-9]\\d)|(?:2[3-6]\\d{2})|(?:27[0-1]\\d)|(?:2720))(?:\\d{12})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "mastercard",
            category: "payment"
          }
        },
        {
          id: "c542c147-3883-43d6-a067-178e4a7bd65d",
          name: "Password",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bpass(?:[_-]?word|wd)?\\b|\\bpwd\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          tags: {
            type: "password",
            category: "credentials"
          }
        },
        {
          id: "18b608bd7a764bff5b2344c0",
          name: "Phone number",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bphone|number|mobile\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "^(?:\\(\\+\\d{1,3}\\)|\\+\\d{1,3}|00\\d{1,3})?[-\\s\\.]?(?:\\(\\d{3}\\)[-\\s\\.]?)?(?:\\d[-\\s\\.]?){6,10}$",
              options: {
                case_sensitive: false,
                min_length: 6
              }
            }
          },
          tags: {
            type: "phone",
            category: "pii"
          }
        },
        {
          id: "de0899e0cbaaa812bb624cf04c912071012f616d-mod",
          name: "UK National Insurance Number Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "^nin$|\\binsurance\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b[A-Z]{2}[\\s-]?\\d{6}[\\s-]?[A-Z]?\\b",
              options: {
                case_sensitive: false,
                min_length: 8
              }
            }
          },
          tags: {
            type: "uk_nin",
            category: "pii"
          }
        },
        {
          id: "d962f7ddb3f55041e39195a60ff79d4814a7c331",
          name: "US Passport Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\bpassport\\b",
              options: {
                case_sensitive: false,
                min_length: 8
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b[0-9A-Z]{9}\\b|\\b[0-9]{6}[A-Z][0-9]{2}\\b",
              options: {
                case_sensitive: false,
                min_length: 8
              }
            }
          },
          tags: {
            type: "passport_number",
            category: "pii"
          }
        },
        {
          id: "7771fc3b-b205-4b93-bcef-28608c5c1b54",
          name: "United States Social Security Number Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:SSN|(?:(?:social)?[\\s_]?(?:security)?[\\s_]?(?:number)?)?)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b\\d{3}[-\\s\\.]{1}\\d{2}[-\\s\\.]{1}\\d{4}\\b",
              options: {
                case_sensitive: false,
                min_length: 11
              }
            }
          },
          tags: {
            type: "us_ssn",
            category: "pii"
          }
        },
        {
          id: "ac6d683cbac77f6e399a14990793dd8fd0fca333",
          name: "US Vehicle Identification Number Scanner",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:vehicle[_\\s-]*identification[_\\s-]*number|vin)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b[A-HJ-NPR-Z0-9]{17}\\b",
              options: {
                case_sensitive: false,
                min_length: 17
              }
            }
          },
          tags: {
            type: "vin",
            category: "pii"
          }
        },
        {
          id: "wJIgOygRQhKkR69b_9XbRQ",
          name: "Visa Card Scanner (2x8 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b4\\d{3}(?:(?:\\d{4}(?:(?:,\\d{8})|(?:-\\d{8})|(?:\\s\\d{8})|(?:\\.\\d{8}))))\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "visa",
            category: "payment"
          }
        },
        {
          id: "0o71SJxXQNK7Q6gMbBesFQ",
          name: "Visa Card Scanner (4x4 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "\\b4\\d{3}(?:(?:,\\d{4}){3}|(?:\\s\\d{4}){3}|(?:\\.\\d{4}){3}|(?:-\\d{4}){3})\\b",
              options: {
                case_sensitive: false,
                min_length: 16
              }
            }
          },
          tags: {
            type: "card",
            card_type: "visa",
            category: "payment"
          }
        },
        {
          id: "QrHD6AfgQm6z-j0wStxTvA",
          name: "Visa Card Scanner (1x15 & 1x16 & 1x19 digits)",
          key: {
            operator: "match_regex",
            parameters: {
              regex: "\\b(?:card|cc|credit|debit|payment|amex|visa|mastercard|maestro|discover|jcb|diner)\\b",
              options: {
                case_sensitive: false,
                min_length: 3
              }
            }
          },
          value: {
            operator: "match_regex",
            parameters: {
              regex: "4[0-9]{12}(?:[0-9]{3})?",
              options: {
                case_sensitive: false,
                min_length: 13
              }
            }
          },
          tags: {
            type: "card",
            card_type: "visa",
            category: "payment"
          }
        }
      ]
    };
  }
});

// ../../packages/dd-trace/src/appsec/rule_manager.js
var require_rule_manager = __commonJS({
  "../../packages/dd-trace/src/appsec/rule_manager.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var waf = require_waf2();
    var { DIAGNOSTIC_KEYS } = require_diagnostics();
    var { ACKNOWLEDGED, ERROR } = require_apply_states();
    var Reporter = require_reporter();
    var blocking = require_blocking();
    var ASM_PRODUCTS = /* @__PURE__ */ new Set(["ASM", "ASM_DD", "ASM_DATA"]);
    var appliedActions = /* @__PURE__ */ new Map();
    function loadRules(config) {
      const defaultRules = config.rules ? JSON.parse(fs.readFileSync(config.rules)) : require_recommended();
      waf.init(defaultRules, config);
      blocking.setDefaultBlockingActionParameters(defaultRules?.actions);
    }
    function updateWafFromRC({ toUnapply, toApply, toModify }) {
      const newActions = new SpyMap(appliedActions);
      let wafUpdated = false;
      let wafUpdatedFailed = false;
      for (const item of toUnapply) {
        if (!ASM_PRODUCTS.has(item.product)) continue;
        try {
          waf.removeConfig(item.path);
          item.apply_state = ACKNOWLEDGED;
          wafUpdated = true;
          if (item.product === "ASM") {
            newActions.delete(item.id);
          }
        } catch (e) {
          item.apply_state = ERROR;
          item.apply_error = e.toString();
          wafUpdatedFailed = true;
        }
      }
      for (const item of [...toApply, ...toModify]) {
        if (!ASM_PRODUCTS.has(item.product)) continue;
        try {
          waf.updateConfig(item.product, item.id, item.path, item.file);
          item.apply_state = ACKNOWLEDGED;
          wafUpdated = true;
          if (item.product === "ASM" && item.file?.actions?.length) {
            newActions.set(item.id, item.file.actions);
          }
        } catch (e) {
          item.apply_state = ERROR;
          item.apply_error = e instanceof waf.WafUpdateError ? JSON.stringify(extractErrors(e.diagnosticErrors)) : e.toString();
          wafUpdatedFailed = true;
        }
      }
      waf.checkAsmDdFallback();
      if (wafUpdated) {
        Reporter.reportWafUpdate(waf.wafManager.ddwafVersion, waf.wafManager.rulesVersion, !wafUpdatedFailed);
      }
      if (newActions.modified) {
        appliedActions = newActions;
        blocking.setDefaultBlockingActionParameters(concatArrays(newActions));
      }
    }
    var SpyMap = class extends Map {
      constructor(iterable) {
        super(iterable);
        this.modified = false;
      }
      set(key, value) {
        this.modified = true;
        return super.set(key, value);
      }
      delete(key) {
        const result = super.delete(key);
        if (result) this.modified = true;
        return result;
      }
      clear() {
        this.modified = false;
        return super.clear();
      }
    };
    function concatArrays(files) {
      return [...files.values()].flat();
    }
    function extractErrors(diagnostics) {
      if (!diagnostics) return;
      if (diagnostics.error) return diagnostics;
      const result = {};
      let isResultPopulated = false;
      for (const diagnosticKey of DIAGNOSTIC_KEYS) {
        if (diagnostics[diagnosticKey]?.error) {
          (result[diagnosticKey] ??= {}).error = diagnostics[diagnosticKey]?.error;
          isResultPopulated = true;
        }
        if (diagnostics[diagnosticKey]?.errors) {
          (result[diagnosticKey] ??= {}).errors = diagnostics[diagnosticKey]?.errors;
          isResultPopulated = true;
        }
      }
      return isResultPopulated ? result : null;
    }
    function clearAllRules() {
      waf.destroy();
      appliedActions.clear();
      blocking.setDefaultBlockingActionParameters(void 0);
    }
    module2.exports = {
      loadRules,
      updateWafFromRC,
      clearAllRules
    };
  }
});

// ../../packages/dd-trace/src/appsec/activation.js
var require_activation = __commonJS({
  "../../packages/dd-trace/src/appsec/activation.js"(exports2, module2) {
    "use strict";
    var Activation = {
      ONECLICK: "OneClick",
      ENABLED: "Enabled",
      DISABLED: "Disabled",
      fromConfig(config) {
        switch (config.appsec.enabled) {
          // ASM is activated by an env var DD_APPSEC_ENABLED=true
          case true:
            return Activation.ENABLED;
          // ASM is disabled by an env var DD_APPSEC_ENABLED=false
          case false:
            return Activation.DISABLED;
          // ASM is activated by one click remote config
          case void 0:
            return Activation.ONECLICK;
          // Any other value should never occur
          default:
            return Activation.DISABLED;
        }
      }
    };
    module2.exports = Activation;
  }
});

// ../../packages/dd-trace/src/remote_config/scheduler.js
var require_scheduler = __commonJS({
  "../../packages/dd-trace/src/remote_config/scheduler.js"(exports2, module2) {
    "use strict";
    var Scheduler = class {
      _timer = null;
      constructor(callback, interval) {
        this._callback = callback;
        this._interval = interval;
      }
      start() {
        if (this._timer) return;
        this.runAfterDelay(0);
      }
      runAfterDelay(interval = this._interval) {
        this._timer = setTimeout(this._callback, interval, () => this.runAfterDelay());
        this._timer.unref && this._timer.unref();
      }
      stop() {
        clearTimeout(this._timer);
        this._timer = null;
      }
    };
    module2.exports = Scheduler;
  }
});

// ../../packages/dd-trace/src/remote_config/manager.js
var require_manager2 = __commonJS({
  "../../packages/dd-trace/src/remote_config/manager.js"(exports2, module2) {
    "use strict";
    var { URL: URL2, format } = __require("url");
    var uuid = require_crypto_randomuuid();
    var { EventEmitter } = __require("events");
    var tracerVersion = require_package().version;
    var request2 = require_request();
    var log = require_log2();
    var { getExtraServices } = require_extra_services();
    var { UNACKNOWLEDGED, ACKNOWLEDGED, ERROR } = require_apply_states();
    var Scheduler = require_scheduler();
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2();
    var tagger = require_tagger();
    var defaults = require_config_defaults();
    var clientId = uuid();
    var DEFAULT_CAPABILITY = Buffer.alloc(1).toString("base64");
    var kPreUpdate = Symbol("kPreUpdate");
    var kSupportsAckCallback = Symbol("kSupportsAckCallback");
    var RemoteConfigManager = class _RemoteConfigManager extends EventEmitter {
      static kPreUpdate = kPreUpdate;
      constructor(config) {
        super();
        const pollInterval = Math.floor(config.remoteConfig.pollInterval * 1e3);
        this.url = config.url || new URL2(format({
          protocol: "http:",
          hostname: config.hostname || defaults.hostname,
          port: config.port
        }));
        tagger.add(config.tags, {
          "_dd.rc.client_id": clientId
        });
        const tags = config.repositoryUrl ? {
          ...config.tags,
          [GIT_REPOSITORY_URL]: config.repositoryUrl,
          [GIT_COMMIT_SHA]: config.commitSHA
        } : config.tags;
        this._handlers = /* @__PURE__ */ new Map();
        const appliedConfigs = this.appliedConfigs = /* @__PURE__ */ new Map();
        this.scheduler = new Scheduler((cb) => this.poll(cb), pollInterval);
        this.state = {
          client: {
            state: {
              // updated by `parseConfig()` and `poll()`
              root_version: 1,
              targets_version: 0,
              // Use getter so `apply_*` can be updated async and still affect the content of `config_states`
              get config_states() {
                const configs = [];
                for (const conf of appliedConfigs.values()) {
                  configs.push({
                    id: conf.id,
                    version: conf.version,
                    product: conf.product,
                    apply_state: conf.apply_state,
                    apply_error: conf.apply_error
                  });
                }
                return configs;
              },
              has_error: false,
              error: "",
              backend_client_state: ""
            },
            id: clientId,
            products: [],
            // updated by `updateProducts()`
            is_tracer: true,
            client_tracer: {
              runtime_id: config.tags["runtime-id"],
              language: "node",
              tracer_version: tracerVersion,
              service: config.service,
              env: config.env,
              app_version: config.version,
              extra_services: [],
              tags: Object.entries(tags).map((pair) => pair.join(":"))
            },
            capabilities: DEFAULT_CAPABILITY
            // updated by `updateCapabilities()`
          },
          cached_target_files: []
          // updated by `parseConfig()`
        };
      }
      updateCapabilities(mask, value) {
        const hex = Buffer.from(this.state.client.capabilities, "base64").toString("hex");
        let num = BigInt(`0x${hex}`);
        if (value) {
          num |= mask;
        } else {
          num &= ~mask;
        }
        let str = num.toString(16);
        if (str.length % 2) str = `0${str}`;
        this.state.client.capabilities = Buffer.from(str, "hex").toString("base64");
      }
      setProductHandler(product, handler) {
        this._handlers.set(product, handler);
        this.updateProducts();
        if (this.state.client.products.length === 1) {
          this.scheduler.start();
        }
      }
      removeProductHandler(product) {
        this._handlers.delete(product);
        this.updateProducts();
        if (this.state.client.products.length === 0) {
          this.scheduler.stop();
        }
      }
      updateProducts() {
        this.state.client.products = [...this._handlers.keys()];
      }
      getPayload() {
        this.state.client.client_tracer.extra_services = getExtraServices();
        return JSON.stringify(this.state);
      }
      poll(cb) {
        const options = {
          url: this.url,
          method: "POST",
          path: "/v0.7/config",
          headers: {
            "Content-Type": "application/json; charset=utf-8"
          }
        };
        request2(this.getPayload(), options, (err, data, statusCode) => {
          if (statusCode === 404) return cb();
          if (err) {
            log.errorWithoutTelemetry("[RC] Error in request", err);
            return cb();
          }
          if (this.state.client.state.has_error) {
            this.state.client.state.has_error = false;
            this.state.client.state.error = "";
          }
          if (data && data !== "{}") {
            try {
              this.parseConfig(JSON.parse(data));
            } catch (err2) {
              log.error("[RC] Could not parse remote config response", err2);
              this.state.client.state.has_error = true;
              this.state.client.state.error = err2.toString();
            }
          }
          cb();
        });
      }
      // `client_configs` is the list of config paths to have applied
      // `targets` is the signed index with metadata for config files
      // `target_files` is the list of config files containing the actual config data
      parseConfig({
        client_configs: clientConfigs = [],
        targets,
        target_files: targetFiles = []
      }) {
        const toUnapply = [];
        const toApply = [];
        const toModify = [];
        for (const appliedConfig of this.appliedConfigs.values()) {
          if (!clientConfigs.includes(appliedConfig.path)) {
            toUnapply.push(appliedConfig);
          }
        }
        targets = fromBase64JSON(targets);
        if (targets) {
          for (const path of clientConfigs) {
            const meta = targets.signed.targets[path];
            if (!meta) throw new Error(`Unable to find target for path ${path}`);
            const current = this.appliedConfigs.get(path);
            const newConf = {};
            if (current) {
              if (current.hashes.sha256 === meta.hashes.sha256) continue;
              toModify.push(newConf);
            } else {
              toApply.push(newConf);
            }
            const file = targetFiles.find((file2) => file2.path === path);
            if (!file) throw new Error(`Unable to find file for path ${path}`);
            const { product, id } = parseConfigPath(path);
            Object.assign(newConf, {
              path,
              product,
              id,
              version: meta.custom.v,
              apply_state: UNACKNOWLEDGED,
              apply_error: "",
              length: meta.length,
              hashes: meta.hashes,
              file: fromBase64JSON(file.raw)
            });
          }
          this.state.client.state.targets_version = targets.signed.version;
          this.state.client.state.backend_client_state = targets.signed.custom.opaque_backend_state;
        }
        if (toUnapply.length || toApply.length || toModify.length) {
          this.emit(_RemoteConfigManager.kPreUpdate, { toUnapply, toApply, toModify });
          this.dispatch(toUnapply, "unapply");
          this.dispatch(toApply, "apply");
          this.dispatch(toModify, "modify");
          this.state.cached_target_files = [];
          for (const conf of this.appliedConfigs.values()) {
            const hashes = [];
            for (const hash of Object.entries(conf.hashes)) {
              hashes.push({ algorithm: hash[0], hash: hash[1] });
            }
            this.state.cached_target_files.push({
              path: conf.path,
              length: conf.length,
              hashes
            });
          }
        }
      }
      dispatch(list, action) {
        for (const item of list) {
          this._callHandlerFor(action, item);
          if (action === "unapply") {
            this.appliedConfigs.delete(item.path);
          } else {
            this.appliedConfigs.set(item.path, item);
          }
        }
      }
      _callHandlerFor(action, item) {
        if (item.apply_state !== UNACKNOWLEDGED && action !== "unapply") return;
        const handler = this._handlers.get(item.product);
        if (!handler) return;
        try {
          if (supportsAckCallback(handler)) {
            handler(action, item.file, item.id, (err) => {
              if (err) {
                item.apply_state = ERROR;
                item.apply_error = err.toString();
              } else if (item.apply_state !== ERROR) {
                item.apply_state = ACKNOWLEDGED;
              }
            });
          } else {
            const result = handler(action, item.file, item.id);
            if (result instanceof Promise) {
              result.then(
                () => {
                  item.apply_state = ACKNOWLEDGED;
                },
                (err) => {
                  item.apply_state = ERROR;
                  item.apply_error = err.toString();
                }
              );
            } else {
              item.apply_state = ACKNOWLEDGED;
            }
          }
        } catch (err) {
          item.apply_state = ERROR;
          item.apply_error = err.toString();
        }
      }
    };
    function fromBase64JSON(str) {
      if (!str) return null;
      return JSON.parse(Buffer.from(str, "base64").toString());
    }
    var configPathRegex = /^(?:datadog\/\d+|employee)\/([^/]+)\/([^/]+)\/[^/]+$/;
    function parseConfigPath(configPath) {
      const match = configPathRegex.exec(configPath);
      if (!match || !match[1] || !match[2]) {
        throw new Error(`Unable to parse path ${configPath}`);
      }
      return {
        product: match[1],
        id: match[2]
      };
    }
    function supportsAckCallback(handler) {
      if (kSupportsAckCallback in handler) return handler[kSupportsAckCallback];
      const numOfArgs = handler.length;
      let result = false;
      if (numOfArgs >= 4) {
        result = true;
      } else if (numOfArgs !== 0) {
        const source = handler.toString();
        result = source.slice(0, source.indexOf(")")).includes("...");
      }
      handler[kSupportsAckCallback] = result;
      return result;
    }
    module2.exports = RemoteConfigManager;
  }
});

// ../../packages/dd-trace/src/remote_config/capabilities.js
var require_capabilities = __commonJS({
  "../../packages/dd-trace/src/remote_config/capabilities.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ASM_ACTIVATION: 1n << 1n,
      ASM_IP_BLOCKING: 1n << 2n,
      ASM_DD_RULES: 1n << 3n,
      ASM_EXCLUSIONS: 1n << 4n,
      ASM_REQUEST_BLOCKING: 1n << 5n,
      ASM_RESPONSE_BLOCKING: 1n << 6n,
      ASM_USER_BLOCKING: 1n << 7n,
      ASM_CUSTOM_RULES: 1n << 8n,
      ASM_CUSTOM_BLOCKING_RESPONSE: 1n << 9n,
      ASM_TRUSTED_IPS: 1n << 10n,
      ASM_API_SECURITY_SAMPLE_RATE: 1n << 11n,
      // deprecated
      APM_TRACING_SAMPLE_RATE: 1n << 12n,
      APM_TRACING_LOGS_INJECTION: 1n << 13n,
      APM_TRACING_HTTP_HEADER_TAGS: 1n << 14n,
      APM_TRACING_CUSTOM_TAGS: 1n << 15n,
      ASM_EXCLUSION_DATA: 1n << 18n,
      APM_TRACING_ENABLED: 1n << 19n,
      ASM_RASP_SQLI: 1n << 21n,
      ASM_RASP_LFI: 1n << 22n,
      ASM_RASP_SSRF: 1n << 23n,
      ASM_RASP_SHI: 1n << 24n,
      APM_TRACING_SAMPLE_RULES: 1n << 29n,
      ASM_AUTO_USER_INSTRUM_MODE: 1n << 31n,
      ASM_ENDPOINT_FINGERPRINT: 1n << 32n,
      ASM_SESSION_FINGERPRINT: 1n << 33n,
      ASM_NETWORK_FINGERPRINT: 1n << 34n,
      ASM_HEADER_FINGERPRINT: 1n << 35n,
      ASM_RASP_CMDI: 1n << 37n,
      ASM_DD_MULTICONFIG: 1n << 42n,
      ASM_TRACE_TAGGING_RULES: 1n << 43n,
      ASM_EXTENDED_DATA_COLLECTION: 1n << 44n,
      FFE_FLAG_CONFIGURATION_RULES: 1n << 46n
      /*
        DO NOT ADD ARBITRARY CAPABILITIES IN YOUR CODE
        UNLESS THEY ARE ALREADY DEFINED IN THE BACKEND SOURCE OF TRUTH
        DOING SO TRIGGERS BACKEND ALERTS
      */
    };
  }
});

// ../../packages/dd-trace/src/appsec/user_tracking.js
var require_user_tracking = __commonJS({
  "../../packages/dd-trace/src/appsec/user_tracking.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var log = require_log2();
    var telemetry = require_telemetry6();
    var addresses = require_addresses();
    var { keepTrace } = require_priority_sampler();
    var waf = require_waf2();
    var { ASM } = require_product();
    var USER_ID_FIELDS = ["id", "_id", "email", "username", "login", "user"];
    var collectionMode;
    function setCollectionMode(mode, overwrite = true) {
      if (!overwrite && collectionMode) return;
      switch (mode) {
        case "safe":
          log.warn('[ASM] Using deprecated value "safe" in config.appsec.eventTracking.mode');
        case "anon":
        case "anonymization":
          collectionMode = "anonymization";
          break;
        case "extended":
          log.warn('[ASM] Using deprecated value "extended" in config.appsec.eventTracking.mode');
        case "ident":
        case "identification":
          collectionMode = "identification";
          break;
        default:
          collectionMode = "disabled";
      }
    }
    function obfuscateIfNeeded(str) {
      return collectionMode === "anonymization" ? "anon_" + crypto.createHash("sha256").update(str).digest().toString("hex", 0, 16).toLowerCase() : str;
    }
    function getUserId(user) {
      if (!user) return;
      for (const field of USER_ID_FIELDS) {
        let id = user[field];
        if (id && typeof id.toString === "function") {
          id = id.toString();
          if (typeof id !== "string" || id.startsWith("[object ")) {
            continue;
          }
          return obfuscateIfNeeded(id);
        }
      }
    }
    function trackLogin(framework, login, user, success, rootSpan) {
      if (!collectionMode || collectionMode === "disabled") return;
      if (typeof login !== "string") {
        log.error("[ASM] Invalid login provided to AppSec trackLogin");
        telemetry.incrementMissingUserLoginMetric(framework, success ? "login_success" : "login_failure");
        return;
      }
      login = obfuscateIfNeeded(login);
      const userId = getUserId(user);
      let newTags;
      const persistent = {
        [addresses.USER_LOGIN]: login
      };
      const currentTags = rootSpan.context()._tags;
      const isSdkCalled = currentTags[`_dd.appsec.events.users.login.${success ? "success" : "failure"}.sdk`] === "true";
      function shouldSetTag(tag) {
        return !(isSdkCalled && currentTags[tag]);
      }
      if (success) {
        newTags = {
          "appsec.events.users.login.success.track": "true",
          "_dd.appsec.events.users.login.success.auto.mode": collectionMode,
          "_dd.appsec.usr.login": login
        };
        if (shouldSetTag("appsec.events.users.login.success.usr.login")) {
          newTags["appsec.events.users.login.success.usr.login"] = login;
        }
        if (userId) {
          newTags["_dd.appsec.usr.id"] = userId;
          if (shouldSetTag("usr.id")) {
            newTags["usr.id"] = userId;
            persistent[addresses.USER_ID] = userId;
          }
        }
        persistent[addresses.LOGIN_SUCCESS] = null;
      } else {
        newTags = {
          "appsec.events.users.login.failure.track": "true",
          "_dd.appsec.events.users.login.failure.auto.mode": collectionMode,
          "_dd.appsec.usr.login": login
        };
        if (shouldSetTag("appsec.events.users.login.failure.usr.login")) {
          newTags["appsec.events.users.login.failure.usr.login"] = login;
        }
        if (userId) {
          newTags["_dd.appsec.usr.id"] = userId;
          if (shouldSetTag("appsec.events.users.login.failure.usr.id")) {
            newTags["appsec.events.users.login.failure.usr.id"] = userId;
          }
        }
        persistent[addresses.LOGIN_FAILURE] = null;
      }
      keepTrace(rootSpan, ASM);
      rootSpan.addTags(newTags);
      return waf.run({ persistent });
    }
    function trackUser(user, rootSpan) {
      if (!collectionMode || collectionMode === "disabled") return;
      const userId = getUserId(user);
      if (!userId) {
        log.error("[ASM] No valid user ID found in AppSec trackUser");
        telemetry.incrementMissingUserIdMetric("passport", "authenticated_request");
        return;
      }
      rootSpan.setTag("_dd.appsec.usr.id", userId);
      const isSdkCalled = rootSpan.context()._tags["_dd.appsec.user.collection_mode"] === "sdk";
      if (!isSdkCalled) {
        rootSpan.addTags({
          "usr.id": userId,
          "_dd.appsec.user.collection_mode": collectionMode
        });
        return waf.run({
          persistent: {
            [addresses.USER_ID]: userId
          }
        });
      }
    }
    module2.exports = {
      setCollectionMode,
      trackLogin,
      trackUser
    };
  }
});

// ../../packages/dd-trace/src/remote_config/index.js
var require_remote_config = __commonJS({
  "../../packages/dd-trace/src/remote_config/index.js"(exports2, module2) {
    "use strict";
    var Activation = require_activation();
    var RemoteConfigManager = require_manager2();
    var RemoteConfigCapabilities = require_capabilities();
    var { setCollectionMode } = require_user_tracking();
    var log = require_log2();
    var rc;
    function enable(config, appsec) {
      rc = new RemoteConfigManager(config);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_CUSTOM_TAGS, true);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_HTTP_HEADER_TAGS, true);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_LOGS_INJECTION, true);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_SAMPLE_RATE, true);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_ENABLED, true);
      rc.updateCapabilities(RemoteConfigCapabilities.APM_TRACING_SAMPLE_RULES, true);
      rc.updateCapabilities(RemoteConfigCapabilities.FFE_FLAG_CONFIGURATION_RULES, true);
      const activation = Activation.fromConfig(config);
      if (activation !== Activation.DISABLED) {
        if (activation === Activation.ONECLICK) {
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_ACTIVATION, true);
        }
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_AUTO_USER_INSTRUM_MODE, true);
        let autoUserInstrumModeId;
        rc.setProductHandler("ASM_FEATURES", (action, rcConfig, configId) => {
          if (!rcConfig) return;
          if (typeof rcConfig.auto_user_instrum?.mode === "string") {
            if (action === "apply" || action === "modify") {
              if (autoUserInstrumModeId && configId !== autoUserInstrumModeId) {
                log.error("[RC] Multiple auto_user_instrum received in ASM_FEATURES. Discarding config");
                throw "Multiple auto_user_instrum.mode received in ASM_FEATURES";
              }
              setCollectionMode(rcConfig.auto_user_instrum.mode);
              autoUserInstrumModeId = configId;
            } else if (configId === autoUserInstrumModeId) {
              setCollectionMode(config.appsec.eventTracking.mode);
              autoUserInstrumModeId = null;
            }
          }
          if (activation === Activation.ONECLICK) {
            enableOrDisableAppsec(action, rcConfig, config, appsec);
          }
        });
      }
      return rc;
    }
    function enableOrDisableAppsec(action, rcConfig, config, appsec) {
      if (typeof rcConfig.asm?.enabled === "boolean") {
        const shouldEnable = action === "apply" || action === "modify" ? rcConfig.asm.enabled : config.appsec.enabled;
        if (shouldEnable) {
          appsec.enable(config);
        } else {
          appsec.disable();
        }
      }
    }
    function enableWafUpdate(appsecConfig) {
      if (rc && appsecConfig && !appsecConfig.rules) {
        const RuleManager = require_rule_manager();
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_IP_BLOCKING, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_USER_BLOCKING, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_RULES, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSIONS, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_REQUEST_BLOCKING, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RESPONSE_BLOCKING, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_RULES, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_BLOCKING_RESPONSE, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRUSTED_IPS, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSION_DATA, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_ENDPOINT_FINGERPRINT, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_SESSION_FINGERPRINT, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_NETWORK_FINGERPRINT, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_HEADER_FINGERPRINT, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_MULTICONFIG, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRACE_TAGGING_RULES, true);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXTENDED_DATA_COLLECTION, true);
        if (appsecConfig.rasp?.enabled) {
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SQLI, true);
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SSRF, true);
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_LFI, true);
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SHI, true);
          rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_CMDI, true);
        }
        rc.setProductHandler("ASM_DATA", noop);
        rc.setProductHandler("ASM_DD", noop);
        rc.setProductHandler("ASM", noop);
        rc.on(RemoteConfigManager.kPreUpdate, RuleManager.updateWafFromRC);
      }
    }
    function disableWafUpdate() {
      if (rc) {
        const RuleManager = require_rule_manager();
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_IP_BLOCKING, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_USER_BLOCKING, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_RULES, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSIONS, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_REQUEST_BLOCKING, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RESPONSE_BLOCKING, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_RULES, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_CUSTOM_BLOCKING_RESPONSE, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRUSTED_IPS, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXCLUSION_DATA, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_ENDPOINT_FINGERPRINT, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_SESSION_FINGERPRINT, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_NETWORK_FINGERPRINT, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_HEADER_FINGERPRINT, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_DD_MULTICONFIG, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_TRACE_TAGGING_RULES, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_EXTENDED_DATA_COLLECTION, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SQLI, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SSRF, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_LFI, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_SHI, false);
        rc.updateCapabilities(RemoteConfigCapabilities.ASM_RASP_CMDI, false);
        rc.removeProductHandler("ASM_DATA");
        rc.removeProductHandler("ASM_DD");
        rc.removeProductHandler("ASM");
        rc.off(RemoteConfigManager.kPreUpdate, RuleManager.updateWafFromRC);
      }
    }
    function noop() {
    }
    module2.exports = {
      enable,
      enableWafUpdate,
      disableWafUpdate
    };
  }
});

// ../../node_modules/@isaacs/ttlcache/index.js
var require_ttlcache = __commonJS({
  "../../node_modules/@isaacs/ttlcache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var now = () => perf.now();
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var isPosIntOrInf = (n) => n === Infinity || isPosInt(n);
    var TTLCache = class _TTLCache {
      constructor({
        max = Infinity,
        ttl,
        updateAgeOnGet = false,
        checkAgeOnGet = false,
        noUpdateTTL = false,
        dispose,
        noDisposeOnSet = false
      } = {}) {
        this.expirations = /* @__PURE__ */ Object.create(null);
        this.data = /* @__PURE__ */ new Map();
        this.expirationMap = /* @__PURE__ */ new Map();
        if (ttl !== void 0 && !isPosIntOrInf(ttl)) {
          throw new TypeError(
            "ttl must be positive integer or Infinity if set"
          );
        }
        if (!isPosIntOrInf(max)) {
          throw new TypeError("max must be positive integer or Infinity");
        }
        this.ttl = ttl;
        this.max = max;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.checkAgeOnGet = !!checkAgeOnGet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDisposeOnSet = !!noDisposeOnSet;
        if (dispose !== void 0) {
          if (typeof dispose !== "function") {
            throw new TypeError("dispose must be function if set");
          }
          this.dispose = dispose;
        }
        this.timer = void 0;
        this.timerExpiration = void 0;
      }
      setTimer(expiration, ttl) {
        if (this.timerExpiration < expiration) {
          return;
        }
        if (this.timer) {
          clearTimeout(this.timer);
        }
        const t = setTimeout(() => {
          this.timer = void 0;
          this.timerExpiration = void 0;
          this.purgeStale();
          for (const exp in this.expirations) {
            this.setTimer(exp, exp - now());
            break;
          }
        }, ttl);
        if (t.unref) t.unref();
        this.timerExpiration = expiration;
        this.timer = t;
      }
      // hang onto the timer so we can clearTimeout if all items
      // are deleted.  Deno doesn't have Timer.unref(), so it
      // hangs otherwise.
      cancelTimer() {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timerExpiration = void 0;
          this.timer = void 0;
        }
      }
      /* istanbul ignore next */
      cancelTimers() {
        process.emitWarning(
          'TTLCache.cancelTimers has been renamed to TTLCache.cancelTimer (no "s"), and will be removed in the next major version update'
        );
        return this.cancelTimer();
      }
      clear() {
        const entries = this.dispose !== _TTLCache.prototype.dispose ? [...this] : [];
        this.data.clear();
        this.expirationMap.clear();
        this.cancelTimer();
        this.expirations = /* @__PURE__ */ Object.create(null);
        for (const [key, val] of entries) {
          this.dispose(val, key, "delete");
        }
      }
      setTTL(key, ttl = this.ttl) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const exp = this.expirations[current];
          if (!exp || exp.length <= 1) {
            delete this.expirations[current];
          } else {
            this.expirations[current] = exp.filter((k) => k !== key);
          }
        }
        if (ttl !== Infinity) {
          const expiration = Math.floor(now() + ttl);
          this.expirationMap.set(key, expiration);
          if (!this.expirations[expiration]) {
            this.expirations[expiration] = [];
            this.setTimer(expiration, ttl);
          }
          this.expirations[expiration].push(key);
        } else {
          this.expirationMap.set(key, Infinity);
        }
      }
      set(key, val, {
        ttl = this.ttl,
        noUpdateTTL = this.noUpdateTTL,
        noDisposeOnSet = this.noDisposeOnSet
      } = {}) {
        if (!isPosIntOrInf(ttl)) {
          throw new TypeError("ttl must be positive integer or Infinity");
        }
        if (this.expirationMap.has(key)) {
          if (!noUpdateTTL) {
            this.setTTL(key, ttl);
          }
          const oldValue = this.data.get(key);
          if (oldValue !== val) {
            this.data.set(key, val);
            if (!noDisposeOnSet) {
              this.dispose(oldValue, key, "set");
            }
          }
        } else {
          this.setTTL(key, ttl);
          this.data.set(key, val);
        }
        while (this.size > this.max) {
          this.purgeToCapacity();
        }
        return this;
      }
      has(key) {
        return this.data.has(key);
      }
      getRemainingTTL(key) {
        const expiration = this.expirationMap.get(key);
        return expiration === Infinity ? expiration : expiration !== void 0 ? Math.max(0, Math.ceil(expiration - now())) : 0;
      }
      get(key, {
        updateAgeOnGet = this.updateAgeOnGet,
        ttl = this.ttl,
        checkAgeOnGet = this.checkAgeOnGet
      } = {}) {
        const val = this.data.get(key);
        if (checkAgeOnGet && this.getRemainingTTL(key) === 0) {
          this.delete(key);
          return void 0;
        }
        if (updateAgeOnGet) {
          this.setTTL(key, ttl);
        }
        return val;
      }
      dispose(_2, __) {
      }
      delete(key) {
        const current = this.expirationMap.get(key);
        if (current !== void 0) {
          const value = this.data.get(key);
          this.data.delete(key);
          this.expirationMap.delete(key);
          const exp = this.expirations[current];
          if (exp) {
            if (exp.length <= 1) {
              delete this.expirations[current];
            } else {
              this.expirations[current] = exp.filter((k) => k !== key);
            }
          }
          this.dispose(value, key, "delete");
          if (this.size === 0) {
            this.cancelTimer();
          }
          return true;
        }
        return false;
      }
      purgeToCapacity() {
        for (const exp in this.expirations) {
          const keys = this.expirations[exp];
          if (this.size - keys.length >= this.max) {
            delete this.expirations[exp];
            const entries = [];
            for (const key of keys) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
          } else {
            const s = this.size - this.max;
            const entries = [];
            for (const key of keys.splice(0, s)) {
              entries.push([key, this.data.get(key)]);
              this.data.delete(key);
              this.expirationMap.delete(key);
            }
            for (const [key, val] of entries) {
              this.dispose(val, key, "evict");
            }
            return;
          }
        }
      }
      get size() {
        return this.data.size;
      }
      purgeStale() {
        const n = Math.ceil(now());
        for (const exp in this.expirations) {
          if (exp === "Infinity" || exp > n) {
            return;
          }
          const keys = [...this.expirations[exp] || []];
          const entries = [];
          delete this.expirations[exp];
          for (const key of keys) {
            entries.push([key, this.data.get(key)]);
            this.data.delete(key);
            this.expirationMap.delete(key);
          }
          for (const [key, val] of entries) {
            this.dispose(val, key, "stale");
          }
        }
        if (this.size === 0) {
          this.cancelTimer();
        }
      }
      *entries() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield [key, this.data.get(key)];
          }
        }
      }
      *keys() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield key;
          }
        }
      }
      *values() {
        for (const exp in this.expirations) {
          for (const key of this.expirations[exp]) {
            yield this.data.get(key);
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
    };
    module2.exports = TTLCache;
  }
});

// ../../packages/dd-trace/src/appsec/api_security_sampler.js
var require_api_security_sampler = __commonJS({
  "../../packages/dd-trace/src/appsec/api_security_sampler.js"(exports2, module2) {
    "use strict";
    var TTLCache = require_ttlcache();
    var web = require_web3();
    var log = require_log2();
    var { AUTO_REJECT, USER_REJECT } = require_priority();
    var { keepTrace } = require_priority_sampler();
    var { ASM } = require_product();
    var MAX_SIZE = 4096;
    var enabled;
    var asmStandaloneEnabled;
    var sampledRequests;
    var NoopTTLCache = class {
      clear() {
      }
      set(_key, _value) {
      }
      has(_key) {
        return false;
      }
    };
    function configure({ appsec, apmTracingEnabled }) {
      enabled = appsec.apiSecurity.enabled;
      asmStandaloneEnabled = apmTracingEnabled === false;
      sampledRequests = appsec.apiSecurity.sampleDelay === 0 ? new NoopTTLCache() : new TTLCache({ max: MAX_SIZE, ttl: appsec.apiSecurity.sampleDelay * 1e3 });
    }
    function disable() {
      enabled = false;
      sampledRequests?.clear();
    }
    function sampleRequest(req, res, force = false) {
      if (!enabled) return false;
      const key = computeKey(req, res);
      if (!key || isSampled(key)) return false;
      const rootSpan = web.root(req);
      if (!rootSpan) return false;
      if (asmStandaloneEnabled) {
        keepTrace(rootSpan, ASM);
      } else {
        let priority = getSpanPriority(rootSpan);
        if (!priority) {
          rootSpan._prioritySampler?.sample(rootSpan);
          priority = getSpanPriority(rootSpan);
        }
        if (priority === AUTO_REJECT || priority === USER_REJECT) {
          return false;
        }
      }
      if (force) {
        sampledRequests.set(key, void 0);
      }
      return true;
    }
    function isSampled(key) {
      return sampledRequests.has(key);
    }
    function computeKey(req, res) {
      const route = web.getContext(req)?.paths?.join("") || "";
      const method = req.method;
      const status = res.statusCode;
      if (!method || !status) {
        log.warn("[ASM] Unsupported groupkey for API security");
        return null;
      }
      return method + route + status;
    }
    function getSpanPriority(span) {
      const spanContext = span.context?.();
      return spanContext._sampling?.priority;
    }
    module2.exports = {
      configure,
      disable,
      sampleRequest,
      isSampled,
      computeKey
    };
  }
});

// ../../packages/dd-trace/src/appsec/graphql.js
var require_graphql4 = __commonJS({
  "../../packages/dd-trace/src/appsec/graphql.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var {
      addSpecificEndpoint,
      specificBlockingTypes,
      getBlockingData,
      getBlockingAction
    } = require_blocking();
    var log = require_log2();
    var waf = require_waf2();
    var addresses = require_addresses();
    var web = require_web3();
    var {
      startGraphqlResolve,
      graphqlMiddlewareChannel,
      apolloHttpServerChannel,
      apolloChannel,
      apolloServerCoreChannel
    } = require_channels2();
    var { updateBlockFailureMetric } = require_telemetry6();
    var graphqlRequestData = /* @__PURE__ */ new WeakMap();
    function enable() {
      enableApollo();
      enableGraphql();
    }
    function disable() {
      disableApollo();
      disableGraphql();
    }
    function onGraphqlStartResolve({ context: context2, resolverInfo }) {
      const req = storage("legacy").getStore()?.req;
      if (!req) return;
      if (!resolverInfo || typeof resolverInfo !== "object") return;
      const result = waf.run({ ephemeral: { [addresses.HTTP_INCOMING_GRAPHQL_RESOLVER]: resolverInfo } }, req);
      const blockingAction = getBlockingAction(result?.actions);
      if (blockingAction) {
        const requestData = graphqlRequestData.get(req);
        if (requestData?.isInGraphqlRequest) {
          requestData.blocked = true;
          requestData.wafAction = blockingAction;
          context2?.abortController?.abort();
        }
      }
    }
    function enterInApolloMiddleware(data) {
      const req = data?.req || storage("legacy").getStore()?.req;
      if (!req) return;
      graphqlRequestData.set(req, {
        blocked: false
      });
    }
    function enterInApolloServerCoreRequest() {
      const req = storage("legacy").getStore()?.req;
      if (!req) return;
      graphqlRequestData.set(req, {
        isInGraphqlRequest: true,
        blocked: false
      });
    }
    function enterInApolloRequest() {
      const req = storage("legacy").getStore()?.req;
      const requestData = graphqlRequestData.get(req);
      if (requestData) {
        requestData.isInGraphqlRequest = true;
        addSpecificEndpoint(req.method, req.originalUrl || req.url, specificBlockingTypes.GRAPHQL);
      }
    }
    function beforeWriteApolloGraphqlResponse({ abortController, abortData }) {
      const req = storage("legacy").getStore()?.req;
      if (!req) return;
      const requestData = graphqlRequestData.get(req);
      if (requestData?.blocked) {
        const rootSpan = web.root(req);
        if (!rootSpan) return;
        try {
          const blockingData = getBlockingData(req, specificBlockingTypes.GRAPHQL, requestData.wafAction);
          abortData.statusCode = blockingData.statusCode;
          abortData.headers = blockingData.headers;
          abortData.message = blockingData.body;
          rootSpan.setTag("appsec.blocked", "true");
          abortController?.abort();
        } catch (err) {
          rootSpan.setTag("_dd.appsec.block.failed", 1);
          log.error("[ASM] Blocking error", err);
          updateBlockFailureMetric(req);
        }
      }
      graphqlRequestData.delete(req);
    }
    function enableApollo() {
      graphqlMiddlewareChannel.subscribe({
        start: enterInApolloMiddleware
      });
      apolloServerCoreChannel.subscribe({
        start: enterInApolloServerCoreRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse
      });
      apolloChannel.subscribe({
        start: enterInApolloRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse
      });
      apolloHttpServerChannel.subscribe({
        start: enterInApolloMiddleware
      });
    }
    function disableApollo() {
      graphqlMiddlewareChannel.unsubscribe({
        start: enterInApolloMiddleware
      });
      apolloServerCoreChannel.unsubscribe({
        start: enterInApolloServerCoreRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse
      });
      apolloChannel.unsubscribe({
        start: enterInApolloRequest,
        asyncEnd: beforeWriteApolloGraphqlResponse
      });
      apolloHttpServerChannel.unsubscribe({
        start: enterInApolloMiddleware
      });
    }
    function enableGraphql() {
      startGraphqlResolve.subscribe(onGraphqlStartResolve);
    }
    function disableGraphql() {
      if (startGraphqlResolve.hasSubscribers) startGraphqlResolve.unsubscribe(onGraphqlStartResolve);
    }
    module2.exports = {
      enable,
      disable
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/filter.js
var require_filter = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/filter.js"(exports2, module2) {
    "use strict";
    var NODE_MODULES = "node_modules";
    var isPrivateModule = function(file) {
      return file && !file.includes(NODE_MODULES);
    };
    var isDdTrace = function(file) {
      return Boolean(file?.includes("dd-trace"));
    };
    module2.exports = {
      isPrivateModule,
      isDdTrace
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js
var require_csi_methods = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/csi-methods.js"(exports2, module2) {
    "use strict";
    var csiMethods = [
      { src: "concat" },
      { src: "join" },
      { src: "parse" },
      { src: "plusOperator", operator: true },
      { src: "random" },
      { src: "replace" },
      { src: "slice" },
      { src: "substr" },
      { src: "substring" },
      { src: "toLowerCase", dst: "stringCase" },
      { src: "toUpperCase", dst: "stringCase" },
      { src: "tplOperator", operator: true },
      { src: "trim" },
      { src: "trimEnd" },
      { src: "trimStart", dst: "trim" },
      { src: "eval", allowedWithoutCallee: true }
    ];
    module2.exports = {
      csiMethods
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/telemetry/verbosity.js
var require_verbosity = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/telemetry/verbosity.js"(exports2, module2) {
    "use strict";
    var Verbosity = {
      OFF: 0,
      MANDATORY: 1,
      INFORMATION: 2,
      DEBUG: 3
    };
    function isDebugAllowed(value) {
      return value >= Verbosity.DEBUG;
    }
    function isInfoAllowed(value) {
      return value >= Verbosity.INFORMATION;
    }
    function getVerbosity(verbosity) {
      if (verbosity) {
        verbosity = verbosity.toUpperCase();
        return Verbosity[verbosity] === void 0 ? Verbosity.INFORMATION : Verbosity[verbosity];
      }
      return Verbosity.INFORMATION;
    }
    function getName(verbosityValue) {
      for (const name in Verbosity) {
        if (Verbosity[name] === verbosityValue) {
          return name;
        }
      }
      return "OFF";
    }
    module2.exports = {
      Verbosity,
      isDebugAllowed,
      isInfoAllowed,
      getVerbosity,
      getName
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/telemetry/span-tags.js
var require_span_tags = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/telemetry/span-tags.js"(exports2, module2) {
    "use strict";
    function addMetricsToSpan(rootSpan, metrics2, tagPrefix) {
      if (!rootSpan?.addTags || !metrics2) return;
      const flattenMap = /* @__PURE__ */ new Map();
      metrics2.filter((data) => data?.metric).forEach((data) => {
        const name = taggedMetricName(data);
        let total = flattenMap.get(name);
        const value = flatten(data);
        if (total) {
          total += value;
        } else {
          total = value;
        }
        flattenMap.set(name, total);
      });
      for (const [key, value] of flattenMap) {
        const tagName = `${tagPrefix}.${key}`;
        rootSpan.addTags({
          [tagName]: value
        });
      }
    }
    function flatten(metricData) {
      const { points } = metricData;
      return points ? points.map((point) => point[1]).reduce((total, value) => total + value, 0) : 0;
    }
    function taggedMetricName(data) {
      const metric = data.metric;
      const tags = filterTags(data.tags);
      return tags?.length ? `${metric}.${processTagValue(tags)}` : metric;
    }
    function filterTags(tags) {
      return tags?.filter((tag) => !tag.startsWith("version"));
    }
    function processTagValue(tags) {
      return tags.map((tag) => tag.includes(":") ? tag.split(":")[1] : tag).join("_").replaceAll(".", "_");
    }
    module2.exports = {
      addMetricsToSpan,
      filterTags
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/tags.js
var require_tags4 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/tags.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      IAST_ENABLED_TAG_KEY: "_dd.iast.enabled",
      IAST_JSON_TAG_KEY: "_dd.iast.json",
      IAST_TRACE_METRIC_PREFIX: "_dd.iast.telemetry"
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/telemetry/namespaces.js
var require_namespaces = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/telemetry/namespaces.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { Namespace } = require_metrics();
    var { addMetricsToSpan } = require_span_tags();
    var { IAST_TRACE_METRIC_PREFIX } = require_tags4();
    var DD_IAST_METRICS_NAMESPACE = Symbol("_dd.iast.request.metrics.namespace");
    function initRequestNamespace(context2) {
      if (!context2) return;
      const namespace2 = new IastNamespace();
      context2[DD_IAST_METRICS_NAMESPACE] = namespace2;
      return namespace2;
    }
    function getNamespaceFromContext(context2) {
      return context2?.[DD_IAST_METRICS_NAMESPACE];
    }
    function finalizeRequestNamespace(context2, rootSpan) {
      try {
        const namespace2 = getNamespaceFromContext(context2);
        if (!namespace2) return;
        addMetricsToSpan(rootSpan, [...namespace2.metrics.values()], IAST_TRACE_METRIC_PREFIX);
        merge(namespace2);
        namespace2.clear();
      } catch (e) {
        log.error("[ASM] Error merging request metrics", e);
      } finally {
        if (context2) {
          delete context2[DD_IAST_METRICS_NAMESPACE];
        }
      }
    }
    function merge(namespace2) {
      for (const [metricName, metricsByTagMap] of namespace2.iastMetrics) {
        for (const [tags, metric] of metricsByTagMap) {
          const { type, points } = metric;
          if (points?.length && type === "count") {
            const gMetric = globalNamespace.getMetric(metricName, tags);
            points.forEach((point) => gMetric.inc(point[1]));
          }
        }
      }
    }
    var IastNamespace = class extends Namespace {
      constructor(maxMetricTagsSize = 100) {
        super("iast");
        this.maxMetricTagsSize = maxMetricTagsSize;
        this.iastMetrics = /* @__PURE__ */ new Map();
      }
      getIastMetrics(name) {
        let metrics2 = this.iastMetrics.get(name);
        if (!metrics2) {
          metrics2 = /* @__PURE__ */ new Map();
          this.iastMetrics.set(name, metrics2);
        }
        return metrics2;
      }
      getMetric(name, tags, type = "count") {
        const metrics2 = this.getIastMetrics(name);
        let metric = metrics2.get(tags);
        if (!metric) {
          metric = super[type](name, Array.isArray(tags) ? [...tags] : tags);
          if (metrics2.size === this.maxMetricTagsSize) {
            metrics2.clear();
            log.error("[ASM] Tags cache max size reached for metric %s", name);
          }
          metrics2.set(tags, metric);
        }
        return metric;
      }
      count(name, tags) {
        return this.getMetric(name, tags, "count");
      }
      clear() {
        this.iastMetrics.clear();
        this.distributions.clear();
        this.metrics.clear();
      }
    };
    var globalNamespace = new IastNamespace();
    module2.exports = {
      initRequestNamespace,
      getNamespaceFromContext,
      finalizeRequestNamespace,
      globalNamespace,
      DD_IAST_METRICS_NAMESPACE,
      IastNamespace
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/telemetry/index.js
var require_telemetry7 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/telemetry/index.js"(exports2, module2) {
    "use strict";
    var telemetryMetrics = require_metrics();
    var { Verbosity, getVerbosity } = require_verbosity();
    var { initRequestNamespace, finalizeRequestNamespace, globalNamespace } = require_namespaces();
    var Telemetry = class {
      configure(config, verbosity) {
        const telemetryAndMetricsEnabled = config?.telemetry?.enabled && config.telemetry.metrics;
        this.verbosity = telemetryAndMetricsEnabled ? getVerbosity(verbosity) : Verbosity.OFF;
        this.enabled = this.verbosity !== Verbosity.OFF;
        if (this.enabled) {
          telemetryMetrics.manager.set("iast", globalNamespace);
        }
      }
      stop() {
        this.enabled = false;
        telemetryMetrics.manager.delete("iast");
      }
      isEnabled() {
        return this.enabled;
      }
      onRequestStart(context2) {
        if (this.isEnabled()) {
          initRequestNamespace(context2);
        }
      }
      onRequestEnd(context2, rootSpan) {
        if (this.isEnabled()) {
          finalizeRequestNamespace(context2, rootSpan);
        }
      }
    };
    module2.exports = new Telemetry();
  }
});

// ../../packages/dd-trace/src/appsec/iast/telemetry/iast-metric.js
var require_iast_metric = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/telemetry/iast-metric.js"(exports2, module2) {
    "use strict";
    var { getNamespaceFromContext, globalNamespace } = require_namespaces();
    var Scope = {
      GLOBAL: "GLOBAL",
      REQUEST: "REQUEST"
    };
    var PropagationType = {
      STRING: "STRING",
      JSON: "JSON",
      URL: "URL"
    };
    var TagKey = {
      VULNERABILITY_TYPE: "vulnerability_type",
      SOURCE_TYPE: "source_type",
      PROPAGATION_TYPE: "propagation_type"
    };
    function formatTags(tags, tagKey) {
      return tags.map((tagValue) => tagValue ? [`${tagKey}:${tagValue.toLowerCase()}`] : void 0);
    }
    function getNamespace(scope, context2) {
      let namespace2 = globalNamespace;
      if (scope === Scope.REQUEST) {
        namespace2 = getNamespaceFromContext(context2) || globalNamespace;
      }
      return namespace2;
    }
    var IastMetric = class {
      constructor(name, scope, tagKey) {
        this.name = name;
        this.scope = scope;
        this.tagKey = tagKey;
      }
      formatTags(...tags) {
        return formatTags(tags, this.tagKey);
      }
      inc(context2, tags, value = 1) {
        const namespace2 = getNamespace(this.scope, context2);
        namespace2.count(this.name, tags).inc(value);
      }
    };
    var NoTaggedIastMetric = class extends IastMetric {
      constructor(name, scope) {
        super(name, scope);
        this.tags = [];
      }
      inc(context2, value = 1) {
        const namespace2 = getNamespace(this.scope, context2);
        namespace2.count(this.name, this.tags).inc(value);
      }
    };
    function getExecutedMetric(tagKey) {
      return tagKey === TagKey.VULNERABILITY_TYPE ? EXECUTED_SINK : EXECUTED_SOURCE;
    }
    function getInstrumentedMetric(tagKey) {
      return tagKey === TagKey.VULNERABILITY_TYPE ? INSTRUMENTED_SINK : INSTRUMENTED_SOURCE;
    }
    var INSTRUMENTED_PROPAGATION = new NoTaggedIastMetric("instrumented.propagation", Scope.GLOBAL);
    var INSTRUMENTED_SOURCE = new IastMetric("instrumented.source", Scope.GLOBAL, TagKey.SOURCE_TYPE);
    var INSTRUMENTED_SINK = new IastMetric("instrumented.sink", Scope.GLOBAL, TagKey.VULNERABILITY_TYPE);
    var EXECUTED_SOURCE = new IastMetric("executed.source", Scope.REQUEST, TagKey.SOURCE_TYPE);
    var EXECUTED_SINK = new IastMetric("executed.sink", Scope.REQUEST, TagKey.VULNERABILITY_TYPE);
    var REQUEST_TAINTED = new NoTaggedIastMetric("request.tainted", Scope.REQUEST);
    var EXECUTED_PROPAGATION = new NoTaggedIastMetric("executed.propagation", Scope.REQUEST);
    var EXECUTED_TAINTED = new NoTaggedIastMetric("executed.tainted", Scope.REQUEST);
    var SUPPRESSED_VULNERABILITIES = new IastMetric(
      "suppressed.vulnerabilities",
      Scope.REQUEST,
      TagKey.VULNERABILITY_TYPE
    );
    module2.exports = {
      INSTRUMENTED_PROPAGATION,
      INSTRUMENTED_SOURCE,
      INSTRUMENTED_SINK,
      EXECUTED_PROPAGATION,
      EXECUTED_SOURCE,
      EXECUTED_SINK,
      EXECUTED_TAINTED,
      REQUEST_TAINTED,
      SUPPRESSED_VULNERABILITIES,
      PropagationType,
      TagKey,
      IastMetric,
      NoTaggedIastMetric,
      getExecutedMetric,
      getInstrumentedMetric,
      formatTags
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/rewriter-telemetry.js
var require_rewriter_telemetry = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/rewriter-telemetry.js"(exports2, module2) {
    "use strict";
    var iastTelemetry = require_telemetry7();
    var { Verbosity } = require_verbosity();
    var { INSTRUMENTED_PROPAGATION } = require_iast_metric();
    function incrementTelemetryIfNeeded(metrics2) {
      if (iastTelemetry.verbosity !== Verbosity.OFF && metrics2?.instrumentedPropagation) {
        INSTRUMENTED_PROPAGATION.inc(void 0, metrics2.instrumentedPropagation);
      }
    }
    module2.exports = { incrementTelemetryIfNeeded };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/constants.js
var require_constants4 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      LOG_MESSAGE: "LOG",
      REWRITTEN_MESSAGE: "REWRITTEN"
    };
  }
});

// ../../packages/datadog-instrumentations/src/orchestrion-config/index.js
var require_orchestrion_config = __commonJS({
  "../../packages/datadog-instrumentations/src/orchestrion-config/index.js"(exports2, module2) {
    "use strict";
    module2.exports = `
version: 1
dc_module: dc-polyfill
instrumentations:
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/runnables/base.js
    function_query:
      name: invoke
      type: method
      kind: async
      class: RunnableSequence
    operator: tracePromise
    channel_name: "RunnableSequence_invoke"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/runnables/base.js
    function_query:
      name: batch
      type: method
      kind: async
      class: RunnableSequence
    operator: tracePromise
    channel_name: "RunnableSequence_batch"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/language_models/chat_models.js
    function_query:
      name: generate
      type: method
      kind: async
      class: BaseChatModel
    operator: tracePromise
    channel_name: "BaseChatModel_generate"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/language_models/llms.js
    function_query:
      name: generate
      type: method
      kind: async
    operator: tracePromise
    channel_name: "BaseLLM_generate"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/embeddings.js
    function_query:
      name: constructor
      type: method
      kind: sync
      class: Embeddings
    operator: traceSync
    channel_name: "Embeddings_constructor"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/tools/index.js
    function_query:
      name: invoke
      type: method
      kind: async
      class: StructuredTool
    operator: tracePromise
    channel_name: "Tool_invoke"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/vectorstores.js
    function_query:
      name: similaritySearch
      type: method
      kind: async
      class: VectorStore
    operator: tracePromise
    channel_name: "VectorStore_similaritySearch"
  - module_name: "@langchain/core"
    version_range: ">=0.1.0"
    file_path: dist/vectorstores.js
    function_query:
      name: similaritySearchWithScore
      type: method
      kind: async
      class: VectorStore
    operator: tracePromise
    channel_name: "VectorStore_similaritySearchWithScore"
`;
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/node_modules/lru-cache/index.js"(exports2, module2) {
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var hasAbortController = typeof AbortController === "function";
    var AC = hasAbortController ? AbortController : class AbortController {
      constructor() {
        this.signal = new AS();
      }
      abort(reason = new Error("This operation was aborted")) {
        this.signal.reason = this.signal.reason || reason;
        this.signal.aborted = true;
        this.signal.dispatchEvent({
          type: "abort",
          target: this.signal
        });
      }
    };
    var hasAbortSignal = typeof AbortSignal === "function";
    var hasACAbortSignal = typeof AC.AbortSignal === "function";
    var AS = hasAbortSignal ? AbortSignal : hasACAbortSignal ? AC.AbortController : class AbortSignal {
      constructor() {
        this.reason = void 0;
        this.aborted = false;
        this._listeners = [];
      }
      dispatchEvent(e) {
        if (e.type === "abort") {
          this.aborted = true;
          this.onabort(e);
          this._listeners.forEach((f) => f(e), this);
        }
      }
      onabort() {
      }
      addEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners.push(fn);
        }
      }
      removeEventListener(ev, fn) {
        if (ev === "abort") {
          this._listeners = this._listeners.filter((f) => f !== fn);
        }
      }
    };
    var warned = /* @__PURE__ */ new Set();
    var deprecatedOption = (opt, instead) => {
      const code = `LRU_CACHE_OPTION_${opt}`;
      if (shouldWarn(code)) {
        warn(code, `${opt} option`, `options.${instead}`, LRUCache);
      }
    };
    var deprecatedMethod = (method, instead) => {
      const code = `LRU_CACHE_METHOD_${method}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get: get3 } = Object.getOwnPropertyDescriptor(prototype, method);
        warn(code, `${method} method`, `cache.${instead}()`, get3);
      }
    };
    var deprecatedProperty = (field, instead) => {
      const code = `LRU_CACHE_PROPERTY_${field}`;
      if (shouldWarn(code)) {
        const { prototype } = LRUCache;
        const { get: get3 } = Object.getOwnPropertyDescriptor(prototype, field);
        warn(code, `${field} property`, `cache.${instead}`, get3);
      }
    };
    var emitWarning = (...a) => {
      typeof process === "object" && process && typeof process.emitWarning === "function" ? process.emitWarning(...a) : console.error(...a);
    };
    var shouldWarn = (code) => !warned.has(code);
    var warn = (code, what, instead, fn) => {
      warned.add(code);
      const msg = `The ${what} is deprecated. Please use ${instead} instead.`;
      emitWarning(msg, "DeprecationWarning", code, fn);
    };
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var Stack = class {
      constructor(max) {
        if (max === 0) {
          return [];
        }
        const UintArray = getUintArray(max);
        this.heap = new UintArray(max);
        this.length = 0;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    var LRUCache = class _LRUCache {
      constructor(options = {}) {
        const {
          max = 0,
          ttl,
          ttlResolution = 1,
          ttlAutopurge,
          updateAgeOnGet,
          updateAgeOnHas,
          allowStale,
          dispose,
          disposeAfter,
          noDisposeOnSet,
          noUpdateTTL,
          maxSize = 0,
          maxEntrySize = 0,
          sizeCalculation,
          fetchMethod,
          fetchContext,
          noDeleteOnFetchRejection,
          noDeleteOnStaleGet,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort
        } = options;
        const { length, maxAge, stale } = options instanceof _LRUCache ? {} : options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        this.max = max;
        this.maxSize = maxSize;
        this.maxEntrySize = maxEntrySize || this.maxSize;
        this.sizeCalculation = sizeCalculation || length;
        if (this.sizeCalculation) {
          if (!this.maxSize && !this.maxEntrySize) {
            throw new TypeError(
              "cannot set sizeCalculation without setting maxSize or maxEntrySize"
            );
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        this.fetchMethod = fetchMethod || null;
        if (this.fetchMethod && typeof this.fetchMethod !== "function") {
          throw new TypeError(
            "fetchMethod must be a function if specified"
          );
        }
        this.fetchContext = fetchContext;
        if (!this.fetchMethod && fetchContext !== void 0) {
          throw new TypeError(
            "cannot set fetchContext without fetchMethod"
          );
        }
        this.keyMap = /* @__PURE__ */ new Map();
        this.keyList = new Array(max).fill(null);
        this.valList = new Array(max).fill(null);
        this.next = new UintArray(max);
        this.prev = new UintArray(max);
        this.head = 0;
        this.tail = 0;
        this.free = new Stack(max);
        this.initialFill = 1;
        this.size = 0;
        if (typeof dispose === "function") {
          this.dispose = dispose;
        }
        if (typeof disposeAfter === "function") {
          this.disposeAfter = disposeAfter;
          this.disposed = [];
        } else {
          this.disposeAfter = null;
          this.disposed = null;
        }
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (this.maxSize !== 0) {
            if (!isPosInt(this.maxSize)) {
              throw new TypeError(
                "maxSize must be a positive integer if specified"
              );
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError(
              "maxEntrySize must be a positive integer if specified"
            );
          }
          this.initializeSizeTracking();
        }
        this.allowStale = !!allowStale || !!stale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || maxAge || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError(
              "ttl must be a positive integer if specified"
            );
          }
          this.initializeTTLTracking();
        }
        if (this.max === 0 && this.ttl === 0 && this.maxSize === 0) {
          throw new TypeError(
            "At least one of max, maxSize, or ttl is required"
          );
        }
        if (!this.ttlAutopurge && !this.max && !this.maxSize) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
        if (stale) {
          deprecatedOption("stale", "allowStale");
        }
        if (maxAge) {
          deprecatedOption("maxAge", "ttl");
        }
        if (length) {
          deprecatedOption("length", "sizeCalculation");
        }
      }
      getRemainingTTL(key) {
        return this.has(key, { updateAgeOnHas: false }) ? Infinity : 0;
      }
      initializeTTLTracking() {
        this.ttls = new ZeroArray(this.max);
        this.starts = new ZeroArray(this.max);
        this.setItemTTL = (index, ttl, start = perf.now()) => {
          this.starts[index] = ttl !== 0 ? start : 0;
          this.ttls[index] = ttl;
          if (ttl !== 0 && this.ttlAutopurge) {
            const t = setTimeout(() => {
              if (this.isStale(index)) {
                this.delete(this.keyList[index]);
              }
            }, ttl + 1);
            if (t.unref) {
              t.unref();
            }
          }
        };
        this.updateItemAge = (index) => {
          this.starts[index] = this.ttls[index] !== 0 ? perf.now() : 0;
        };
        this.statusTTL = (status, index) => {
          if (status) {
            status.ttl = this.ttls[index];
            status.start = this.starts[index];
            status.now = cachedNow || getNow();
            status.remainingTTL = status.now + status.ttl - status.start;
          }
        };
        let cachedNow = 0;
        const getNow = () => {
          const n = perf.now();
          if (this.ttlResolution > 0) {
            cachedNow = n;
            const t = setTimeout(
              () => cachedNow = 0,
              this.ttlResolution
            );
            if (t.unref) {
              t.unref();
            }
          }
          return n;
        };
        this.getRemainingTTL = (key) => {
          const index = this.keyMap.get(key);
          if (index === void 0) {
            return 0;
          }
          return this.ttls[index] === 0 || this.starts[index] === 0 ? Infinity : this.starts[index] + this.ttls[index] - (cachedNow || getNow());
        };
        this.isStale = (index) => {
          return this.ttls[index] !== 0 && this.starts[index] !== 0 && (cachedNow || getNow()) - this.starts[index] > this.ttls[index];
        };
      }
      updateItemAge(_index) {
      }
      statusTTL(_status, _index) {
      }
      setItemTTL(_index, _ttl, _start) {
      }
      isStale(_index) {
        return false;
      }
      initializeSizeTracking() {
        this.calculatedSize = 0;
        this.sizes = new ZeroArray(this.max);
        this.removeItemSize = (index) => {
          this.calculatedSize -= this.sizes[index];
          this.sizes[index] = 0;
        };
        this.requireSize = (k, v, size, sizeCalculation) => {
          if (this.isBackgroundFetch(v)) {
            return 0;
          }
          if (!isPosInt(size)) {
            if (sizeCalculation) {
              if (typeof sizeCalculation !== "function") {
                throw new TypeError("sizeCalculation must be a function");
              }
              size = sizeCalculation(v, k);
              if (!isPosInt(size)) {
                throw new TypeError(
                  "sizeCalculation return invalid (expect positive integer)"
                );
              }
            } else {
              throw new TypeError(
                "invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set."
              );
            }
          }
          return size;
        };
        this.addItemSize = (index, size, status) => {
          this.sizes[index] = size;
          if (this.maxSize) {
            const maxSize = this.maxSize - this.sizes[index];
            while (this.calculatedSize > maxSize) {
              this.evict(true);
            }
          }
          this.calculatedSize += this.sizes[index];
          if (status) {
            status.entrySize = size;
            status.totalCalculatedSize = this.calculatedSize;
          }
        };
      }
      removeItemSize(_index) {
      }
      addItemSize(_index, _size) {
      }
      requireSize(_k, _v, size, sizeCalculation) {
        if (size || sizeCalculation) {
          throw new TypeError(
            "cannot set size without setting maxSize or maxEntrySize on cache"
          );
        }
      }
      *indexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.tail; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.head) {
              break;
            } else {
              i = this.prev[i];
            }
          }
        }
      }
      *rindexes({ allowStale = this.allowStale } = {}) {
        if (this.size) {
          for (let i = this.head; true; ) {
            if (!this.isValidIndex(i)) {
              break;
            }
            if (allowStale || !this.isStale(i)) {
              yield i;
            }
            if (i === this.tail) {
              break;
            } else {
              i = this.next[i];
            }
          }
        }
      }
      isValidIndex(index) {
        return index !== void 0 && this.keyMap.get(this.keyList[index]) === index;
      }
      *entries() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *rentries() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield [this.keyList[i], this.valList[i]];
          }
        }
      }
      *keys() {
        for (const i of this.indexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *rkeys() {
        for (const i of this.rindexes()) {
          if (this.keyList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.keyList[i];
          }
        }
      }
      *values() {
        for (const i of this.indexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      *rvalues() {
        for (const i of this.rindexes()) {
          if (this.valList[i] !== void 0 && !this.isBackgroundFetch(this.valList[i])) {
            yield this.valList[i];
          }
        }
      }
      [Symbol.iterator]() {
        return this.entries();
      }
      find(fn, getOptions) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          if (fn(value, this.keyList[i], this)) {
            return this.get(this.keyList[i], getOptions);
          }
        }
      }
      forEach(fn, thisp = this) {
        for (const i of this.indexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      rforEach(fn, thisp = this) {
        for (const i of this.rindexes()) {
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          fn.call(thisp, value, this.keyList[i], this);
        }
      }
      get prune() {
        deprecatedMethod("prune", "purgeStale");
        return this.purgeStale;
      }
      purgeStale() {
        let deleted = false;
        for (const i of this.rindexes({ allowStale: true })) {
          if (this.isStale(i)) {
            this.delete(this.keyList[i]);
            deleted = true;
          }
        }
        return deleted;
      }
      dump() {
        const arr = [];
        for (const i of this.indexes({ allowStale: true })) {
          const key = this.keyList[i];
          const v = this.valList[i];
          const value = this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === void 0) continue;
          const entry = { value };
          if (this.ttls) {
            entry.ttl = this.ttls[i];
            const age = perf.now() - this.starts[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (this.sizes) {
            entry.size = this.sizes[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      dispose(_v, _k, _reason) {
      }
      set(k, v, {
        ttl = this.ttl,
        start,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        status
      } = {}) {
        size = this.requireSize(k, v, size, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          this.delete(k);
          return this;
        }
        let index = this.size === 0 ? void 0 : this.keyMap.get(k);
        if (index === void 0) {
          index = this.newIndex();
          this.keyList[index] = k;
          this.valList[index] = v;
          this.keyMap.set(k, index);
          this.next[this.tail] = index;
          this.prev[index] = this.tail;
          this.tail = index;
          this.size++;
          this.addItemSize(index, size, status);
          if (status) {
            status.set = "add";
          }
          noUpdateTTL = false;
        } else {
          this.moveToTail(index);
          const oldVal = this.valList[index];
          if (v !== oldVal) {
            if (this.isBackgroundFetch(oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
            } else {
              if (!noDisposeOnSet) {
                this.dispose(oldVal, k, "set");
                if (this.disposeAfter) {
                  this.disposed.push([oldVal, k, "set"]);
                }
              }
            }
            this.removeItemSize(index);
            this.valList[index] = v;
            this.addItemSize(index, size, status);
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && this.isBackgroundFetch(oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0) status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && this.ttl === 0 && !this.ttls) {
          this.initializeTTLTracking();
        }
        if (!noUpdateTTL) {
          this.setItemTTL(index, ttl, start);
        }
        this.statusTTL(status, index);
        if (this.disposeAfter) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return this;
      }
      newIndex() {
        if (this.size === 0) {
          return this.tail;
        }
        if (this.size === this.max && this.max !== 0) {
          return this.evict(false);
        }
        if (this.free.length !== 0) {
          return this.free.pop();
        }
        return this.initialFill++;
      }
      pop() {
        if (this.size) {
          const val = this.valList[this.head];
          this.evict(true);
          return val;
        }
      }
      evict(free) {
        const head = this.head;
        const k = this.keyList[head];
        const v = this.valList[head];
        if (this.isBackgroundFetch(v)) {
          v.__abortController.abort(new Error("evicted"));
        } else {
          this.dispose(v, k, "evict");
          if (this.disposeAfter) {
            this.disposed.push([v, k, "evict"]);
          }
        }
        this.removeItemSize(head);
        if (free) {
          this.keyList[head] = null;
          this.valList[head] = null;
          this.free.push(head);
        }
        this.head = this.next[head];
        this.keyMap.delete(k);
        this.size--;
        return head;
      }
      has(k, { updateAgeOnHas = this.updateAgeOnHas, status } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          if (!this.isStale(index)) {
            if (updateAgeOnHas) {
              this.updateItemAge(index);
            }
            if (status) status.has = "hit";
            this.statusTTL(status, index);
            return true;
          } else if (status) {
            status.has = "stale";
            this.statusTTL(status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      // like get(), but without any LRU updating or TTL expiration
      peek(k, { allowStale = this.allowStale } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0 && (allowStale || !this.isStale(index))) {
          const v = this.valList[index];
          return this.isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
      }
      backgroundFetch(k, index, options, context2) {
        const v = index === void 0 ? void 0 : this.valList[index];
        if (this.isBackgroundFetch(v)) {
          return v;
        }
        const ac = new AC();
        if (options.signal) {
          options.signal.addEventListener(
            "abort",
            () => ac.abort(options.signal.reason)
          );
        }
        const fetchOpts = {
          signal: ac.signal,
          options,
          context: context2
        };
        const cb = (v2, updateCache = false) => {
          const { aborted } = ac.signal;
          const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
          if (options.status) {
            if (aborted && !updateCache) {
              options.status.fetchAborted = true;
              options.status.fetchError = ac.signal.reason;
              if (ignoreAbort) options.status.fetchAbortIgnored = true;
            } else {
              options.status.fetchResolved = true;
            }
          }
          if (aborted && !ignoreAbort && !updateCache) {
            return fetchFail(ac.signal.reason);
          }
          if (this.valList[index] === p) {
            if (v2 === void 0) {
              if (p.__staleWhileFetching) {
                this.valList[index] = p.__staleWhileFetching;
              } else {
                this.delete(k);
              }
            } else {
              if (options.status) options.status.fetchUpdated = true;
              this.set(k, v2, fetchOpts.options);
            }
          }
          return v2;
        };
        const eb = (er) => {
          if (options.status) {
            options.status.fetchRejected = true;
            options.status.fetchError = er;
          }
          return fetchFail(er);
        };
        const fetchFail = (er) => {
          const { aborted } = ac.signal;
          const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
          const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
          const noDelete = allowStale || options.noDeleteOnFetchRejection;
          if (this.valList[index] === p) {
            const del = !noDelete || p.__staleWhileFetching === void 0;
            if (del) {
              this.delete(k);
            } else if (!allowStaleAborted) {
              this.valList[index] = p.__staleWhileFetching;
            }
          }
          if (allowStale) {
            if (options.status && p.__staleWhileFetching !== void 0) {
              options.status.returnedStale = true;
            }
            return p.__staleWhileFetching;
          } else if (p.__returned === p) {
            throw er;
          }
        };
        const pcall = (res, rej) => {
          this.fetchMethod(k, v, fetchOpts).then((v2) => res(v2), rej);
          ac.signal.addEventListener("abort", () => {
            if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
              res();
              if (options.allowStaleOnFetchAbort) {
                res = (v2) => cb(v2, true);
              }
            }
          });
        };
        if (options.status) options.status.fetchDispatched = true;
        const p = new Promise(pcall).then(cb, eb);
        p.__abortController = ac;
        p.__staleWhileFetching = v;
        p.__returned = null;
        if (index === void 0) {
          this.set(k, p, { ...fetchOpts.options, status: void 0 });
          index = this.keyMap.get(k);
        } else {
          this.valList[index] = p;
        }
        return p;
      }
      isBackgroundFetch(p) {
        return p && typeof p === "object" && typeof p.then === "function" && Object.prototype.hasOwnProperty.call(
          p,
          "__staleWhileFetching"
        ) && Object.prototype.hasOwnProperty.call(p, "__returned") && (p.__returned === p || p.__returned === null);
      }
      // this takes the union of get() and set() opts, because it does both
      async fetch(k, {
        // get options
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        // set options
        ttl = this.ttl,
        noDisposeOnSet = this.noDisposeOnSet,
        size = 0,
        sizeCalculation = this.sizeCalculation,
        noUpdateTTL = this.noUpdateTTL,
        // fetch exclusive options
        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
        allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
        ignoreFetchAbort = this.ignoreFetchAbort,
        allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
        fetchContext = this.fetchContext,
        forceRefresh = false,
        status,
        signal
      } = {}) {
        if (!this.fetchMethod) {
          if (status) status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = this.keyMap.get(k);
        if (index === void 0) {
          if (status) status.fetch = "miss";
          const p = this.backgroundFetch(k, index, options, fetchContext);
          return p.__returned = p;
        } else {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale) status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = this.isStale(index);
          if (!forceRefresh && !isStale) {
            if (status) status.fetch = "hit";
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            this.statusTTL(status, index);
            return v;
          }
          const p = this.backgroundFetch(k, index, options, fetchContext);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = hasStale && isStale ? "stale" : "refresh";
            if (staleVal && isStale) status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      get(k, {
        allowStale = this.allowStale,
        updateAgeOnGet = this.updateAgeOnGet,
        noDeleteOnStaleGet = this.noDeleteOnStaleGet,
        status
      } = {}) {
        const index = this.keyMap.get(k);
        if (index !== void 0) {
          const value = this.valList[index];
          const fetching = this.isBackgroundFetch(value);
          this.statusTTL(status, index);
          if (this.isStale(index)) {
            if (status) status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                this.delete(k);
              }
              if (status) status.returnedStale = allowStale;
              return allowStale ? value : void 0;
            } else {
              if (status) {
                status.returnedStale = allowStale && value.__staleWhileFetching !== void 0;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status) status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            this.moveToTail(index);
            if (updateAgeOnGet) {
              this.updateItemAge(index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      connect(p, n) {
        this.prev[n] = p;
        this.next[p] = n;
      }
      moveToTail(index) {
        if (index !== this.tail) {
          if (index === this.head) {
            this.head = this.next[index];
          } else {
            this.connect(this.prev[index], this.next[index]);
          }
          this.connect(this.tail, index);
          this.tail = index;
        }
      }
      get del() {
        deprecatedMethod("del", "delete");
        return this.delete;
      }
      delete(k) {
        let deleted = false;
        if (this.size !== 0) {
          const index = this.keyMap.get(k);
          if (index !== void 0) {
            deleted = true;
            if (this.size === 1) {
              this.clear();
            } else {
              this.removeItemSize(index);
              const v = this.valList[index];
              if (this.isBackgroundFetch(v)) {
                v.__abortController.abort(new Error("deleted"));
              } else {
                this.dispose(v, k, "delete");
                if (this.disposeAfter) {
                  this.disposed.push([v, k, "delete"]);
                }
              }
              this.keyMap.delete(k);
              this.keyList[index] = null;
              this.valList[index] = null;
              if (index === this.tail) {
                this.tail = this.prev[index];
              } else if (index === this.head) {
                this.head = this.next[index];
              } else {
                this.next[this.prev[index]] = this.next[index];
                this.prev[this.next[index]] = this.prev[index];
              }
              this.size--;
              this.free.push(index);
            }
          }
        }
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
        return deleted;
      }
      clear() {
        for (const index of this.rindexes({ allowStale: true })) {
          const v = this.valList[index];
          if (this.isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("deleted"));
          } else {
            const k = this.keyList[index];
            this.dispose(v, k, "delete");
            if (this.disposeAfter) {
              this.disposed.push([v, k, "delete"]);
            }
          }
        }
        this.keyMap.clear();
        this.valList.fill(null);
        this.keyList.fill(null);
        if (this.ttls) {
          this.ttls.fill(0);
          this.starts.fill(0);
        }
        if (this.sizes) {
          this.sizes.fill(0);
        }
        this.head = 0;
        this.tail = 0;
        this.initialFill = 1;
        this.free.length = 0;
        this.calculatedSize = 0;
        this.size = 0;
        if (this.disposed) {
          while (this.disposed.length) {
            this.disposeAfter(...this.disposed.shift());
          }
        }
      }
      get reset() {
        deprecatedMethod("reset", "clear");
        return this.clear;
      }
      get length() {
        deprecatedProperty("length", "size");
        return this.size;
      }
      static get AbortController() {
        return AC;
      }
      static get AbortSignal() {
        return AS;
      }
    };
    module2.exports = LRUCache;
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/js/source-map/primordials.js
var require_primordials2 = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/js/source-map/primordials.js"(exports2, module2) {
    "use strict";
    function generateCaller(method) {
      return function(self2, ...args) {
        return method.apply(self2, args);
      };
    }
    var primordials = {
      ArrayPrototypePush: generateCaller(Array.prototype.push),
      ArrayPrototypeSlice: generateCaller(Array.prototype.slice),
      ArrayPrototypeSort: generateCaller(Array.prototype.sort),
      ArrayIsArray: Array.isArray,
      ObjectPrototypeHasOwnProperty: generateCaller(Object.prototype.hasOwnProperty),
      StringPrototypeCharAt: generateCaller(String.prototype.charAt)
    };
    module2.exports = primordials;
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/js/source-map/node_source_map.js
var require_node_source_map = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/js/source-map/node_source_map.js"(exports2, module2) {
    "use strict";
    var {
      ArrayPrototypePush,
      ArrayPrototypeSlice,
      ArrayPrototypeSort,
      ArrayIsArray,
      ObjectPrototypeHasOwnProperty,
      StringPrototypeCharAt
    } = require_primordials2();
    var validateObject = function() {
    };
    var base64Map;
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE_MASK = (1 << 5) - 1;
    var VLQ_CONTINUATION_MASK = 1 << 5;
    var StringCharIterator = class {
      /**
       * @constructor
       * @param {string} string
       */
      constructor(string) {
        this._string = string;
        this._position = 0;
      }
      /**
       * @return {string}
       */
      next() {
        return StringPrototypeCharAt(this._string, this._position++);
      }
      /**
       * @return {string}
       */
      peek() {
        return StringPrototypeCharAt(this._string, this._position);
      }
      /**
       * @return {boolean}
       */
      hasNext() {
        return this._position < this._string.length;
      }
    };
    var SourceMap = class {
      /**
       * @constructor
       * @param {SourceMapV3} payload
       */
      constructor(payload) {
        this._mappings = [];
        this._sources = {};
        this._sources = {};
        if (!base64Map) {
          const base64Digits = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          base64Map = {};
          for (let i = 0; i < base64Digits.length; ++i) {
            base64Map[base64Digits[i]] = i;
          }
        }
        this._payload = cloneSourceMapV3(payload);
        this._parseMappingPayload();
      }
      _parseMappingPayload() {
        if (this._payload.sections) {
          this._parseSections(this._payload.sections);
        } else {
          this._parseMap(this._payload, 0, 0);
        }
        ArrayPrototypeSort(this._mappings, compareSourceMapEntry);
      }
      /**
       * @param {Array.<SourceMapV3.Section>} sections
       */
      _parseSections(sections) {
        for (let i = 0; i < sections.length; ++i) {
          const section = sections[i];
          this._parseMap(section.map, section.offset.line, section.offset.column);
        }
      }
      /**
       * @param {number} lineNumber in compiled resource
       * @param {number} columnNumber in compiled resource
       * @return {?Array}
       */
      findEntry(lineNumber, columnNumber) {
        let first = 0;
        let count = this._mappings.length;
        while (count > 1) {
          const step = count >> 1;
          const middle = first + step;
          const mapping = this._mappings[middle];
          if (lineNumber < mapping[0] || lineNumber === mapping[0] && columnNumber < mapping[1]) {
            count = step;
          } else {
            first = middle;
            count -= step;
          }
        }
        const entry = this._mappings[first];
        if (!first && entry && (lineNumber < entry[0] || lineNumber === entry[0] && columnNumber < entry[1])) {
          return {};
        } else if (!entry) {
          return {};
        }
        return {
          generatedLine: entry[0],
          generatedColumn: entry[1],
          originalSource: entry[2],
          originalLine: entry[3],
          originalColumn: entry[4],
          name: entry[5]
        };
      }
      /**
       * @override
       */
      _parseMap(map, lineNumber, columnNumber) {
        let sourceIndex = 0;
        let sourceLineNumber = 0;
        let sourceColumnNumber = 0;
        let nameIndex = 0;
        const sources = [];
        const originalToCanonicalURLMap = {};
        for (let i = 0; i < map.sources.length; ++i) {
          const url = map.sources[i];
          originalToCanonicalURLMap[url] = url;
          ArrayPrototypePush(sources, url);
          this._sources[url] = true;
          if (map.sourcesContent && map.sourcesContent[i]) {
            this._sources[url] = map.sourcesContent[i];
          }
        }
        const stringCharIterator = new StringCharIterator(map.mappings);
        let sourceURL = sources[sourceIndex];
        while (true) {
          if (stringCharIterator.peek() === ",") {
            stringCharIterator.next();
          } else {
            while (stringCharIterator.peek() === ";") {
              lineNumber += 1;
              columnNumber = 0;
              stringCharIterator.next();
            }
            if (!stringCharIterator.hasNext()) {
              break;
            }
          }
          columnNumber += decodeVLQ(stringCharIterator);
          if (isSeparator(stringCharIterator.peek())) {
            ArrayPrototypePush(this._mappings, [lineNumber, columnNumber]);
            continue;
          }
          const sourceIndexDelta = decodeVLQ(stringCharIterator);
          if (sourceIndexDelta) {
            sourceIndex += sourceIndexDelta;
            sourceURL = sources[sourceIndex];
          }
          sourceLineNumber += decodeVLQ(stringCharIterator);
          sourceColumnNumber += decodeVLQ(stringCharIterator);
          let name;
          if (!isSeparator(stringCharIterator.peek())) {
            nameIndex += decodeVLQ(stringCharIterator);
            name = map.names ? map.names[nameIndex] : void 0;
          }
          ArrayPrototypePush(this._mappings, [
            lineNumber,
            columnNumber,
            sourceURL,
            sourceLineNumber,
            sourceColumnNumber,
            name
          ]);
        }
      }
    };
    function isSeparator(char) {
      return char === "," || char === ";";
    }
    function decodeVLQ(stringCharIterator) {
      let result = 0;
      let shift = 0;
      let digit;
      do {
        digit = base64Map[stringCharIterator.next()];
        result += (digit & VLQ_BASE_MASK) << shift;
        shift += VLQ_BASE_SHIFT;
      } while (digit & VLQ_CONTINUATION_MASK);
      const negative = result & 1;
      result >>>= 1;
      if (!negative) {
        return result;
      }
      return -result | 1 << 31;
    }
    function cloneSourceMapV3(payload) {
      validateObject(payload, "payload");
      payload = { ...payload };
      for (const key in payload) {
        if (ObjectPrototypeHasOwnProperty(payload, key) && ArrayIsArray(payload[key])) {
          payload[key] = ArrayPrototypeSlice(payload[key]);
        }
      }
      return payload;
    }
    function compareSourceMapEntry(entry1, entry2) {
      const { 0: lineNumber1, 1: columnNumber1 } = entry1;
      const { 0: lineNumber2, 1: columnNumber2 } = entry2;
      if (lineNumber1 !== lineNumber2) {
        return lineNumber1 - lineNumber2;
      }
      return columnNumber1 - columnNumber2;
    }
    module2.exports = {
      SourceMap
    };
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/js/source-map/index.js
var require_source_map = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/js/source-map/index.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var fs = __require("fs");
    var LRU = require_lru_cache();
    var { SourceMap } = require_node_source_map();
    var SOURCE_MAP_LINE_START = "//# sourceMappingURL=";
    var SOURCE_MAP_INLINE_LINE_START = "//# sourceMappingURL=data:application/json;base64,";
    var rewrittenSourceMapsCache = /* @__PURE__ */ new Map();
    var originalSourceMapsCache = new LRU({ max: 1e3 });
    function generateSourceMapFromFileContent(fileContent, filePath) {
      const fileLines = fileContent.trim().split("\n");
      const lastLine = fileLines[fileLines.length - 1];
      let rawSourceMap;
      if (lastLine.indexOf(SOURCE_MAP_INLINE_LINE_START) === 0) {
        const sourceMapInBase64 = lastLine.substring(SOURCE_MAP_INLINE_LINE_START.length);
        rawSourceMap = Buffer.from(sourceMapInBase64, "base64").toString("utf8");
      } else if (lastLine.indexOf(SOURCE_MAP_LINE_START) === 0) {
        let sourceMappingURL = lastLine.substring(SOURCE_MAP_LINE_START.length);
        if (sourceMappingURL) {
          sourceMappingURL = path.isAbsolute(sourceMappingURL) ? sourceMappingURL : path.join(filePath, sourceMappingURL);
          rawSourceMap = fs.readFileSync(sourceMappingURL).toString();
        }
      }
      if (rawSourceMap) {
        return new SourceMap(JSON.parse(rawSourceMap));
      }
    }
    function cacheRewrittenSourceMap(filename, fileContent) {
      if (fileContent) {
        const sm = generateSourceMapFromFileContent(fileContent, getFilePathFromName(filename));
        rewrittenSourceMapsCache.set(filename, sm);
      }
    }
    function getFilePathFromName(filename) {
      const filenameParts = filename.split(path.sep);
      filenameParts.pop();
      return filenameParts.join(path.sep);
    }
    function getPathAndLine(sourceMap, filename, line, column) {
      try {
        if (sourceMap) {
          const filePath = getFilePathFromName(filename);
          const { originalSource, originalLine, originalColumn } = sourceMap.findEntry(line - 1, column - 1);
          return {
            path: path.join(filePath, originalSource),
            line: originalLine + 1,
            column: originalColumn + 1
          };
        }
      } catch (e) {
      }
      return { path: filename, line, column };
    }
    function getSourcePathAndLineFromSourceMaps(filename, line, column = 0) {
      const sourceMap = rewrittenSourceMapsCache.get(filename);
      return getPathAndLine(sourceMap, filename, line, column);
    }
    function getOriginalPathAndLineFromSourceMap(filename, line, column = 0) {
      if (filename && line) {
        let sourceMap;
        try {
          sourceMap = originalSourceMapsCache.get(filename);
          if (sourceMap === void 0) {
            if (fs.existsSync(filename)) {
              const filePath = getFilePathFromName(filename);
              sourceMap = generateSourceMapFromFileContent(fs.readFileSync(filename).toString(), filePath);
            }
            originalSourceMapsCache.set(filename, sourceMap || null);
          }
          return getPathAndLine(sourceMap, filename, line, column);
        } catch (e) {
          if (sourceMap === void 0) {
            originalSourceMapsCache.set(filename, null);
          }
        }
      }
      return { path: filename, line, column };
    }
    module2.exports = {
      getSourcePathAndLineFromSourceMaps,
      getOriginalPathAndLineFromSourceMap,
      cacheRewrittenSourceMap,
      generateSourceMapFromFileContent
    };
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/js/stack-trace/index.js
var require_stack_trace = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/js/stack-trace/index.js"(exports2, module2) {
    var { getSourcePathAndLineFromSourceMaps } = require_source_map();
    var kSymbolPrepareStackTrace = Symbol("_ddiastPrepareStackTrace");
    var evalRegex = /.*\(((?:.:[/\\]?)?[/\\].*):(\d*):(\d*)\)/g;
    var WrappedCallSite = class {
      constructor(callSite) {
        if (callSite.isEval()) {
          evalRegex.lastIndex = 0;
          const evalOrigin = callSite.getEvalOrigin();
          const evalData = evalRegex.exec(evalOrigin);
          if (evalData) {
            const { path: path2, line: line2, column: column2 } = getSourcePathAndLineFromSourceMaps(
              evalData[1],
              evalData[2],
              evalData[3]
            );
            this.evalOrigin = evalOrigin.replace(
              `${evalData[1]}:${evalData[2]}:${evalData[3]}`,
              `${path2}:${line2}:${column2}`
            );
          }
        }
        const { path, line, column } = getSourcePathAndLineFromSourceMaps(
          callSite.getFileName(),
          callSite.getLineNumber(),
          callSite.getColumnNumber()
        );
        this.source = path;
        this.lineNumber = line;
        this.columnNumber = column;
        this.callSite = callSite;
      }
      getThis() {
        return this.callSite;
      }
      getTypeName() {
        return this.callSite.getTypeName();
      }
      getFunction() {
        return this.callSite.getFunction();
      }
      getFunctionName() {
        return this.callSite.getFunctionName();
      }
      getMethodName() {
        return this.callSite.getMethodName();
      }
      getFileName() {
        return this.source;
      }
      getScriptNameOrSourceURL() {
        return null;
      }
      getLineNumber() {
        return this.lineNumber;
      }
      getColumnNumber() {
        return this.columnNumber;
      }
      getEvalOrigin() {
        return this.evalOrigin || this.callSite.getEvalOrigin();
      }
      isToplevel() {
        return this.callSite.isToplevel();
      }
      isEval() {
        return this.callSite.isEval();
      }
      isNative() {
        return this.callSite.isNative();
      }
      isConstructor() {
        return this.callSite.isConstructor();
      }
      toString() {
        let callSiteString = this.callSite.toString();
        if (this.isEval()) {
          callSiteString = callSiteString.replace(this.callSite.getEvalOrigin(), this.getEvalOrigin());
        }
        const newFileLineChar = `${this.source}:${this.lineNumber}:${this.columnNumber})`;
        const originalFileLineChar = `${this.callSite.getFileName()}:${this.callSite.getLineNumber()}:${this.callSite.getColumnNumber()})`;
        return callSiteString.toString()?.replace(originalFileLineChar, newFileLineChar);
      }
      toLocaleString() {
        return this.callSite.toLocaleString();
      }
    };
    function getPrepareStackTrace(originalPrepareStackTrace) {
      if (originalPrepareStackTrace && originalPrepareStackTrace[kSymbolPrepareStackTrace]) {
        return originalPrepareStackTrace;
      }
      const wrappedPrepareStackTrace = (error, structuredStackTrace) => {
        if (originalPrepareStackTrace) {
          let parsedCallSites;
          try {
            parsedCallSites = structuredStackTrace.map((callSite) => new WrappedCallSite(callSite));
          } catch (e) {
            parsedCallSites = structuredStackTrace;
          }
          return originalPrepareStackTrace(error, parsedCallSites);
        }
        const stackLines = error.stack.split("\n");
        let firstIndex = -1;
        for (let i = 0; i < stackLines.length; i++) {
          if (stackLines[i].match(/^\s*at/gm)) {
            firstIndex = i;
            break;
          }
        }
        return stackLines.map((stackFrame, index) => {
          if (index < firstIndex) {
            return stackFrame;
          }
          index = index - firstIndex;
          const stackTraceItem = structuredStackTrace[index];
          if (!stackTraceItem) {
            return stackFrame;
          }
          let filename = stackTraceItem.getFileName();
          let originalLine = stackTraceItem.getLineNumber();
          let originalColumn = stackTraceItem.getColumnNumber();
          if (stackTraceItem.isEval()) {
            const evalOrigin = stackTraceItem.getEvalOrigin();
            const evalRegex2 = /.*\(((?:.:[/\\]?)?[/\\].*):(\d*):(\d*)\)/g;
            const evalData = evalRegex2.exec(evalOrigin);
            if (evalData) {
              filename = evalData[1];
              originalLine = evalData[2];
              originalColumn = evalData[3];
            } else {
              return stackFrame;
            }
          }
          const { path, line, column } = getSourcePathAndLineFromSourceMaps(filename, originalLine, originalColumn);
          if (path !== filename || line !== originalLine || column !== originalColumn) {
            return stackFrame.replace(`${filename}:${originalLine}:${originalColumn}`, `${path}:${line}:${column}`);
          }
          return stackFrame;
        }).join("\n");
      };
      Object.defineProperty(wrappedPrepareStackTrace, kSymbolPrepareStackTrace, {
        value: true
      });
      return wrappedPrepareStackTrace;
    }
    module2.exports = {
      getPrepareStackTrace,
      kSymbolPrepareStackTrace
    };
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/js/module-details/index.js
var require_module_details = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/js/module-details/index.js"(exports2, module2) {
    var fs = __require("fs");
    var getDetails = require_module_details_from_path();
    var url = __require("url");
    var path = __require("path");
    function getVersion(baseDir) {
      if (baseDir instanceof URL || baseDir.startsWith("file://")) {
        baseDir = url.fileURLToPath(baseDir);
      }
      try {
        return JSON.parse(fs.readFileSync(`${baseDir}/package.json`, "utf8")).version;
      } catch (e) {
        return null;
      }
    }
    var getFilename = path.sep === "/" ? (f) => f : (f) => f.replaceAll("/", path.sep);
    module2.exports = function getNameAndVersion(filename) {
      const details = getDetails(getFilename(filename));
      if (details) {
        return { name: details.name, version: getVersion(details.basedir) };
      }
      return { name: null, version: null };
    };
  }
});

// ../../node_modules/js-yaml/lib/common.js
var require_common3 = __commonJS({
  "../../node_modules/js-yaml/lib/common.js"(exports2, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;
      else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// ../../node_modules/js-yaml/lib/exception.js
var require_exception = __commonJS({
  "../../node_modules/js-yaml/lib/exception.js"(exports2, module2) {
    "use strict";
    function formatError(exception, compact) {
      var where = "", message = exception.reason || "(unknown reason)";
      if (!exception.mark) return message;
      if (exception.mark.name) {
        where += 'in "' + exception.mark.name + '" ';
      }
      where += "(" + (exception.mark.line + 1) + ":" + (exception.mark.column + 1) + ")";
      if (!compact && exception.mark.snippet) {
        where += "\n\n" + exception.mark.snippet;
      }
      return message + " " + where;
    }
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = formatError(this, false);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString2(compact) {
      return this.name + ": " + formatError(this, compact);
    };
    module2.exports = YAMLException;
  }
});

// ../../node_modules/js-yaml/lib/snippet.js
var require_snippet = __commonJS({
  "../../node_modules/js-yaml/lib/snippet.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {
      var head = "";
      var tail = "";
      var maxHalfLength = Math.floor(maxLineLength / 2) - 1;
      if (position - lineStart > maxHalfLength) {
        head = " ... ";
        lineStart = position - maxHalfLength + head.length;
      }
      if (lineEnd - position > maxHalfLength) {
        tail = " ...";
        lineEnd = position + maxHalfLength - tail.length;
      }
      return {
        str: head + buffer.slice(lineStart, lineEnd).replace(/\t/g, "\u2192") + tail,
        pos: position - lineStart + head.length
        // relative position
      };
    }
    function padStart(string, max) {
      return common.repeat(" ", max - string.length) + string;
    }
    function makeSnippet(mark, options) {
      options = Object.create(options || null);
      if (!mark.buffer) return null;
      if (!options.maxLength) options.maxLength = 79;
      if (typeof options.indent !== "number") options.indent = 1;
      if (typeof options.linesBefore !== "number") options.linesBefore = 3;
      if (typeof options.linesAfter !== "number") options.linesAfter = 2;
      var re2 = /\r?\n|\r|\0/g;
      var lineStarts = [0];
      var lineEnds = [];
      var match;
      var foundLineNo = -1;
      while (match = re2.exec(mark.buffer)) {
        lineEnds.push(match.index);
        lineStarts.push(match.index + match[0].length);
        if (mark.position <= match.index && foundLineNo < 0) {
          foundLineNo = lineStarts.length - 2;
        }
      }
      if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;
      var result = "", i, line;
      var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;
      var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);
      for (i = 1; i <= options.linesBefore; i++) {
        if (foundLineNo - i < 0) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo - i],
          lineEnds[foundLineNo - i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),
          maxLineLength
        );
        result = common.repeat(" ", options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) + " | " + line.str + "\n" + result;
      }
      line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);
      result += common.repeat(" ", options.indent) + padStart((mark.line + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      result += common.repeat("-", options.indent + lineNoLength + 3 + line.pos) + "^\n";
      for (i = 1; i <= options.linesAfter; i++) {
        if (foundLineNo + i >= lineEnds.length) break;
        line = getLine(
          mark.buffer,
          lineStarts[foundLineNo + i],
          lineEnds[foundLineNo + i],
          mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),
          maxLineLength
        );
        result += common.repeat(" ", options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) + " | " + line.str + "\n";
      }
      return result.replace(/\n$/, "");
    }
    module2.exports = makeSnippet;
  }
});

// ../../node_modules/js-yaml/lib/type.js
var require_type = __commonJS({
  "../../node_modules/js-yaml/lib/type.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "multi",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "representName",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.options = options;
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.representName = options["representName"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.multi = options["multi"] || false;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// ../../node_modules/js-yaml/lib/schema.js
var require_schema3 = __commonJS({
  "../../node_modules/js-yaml/lib/schema.js"(exports2, module2) {
    "use strict";
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name) {
      var result = [];
      schema[name].forEach(function(currentType) {
        var newIndex = result.length;
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind && previousType.multi === currentType.multi) {
            newIndex = previousIndex;
          }
        });
        result[newIndex] = currentType;
      });
      return result;
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: {
          scalar: [],
          sequence: [],
          mapping: [],
          fallback: []
        }
      }, index, length;
      function collectType(type) {
        if (type.multi) {
          result.multi[type.kind].push(type);
          result.multi["fallback"].push(type);
        } else {
          result[type.kind][type.tag] = result["fallback"][type.tag] = type;
        }
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      return this.extend(definition);
    }
    Schema.prototype.extend = function extend(definition) {
      var implicit = [];
      var explicit = [];
      if (definition instanceof Type) {
        explicit.push(definition);
      } else if (Array.isArray(definition)) {
        explicit = explicit.concat(definition);
      } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {
        if (definition.implicit) implicit = implicit.concat(definition.implicit);
        if (definition.explicit) explicit = explicit.concat(definition.explicit);
      } else {
        throw new YAMLException("Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })");
      }
      implicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
        if (type.multi) {
          throw new YAMLException("There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.");
        }
      });
      explicit.forEach(function(type) {
        if (!(type instanceof Type)) {
          throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
        }
      });
      var result = Object.create(Schema.prototype);
      result.implicit = (this.implicit || []).concat(implicit);
      result.explicit = (this.explicit || []).concat(explicit);
      result.compiledImplicit = compileList(result, "implicit");
      result.compiledExplicit = compileList(result, "explicit");
      result.compiledTypeMap = compileMap(result.compiledImplicit, result.compiledExplicit);
      return result;
    };
    module2.exports = Schema;
  }
});

// ../../node_modules/js-yaml/lib/type/str.js
var require_str = __commonJS({
  "../../node_modules/js-yaml/lib/type/str.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/type/seq.js
var require_seq = __commonJS({
  "../../node_modules/js-yaml/lib/type/seq.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/type/map.js
var require_map = __commonJS({
  "../../node_modules/js-yaml/lib/type/map.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/schema/failsafe.js
var require_failsafe = __commonJS({
  "../../node_modules/js-yaml/lib/schema/failsafe.js"(exports2, module2) {
    "use strict";
    var Schema = require_schema3();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/type/null.js
var require_null = __commonJS({
  "../../node_modules/js-yaml/lib/type/null.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null) return true;
      var max = data.length;
      return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        },
        empty: function() {
          return "";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/type/bool.js
var require_bool = __commonJS({
  "../../node_modules/js-yaml/lib/type/bool.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max = data.length;
      return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/type/int.js
var require_int = __commonJS({
  "../../node_modules/js-yaml/lib/type/int.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max = data.length, index = 0, hasDigits = false, ch;
      if (!max) return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max) return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (ch !== "0" && ch !== "1") return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isHexCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "o") {
          index++;
          for (; index < max; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isOctCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
      }
      if (ch === "_") return false;
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_") return false;
      return true;
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch;
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0") return 0;
      if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value.slice(2), 16);
        if (value[1] === "o") return sign * parseInt(value.slice(2), 8);
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0o" + obj.toString(8) : "-0o" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// ../../node_modules/js-yaml/lib/type/float.js
var require_float2 = __commonJS({
  "../../node_modules/js-yaml/lib/type/float.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// ../../node_modules/js-yaml/lib/schema/json.js
var require_json = __commonJS({
  "../../node_modules/js-yaml/lib/schema/json.js"(exports2, module2) {
    "use strict";
    module2.exports = require_failsafe().extend({
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float2()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/schema/core.js
var require_core = __commonJS({
  "../../node_modules/js-yaml/lib/schema/core.js"(exports2, module2) {
    "use strict";
    module2.exports = require_json();
  }
});

// ../../node_modules/js-yaml/lib/type/timestamp.js
var require_timestamp = __commonJS({
  "../../node_modules/js-yaml/lib/type/timestamp.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null) throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-") delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// ../../node_modules/js-yaml/lib/type/merge.js
var require_merge2 = __commonJS({
  "../../node_modules/js-yaml/lib/type/merge.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// ../../node_modules/js-yaml/lib/type/binary.js
var require_binary2 = __commonJS({
  "../../node_modules/js-yaml/lib/type/binary.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      return new Uint8Array(result);
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(obj) {
      return Object.prototype.toString.call(obj) === "[object Uint8Array]";
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// ../../node_modules/js-yaml/lib/type/omap.js
var require_omap = __commonJS({
  "../../node_modules/js-yaml/lib/type/omap.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]") return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// ../../node_modules/js-yaml/lib/type/pairs.js
var require_pairs = __commonJS({
  "../../node_modules/js-yaml/lib/type/pairs.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// ../../node_modules/js-yaml/lib/type/set.js
var require_set3 = __commonJS({
  "../../node_modules/js-yaml/lib/type/set.js"(exports2, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// ../../node_modules/js-yaml/lib/schema/default.js
var require_default3 = __commonJS({
  "../../node_modules/js-yaml/lib/schema/default.js"(exports2, module2) {
    "use strict";
    module2.exports = require_core().extend({
      implicit: [
        require_timestamp(),
        require_merge2()
      ],
      explicit: [
        require_binary2(),
        require_omap(),
        require_pairs(),
        require_set3()
      ]
    });
  }
});

// ../../node_modules/js-yaml/lib/loader.js
var require_loader = __commonJS({
  "../../node_modules/js-yaml/lib/loader.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    var YAMLException = require_exception();
    var makeSnippet = require_snippet();
    var DEFAULT_SCHEMA = require_default3();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.firstTabInLine = -1;
      this.documents = [];
    }
    function generateError(state, message) {
      var mark = {
        name: state.filename,
        buffer: state.input.slice(0, -1),
        // omit trailing \0
        position: state.position,
        line: state.line,
        column: state.position - state.lineStart
      };
      mark.snippet = makeSnippet(mark);
      return new YAMLException(message, mark);
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major2, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major2 = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major2 !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        try {
          prefix = decodeURIComponent(prefix);
        } catch (err) {
          throwError(state, "tag prefix is malformed: " + prefix);
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startLineStart, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.lineStart = startLineStart || state.lineStart;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        if (keyNode === "__proto__") {
          Object.defineProperty(_result, keyNode, {
            configurable: true,
            enumerable: true,
            writable: true,
            value: valueNode
          });
        } else {
          _result[keyNode] = valueNode;
        }
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
      state.firstTabInLine = -1;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          if (ch === 9 && state.firstTabInLine === -1) {
            state.firstTabInLine = state.position;
          }
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _lineStart, _pos, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = /* @__PURE__ */ Object.create(null), keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        } else if (ch === 44) {
          throwError(state, "expected the node content, but found ','");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        _lineStart = state.lineStart;
        _pos = state.position;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _keyLine, _keyLineStart, _keyPos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = /* @__PURE__ */ Object.create(null), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.firstTabInLine !== -1) return false;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (!atExplicitKey && state.firstTabInLine !== -1) {
          state.position = state.firstTabInLine;
          throwError(state, "tab characters must not be used in indentation");
        }
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else {
          _keyLine = state.line;
          _keyLineStart = state.lineStart;
          _keyPos = state.position;
          if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            break;
          }
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (atExplicitKey) {
            _keyLine = state.line;
            _keyLineStart = state.lineStart;
            _keyPos = state.position;
          }
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33) return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      try {
        tagName = decodeURIComponent(tagName);
      } catch (err) {
        throwError(state, "tag name is malformed: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38) return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, typeList, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag === null) {
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      } else if (state.tag === "?") {
        if (state.result !== null && state.kind !== "scalar") {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (state.tag !== "!") {
        if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
        } else {
          type = null;
          typeList = state.typeMap.multi[state.kind || "fallback"];
          for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {
            if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {
              type = typeList[typeIndex];
              break;
            }
          }
        }
        if (!type) {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result, state.tag)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result, state.tag);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = /* @__PURE__ */ Object.create(null);
      state.anchorMap = /* @__PURE__ */ Object.create(null);
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
  }
});

// ../../node_modules/js-yaml/lib/dumper.js
var require_dumper = __commonJS({
  "../../node_modules/js-yaml/lib/dumper.js"(exports2, module2) {
    "use strict";
    var common = require_common3();
    var YAMLException = require_exception();
    var DEFAULT_SCHEMA = require_default3();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_BOM = 65279;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/;
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    var QUOTING_TYPE_SINGLE = 1;
    var QUOTING_TYPE_DOUBLE = 2;
    function State(options) {
      this.schema = options["schema"] || DEFAULT_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.quotingType = options["quotingType"] === '"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;
      this.forceQuotes = options["forceQuotes"] || false;
      this.replacer = typeof options["replacer"] === "function" ? options["replacer"] : null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== CHAR_BOM || 65536 <= c && c <= 1114111;
    }
    function isNsCharOrWhitespace(c) {
      return isPrintable(c) && c !== CHAR_BOM && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev, inblock) {
      var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);
      var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);
      return (
        // ns-plain-safe
        (inblock ? (
          // c = flow-in
          cIsNsCharOrWhitespace
        ) : cIsNsCharOrWhitespace && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET) && c !== CHAR_SHARP && !(prev === CHAR_COLON && !cIsNsChar) || isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP || prev === CHAR_COLON && cIsNsChar
      );
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== CHAR_BOM && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function isPlainSafeLast(c) {
      return !isWhitespace(c) && c !== CHAR_COLON;
    }
    function codePointAt(string, pos) {
      var first = string.charCodeAt(pos), second;
      if (first >= 55296 && first <= 56319 && pos + 1 < string.length) {
        second = string.charCodeAt(pos + 1);
        if (second >= 56320 && second <= 57343) {
          return (first - 55296) * 1024 + second - 56320 + 65536;
        }
      }
      return first;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType, quotingType, forceQuotes, inblock) {
      var i;
      var char = 0;
      var prevChar = null;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(codePointAt(string, 0)) && isPlainSafeLast(codePointAt(string, string.length - 1));
      if (singleLineOnly || forceQuotes) {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
      } else {
        for (i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
          char = codePointAt(string, i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          plain = plain && isPlainSafe(char, prevChar, inblock);
          prevChar = char;
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        if (plain && !forceQuotes && !testAmbiguousType(string)) {
          return STYLE_PLAIN;
        }
        return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      if (!forceQuotes) {
        return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
      }
      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;
    }
    function writeScalar(state, string, level, iskey, inblock) {
      state.dump = (function() {
        if (string.length === 0) {
          return state.quotingType === QUOTING_TYPE_DOUBLE ? '""' : "''";
        }
        if (!state.noCompatMode) {
          if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {
            return state.quotingType === QUOTING_TYPE_DOUBLE ? '"' + string + '"' : "'" + string + "'";
          }
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(
          string,
          singleLineOnly,
          state.indent,
          lineWidth,
          testAmbiguity,
          state.quotingType,
          state.forceQuotes && !iskey,
          inblock
        )) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      })();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = (function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      })();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ") return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char = 0;
      var escapeSeq;
      for (var i = 0; i < string.length; char >= 65536 ? i += 2 : i++) {
        char = codePointAt(string, i);
        escapeSeq = ESCAPE_SEQUENCES[char];
        if (!escapeSeq && isPrintable(char)) {
          result += string[i];
          if (char >= 65536) result += string[i + 1];
        } else {
          result += escapeSeq || encodeHex(char);
        }
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level, value, false, false) || typeof value === "undefined" && writeNode(state, level, null, false, false)) {
          if (_result !== "") _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length, value;
      for (index = 0, length = object.length; index < length; index += 1) {
        value = object[index];
        if (state.replacer) {
          value = state.replacer.call(object, String(index), value);
        }
        if (writeNode(state, level + 1, value, true, true, false, true) || typeof value === "undefined" && writeNode(state, level + 1, null, true, true, false, true)) {
          if (!compact || _result !== "") {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (_result !== "") pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || _result !== "") {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (state.replacer) {
          objectValue = state.replacer.call(object, objectKey, objectValue);
        }
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          if (explicit) {
            if (type.multi && type.representName) {
              state.tag = type.representName(object);
            } else {
              state.tag = type.tag;
            }
          } else {
            state.tag = "?";
          }
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey, isblockseq) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      var inblock = block;
      var tagStr;
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          if (block && state.dump.length !== 0) {
            if (state.noArrayIndent && !isblockseq && level > 0) {
              writeBlockSequence(state, level - 1, state.dump, compact);
            } else {
              writeBlockSequence(state, level, state.dump, compact);
            }
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey, inblock);
          }
        } else if (type === "[object Undefined]") {
          return false;
        } else {
          if (state.skipInvalid) return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          tagStr = encodeURI(
            state.tag[0] === "!" ? state.tag.slice(1) : state.tag
          ).replace(/!/g, "%21");
          if (state.tag[0] === "!") {
            tagStr = "!" + tagStr;
          } else if (tagStr.slice(0, 18) === "tag:yaml.org,2002:") {
            tagStr = "!!" + tagStr.slice(18);
          } else {
            tagStr = "!<" + tagStr + ">";
          }
          state.dump = tagStr + " " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs) getDuplicateReferences(input, state);
      var value = input;
      if (state.replacer) {
        value = state.replacer.call({ "": value }, "", value);
      }
      if (writeNode(state, 0, value, true, true)) return state.dump + "\n";
      return "";
    }
    module2.exports.dump = dump;
  }
});

// ../../node_modules/js-yaml/index.js
var require_js_yaml = __commonJS({
  "../../node_modules/js-yaml/index.js"(exports2, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function renamed(from, to) {
      return function() {
        throw new Error("Function yaml." + from + " is removed in js-yaml 4. Use yaml." + to + " instead, which is now safe by default.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema3();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SCHEMA = require_default3();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.YAMLException = require_exception();
    module2.exports.types = {
      binary: require_binary2(),
      float: require_float2(),
      map: require_map(),
      null: require_null(),
      pairs: require_pairs(),
      set: require_set3(),
      timestamp: require_timestamp(),
      bool: require_bool(),
      int: require_int(),
      merge: require_merge2(),
      omap: require_omap(),
      seq: require_seq(),
      str: require_str()
    };
    module2.exports.safeLoad = renamed("safeLoad", "load");
    module2.exports.safeLoadAll = renamed("safeLoadAll", "loadAll");
    module2.exports.safeDump = renamed("safeDump", "dump");
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/wasm/wasm_js_rewriter.js
var require_wasm_js_rewriter = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/wasm/wasm_js_rewriter.js"(exports2, module2) {
    var imports = {};
    imports["__wbindgen_placeholder__"] = module2.exports;
    var wasm;
    var { log, setLogger } = __require(String.raw`./snippets/wasm-js-rewriter-352b414960a32145/tracer_logger.js`);
    var { readFileSync } = __require("fs");
    var { dirname } = __require("path");
    var { TextEncoder: TextEncoder2, TextDecoder: TextDecoder2 } = __require("util");
    var heap = new Array(128).fill(void 0);
    heap.push(void 0, null, true, false);
    function getObject(idx) {
      return heap[idx];
    }
    var heap_next = heap.length;
    function dropObject(idx) {
      if (idx < 132) return;
      heap[idx] = heap_next;
      heap_next = idx;
    }
    function takeObject(idx) {
      const ret = getObject(idx);
      dropObject(idx);
      return ret;
    }
    var WASM_VECTOR_LEN = 0;
    var cachedUint8Memory0 = null;
    function getUint8Memory0() {
      if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {
        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);
      }
      return cachedUint8Memory0;
    }
    var cachedTextEncoder = new TextEncoder2("utf-8");
    var encodeString = typeof cachedTextEncoder.encodeInto === "function" ? function(arg, view) {
      return cachedTextEncoder.encodeInto(arg, view);
    } : function(arg, view) {
      const buf = cachedTextEncoder.encode(arg);
      view.set(buf);
      return {
        read: arg.length,
        written: buf.length
      };
    };
    function passStringToWasm0(arg, malloc, realloc) {
      if (realloc === void 0) {
        const buf = cachedTextEncoder.encode(arg);
        const ptr2 = malloc(buf.length, 1) >>> 0;
        getUint8Memory0().subarray(ptr2, ptr2 + buf.length).set(buf);
        WASM_VECTOR_LEN = buf.length;
        return ptr2;
      }
      let len = arg.length;
      let ptr = malloc(len, 1) >>> 0;
      const mem = getUint8Memory0();
      let offset = 0;
      for (; offset < len; offset++) {
        const code = arg.charCodeAt(offset);
        if (code > 127) break;
        mem[ptr + offset] = code;
      }
      if (offset !== len) {
        if (offset !== 0) {
          arg = arg.slice(offset);
        }
        ptr = realloc(ptr, len, len = offset + arg.length * 3, 1) >>> 0;
        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);
        const ret = encodeString(arg, view);
        offset += ret.written;
        ptr = realloc(ptr, len, offset, 1) >>> 0;
      }
      WASM_VECTOR_LEN = offset;
      return ptr;
    }
    function isLikeNone(x) {
      return x === void 0 || x === null;
    }
    var cachedInt32Memory0 = null;
    function getInt32Memory0() {
      if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {
        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);
      }
      return cachedInt32Memory0;
    }
    var cachedTextDecoder = new TextDecoder2("utf-8", { ignoreBOM: true, fatal: true });
    cachedTextDecoder.decode();
    function getStringFromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));
    }
    function addHeapObject(obj) {
      if (heap_next === heap.length) heap.push(heap.length + 1);
      const idx = heap_next;
      heap_next = heap[idx];
      heap[idx] = obj;
      return idx;
    }
    var cachedFloat64Memory0 = null;
    function getFloat64Memory0() {
      if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {
        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);
      }
      return cachedFloat64Memory0;
    }
    function debugString(val) {
      const type = typeof val;
      if (type == "number" || type == "boolean" || val == null) {
        return `${val}`;
      }
      if (type == "string") {
        return `"${val}"`;
      }
      if (type == "symbol") {
        const description = val.description;
        if (description == null) {
          return "Symbol";
        } else {
          return `Symbol(${description})`;
        }
      }
      if (type == "function") {
        const name = val.name;
        if (typeof name == "string" && name.length > 0) {
          return `Function(${name})`;
        } else {
          return "Function";
        }
      }
      if (Array.isArray(val)) {
        const length = val.length;
        let debug = "[";
        if (length > 0) {
          debug += debugString(val[0]);
        }
        for (let i = 1; i < length; i++) {
          debug += ", " + debugString(val[i]);
        }
        debug += "]";
        return debug;
      }
      const builtInMatches = /\[object ([^\]]+)\]/.exec(toString.call(val));
      let className;
      if (builtInMatches.length > 1) {
        className = builtInMatches[1];
      } else {
        return toString.call(val);
      }
      if (className == "Object") {
        try {
          return "Object(" + JSON.stringify(val) + ")";
        } catch (_2) {
          return "Object";
        }
      }
      if (val instanceof Error) {
        return `${val.name}: ${val.message}
${val.stack}`;
      }
      return className;
    }
    function handleError(f, args) {
      try {
        return f.apply(this, args);
      } catch (e) {
        wasm.__wbindgen_exn_store(addHeapObject(e));
      }
    }
    var cachedUint32Memory0 = null;
    function getUint32Memory0() {
      if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {
        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);
      }
      return cachedUint32Memory0;
    }
    function passArrayJsValueToWasm0(array, malloc) {
      const ptr = malloc(array.length * 4, 4) >>> 0;
      const mem = getUint32Memory0();
      for (let i = 0; i < array.length; i++) {
        mem[ptr / 4 + i] = addHeapObject(array[i]);
      }
      WASM_VECTOR_LEN = array.length;
      return ptr;
    }
    var stack_pointer = 128;
    function addBorrowedObject(obj) {
      if (stack_pointer == 1) throw new Error("out of js stack");
      heap[--stack_pointer] = obj;
      return stack_pointer;
    }
    function getArrayU8FromWasm0(ptr, len) {
      ptr = ptr >>> 0;
      return getUint8Memory0().subarray(ptr / 1, ptr / 1 + len);
    }
    var RewriterFinalization = typeof FinalizationRegistry === "undefined" ? { register: () => {
    }, unregister: () => {
    } } : new FinalizationRegistry((ptr) => wasm.__wbg_rewriter_free(ptr >>> 0));
    var Rewriter = class {
      __destroy_into_raw() {
        const ptr = this.__wbg_ptr;
        this.__wbg_ptr = 0;
        RewriterFinalization.unregister(this);
        return ptr;
      }
      free() {
        const ptr = this.__destroy_into_raw();
        wasm.__wbg_rewriter_free(ptr);
      }
      /**
      * @param {any} config_js
      */
      constructor(config_js) {
        const ret = wasm.rewriter_new(addHeapObject(config_js));
        this.__wbg_ptr = ret >>> 0;
        return this;
      }
      /**
      * @param {string} code
      * @param {string} file
      * @param {(string)[]} passes
      * @param {string | undefined} [module_name]
      * @param {string | undefined} [module_version]
      * @returns {any}
      */
      rewrite(code, file, passes, module_name, module_version) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(code, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          const ptr1 = passStringToWasm0(file, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len1 = WASM_VECTOR_LEN;
          const ptr2 = passArrayJsValueToWasm0(passes, wasm.__wbindgen_malloc);
          const len2 = WASM_VECTOR_LEN;
          var ptr3 = isLikeNone(module_name) ? 0 : passStringToWasm0(module_name, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          var len3 = WASM_VECTOR_LEN;
          var ptr4 = isLikeNone(module_version) ? 0 : passStringToWasm0(module_version, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          var len4 = WASM_VECTOR_LEN;
          wasm.rewriter_rewrite(retptr, this.__wbg_ptr, ptr0, len0, ptr1, len1, ptr2, len2, ptr3, len3, ptr4, len4);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @returns {any}
      */
      csiMethods() {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          wasm.rewriter_csiMethods(retptr, this.__wbg_ptr);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          var r2 = getInt32Memory0()[retptr / 4 + 2];
          if (r2) {
            throw takeObject(r1);
          }
          return takeObject(r0);
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
        }
      }
      /**
      * @param {any} logger
      * @param {string} level
      */
      setLogger(logger, level) {
        try {
          const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);
          const ptr0 = passStringToWasm0(level, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
          const len0 = WASM_VECTOR_LEN;
          wasm.rewriter_setLogger(retptr, this.__wbg_ptr, addBorrowedObject(logger), ptr0, len0);
          var r0 = getInt32Memory0()[retptr / 4 + 0];
          var r1 = getInt32Memory0()[retptr / 4 + 1];
          if (r1) {
            throw takeObject(r0);
          }
        } finally {
          wasm.__wbindgen_add_to_stack_pointer(16);
          heap[stack_pointer++] = void 0;
        }
      }
    };
    module2.exports.Rewriter = Rewriter;
    module2.exports.__wbindgen_object_drop_ref = function(arg0) {
      takeObject(arg0);
    };
    module2.exports.__wbindgen_string_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "string" ? obj : void 0;
      var ptr1 = isLikeNone(ret) ? 0 : passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      var len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    };
    module2.exports.__wbindgen_is_object = function(arg0) {
      const val = getObject(arg0);
      const ret = typeof val === "object" && val !== null;
      return ret;
    };
    module2.exports.__wbg_getwithrefkey_15c62c2b8546208d = function(arg0, arg1) {
      const ret = getObject(arg0)[getObject(arg1)];
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_is_undefined = function(arg0) {
      const ret = getObject(arg0) === void 0;
      return ret;
    };
    module2.exports.__wbindgen_in = function(arg0, arg1) {
      const ret = getObject(arg0) in getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_jsval_loose_eq = function(arg0, arg1) {
      const ret = getObject(arg0) == getObject(arg1);
      return ret;
    };
    module2.exports.__wbindgen_boolean_get = function(arg0) {
      const v = getObject(arg0);
      const ret = typeof v === "boolean" ? v ? 1 : 0 : 2;
      return ret;
    };
    module2.exports.__wbindgen_string_new = function(arg0, arg1) {
      const ret = getStringFromWasm0(arg0, arg1);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_20cbc34131e76824 = function(arg0, arg1, arg2) {
      getObject(arg0)[takeObject(arg1)] = takeObject(arg2);
    };
    module2.exports.__wbindgen_number_new = function(arg0) {
      const ret = arg0;
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_bigint_from_u64 = function(arg0) {
      const ret = BigInt.asUintN(64, arg0);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_dirname_84a7eeb45dcbdcfc = function() {
      return handleError(function(arg0, arg1) {
        const ret = dirname(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_readFileSync_32f00c8b2f5b7215 = function() {
      return handleError(function(arg0, arg1) {
        const ret = readFileSync(getStringFromWasm0(arg0, arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_new_09938a7d020f049b = function(arg0) {
      const ret = new Uint8Array(getObject(arg0));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_log_15ee026984f9a0f5 = function() {
      return handleError(function(arg0, arg1) {
        const ret = log(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_setLogger_02607cfa3e4f2824 = function() {
      return handleError(function(arg0) {
        const ret = setLogger(getObject(arg0));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_isArray_04e59fb73f78ab5b = function(arg0) {
      const ret = Array.isArray(getObject(arg0));
      return ret;
    };
    module2.exports.__wbg_length_820c786973abdd8a = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbg_get_7303ed2ef026b2f5 = function(arg0, arg1) {
      const ret = getObject(arg0)[arg1 >>> 0];
      return addHeapObject(ret);
    };
    module2.exports.__wbg_iterator_7c7e58f62eb84700 = function() {
      const ret = Symbol.iterator;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_get_f53c921291c381bd = function() {
      return handleError(function(arg0, arg1) {
        const ret = Reflect.get(getObject(arg0), getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbindgen_is_function = function(arg0) {
      const ret = typeof getObject(arg0) === "function";
      return ret;
    };
    module2.exports.__wbg_call_557a2f2deacc4912 = function() {
      return handleError(function(arg0, arg1) {
        const ret = getObject(arg0).call(getObject(arg1));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_next_f4bc0e96ea67da68 = function(arg0) {
      const ret = getObject(arg0).next;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_next_ec061e48a0e72a96 = function() {
      return handleError(function(arg0) {
        const ret = getObject(arg0).next();
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_done_b6abb27d42b63867 = function(arg0) {
      const ret = getObject(arg0).done;
      return ret;
    };
    module2.exports.__wbg_value_2f4ef2036bfad28e = function(arg0) {
      const ret = getObject(arg0).value;
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_error_new = function(arg0, arg1) {
      const ret = new Error(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_new_2b6fea4ea03b1b95 = function() {
      const ret = new Object();
      return addHeapObject(ret);
    };
    module2.exports.__wbg_new_0f2b71ca2f2a6029 = function() {
      const ret = /* @__PURE__ */ new Map();
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_da7be7bf0e037b14 = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).set(getObject(arg1), getObject(arg2));
      return addHeapObject(ret);
    };
    module2.exports.__wbindgen_is_string = function(arg0) {
      const ret = typeof getObject(arg0) === "string";
      return ret;
    };
    module2.exports.__wbg_new_0394642eae39db16 = function() {
      const ret = new Array();
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_b4da98d504ac6091 = function(arg0, arg1, arg2) {
      getObject(arg0)[arg1 >>> 0] = takeObject(arg2);
    };
    module2.exports.__wbg_new_abda76e883ba8a5f = function() {
      const ret = new Error();
      return addHeapObject(ret);
    };
    module2.exports.__wbg_stack_658279fe44541cf6 = function(arg0, arg1) {
      const ret = getObject(arg1).stack;
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    };
    module2.exports.__wbg_error_f851667af71bcfc6 = function(arg0, arg1) {
      let deferred0_0;
      let deferred0_1;
      try {
        deferred0_0 = arg0;
        deferred0_1 = arg1;
        console.error(getStringFromWasm0(arg0, arg1));
      } finally {
        wasm.__wbindgen_free(deferred0_0, deferred0_1, 1);
      }
    };
    module2.exports.__wbg_randomFillSync_6894564c2c334c42 = function() {
      return handleError(function(arg0, arg1, arg2) {
        getObject(arg0).randomFillSync(getArrayU8FromWasm0(arg1, arg2));
      }, arguments);
    };
    module2.exports.__wbg_subarray_d82be056deb4ad27 = function(arg0, arg1, arg2) {
      const ret = getObject(arg0).subarray(arg1 >>> 0, arg2 >>> 0);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_getRandomValues_805f1c3d65988a5a = function() {
      return handleError(function(arg0, arg1) {
        getObject(arg0).getRandomValues(getObject(arg1));
      }, arguments);
    };
    module2.exports.__wbg_length_0aab7ffd65ad19ed = function(arg0) {
      const ret = getObject(arg0).length;
      return ret;
    };
    module2.exports.__wbindgen_object_clone_ref = function(arg0) {
      const ret = getObject(arg0);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_crypto_e1d53a1d73fb10b8 = function(arg0) {
      const ret = getObject(arg0).crypto;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_process_038c26bf42b093f8 = function(arg0) {
      const ret = getObject(arg0).process;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_versions_ab37218d2f0b24a8 = function(arg0) {
      const ret = getObject(arg0).versions;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_node_080f4b19d15bc1fe = function(arg0) {
      const ret = getObject(arg0).node;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_require_78a3dcfbdba9cbce = function() {
      return handleError(function() {
        const ret = module2.require;
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_msCrypto_6e7d3e1f92610cbb = function(arg0) {
      const ret = getObject(arg0).msCrypto;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_newwithlength_89eeca401d8918c2 = function(arg0) {
      const ret = new Uint8Array(arg0 >>> 0);
      return addHeapObject(ret);
    };
    module2.exports.__wbg_self_742dd6eab3e9211e = function() {
      return handleError(function() {
        const ret = self.self;
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_window_c409e731db53a0e2 = function() {
      return handleError(function() {
        const ret = window.window;
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_globalThis_b70c095388441f2d = function() {
      return handleError(function() {
        const ret = globalThis.globalThis;
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_global_1c72617491ed7194 = function() {
      return handleError(function() {
        const ret = global.global;
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbg_newnoargs_c9e6043b8ad84109 = function(arg0, arg1) {
      const ret = new Function(getStringFromWasm0(arg0, arg1));
      return addHeapObject(ret);
    };
    module2.exports.__wbg_call_587b30eea3e09332 = function() {
      return handleError(function(arg0, arg1, arg2) {
        const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));
        return addHeapObject(ret);
      }, arguments);
    };
    module2.exports.__wbindgen_memory = function() {
      const ret = wasm.memory;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_buffer_55ba7a6b1b92e2ac = function(arg0) {
      const ret = getObject(arg0).buffer;
      return addHeapObject(ret);
    };
    module2.exports.__wbg_set_3698e3ca519b3c3c = function(arg0, arg1, arg2) {
      getObject(arg0).set(getObject(arg1), arg2 >>> 0);
    };
    module2.exports.__wbindgen_number_get = function(arg0, arg1) {
      const obj = getObject(arg1);
      const ret = typeof obj === "number" ? obj : void 0;
      getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;
      getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);
    };
    module2.exports.__wbg_instanceof_Uint8Array_1349640af2da2e88 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof Uint8Array;
      } catch (_2) {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbg_instanceof_ArrayBuffer_ef2632aa0d4bfff8 = function(arg0) {
      let result;
      try {
        result = getObject(arg0) instanceof ArrayBuffer;
      } catch (_2) {
        result = false;
      }
      const ret = result;
      return ret;
    };
    module2.exports.__wbindgen_debug_string = function(arg0, arg1) {
      const ret = debugString(getObject(arg1));
      const ptr1 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);
      const len1 = WASM_VECTOR_LEN;
      getInt32Memory0()[arg0 / 4 + 1] = len1;
      getInt32Memory0()[arg0 / 4 + 0] = ptr1;
    };
    module2.exports.__wbindgen_throw = function(arg0, arg1) {
      throw new Error(getStringFromWasm0(arg0, arg1));
    };
    var path = __require("path").join(__dirname, "wasm_js_rewriter_bg.wasm");
    var bytes = __require("fs").readFileSync(path);
    var wasmModule = new WebAssembly.Module(bytes);
    var wasmInstance = new WebAssembly.Instance(wasmModule, imports);
    wasm = wasmInstance.exports;
    module2.exports.__wasm = wasm;
  }
});

// ../../node_modules/@datadog/wasm-js-rewriter/main.js
var require_main2 = __commonJS({
  "../../node_modules/@datadog/wasm-js-rewriter/main.js"(exports2, module2) {
    "use strict";
    var { getPrepareStackTrace, kSymbolPrepareStackTrace } = require_stack_trace();
    var { cacheRewrittenSourceMap, getOriginalPathAndLineFromSourceMap } = require_source_map();
    var getNameAndVersion = require_module_details();
    var yaml = require_js_yaml();
    var DummyRewriter = class {
      rewrite(code, file, passes, moduleName2, moduleVersion) {
        return {
          content: code
        };
      }
      csiMethods() {
        return [];
      }
    };
    var NativeRewriter;
    var NonCacheRewriter = class {
      constructor(config) {
        if (NativeRewriter) {
          this.nativeRewriter = new NativeRewriter(config);
          this.setLogger(config);
        } else {
          this.nativeRewriter = new DummyRewriter();
        }
        if (config?.orchestrion) {
          const { instrumentations } = yaml.load(config.orchestrion);
          this.orchestrionModules = new Set(instrumentations.map((i) => i.module_name));
        }
      }
      rewrite(code, file, passes) {
        let moduleName2;
        let moduleVersion;
        if (passes.includes("orchestrion")) {
          const details = getNameAndVersion(file);
          moduleName2 = details.name;
          moduleVersion = details.version;
          if (!this.orchestrionModules.has(moduleName2)) {
            passes.splice(passes.indexOf("orchestrion"), 1);
          }
        }
        if (passes.length === 0) {
          return { content: code };
        }
        const response = this.nativeRewriter.rewrite(code, file, passes, moduleName2, moduleVersion);
        if (response?.metrics?.status === "notmodified") {
          response.content = code;
        }
        return response;
      }
      csiMethods() {
        return this.nativeRewriter.csiMethods();
      }
      setLogger(config) {
        if (config && (config.logger || config.logLevel)) {
          this.logger = config.logger || console;
          const logLevel = config.logLevel || "ERROR";
          try {
            this.nativeRewriter.setLogger(this.logger, logLevel);
          } catch (e) {
            this.logError(e);
          }
        }
      }
      logError(e) {
        this.logger?.error?.(e);
      }
    };
    var CacheRewriter = class extends NonCacheRewriter {
      rewrite(code, file, passes) {
        const response = super.rewrite(code, file, passes);
        try {
          const { metrics: metrics2, content } = response;
          if (metrics2?.status === "modified") {
            cacheRewrittenSourceMap(file, content);
          }
        } catch (e) {
          this.logError(e);
        }
        return response;
      }
    };
    function getRewriter(withoutCache = false) {
      try {
        const rewriter = require_wasm_js_rewriter();
        NativeRewriter = rewriter.Rewriter;
        return withoutCache ? NonCacheRewriter : CacheRewriter;
      } catch (e) {
        return DummyRewriter;
      }
    }
    module2.exports = {
      Rewriter: getRewriter(),
      NonCacheRewriter: getRewriter(true),
      DummyRewriter,
      getPrepareStackTrace,
      getOriginalPathAndLineFromSourceMap,
      kSymbolPrepareStackTrace,
      cacheRewrittenSourceMap
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js
var require_rewriter = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/rewriter.js"(exports2, module2) {
    "use strict";
    var Module = __require("module");
    var { pathToFileURL } = __require("url");
    var { MessageChannel: MessageChannel2 } = __require("worker_threads");
    var shimmer = require_datadog_shimmer();
    var { isPrivateModule, isDdTrace } = require_filter();
    var { csiMethods } = require_csi_methods();
    var { getName } = require_verbosity();
    var telemetry = require_telemetry7();
    var { incrementTelemetryIfNeeded } = require_rewriter_telemetry();
    var dc = require_dc_polyfill();
    var log = require_log2();
    var { isMainThread } = __require("worker_threads");
    var { LOG_MESSAGE, REWRITTEN_MESSAGE } = require_constants4();
    var orchestrionConfig = require_orchestrion_config();
    var { getEnvironmentVariable } = require_config_helper();
    var config;
    var hardcodedSecretCh = dc.channel("datadog:secrets:result");
    var rewriter;
    var unwrapCompile = () => {
    };
    var getPrepareStackTrace;
    var cacheRewrittenSourceMap;
    var kSymbolPrepareStackTrace;
    function noop() {
    }
    function isFlagPresent(flag) {
      return getEnvironmentVariable("NODE_OPTIONS")?.includes(flag) || process.execArgv?.some((arg) => arg.includes(flag));
    }
    var getRewriterOriginalPathAndLineFromSourceMap = function(path, line, column) {
      return { path, line, column };
    };
    function setGetOriginalPathAndLineFromSourceMapFunction(chainSourceMap, { getOriginalPathAndLineFromSourceMap: getOriginalPathAndLineFromSourceMap2 }) {
      if (!getOriginalPathAndLineFromSourceMap2) return;
      getRewriterOriginalPathAndLineFromSourceMap = chainSourceMap ? (path, line, column) => {
        return !globalThis.__DD_ESBUILD_IAST_WITH_SM && isPrivateModule(path) && !isDdTrace(path) ? { path, line, column } : getOriginalPathAndLineFromSourceMap2(path, line, column);
      } : getOriginalPathAndLineFromSourceMap2;
    }
    function getRewriter(telemetryVerbosity) {
      if (!rewriter) {
        try {
          const iastRewriter = require_main2();
          const Rewriter = iastRewriter.Rewriter;
          getPrepareStackTrace = iastRewriter.getPrepareStackTrace;
          kSymbolPrepareStackTrace = iastRewriter.kSymbolPrepareStackTrace;
          cacheRewrittenSourceMap = iastRewriter.cacheRewrittenSourceMap;
          const chainSourceMap = isFlagPresent("--enable-source-maps");
          setGetOriginalPathAndLineFromSourceMapFunction(chainSourceMap, iastRewriter);
          rewriter = new Rewriter({
            csiMethods,
            telemetryVerbosity: getName(telemetryVerbosity),
            chainSourceMap,
            orchestrion: orchestrionConfig
          });
        } catch (e) {
          log.error("Unable to initialize Rewriter", e);
        }
      }
      return rewriter;
    }
    var originalPrepareStackTrace;
    function getPrepareStackTraceAccessor() {
      if (!getPrepareStackTrace) {
        getPrepareStackTrace = require_stack_trace().getPrepareStackTrace;
      }
      originalPrepareStackTrace = Error.prepareStackTrace;
      let actual = getPrepareStackTrace(originalPrepareStackTrace);
      return {
        configurable: true,
        get() {
          return actual;
        },
        set(value) {
          actual = getPrepareStackTrace(value);
          originalPrepareStackTrace = value;
        }
      };
    }
    function getCompileMethodFn(compileMethod) {
      let delegate = function(content, filename) {
        try {
          if (isDdTrace(filename)) {
            return compileMethod.apply(this, [content, filename]);
          }
          if (!isPrivateModule(filename) || !config.iast?.enabled) {
            return compileMethod.apply(this, [content, filename]);
          }
          const rewritten = rewriter.rewrite(content, filename, ["iast"]);
          incrementTelemetryIfNeeded(rewritten.metrics);
          if (rewritten?.literalsResult && hardcodedSecretCh.hasSubscribers) {
            hardcodedSecretCh.publish(rewritten.literalsResult);
          }
          if (rewritten?.content) {
            return compileMethod.apply(this, [rewritten.content, filename]);
          }
        } catch (e) {
          log.error("Error rewriting file %s", filename, e);
        }
        return compileMethod.apply(this, [content, filename]);
      };
      const shim = function() {
        return delegate.apply(this, arguments);
      };
      unwrapCompile = function() {
        delegate = compileMethod;
      };
      return shim;
    }
    function esmRewritePostProcess(rewritten, filename) {
      const { literalsResult, metrics: metrics2 } = rewritten;
      if (metrics2?.status === "modified") {
        if (filename.startsWith("file://")) {
          filename = filename.slice(7);
        }
        cacheRewrittenSourceMap(filename, rewritten.content);
      }
      incrementTelemetryIfNeeded(metrics2);
      if (literalsResult && hardcodedSecretCh.hasSubscribers) {
        hardcodedSecretCh.publish(literalsResult);
      }
    }
    var shimmedPrepareStackTrace = false;
    function shimPrepareStackTrace() {
      if (shimmedPrepareStackTrace) {
        return;
      }
      const pstDescriptor = Object.getOwnPropertyDescriptor(global.Error, "prepareStackTrace");
      if (!pstDescriptor || pstDescriptor.configurable || pstDescriptor.writable) {
        Object.defineProperty(global.Error, "prepareStackTrace", getPrepareStackTraceAccessor());
      }
      shimmedPrepareStackTrace = true;
    }
    function enableRewriter(telemetryVerbosity) {
      try {
        if (config.iast?.enabled) {
          const rewriter2 = getRewriter(telemetryVerbosity);
          if (rewriter2) {
            shimPrepareStackTrace();
            if (!globalThis.__DD_ESBUILD_IAST_WITH_SM && !globalThis.__DD_ESBUILD_IAST_WITH_NO_SM) {
              shimmer.wrap(Module.prototype, "_compile", (compileMethod) => getCompileMethodFn(compileMethod));
            }
          }
        }
        enableEsmRewriter(telemetryVerbosity);
      } catch (e) {
        log.error("Error enabling Rewriter", e);
      }
    }
    function isEsmConfigured() {
      const hasLoaderArg = isFlagPresent("--loader") || isFlagPresent("--experimental-loader");
      if (hasLoaderArg) return true;
      if (__require.cache[`${process.cwd()}/node_modules/import-in-the-middle/hook.js`]) {
        return true;
      }
      return Object.keys(__require.cache).some((file) => file.endsWith("import-in-the-middle/hook.js"));
    }
    var enableEsmRewriter = function(telemetryVerbosity) {
      if (isMainThread && Module.register && isEsmConfigured()) {
        shimPrepareStackTrace();
        const { port1, port2 } = new MessageChannel2();
        port1.on("message", (message) => {
          const { type, data } = message;
          switch (type) {
            case LOG_MESSAGE:
              log[data.level]?.(...data.messages);
              break;
            case REWRITTEN_MESSAGE:
              esmRewritePostProcess(data.rewritten, data.url);
              break;
          }
        });
        port1.unref();
        port2.unref();
        try {
          Module.register("./rewriter-esm.mjs", {
            parentURL: pathToFileURL(__filename),
            transferList: [port2],
            data: {
              port: port2,
              csiMethods,
              telemetryVerbosity,
              chainSourceMap: isFlagPresent("--enable-source-maps"),
              orchestrionConfig,
              iastEnabled: config?.iast?.enabled
            }
          });
        } catch (e) {
          log.error("Error enabling ESM Rewriter", e);
          port1.close();
          port2.close();
        }
        cacheRewrittenSourceMap = require_source_map().cacheRewrittenSourceMap;
        enableEsmRewriter = noop;
      }
    };
    function disable() {
      unwrapCompile();
      if (!Error.prepareStackTrace?.[kSymbolPrepareStackTrace]) return;
      try {
        delete Error.prepareStackTrace;
        Error.prepareStackTrace = originalPrepareStackTrace;
        shimmedPrepareStackTrace = false;
      } catch (e) {
        log.warn("Error disabling Rewriter", e);
      }
    }
    function getOriginalPathAndLineFromSourceMap({ path, line, column }) {
      return getRewriterOriginalPathAndLineFromSourceMap(path, line, column);
    }
    function enable(configArg) {
      config = configArg;
      enableRewriter(telemetry.verbosity || "OFF");
    }
    module2.exports = {
      enable,
      disable,
      getOriginalPathAndLineFromSourceMap,
      getRewriter
    };
  }
});

// ../../packages/dd-trace/src/appsec/stack_trace.js
var require_stack_trace2 = __commonJS({
  "../../packages/dd-trace/src/appsec/stack_trace.js"(exports2, module2) {
    "use strict";
    var { ddBasePath } = require_util();
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter();
    var LIBRARY_FRAMES_BUFFER = 20;
    var STACK_TRACE_NAMESPACES = {
      RASP: "exploit",
      IAST: "vulnerability"
    };
    function prepareStackTrace(_2, callsites) {
      return callsites;
    }
    function getCallSiteList(maxDepth = 100, constructorOpt) {
      const previousPrepareStackTrace = Error.prepareStackTrace;
      const previousStackTraceLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = maxDepth + LIBRARY_FRAMES_BUFFER;
      try {
        Error.prepareStackTrace = prepareStackTrace;
        const obj = {};
        Error.captureStackTrace(obj, constructorOpt);
        return obj.stack;
      } finally {
        Error.prepareStackTrace = previousPrepareStackTrace;
        Error.stackTraceLimit = previousStackTraceLimit;
      }
    }
    function filterOutFramesFromLibrary(callSiteList) {
      return callSiteList.filter((callSite) => {
        if (globalThis.__DD_ESBUILD_IAST_WITH_NO_SM) {
          return true;
        }
        if (globalThis.__DD_ESBUILD_IAST_WITH_SM) {
          const callSiteLocation = {
            path: callSite.getFileName(),
            line: callSite.getLineNumber(),
            column: callSite.getColumnNumber()
          };
          const { path } = getOriginalPathAndLineFromSourceMap(callSiteLocation);
          return !path?.startsWith(ddBasePath);
        }
        return !callSite.getFileName()?.startsWith(ddBasePath);
      });
    }
    function getCallsiteFrames(maxDepth = 32, constructorOpt = getCallsiteFrames, callSiteListGetter = getCallSiteList) {
      if (maxDepth < 1) maxDepth = Infinity;
      const callSiteList = callSiteListGetter(maxDepth, constructorOpt);
      const filteredFrames = filterOutFramesFromLibrary(callSiteList);
      const half = filteredFrames.length > maxDepth ? Math.round(maxDepth / 2) : Infinity;
      const indexedFrames = [];
      for (let i = 0; i < Math.min(filteredFrames.length, maxDepth); i++) {
        const index = i < half ? i : i + filteredFrames.length - maxDepth;
        const callSite = filteredFrames[index];
        indexedFrames.push({
          id: index,
          file: callSite.getFileName(),
          line: callSite.getLineNumber(),
          column: callSite.getColumnNumber(),
          function: callSite.getFunctionName(),
          class_name: callSite.getTypeName(),
          isNative: callSite.isNative()
        });
      }
      return indexedFrames;
    }
    function reportStackTrace(rootSpan, stackId, frames, namespace2 = STACK_TRACE_NAMESPACES.RASP) {
      if (!rootSpan) return;
      if (!Array.isArray(frames)) return;
      if (!rootSpan.meta_struct) {
        rootSpan.meta_struct = {};
      }
      if (!rootSpan.meta_struct["_dd.stack"]) {
        rootSpan.meta_struct["_dd.stack"] = {};
      }
      if (!rootSpan.meta_struct["_dd.stack"][namespace2]) {
        rootSpan.meta_struct["_dd.stack"][namespace2] = [];
      }
      rootSpan.meta_struct["_dd.stack"][namespace2].push({
        id: stackId,
        language: "nodejs",
        frames
      });
    }
    function canReportStackTrace(rootSpan, maxStackTraces, namespace2 = STACK_TRACE_NAMESPACES.RASP) {
      if (!rootSpan) return false;
      return maxStackTraces < 1 || (rootSpan.meta_struct?.["_dd.stack"]?.[namespace2]?.length ?? 0) < maxStackTraces;
    }
    module2.exports = {
      getCallsiteFrames,
      reportStackTrace,
      canReportStackTrace,
      STACK_TRACE_NAMESPACES
    };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/utils.js
var require_utils9 = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/utils.js"(exports2, module2) {
    "use strict";
    var web = require_web3();
    var { getCallsiteFrames, reportStackTrace, canReportStackTrace } = require_stack_trace2();
    var { getBlockingAction } = require_blocking();
    var log = require_log2();
    var { updateRaspRuleMatchMetricTags } = require_telemetry6();
    var abortOnUncaughtException = process.execArgv?.includes("--abort-on-uncaught-exception");
    if (abortOnUncaughtException) {
      log.warn("[ASM] The --abort-on-uncaught-exception flag is enabled. The RASP module will not block operations.");
    }
    var RULE_TYPES = {
      COMMAND_INJECTION: "command_injection",
      LFI: "lfi",
      SQL_INJECTION: "sql_injection",
      SSRF: "ssrf"
    };
    var ALLOWED_ROOTSPAN_NAMES = /* @__PURE__ */ new Set([
      "express.request",
      "fastify.request"
    ]);
    var DatadogRaspAbortError = class extends Error {
      constructor(req, res, blockingAction, raspRule, ruleTriggered) {
        super("DatadogRaspAbortError");
        this.name = "DatadogRaspAbortError";
        this.req = req;
        this.res = res;
        this.blockingAction = blockingAction;
        this.raspRule = raspRule;
        this.ruleTriggered = ruleTriggered;
        Object.defineProperties(this, {
          req: { enumerable: false },
          res: { enumerable: false }
        });
      }
    };
    function handleResult(result, req, res, abortController, config, raspRule) {
      const generateStackTraceAction = result?.actions?.generate_stack;
      const { enabled, maxDepth, maxStackTraces } = config.appsec.stackTrace;
      const rootSpan = web.root(req);
      const ruleTriggered = !!result?.events?.length;
      if (generateStackTraceAction && enabled && canReportStackTrace(rootSpan, maxStackTraces)) {
        const frames = getCallsiteFrames(maxDepth, handleResult);
        reportStackTrace(
          rootSpan,
          generateStackTraceAction.stack_id,
          frames
        );
      }
      if (abortController && !abortOnUncaughtException) {
        const blockingAction = getBlockingAction(result?.actions);
        const rootSpanName = rootSpan?.context?.()?._name;
        if (blockingAction && ALLOWED_ROOTSPAN_NAMES.has(rootSpanName)) {
          const abortError = new DatadogRaspAbortError(req, res, blockingAction, raspRule, ruleTriggered);
          abortController.abort(abortError);
          return;
        }
      }
      if (ruleTriggered) {
        updateRaspRuleMatchMetricTags(req, raspRule, false, false);
      }
    }
    module2.exports = {
      handleResult,
      RULE_TYPES,
      DatadogRaspAbortError
    };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/ssrf.js
var require_ssrf = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/ssrf.js"(exports2, module2) {
    "use strict";
    var { format } = __require("url");
    var { httpClientRequestStart } = require_channels2();
    var { storage } = require_datadog_core();
    var addresses = require_addresses();
    var waf = require_waf2();
    var { RULE_TYPES, handleResult } = require_utils9();
    var config;
    function enable(_config) {
      config = _config;
      httpClientRequestStart.subscribe(analyzeSsrf);
    }
    function disable() {
      if (httpClientRequestStart.hasSubscribers) httpClientRequestStart.unsubscribe(analyzeSsrf);
    }
    function analyzeSsrf(ctx) {
      const store = storage("legacy").getStore();
      const req = store?.req;
      const outgoingUrl = (ctx.args.options?.uri && format(ctx.args.options.uri)) ?? ctx.args.uri;
      if (!req || !outgoingUrl) return;
      const ephemeral = {
        [addresses.HTTP_OUTGOING_URL]: outgoingUrl
      };
      const raspRule = { type: RULE_TYPES.SSRF };
      const result = waf.run({ ephemeral }, req, raspRule);
      const res = store?.res;
      handleResult(result, req, res, ctx.abortController, config, raspRule);
    }
    module2.exports = { enable, disable };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/sql_injection.js
var require_sql_injection = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/sql_injection.js"(exports2, module2) {
    "use strict";
    var {
      pgQueryStart,
      pgPoolQueryStart,
      wafRunFinished,
      mysql2OuterQueryStart
    } = require_channels2();
    var { storage } = require_datadog_core();
    var addresses = require_addresses();
    var waf = require_waf2();
    var { RULE_TYPES, handleResult } = require_utils9();
    var DB_SYSTEM_POSTGRES = "postgresql";
    var DB_SYSTEM_MYSQL = "mysql";
    var reqQueryMap = /* @__PURE__ */ new WeakMap();
    var config;
    function enable(_config) {
      config = _config;
      pgQueryStart.subscribe(analyzePgSqlInjection);
      pgPoolQueryStart.subscribe(analyzePgSqlInjection);
      wafRunFinished.subscribe(clearQuerySet);
      mysql2OuterQueryStart.subscribe(analyzeMysql2SqlInjection);
    }
    function disable() {
      if (pgQueryStart.hasSubscribers) pgQueryStart.unsubscribe(analyzePgSqlInjection);
      if (pgPoolQueryStart.hasSubscribers) pgPoolQueryStart.unsubscribe(analyzePgSqlInjection);
      if (wafRunFinished.hasSubscribers) wafRunFinished.unsubscribe(clearQuerySet);
      if (mysql2OuterQueryStart.hasSubscribers) mysql2OuterQueryStart.unsubscribe(analyzeMysql2SqlInjection);
    }
    function analyzeMysql2SqlInjection(ctx) {
      const query = ctx.sql;
      if (!query) return;
      analyzeSqlInjection(query, DB_SYSTEM_MYSQL, ctx.abortController);
    }
    function analyzePgSqlInjection(ctx) {
      const query = ctx.query?.text;
      if (!query) return;
      analyzeSqlInjection(query, DB_SYSTEM_POSTGRES, ctx.abortController);
    }
    function analyzeSqlInjection(query, dbSystem, abortController) {
      const store = storage("legacy").getStore();
      if (!store) return;
      const { req, res } = store;
      if (!req) return;
      let executedQueries = reqQueryMap.get(req);
      if (executedQueries?.has(query)) return;
      if (!executedQueries) {
        executedQueries = /* @__PURE__ */ new Set();
        reqQueryMap.set(req, executedQueries);
      }
      executedQueries.add(query);
      const ephemeral = {
        [addresses.DB_STATEMENT]: query,
        [addresses.DB_SYSTEM]: dbSystem
      };
      const raspRule = { type: RULE_TYPES.SQL_INJECTION };
      const result = waf.run({ ephemeral }, req, raspRule);
      handleResult(result, req, res, abortController, config, raspRule);
    }
    function hasInputAddress(payload) {
      return hasAddressesObjectInputAddress(payload.ephemeral) || hasAddressesObjectInputAddress(payload.persistent);
    }
    function hasAddressesObjectInputAddress(addressesObject) {
      return addressesObject && Object.keys(addressesObject).some((address) => address.startsWith("server.request") || address.startsWith("graphql.server"));
    }
    function clearQuerySet({ payload }) {
      if (!payload) return;
      const store = storage("legacy").getStore();
      if (!store) return;
      const { req } = store;
      if (!req) return;
      const executedQueries = reqQueryMap.get(req);
      if (!executedQueries) return;
      if (hasInputAddress(payload)) {
        executedQueries.clear();
      }
    }
    module2.exports = { enable, disable };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/fs-plugin.js
var require_fs_plugin = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/fs-plugin.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { storage } = require_datadog_core();
    var log = require_log2();
    var RASP_MODULE = "rasp";
    var IAST_MODULE = "iast";
    var enabledFor = {
      [RASP_MODULE]: false,
      [IAST_MODULE]: false
    };
    var fsPlugin;
    function getStoreToStart(fsProps, store = storage("legacy").getStore()) {
      if (store && !store.fs?.opExcluded) {
        return {
          ...store,
          fs: {
            ...store.fs,
            ...fsProps,
            parentStore: store
          }
        };
      }
      return store;
    }
    var AppsecFsPlugin = class extends Plugin {
      enable() {
        this.addBind("apm:fs:operation:start", this._onFsOperationStart);
        this.addBind("apm:fs:operation:finish", this._onFsOperationFinishOrRenderEnd);
        this.addBind("tracing:datadog:express:response:render:start", this._onResponseRenderStart);
        this.addBind("tracing:datadog:express:response:render:end", this._onFsOperationFinishOrRenderEnd);
        super.configure(true);
      }
      disable() {
        super.configure(false);
      }
      _onFsOperationStart() {
        const store = storage("legacy").getStore();
        if (store) {
          return getStoreToStart({ root: store.fs?.root === void 0 }, store);
        }
      }
      _onResponseRenderStart() {
        return getStoreToStart({ opExcluded: true });
      }
      _onFsOperationFinishOrRenderEnd() {
        const store = storage("legacy").getStore();
        if (store?.fs) {
          return store.fs.parentStore;
        }
        return store;
      }
    };
    function enable(mod2) {
      if (enabledFor[mod2] !== false) return;
      enabledFor[mod2] = true;
      if (!fsPlugin) {
        fsPlugin = new AppsecFsPlugin();
        fsPlugin.enable();
      }
      log.info("[ASM] Enabled AppsecFsPlugin for %s", mod2);
    }
    function disable(mod2) {
      if (!mod2 || !enabledFor[mod2]) return;
      enabledFor[mod2] = false;
      const allDisabled = Object.values(enabledFor).every((val) => val === false);
      if (allDisabled) {
        fsPlugin?.disable();
        fsPlugin = void 0;
      }
      log.info("[ASM] Disabled AppsecFsPlugin for %s", mod2);
    }
    module2.exports = {
      enable,
      disable,
      AppsecFsPlugin,
      RASP_MODULE,
      IAST_MODULE
    };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/lfi.js
var require_lfi = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/lfi.js"(exports2, module2) {
    "use strict";
    var { fsOperationStart, incomingHttpRequestStart } = require_channels2();
    var { storage } = require_datadog_core();
    var { enable: enableFsPlugin, disable: disableFsPlugin, RASP_MODULE } = require_fs_plugin();
    var { FS_OPERATION_PATH } = require_addresses();
    var waf = require_waf2();
    var { RULE_TYPES, handleResult } = require_utils9();
    var { isAbsolute } = __require("path");
    var config;
    var enabled;
    var analyzeSubscribed;
    function enable(_config) {
      config = _config;
      if (enabled) return;
      enabled = true;
      incomingHttpRequestStart.subscribe(onFirstReceivedRequest);
    }
    function disable() {
      if (fsOperationStart.hasSubscribers) fsOperationStart.unsubscribe(analyzeLfi);
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(onFirstReceivedRequest);
      disableFsPlugin(RASP_MODULE);
      enabled = false;
      analyzeSubscribed = false;
    }
    function onFirstReceivedRequest() {
      process.nextTick(() => {
        incomingHttpRequestStart.unsubscribe(onFirstReceivedRequest);
      });
      enableFsPlugin(RASP_MODULE);
      if (!analyzeSubscribed) {
        fsOperationStart.subscribe(analyzeLfi);
        analyzeSubscribed = true;
      }
    }
    function analyzeLfi(ctx) {
      const store = storage("legacy").getStore();
      if (!store) return;
      const { req, fs, res } = store;
      if (!req || !fs) return;
      getPaths(ctx, fs).forEach((path) => {
        const ephemeral = {
          [FS_OPERATION_PATH]: path
        };
        const raspRule = { type: RULE_TYPES.LFI };
        const result = waf.run({ ephemeral }, req, raspRule);
        handleResult(result, req, res, ctx.abortController, config, raspRule);
      });
    }
    function getPaths(ctx, fs) {
      const pathArguments = [
        ctx.dest,
        ctx.existingPath,
        ctx.file,
        ctx.newPath,
        ctx.oldPath,
        ctx.path,
        ctx.prefix,
        ctx.src,
        ctx.target
      ];
      return pathArguments.map((path) => pathToStr(path)).filter((path) => shouldAnalyze(path, fs));
    }
    function pathToStr(path) {
      if (!path) return;
      if (typeof path === "string" || // eslint-disable-next-line unicorn/no-instanceof-builtins
      path instanceof String || path instanceof Buffer || path instanceof URL) {
        return path.toString();
      }
    }
    function shouldAnalyze(path, fs) {
      if (!path) return;
      const notExcludedRootOp = !fs.opExcluded && fs.root;
      return notExcludedRootOp && (isAbsolute(path) || path.includes("../") || shouldAnalyzeURLFile(path, fs));
    }
    function shouldAnalyzeURLFile(path, fs) {
      if (path.startsWith("file://")) {
        return shouldAnalyze(path.slice(7), fs);
      }
    }
    module2.exports = {
      enable,
      disable
    };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/command_injection.js
var require_command_injection = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/command_injection.js"(exports2, module2) {
    "use strict";
    var { childProcessExecutionTracingChannel } = require_channels2();
    var { RULE_TYPES, handleResult } = require_utils9();
    var { storage } = require_datadog_core();
    var addresses = require_addresses();
    var waf = require_waf2();
    var config;
    function enable(_config) {
      config = _config;
      childProcessExecutionTracingChannel.subscribe({
        start: analyzeCommandInjection
      });
    }
    function disable() {
      if (childProcessExecutionTracingChannel.start.hasSubscribers) {
        childProcessExecutionTracingChannel.unsubscribe({
          start: analyzeCommandInjection
        });
      }
    }
    function analyzeCommandInjection({ file, fileArgs, shell, abortController }) {
      if (!file) return;
      const store = storage("legacy").getStore();
      const req = store?.req;
      if (!req) return;
      const ephemeral = {};
      const raspRule = { type: RULE_TYPES.COMMAND_INJECTION };
      const params = fileArgs ? [file, ...fileArgs] : file;
      if (shell) {
        ephemeral[addresses.SHELL_COMMAND] = params;
        raspRule.variant = "shell";
      } else {
        const commandParams = Array.isArray(params) ? params : [params];
        ephemeral[addresses.EXEC_COMMAND] = commandParams;
        raspRule.variant = "exec";
      }
      const result = waf.run({ ephemeral }, req, raspRule);
      const res = store?.res;
      handleResult(result, req, res, abortController, config, raspRule);
    }
    module2.exports = {
      enable,
      disable
    };
  }
});

// ../../packages/dd-trace/src/appsec/rasp/index.js
var require_rasp2 = __commonJS({
  "../../packages/dd-trace/src/appsec/rasp/index.js"(exports2, module2) {
    "use strict";
    var web = require_web3();
    var {
      setUncaughtExceptionCaptureCallbackStart,
      expressMiddlewareError,
      fastifyMiddlewareError,
      routerMiddlewareError
    } = require_channels2();
    var { block, registerBlockDelegation, isBlocked } = require_blocking();
    var ssrf = require_ssrf();
    var sqli = require_sql_injection();
    var lfi = require_lfi();
    var cmdi = require_command_injection();
    var { updateRaspRuleMatchMetricTags } = require_telemetry6();
    var { DatadogRaspAbortError } = require_utils9();
    function removeAllListeners(emitter, event) {
      const listeners = emitter.listeners(event);
      emitter.removeAllListeners(event);
      let cleaned = false;
      return function() {
        if (cleaned === true) {
          return;
        }
        cleaned = true;
        for (const listener of listeners) {
          emitter.on(event, listener);
        }
      };
    }
    function findDatadogRaspAbortError(err, deep = 10) {
      if (err instanceof DatadogRaspAbortError) {
        return err;
      }
      if (err?.cause && deep > 0) {
        return findDatadogRaspAbortError(err.cause, deep - 1);
      }
    }
    function handleUncaughtExceptionMonitor(error) {
      if (!blockOnDatadogRaspAbortError({ error, isTopLevel: true })) return;
      if (process.hasUncaughtExceptionCaptureCallback()) {
        let previousCb;
        const cb = ({ currentCallback, abortController }) => {
          setUncaughtExceptionCaptureCallbackStart.unsubscribe(cb);
          if (!currentCallback) {
            abortController.abort();
            return;
          }
          previousCb = currentCallback;
        };
        setUncaughtExceptionCaptureCallbackStart.subscribe(cb);
        process.setUncaughtExceptionCaptureCallback(null);
        if (previousCb) {
          process.setUncaughtExceptionCaptureCallback(() => {
            process.setUncaughtExceptionCaptureCallback(null);
            process.setUncaughtExceptionCaptureCallback(previousCb);
          });
        }
      } else {
        const cleanUp = removeAllListeners(process, "uncaughtException");
        const handler = () => {
          process.removeListener("uncaughtException", handler);
        };
        setTimeout(() => {
          process.removeListener("uncaughtException", handler);
          cleanUp();
        });
        process.on("uncaughtException", handler);
      }
    }
    function blockOnDatadogRaspAbortError({ error, isTopLevel }) {
      const abortError = findDatadogRaspAbortError(error);
      if (!abortError) return false;
      const { req, res, blockingAction, raspRule, ruleTriggered } = abortError;
      if (!isBlocked(res)) {
        const blockFn = isTopLevel ? block : registerBlockDelegation;
        const blocked = blockFn(req, res, web.root(req), null, blockingAction);
        if (ruleTriggered) {
          Promise.resolve(blocked).then((blocked2) => {
            updateRaspRuleMatchMetricTags(req, raspRule, true, blocked2);
          });
        }
      }
      return true;
    }
    function enable(config) {
      ssrf.enable(config);
      sqli.enable(config);
      lfi.enable(config);
      cmdi.enable(config);
      process.on("uncaughtExceptionMonitor", handleUncaughtExceptionMonitor);
      expressMiddlewareError.subscribe(blockOnDatadogRaspAbortError);
      fastifyMiddlewareError.subscribe(blockOnDatadogRaspAbortError);
      routerMiddlewareError.subscribe(blockOnDatadogRaspAbortError);
    }
    function disable() {
      ssrf.disable();
      sqli.disable();
      lfi.disable();
      cmdi.disable();
      process.off("uncaughtExceptionMonitor", handleUncaughtExceptionMonitor);
      expressMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError);
      fastifyMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError);
      routerMiddlewareError.unsubscribe(blockOnDatadogRaspAbortError);
    }
    module2.exports = {
      enable,
      disable,
      handleUncaughtExceptionMonitor,
      // exported only for testing purpose
      blockOnDatadogRaspAbortError
      // exported only for testing purpose
    };
  }
});

// ../../packages/dd-trace/src/appsec/index.js
var require_appsec = __commonJS({
  "../../packages/dd-trace/src/appsec/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var RuleManager = require_rule_manager();
    var remoteConfig = require_remote_config();
    var {
      bodyParser,
      cookieParser,
      multerParser,
      fastifyBodyParser,
      fastifyCookieParser,
      incomingHttpRequestStart,
      incomingHttpRequestEnd,
      passportVerify,
      passportUser,
      expressSession,
      queryParser,
      nextBodyParsed,
      nextQueryParsed,
      expressProcessParams,
      fastifyQueryParams,
      responseBody,
      responseWriteHead,
      responseSetHeader,
      routerParam,
      fastifyResponseChannel,
      fastifyPathParams
    } = require_channels2();
    var waf = require_waf2();
    var addresses = require_addresses();
    var Reporter = require_reporter();
    var appsecTelemetry = require_telemetry6();
    var apiSecuritySampler = require_api_security_sampler();
    var web = require_web3();
    var { extractIp } = require_ip_extractor();
    var { HTTP_CLIENT_IP } = require_tags();
    var { isBlocked, block, callBlockDelegation, setTemplates, getBlockingAction } = require_blocking();
    var UserTracking = require_user_tracking();
    var { storage } = require_datadog_core();
    var graphql = require_graphql4();
    var rasp = require_rasp2();
    var { isInServerlessEnvironment } = require_serverless();
    var responseAnalyzedSet = /* @__PURE__ */ new WeakSet();
    var storedResponseHeaders = /* @__PURE__ */ new WeakMap();
    var storedBodies = /* @__PURE__ */ new WeakMap();
    var isEnabled = false;
    var config;
    function enable(_config) {
      if (isEnabled) return;
      try {
        appsecTelemetry.enable(_config);
        graphql.enable();
        if (_config.appsec.rasp.enabled) {
          rasp.enable(_config);
        }
        setTemplates(_config);
        RuleManager.loadRules(_config.appsec);
        remoteConfig.enableWafUpdate(_config.appsec);
        Reporter.init(_config.appsec);
        apiSecuritySampler.configure(_config);
        UserTracking.setCollectionMode(_config.appsec.eventTracking.mode, false);
        bodyParser.subscribe(onRequestBodyParsed);
        multerParser.subscribe(onRequestBodyParsed);
        cookieParser.subscribe(onRequestCookieParser);
        incomingHttpRequestStart.subscribe(incomingHttpStartTranslator);
        incomingHttpRequestEnd.subscribe(incomingHttpEndTranslator);
        passportVerify.subscribe(onPassportVerify);
        passportUser.subscribe(onPassportDeserializeUser);
        expressSession.subscribe(onExpressSession);
        queryParser.subscribe(onRequestQueryParsed);
        nextBodyParsed.subscribe(onRequestBodyParsed);
        nextQueryParsed.subscribe(onRequestQueryParsed);
        expressProcessParams.subscribe(onRequestProcessParams);
        fastifyBodyParser.subscribe(onRequestBodyParsed);
        fastifyQueryParams.subscribe(onRequestQueryParsed);
        fastifyCookieParser.subscribe(onRequestCookieParser);
        fastifyPathParams.subscribe(onRequestProcessParams);
        routerParam.subscribe(onRequestProcessParams);
        responseBody.subscribe(onResponseBody);
        fastifyResponseChannel.subscribe(onResponseBody);
        responseWriteHead.subscribe(onResponseWriteHead);
        responseSetHeader.subscribe(onResponseSetHeader);
        isEnabled = true;
        config = _config;
      } catch (err) {
        if (!isInServerlessEnvironment()) {
          log.error("[ASM] Unable to start AppSec", err);
        }
        disable();
      }
    }
    function onRequestBodyParsed({ req, res, body, abortController }) {
      if (body === void 0 || body === null) return;
      if (!req) {
        const store = storage("legacy").getStore();
        req = store?.req;
      }
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      if (!req.body) {
        storedBodies.set(req, body);
      }
      const results = waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_BODY]: body
        }
      }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function onRequestCookieParser({ req, res, abortController, cookies }) {
      if (!cookies || typeof cookies !== "object") return;
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      const results = waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_COOKIES]: cookies
        }
      }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function incomingHttpStartTranslator({ req, res, abortController }) {
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      const clientIp = extractIp(config, req);
      rootSpan.addTags({
        "_dd.appsec.enabled": 1,
        "_dd.runtime_family": "nodejs",
        [HTTP_CLIENT_IP]: clientIp
      });
      const requestHeaders = { ...req.headers };
      delete requestHeaders.cookie;
      const persistent = {
        [addresses.HTTP_INCOMING_URL]: req.url,
        [addresses.HTTP_INCOMING_HEADERS]: requestHeaders,
        [addresses.HTTP_INCOMING_METHOD]: req.method
      };
      if (clientIp) {
        persistent[addresses.HTTP_CLIENT_IP] = clientIp;
      }
      const results = waf.run({ persistent }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function incomingHttpEndTranslator({ req, res }) {
      const persistent = {};
      if (req.body !== void 0 && req.body !== null) {
        persistent[addresses.HTTP_INCOMING_BODY] = req.body;
      }
      if (req.cookies !== null && typeof req.cookies === "object") {
        persistent[addresses.HTTP_INCOMING_COOKIES] = req.cookies;
      }
      const query = req.query;
      if (query !== null && typeof query === "object") {
        persistent[addresses.HTTP_INCOMING_QUERY] = query;
      }
      if (apiSecuritySampler.sampleRequest(req, res, true)) {
        persistent[addresses.WAF_CONTEXT_PROCESSOR] = { "extract-schema": true };
      }
      if (Object.keys(persistent).length) {
        waf.run({ persistent }, req);
      }
      waf.disposeContext(req);
      const storedHeaders = storedResponseHeaders.get(req) || {};
      const body = req.body || storedBodies.get(req);
      Reporter.finishRequest(req, res, storedHeaders, body);
      if (storedHeaders) {
        storedResponseHeaders.delete(req);
      }
      storedBodies.delete(req);
    }
    function onPassportVerify({ framework, login, user, success, abortController }) {
      const store = storage("legacy").getStore();
      const rootSpan = store?.req && web.root(store.req);
      if (!rootSpan) {
        log.warn("[ASM] No rootSpan found in onPassportVerify");
        return;
      }
      const results = UserTracking.trackLogin(framework, login, user, success, rootSpan);
      handleResults(results?.actions, store.req, store.req.res, rootSpan, abortController);
    }
    function onPassportDeserializeUser({ user, abortController }) {
      const store = storage("legacy").getStore();
      const rootSpan = store?.req && web.root(store.req);
      if (!rootSpan) {
        log.warn("[ASM] No rootSpan found in onPassportDeserializeUser");
        return;
      }
      const results = UserTracking.trackUser(user, rootSpan);
      handleResults(results?.actions, store.req, store.req.res, rootSpan, abortController);
    }
    function onExpressSession({ req, res, sessionId, abortController }) {
      const rootSpan = web.root(req);
      if (!rootSpan) {
        log.warn("[ASM] No rootSpan found in onExpressSession");
        return;
      }
      const isSdkCalled = rootSpan.context()._tags["usr.session_id"];
      if (isSdkCalled) return;
      const results = waf.run({
        persistent: {
          [addresses.USER_SESSION_ID]: sessionId
        }
      }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function onRequestQueryParsed({ req, res, query, abortController }) {
      if (!query || typeof query !== "object") return;
      if (!req) {
        const store = storage("legacy").getStore();
        req = store?.req;
      }
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      const results = waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_QUERY]: query
        }
      }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function onRequestProcessParams({ req, res, abortController, params }) {
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      if (!params || typeof params !== "object" || !Object.keys(params).length) return;
      const results = waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_PARAMS]: params
        }
      }, req);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function onResponseBody({ req, res, body }) {
      if (!body || typeof body !== "object") return;
      if (!apiSecuritySampler.sampleRequest(req, res)) return;
      waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_RESPONSE_BODY]: body
        }
      }, req);
    }
    function onResponseWriteHead({ req, res, abortController, statusCode, responseHeaders }) {
      if (Object.keys(responseHeaders).length) {
        storedResponseHeaders.set(req, responseHeaders);
      }
      if (isBlocked(res) || callBlockDelegation(res)) {
        abortController?.abort();
        return;
      }
      if (responseAnalyzedSet.has(res)) {
        return;
      }
      const rootSpan = web.root(req);
      if (!rootSpan) return;
      responseHeaders = { ...responseHeaders };
      delete responseHeaders["set-cookie"];
      const results = waf.run({
        persistent: {
          [addresses.HTTP_INCOMING_RESPONSE_CODE]: String(statusCode),
          [addresses.HTTP_INCOMING_RESPONSE_HEADERS]: responseHeaders
        }
      }, req);
      responseAnalyzedSet.add(res);
      handleResults(results?.actions, req, res, rootSpan, abortController);
    }
    function onResponseSetHeader({ res, abortController }) {
      if (isBlocked(res)) {
        abortController?.abort();
      }
    }
    function handleResults(actions, req, res, rootSpan, abortController) {
      if (!actions || !req || !res || !rootSpan || !abortController) return;
      const blockingAction = getBlockingAction(actions);
      if (blockingAction) {
        block(req, res, rootSpan, abortController, blockingAction);
      }
    }
    function disable() {
      isEnabled = false;
      config = null;
      RuleManager.clearAllRules();
      appsecTelemetry.disable();
      graphql.disable();
      rasp.disable();
      remoteConfig.disableWafUpdate();
      apiSecuritySampler.disable();
      if (bodyParser.hasSubscribers) bodyParser.unsubscribe(onRequestBodyParsed);
      if (multerParser.hasSubscribers) multerParser.unsubscribe(onRequestBodyParsed);
      if (cookieParser.hasSubscribers) cookieParser.unsubscribe(onRequestCookieParser);
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(incomingHttpStartTranslator);
      if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(incomingHttpEndTranslator);
      if (passportVerify.hasSubscribers) passportVerify.unsubscribe(onPassportVerify);
      if (passportUser.hasSubscribers) passportUser.unsubscribe(onPassportDeserializeUser);
      if (expressSession.hasSubscribers) expressSession.unsubscribe(onExpressSession);
      if (queryParser.hasSubscribers) queryParser.unsubscribe(onRequestQueryParsed);
      if (nextBodyParsed.hasSubscribers) nextBodyParsed.unsubscribe(onRequestBodyParsed);
      if (nextQueryParsed.hasSubscribers) nextQueryParsed.unsubscribe(onRequestQueryParsed);
      if (expressProcessParams.hasSubscribers) expressProcessParams.unsubscribe(onRequestProcessParams);
      if (fastifyBodyParser.hasSubscribers) fastifyBodyParser.unsubscribe(onRequestBodyParsed);
      if (fastifyQueryParams.hasSubscribers) fastifyQueryParams.unsubscribe(onRequestQueryParsed);
      if (fastifyCookieParser.hasSubscribers) fastifyCookieParser.unsubscribe(onRequestCookieParser);
      if (fastifyPathParams.hasSubscribers) fastifyPathParams.unsubscribe(onRequestProcessParams);
      if (routerParam.hasSubscribers) routerParam.unsubscribe(onRequestProcessParams);
      if (responseBody.hasSubscribers) responseBody.unsubscribe(onResponseBody);
      if (fastifyResponseChannel.hasSubscribers) fastifyResponseChannel.unsubscribe(onResponseBody);
      if (responseWriteHead.hasSubscribers) responseWriteHead.unsubscribe(onResponseWriteHead);
      if (responseSetHeader.hasSubscribers) responseSetHeader.unsubscribe(onResponseSetHeader);
    }
    module2.exports = {
      enable,
      disable,
      incomingHttpStartTranslator,
      incomingHttpEndTranslator
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities.js
var require_vulnerabilities = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      COMMAND_INJECTION: "COMMAND_INJECTION",
      CODE_INJECTION: "CODE_INJECTION",
      HARDCODED_PASSWORD: "HARDCODED_PASSWORD",
      HARDCODED_SECRET: "HARDCODED_SECRET",
      HSTS_HEADER_MISSING: "HSTS_HEADER_MISSING",
      INSECURE_COOKIE: "INSECURE_COOKIE",
      LDAP_INJECTION: "LDAP_INJECTION",
      NO_HTTPONLY_COOKIE: "NO_HTTPONLY_COOKIE",
      NO_SAMESITE_COOKIE: "NO_SAMESITE_COOKIE",
      NOSQL_MONGODB_INJECTION: "NOSQL_MONGODB_INJECTION",
      PATH_TRAVERSAL: "PATH_TRAVERSAL",
      SQL_INJECTION: "SQL_INJECTION",
      SSRF: "SSRF",
      TEMPLATE_INJECTION: "TEMPLATE_INJECTION",
      UNVALIDATED_REDIRECT: "UNVALIDATED_REDIRECT",
      UNTRUSTED_DESERIALIZATION: "UNTRUSTED_DESERIALIZATION",
      WEAK_CIPHER: "WEAK_CIPHER",
      WEAK_HASH: "WEAK_HASH",
      WEAK_RANDOMNESS: "WEAK_RANDOMNESS",
      XCONTENTTYPE_HEADER_MISSING: "XCONTENTTYPE_HEADER_MISSING"
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/range-utils.js
var require_range_utils = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/range-utils.js"(exports2, module2) {
    "use strict";
    function contains(rangeContainer, rangeContained) {
      if (rangeContainer.start > rangeContained.start) {
        return false;
      }
      return rangeContainer.end >= rangeContained.end;
    }
    function intersects(rangeA, rangeB) {
      return rangeB.start < rangeA.end && rangeB.end > rangeA.start;
    }
    function remove(range, rangeToRemove) {
      if (!intersects(range, rangeToRemove)) {
        return [range];
      } else if (contains(rangeToRemove, range)) {
        return [];
      }
      const result = [];
      if (rangeToRemove.start > range.start) {
        const offset = rangeToRemove.start - range.start;
        result.push({ start: range.start, end: range.start + offset });
      }
      if (rangeToRemove.end < range.end) {
        const offset = range.end - rangeToRemove.end;
        result.push({ start: rangeToRemove.end, end: rangeToRemove.end + offset });
      }
      return result;
    }
    module2.exports = {
      contains,
      intersects,
      remove
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/command-sensitive-analyzer.js
var require_command_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/command-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var COMMAND_PATTERN = String.raw`^(?:\s*(?:sudo|doas)\s+)?\b\S+\b\s(.*)`;
    var pattern = new RegExp(COMMAND_PATTERN, "gmi");
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        pattern.lastIndex = 0;
        const regexResult = pattern.exec(evidence.value);
        if (regexResult && regexResult.length > 1) {
          const start = regexResult.index + (regexResult[0].length - regexResult[1].length);
          const end = start + regexResult[1].length;
          return [{ start, end }];
        }
      } catch (e) {
        log.debug("[ASM] Error extracting sensitive ranges", e);
      }
      return [];
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/hardcoded-password-analyzer.js
var require_hardcoded_password_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/hardcoded-password-analyzer.js"(exports2, module2) {
    "use strict";
    module2.exports = function extractSensitiveRanges(evidence, valuePattern) {
      const { value } = evidence;
      if (valuePattern.test(value)) {
        return [{
          start: 0,
          end: value.length
        }];
      }
      return [];
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-regex.js
var require_sensitive_regex = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-regex.js"(exports2, module2) {
    "use strict";
    var DEFAULT_IAST_REDACTION_NAME_PATTERN = "(?:p(?:ass)?w(?:or)?d|pass(?:_?phrase)?|secret|(?:api_?|private_?|public_?|access_?|secret_?)key(?:_?id)?|token|consumer_?(?:id|key|secret)|sign(?:ed|ature)?|auth(?:entication|orization)?|(?:sur|last)name|user(?:name)?|address|e?mail)";
    var DEFAULT_IAST_REDACTION_VALUE_PATTERN = String.raw`(?:bearer\s+[a-z0-9\._\-]+|glpat-[\w\-]{20}|gh[opsu]_[0-9a-zA-Z]{36}|ey[I-L][\w=\-]+\.ey[I-L][\w=\-]+(?:\.[\w.+/=\-]+)?|(?:[\-]{5}BEGIN[a-z\s]+PRIVATE\sKEY[\-]{5}[^\-]+[\-]{5}END[a-z\s]+PRIVATE\sKEY[\-]{5}|ssh-rsa\s*[a-z0-9/\.+]{100,})|[\w\.-]+@[a-zA-Z\d\.-]+\.[a-zA-Z]{2,})`;
    module2.exports = {
      DEFAULT_IAST_REDACTION_NAME_PATTERN,
      DEFAULT_IAST_REDACTION_VALUE_PATTERN
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/utils.js
var require_utils10 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/utils.js"(exports2, module2) {
    "use strict";
    var crypto = __require("crypto");
    var { DEFAULT_IAST_REDACTION_VALUE_PATTERN } = require_sensitive_regex();
    var STRINGIFY_RANGE_KEY = "DD_" + crypto.randomBytes(20).toString("hex");
    var STRINGIFY_SENSITIVE_KEY = STRINGIFY_RANGE_KEY + "SENSITIVE";
    var STRINGIFY_SENSITIVE_NOT_STRING_KEY = STRINGIFY_SENSITIVE_KEY + "NOTSTRING";
    var KEYS_REGEX_WITH_SENSITIVE_RANGES = new RegExp(`(?:"(${STRINGIFY_RANGE_KEY}_\\d+_))|(?:"(${STRINGIFY_SENSITIVE_KEY}_\\d+_(\\d+)_))|("${STRINGIFY_SENSITIVE_NOT_STRING_KEY}_\\d+_([\\s0-9.a-zA-Z]*)")`, "gm");
    var KEYS_REGEX_WITHOUT_SENSITIVE_RANGES = new RegExp(`"(${STRINGIFY_RANGE_KEY}_\\d+_)`, "gm");
    var sensitiveValueRegex = new RegExp(DEFAULT_IAST_REDACTION_VALUE_PATTERN, "gmi");
    function iterateObject(target, fn, levelKeys = [], depth = 10, visited = /* @__PURE__ */ new Set()) {
      Object.keys(target).forEach((key) => {
        const nextLevelKeys = [...levelKeys, key];
        const val = target[key];
        if (typeof val !== "object" || !visited.has(val)) {
          visited.add(val);
          fn(val, nextLevelKeys, target, key);
          if (val !== null && typeof val === "object" && depth > 0) {
            iterateObject(val, fn, nextLevelKeys, depth - 1, visited);
          }
        }
      });
    }
    function stringifyWithRanges(obj, objRanges, loadSensitiveRanges = false) {
      let value;
      const ranges = [];
      const sensitiveRanges = [];
      objRanges = objRanges || {};
      if (objRanges || loadSensitiveRanges) {
        const cloneObj = Array.isArray(obj) ? [] : {};
        let counter = 0;
        const allRanges = {};
        const sensitiveKeysMapping = {};
        iterateObject(obj, (val, levelKeys, parent, key) => {
          let currentLevelClone = cloneObj;
          for (let i = 0; i < levelKeys.length - 1; i++) {
            let levelKey = levelKeys[i];
            if (!currentLevelClone[levelKey]) {
              const sensitiveKey = sensitiveKeysMapping[levelKey];
              if (currentLevelClone[sensitiveKey]) {
                levelKey = sensitiveKey;
              }
            }
            currentLevelClone = currentLevelClone[levelKey];
          }
          if (loadSensitiveRanges) {
            const sensitiveKey = sensitiveKeysMapping[key];
            if (sensitiveKey) {
              key = sensitiveKey;
            } else {
              sensitiveValueRegex.lastIndex = 0;
              if (sensitiveValueRegex.test(key)) {
                const current = counter++;
                const id = `${STRINGIFY_SENSITIVE_KEY}_${current}_${key.length}_`;
                key = `${id}${key}`;
              }
            }
          }
          if (typeof val === "string") {
            const ranges2 = objRanges[levelKeys.join(".")];
            if (ranges2) {
              const current = counter++;
              const id = `${STRINGIFY_RANGE_KEY}_${current}_`;
              allRanges[id] = ranges2;
              currentLevelClone[key] = `${id}${val}`;
            } else {
              currentLevelClone[key] = val;
            }
            if (loadSensitiveRanges) {
              const current = counter++;
              const id = `${STRINGIFY_SENSITIVE_KEY}_${current}_${val.length}_`;
              currentLevelClone[key] = `${id}${currentLevelClone[key]}`;
            }
          } else if (typeof val !== "object" || val === null) {
            if (loadSensitiveRanges) {
              const current = counter++;
              const id = `${STRINGIFY_SENSITIVE_NOT_STRING_KEY}_${current}_`;
              currentLevelClone[key] = id + val;
            } else {
              currentLevelClone[key] = val;
            }
          } else {
            currentLevelClone[key] = Array.isArray(val) ? [] : {};
          }
        });
        value = JSON.stringify(cloneObj, null, 2);
        if (counter > 0) {
          const keysRegex = loadSensitiveRanges ? KEYS_REGEX_WITH_SENSITIVE_RANGES : KEYS_REGEX_WITHOUT_SENSITIVE_RANGES;
          keysRegex.lastIndex = 0;
          let regexRes = keysRegex.exec(value);
          while (regexRes) {
            const offset = regexRes.index + 1;
            if (regexRes[1]) {
              const rangesId = regexRes[1];
              value = value.replace(rangesId, "");
              const updatedRanges = allRanges[rangesId].map((range) => {
                return {
                  ...range,
                  start: range.start + offset,
                  end: range.end + offset
                };
              });
              ranges.push(...updatedRanges);
            } else if (regexRes[2]) {
              const sensitiveId = regexRes[2];
              sensitiveRanges.push({
                start: offset,
                end: offset + Number.parseInt(regexRes[3])
              });
              value = value.replace(sensitiveId, "");
            } else if (regexRes[4]) {
              const sensitiveId = regexRes[4];
              const originalValue = regexRes[5];
              sensitiveRanges.push({
                start: regexRes.index,
                end: regexRes.index + originalValue.length
              });
              value = value.replace(sensitiveId, originalValue);
            }
            keysRegex.lastIndex = 0;
            regexRes = keysRegex.exec(value);
          }
        }
      } else {
        value = JSON.stringify(obj, null, 2);
      }
      return { value, ranges, sensitiveRanges };
    }
    module2.exports = { stringifyWithRanges };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/json-sensitive-analyzer.js
var require_json_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/json-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    var { stringifyWithRanges } = require_utils10();
    module2.exports = function extractSensitiveRanges(evidence) {
      const { value, ranges, sensitiveRanges } = stringifyWithRanges(evidence.value, evidence.rangesToApply, true);
      evidence.value = value;
      evidence.ranges = ranges;
      return sensitiveRanges;
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/ldap-sensitive-analyzer.js
var require_ldap_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/ldap-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var LDAP_PATTERN = String.raw`\(.*?(?:~=|=|<=|>=)(?<LITERAL>[^)]+)\)`;
    var pattern = new RegExp(LDAP_PATTERN, "gmi");
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        pattern.lastIndex = 0;
        const tokens = [];
        let regexResult = pattern.exec(evidence.value);
        while (regexResult != null) {
          if (!regexResult.groups.LITERAL) continue;
          const start = regexResult.index + (regexResult[0].length - regexResult.groups.LITERAL.length - 1);
          const end = start + regexResult.groups.LITERAL.length;
          tokens.push({ start, end });
          regexResult = pattern.exec(evidence.value);
        }
        return tokens;
      } catch (e) {
        log.debug("[ASM] Error extracting sensitive ranges", e);
      }
      return [];
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/sql-sensitive-analyzer.js
var require_sql_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/sql-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var STRING_LITERAL = "'(?:''|[^'])*'";
    var POSTGRESQL_ESCAPED_LITERAL = String.raw`\$([^$]*)\$.*?\$\1\$`;
    var MYSQL_STRING_LITERAL = String.raw`"(?:\\"|[^"])*"|'(?:\\'|[^'])*'`;
    var LINE_COMMENT = "--.*$";
    var BLOCK_COMMENT = String.raw`/\*[\s\S]*\*/`;
    var EXPONENT = String.raw`(?:E[-+]?\d+[fd]?)?`;
    var INTEGER_NUMBER = String.raw`(?<!\w)\d+`;
    var DECIMAL_NUMBER = String.raw`\d*\.\d+`;
    var HEX_NUMBER = "x'[0-9a-f]+'|0x[0-9a-f]+";
    var BIN_NUMBER = "b'[0-9a-f]+'|0b[0-9a-f]+";
    var NUMERIC_LITERAL = `[-+]?(?:${[
      HEX_NUMBER,
      BIN_NUMBER,
      DECIMAL_NUMBER + EXPONENT,
      INTEGER_NUMBER + EXPONENT
    ].join("|")})`;
    var ORACLE_ESCAPED_LITERAL = String.raw`q'<.*?>'|q'\(.*?\)'|q'\{.*?\}'|q'\[.*?\]'|q'(?<ESCAPE>.).*?\k<ESCAPE>'`;
    var patterns = {
      ANSI: new RegExp(
        // Default
        [
          NUMERIC_LITERAL,
          STRING_LITERAL,
          LINE_COMMENT,
          BLOCK_COMMENT
        ].join("|"),
        "gmi"
      ),
      MYSQL: new RegExp(
        [
          NUMERIC_LITERAL,
          MYSQL_STRING_LITERAL,
          LINE_COMMENT,
          BLOCK_COMMENT
        ].join("|"),
        "gmi"
      ),
      POSTGRES: new RegExp(
        [
          NUMERIC_LITERAL,
          POSTGRESQL_ESCAPED_LITERAL,
          STRING_LITERAL,
          LINE_COMMENT,
          BLOCK_COMMENT
        ].join("|"),
        "gmi"
      ),
      ORACLE: new RegExp(
        [
          NUMERIC_LITERAL,
          ORACLE_ESCAPED_LITERAL,
          STRING_LITERAL,
          LINE_COMMENT,
          BLOCK_COMMENT
        ].join("|"),
        "gmi"
      )
    };
    patterns.SQLITE = patterns.MYSQL;
    patterns.MARIADB = patterns.MYSQL;
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        let pattern = patterns[evidence.dialect];
        if (!pattern) {
          pattern = patterns.ANSI;
        }
        pattern.lastIndex = 0;
        const tokens = [];
        let regexResult = pattern.exec(evidence.value);
        while (regexResult != null) {
          let start = regexResult.index;
          let end = regexResult.index + regexResult[0].length;
          const startChar = evidence.value.charAt(start);
          if (startChar === "'" || startChar === '"') {
            start++;
            end--;
          } else if (end > start + 1) {
            const nextChar = evidence.value.charAt(start + 1);
            if (startChar === "/" && nextChar === "*") {
              start += 2;
              end -= 2;
            } else if (startChar === "-" && startChar === nextChar) {
              start += 2;
            } else if (startChar.toLowerCase() === "q" && nextChar === "'") {
              start += 3;
              end -= 2;
            } else if (startChar === "$") {
              const match = regexResult[0];
              const size = match.indexOf("$", 1) + 1;
              if (size > 1) {
                start += size;
                end -= size;
              }
            }
          }
          tokens.push({ start, end });
          regexResult = pattern.exec(evidence.value);
        }
        return tokens;
      } catch (e) {
        log.debug("[ASM] Error extracting sensitive ranges", e);
      }
      return [];
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/tainted-range-based-sensitive-analyzer.js
var require_tainted_range_based_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/tainted-range-based-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    module2.exports = function extractSensitiveRanges(evidence) {
      const newRanges = [];
      if (evidence.ranges[0].start > 0) {
        newRanges.push({
          start: 0,
          end: evidence.ranges[0].start
        });
      }
      for (let i = 0; i < evidence.ranges.length; i++) {
        const currentRange = evidence.ranges[i];
        const nextRange = evidence.ranges[i + 1];
        const start = currentRange.end;
        const end = nextRange?.start || evidence.value.length;
        if (start < end) {
          newRanges.push({ start, end });
        }
      }
      return newRanges;
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/url-sensitive-analyzer.js
var require_url_sensitive_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-analyzers/url-sensitive-analyzer.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var AUTHORITY = "^(?:[^:]+:)?//([^@]+)@";
    var QUERY_FRAGMENT = "[?#&]([^=&;]+)=([^?#&]+)";
    var pattern = new RegExp([AUTHORITY, QUERY_FRAGMENT].join("|"), "gmi");
    module2.exports = function extractSensitiveRanges(evidence) {
      try {
        const ranges = [];
        let regexResult = pattern.exec(evidence.value);
        while (regexResult != null) {
          if (typeof regexResult[1] === "string") {
            const end = regexResult.index + (regexResult[0].length - 1);
            const start = end - regexResult[1].length;
            ranges.push({ start, end });
          }
          if (typeof regexResult[3] === "string") {
            const end = regexResult.index + regexResult[0].length;
            const start = end - regexResult[3].length;
            ranges.push({ start, end });
          }
          regexResult = pattern.exec(evidence.value);
        }
        return ranges;
      } catch (e) {
        log.debug("[ASM] Error extracting sensitive ranges", e);
      }
      return [];
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-handler.js
var require_sensitive_handler = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-handler.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var vulnerabilities = require_vulnerabilities();
    var { contains, intersects, remove } = require_range_utils();
    var commandSensitiveAnalyzer = require_command_sensitive_analyzer();
    var hardcodedPasswordAnalyzer = require_hardcoded_password_analyzer();
    var jsonSensitiveAnalyzer = require_json_sensitive_analyzer();
    var ldapSensitiveAnalyzer = require_ldap_sensitive_analyzer();
    var sqlSensitiveAnalyzer = require_sql_sensitive_analyzer();
    var taintedRangeBasedSensitiveAnalyzer = require_tainted_range_based_sensitive_analyzer();
    var urlSensitiveAnalyzer = require_url_sensitive_analyzer();
    var { DEFAULT_IAST_REDACTION_NAME_PATTERN, DEFAULT_IAST_REDACTION_VALUE_PATTERN } = require_sensitive_regex();
    var REDACTED_SOURCE_BUFFER = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    var SensitiveHandler = class {
      constructor() {
        this._namePattern = new RegExp(DEFAULT_IAST_REDACTION_NAME_PATTERN, "gmi");
        this._valuePattern = new RegExp(DEFAULT_IAST_REDACTION_VALUE_PATTERN, "gmi");
        this._sensitiveAnalyzers = /* @__PURE__ */ new Map();
        this._sensitiveAnalyzers.set(vulnerabilities.CODE_INJECTION, taintedRangeBasedSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.COMMAND_INJECTION, commandSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.HARDCODED_PASSWORD, (evidence) => {
          return hardcodedPasswordAnalyzer(evidence, this._valuePattern);
        });
        this._sensitiveAnalyzers.set(vulnerabilities.LDAP_INJECTION, ldapSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.NOSQL_MONGODB_INJECTION, jsonSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.SQL_INJECTION, sqlSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.SSRF, urlSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.TEMPLATE_INJECTION, taintedRangeBasedSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.UNTRUSTED_DESERIALIZATION, taintedRangeBasedSensitiveAnalyzer);
        this._sensitiveAnalyzers.set(vulnerabilities.UNVALIDATED_REDIRECT, urlSensitiveAnalyzer);
      }
      isSensibleName(name) {
        this._namePattern.lastIndex = 0;
        return this._namePattern.test(name);
      }
      isSensibleValue(value) {
        this._valuePattern.lastIndex = 0;
        return this._valuePattern.test(value);
      }
      isSensibleSource(source) {
        return source != null && (this.isSensibleName(source.name) || this.isSensibleValue(source.value));
      }
      scrubEvidence(vulnerabilityType, evidence, sourcesIndexes, sources) {
        const sensitiveAnalyzer = this._sensitiveAnalyzers.get(vulnerabilityType);
        if (sensitiveAnalyzer) {
          const sensitiveRanges = sensitiveAnalyzer(evidence);
          if (evidence.ranges || sensitiveRanges?.length) {
            return this.toRedactedJson(evidence, sensitiveRanges, sourcesIndexes, sources);
          }
        }
        return null;
      }
      toRedactedJson(evidence, sensitive, sourcesIndexes, sources) {
        const valueParts = [];
        const redactedSources = [];
        const redactedSourcesContext = [];
        const { value, ranges } = evidence;
        let start = 0;
        let nextTaintedIndex = 0;
        let sourceIndex;
        let nextTainted = ranges?.shift();
        let nextSensitive = sensitive.shift();
        for (let i = 0; i < value.length; i++) {
          if (nextTainted != null && nextTainted.start === i) {
            this.writeValuePart(valueParts, value.slice(start, i), sourceIndex);
            sourceIndex = sourcesIndexes[nextTaintedIndex];
            while (nextSensitive != null && contains(nextTainted, nextSensitive)) {
              const redactionStart = nextSensitive.start - nextTainted.start;
              const redactionEnd = nextSensitive.end - nextTainted.start;
              if (redactionStart === redactionEnd) {
                this.writeRedactedValuePart(valueParts, 0);
              } else {
                this.redactSource(
                  sources,
                  redactedSources,
                  redactedSourcesContext,
                  sourceIndex,
                  redactionStart,
                  redactionEnd
                );
              }
              nextSensitive = sensitive.shift();
            }
            if (nextSensitive != null && intersects(nextSensitive, nextTainted)) {
              const redactionStart = nextSensitive.start - nextTainted.start;
              const redactionEnd = nextSensitive.end - nextTainted.start;
              this.redactSource(sources, redactedSources, redactedSourcesContext, sourceIndex, redactionStart, redactionEnd);
              const entries = remove(nextSensitive, nextTainted);
              nextSensitive = entries.length > 0 ? entries[0] : null;
            }
            if (this.isSensibleSource(sources[sourceIndex]) && !sources[sourceIndex].redacted) {
              redactedSources.push(sourceIndex);
              sources[sourceIndex].pattern = "".padEnd(sources[sourceIndex].value.length, REDACTED_SOURCE_BUFFER);
              sources[sourceIndex].redacted = true;
            }
            if (redactedSources.includes(sourceIndex)) {
              const partValue = value.slice(i, i + (nextTainted.end - nextTainted.start));
              this.writeRedactedValuePart(
                valueParts,
                partValue.length,
                sourceIndex,
                partValue,
                sources[sourceIndex],
                redactedSourcesContext[sourceIndex],
                this.isSensibleSource(sources[sourceIndex])
              );
              redactedSourcesContext[sourceIndex] = [];
            } else {
              const substringEnd = Math.min(nextTainted.end, value.length);
              this.writeValuePart(valueParts, value.slice(nextTainted.start, substringEnd), sourceIndex);
            }
            start = i + (nextTainted.end - nextTainted.start);
            i = start - 1;
            nextTainted = ranges.shift();
            nextTaintedIndex++;
            sourceIndex = null;
          } else if (nextSensitive != null && nextSensitive.start === i) {
            this.writeValuePart(valueParts, value.slice(start, i), sourceIndex);
            if (nextTainted != null && intersects(nextSensitive, nextTainted)) {
              sourceIndex = sourcesIndexes[nextTaintedIndex];
              const redactionStart = nextSensitive.start - nextTainted.start;
              const redactionEnd = nextSensitive.end - nextTainted.start;
              this.redactSource(sources, redactedSources, redactedSourcesContext, sourceIndex, redactionStart, redactionEnd);
              for (const entry of remove(nextSensitive, nextTainted)) {
                if (entry.start === i) {
                  nextSensitive = entry;
                } else {
                  sensitive.unshift(entry);
                }
              }
            }
            const _length = nextSensitive.end - nextSensitive.start;
            this.writeRedactedValuePart(valueParts, _length);
            start = i + _length;
            i = start - 1;
            nextSensitive = sensitive.shift();
          }
        }
        if (start < value.length) {
          this.writeValuePart(valueParts, value.slice(start));
        }
        return { redactedValueParts: valueParts, redactedSources };
      }
      redactSource(sources, redactedSources, redactedSourcesContext, sourceIndex, start, end) {
        if (sourceIndex != null) {
          if (!sources[sourceIndex].redacted) {
            redactedSources.push(sourceIndex);
            sources[sourceIndex].pattern = "".padEnd(sources[sourceIndex].value.length, REDACTED_SOURCE_BUFFER);
            sources[sourceIndex].redacted = true;
          }
          if (!redactedSourcesContext[sourceIndex]) {
            redactedSourcesContext[sourceIndex] = [];
          }
          redactedSourcesContext[sourceIndex].push({
            start,
            end
          });
        }
      }
      writeValuePart(valueParts, value, source) {
        if (value.length > 0) {
          if (source == null) {
            valueParts.push({ value });
          } else {
            valueParts.push({ value, source });
          }
        }
      }
      writeRedactedValuePart(valueParts, length, sourceIndex, partValue, source, sourceRedactionContext, isSensibleSource) {
        if (sourceIndex == null) {
          valueParts.push({ redacted: true });
        } else {
          const placeholder = source.value.includes(partValue) ? source.pattern : "*".repeat(length);
          if (isSensibleSource) {
            valueParts.push({ redacted: true, source: sourceIndex, pattern: placeholder });
          } else {
            let _value = partValue;
            const dedupedSourceRedactionContexts = [];
            sourceRedactionContext.forEach((_sourceRedactionContext) => {
              const isPresentInDeduped = dedupedSourceRedactionContexts.some(
                (_dedupedSourceRedactionContext) => _dedupedSourceRedactionContext.start === _sourceRedactionContext.start && _dedupedSourceRedactionContext.end === _sourceRedactionContext.end
              );
              if (!isPresentInDeduped) {
                dedupedSourceRedactionContexts.push(_sourceRedactionContext);
              }
            });
            let offset = 0;
            dedupedSourceRedactionContexts.forEach((_sourceRedactionContext) => {
              if (_sourceRedactionContext.start > 0) {
                valueParts.push({
                  source: sourceIndex,
                  value: _value.substring(0, _sourceRedactionContext.start - offset)
                });
                _value = _value.substring(_sourceRedactionContext.start - offset);
                offset = _sourceRedactionContext.start;
              }
              const sensitive = _value.substring(_sourceRedactionContext.start - offset, _sourceRedactionContext.end - offset);
              const indexOfPartValueInPattern = source.value.indexOf(sensitive);
              const pattern = indexOfPartValueInPattern === -1 ? placeholder.substring(_sourceRedactionContext.start, _sourceRedactionContext.end) : placeholder.substring(indexOfPartValueInPattern, indexOfPartValueInPattern + sensitive.length);
              valueParts.push({
                redacted: true,
                source: sourceIndex,
                pattern
              });
              _value = _value.slice(pattern.length);
              offset += pattern.length;
            });
            if (_value.length) {
              valueParts.push({
                source: sourceIndex,
                value: _value
              });
            }
          }
        }
      }
      setRedactionPatterns(redactionNamePattern, redactionValuePattern) {
        if (redactionNamePattern) {
          try {
            this._namePattern = new RegExp(redactionNamePattern, "gmi");
          } catch {
            log.warn("[ASM] Redaction name pattern is not valid");
          }
        }
        if (redactionValuePattern) {
          try {
            this._valuePattern = new RegExp(redactionValuePattern, "gmi");
          } catch {
            log.warn("[ASM] Redaction value pattern is not valid");
          }
        }
      }
    };
    module2.exports = new SensitiveHandler();
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/index.js
var require_vulnerabilities_formatter = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerabilities-formatter/index.js"(exports2, module2) {
    "use strict";
    var sensitiveHandler = require_sensitive_handler();
    var { stringifyWithRanges } = require_utils10();
    var VulnerabilityFormatter = class {
      _redactVulnearbilities = true;
      setRedactVulnerabilities(shouldRedactVulnerabilities, redactionNamePattern, redactionValuePattern) {
        this._redactVulnearbilities = shouldRedactVulnerabilities;
        sensitiveHandler.setRedactionPatterns(redactionNamePattern, redactionValuePattern);
      }
      extractSourcesFromVulnerability(vulnerability) {
        if (!vulnerability.evidence.ranges) {
          return [];
        }
        return vulnerability.evidence.ranges.map((range) => ({
          origin: range.iinfo.type,
          name: range.iinfo.parameterName,
          value: range.iinfo.parameterValue
        }));
      }
      getRedactedValueParts(type, evidence, sourcesIndexes, sources) {
        const scrubbingResult = sensitiveHandler.scrubEvidence(type, evidence, sourcesIndexes, sources);
        if (scrubbingResult) {
          const { redactedValueParts, redactedSources } = scrubbingResult;
          redactedSources.forEach((i) => {
            delete sources[i].value;
          });
          return { valueParts: redactedValueParts };
        }
        return this.getUnredactedValueParts(evidence, sourcesIndexes);
      }
      getUnredactedValueParts(evidence, sourcesIndexes) {
        const valueParts = [];
        let fromIndex = 0;
        if (evidence.value == null) return { valueParts };
        if (typeof evidence.value === "object" && evidence.rangesToApply) {
          const { value, ranges } = stringifyWithRanges(evidence.value, evidence.rangesToApply);
          evidence.value = value;
          evidence.ranges = ranges;
        }
        if (!evidence.ranges) {
          return { value: evidence.value };
        }
        evidence.ranges.forEach((range, rangeIndex) => {
          if (fromIndex < range.start) {
            valueParts.push({ value: evidence.value.slice(fromIndex, range.start) });
          }
          valueParts.push({ value: evidence.value.slice(range.start, range.end), source: sourcesIndexes[rangeIndex] });
          fromIndex = range.end;
        });
        if (fromIndex < evidence.value.length) {
          valueParts.push({ value: evidence.value.slice(fromIndex) });
        }
        return { valueParts };
      }
      formatEvidence(type, evidence, sourcesIndexes, sources) {
        if (evidence.value === void 0) {
          return;
        }
        return this._redactVulnearbilities ? this.getRedactedValueParts(type, evidence, sourcesIndexes, sources) : this.getUnredactedValueParts(evidence, sourcesIndexes);
      }
      formatVulnerability(vulnerability, sourcesIndexes, sources) {
        const { type, hash, evidence, location } = vulnerability;
        const formattedVulnerability = {
          type,
          hash,
          evidence: this.formatEvidence(type, evidence, sourcesIndexes, sources),
          location
        };
        return formattedVulnerability;
      }
      toJson(vulnerabilitiesToFormat) {
        const sources = [];
        const vulnerabilities = vulnerabilitiesToFormat.map((vulnerability) => {
          const vulnerabilitySources = this.extractSourcesFromVulnerability(vulnerability);
          const sourcesIndexes = [];
          vulnerabilitySources.forEach((source) => {
            let sourceIndex = sources.findIndex(
              (existingSource) => existingSource.origin === source.origin && existingSource.name === source.name && existingSource.value === source.value
            );
            if (sourceIndex === -1) {
              sourceIndex = sources.length;
              sources.push(source);
            }
            sourcesIndexes.push(sourceIndex);
          });
          return this.formatVulnerability(vulnerability, sourcesIndexes, sources);
        });
        return {
          sources,
          vulnerabilities
        };
      }
    };
    module2.exports = new VulnerabilityFormatter();
  }
});

// ../../packages/dd-trace/src/appsec/iast/vulnerability-reporter.js
var require_vulnerability_reporter = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/vulnerability-reporter.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs();
    var vulnerabilitiesFormatter = require_vulnerabilities_formatter();
    var { IAST_ENABLED_TAG_KEY, IAST_JSON_TAG_KEY } = require_tags4();
    var { keepTrace } = require_priority_sampler();
    var { reportStackTrace, getCallsiteFrames, canReportStackTrace, STACK_TRACE_NAMESPACES } = require_stack_trace2();
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter();
    var { ASM } = require_product();
    var VULNERABILITIES_KEY = "vulnerabilities";
    var VULNERABILITY_HASHES_MAX_SIZE = 1e3;
    var VULNERABILITY_HASHES = new LRUCache({ max: VULNERABILITY_HASHES_MAX_SIZE });
    var RESET_VULNERABILITY_CACHE_INTERVAL = 60 * 60 * 1e3;
    var tracer2;
    var resetVulnerabilityCacheTimer;
    var deduplicationEnabled = true;
    var stackTraceEnabled = true;
    var stackTraceMaxDepth;
    var maxStackTraces;
    function canAddVulnerability(vulnerability) {
      const hasRequiredFields = vulnerability?.evidence && vulnerability?.type && vulnerability?.location;
      if (!hasRequiredFields) return false;
      const isDuplicated = deduplicationEnabled && isDuplicatedVulnerability(vulnerability);
      return !isDuplicated;
    }
    function addVulnerability(iastContext, vulnerability, callSiteFrames) {
      if (!canAddVulnerability(vulnerability)) return;
      VULNERABILITY_HASHES.set(`${vulnerability.type}${vulnerability.hash}`, true);
      let span = iastContext?.rootSpan;
      if (!span && tracer2) {
        span = tracer2.startSpan("vulnerability", {
          type: "vulnerability"
        });
        vulnerability.location.spanId = span.context().toSpanId();
        span.addTags({
          [IAST_ENABLED_TAG_KEY]: 1
        });
      }
      if (!span) return;
      keepTrace(span, ASM);
      if (stackTraceEnabled && canReportStackTrace(span, maxStackTraces, STACK_TRACE_NAMESPACES.IAST)) {
        const originalCallSiteList = callSiteFrames.map((callsite) => replaceCallSiteFromSourceMap(callsite));
        reportStackTrace(
          span,
          vulnerability.location.stackId,
          originalCallSiteList,
          STACK_TRACE_NAMESPACES.IAST
        );
      }
      if (iastContext?.rootSpan) {
        iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || [];
        iastContext[VULNERABILITIES_KEY].push(vulnerability);
      } else {
        sendVulnerabilities([vulnerability], span);
        span.finish();
      }
    }
    function isValidVulnerability(vulnerability) {
      return vulnerability && vulnerability.type && vulnerability.evidence && vulnerability.location && vulnerability.location.spanId;
    }
    function sendVulnerabilities(vulnerabilities, span) {
      if (vulnerabilities?.length && span?.addTags) {
        const validatedVulnerabilities = vulnerabilities.filter(isValidVulnerability);
        const jsonToSend = vulnerabilitiesFormatter.toJson(validatedVulnerabilities);
        if (jsonToSend.vulnerabilities.length > 0) {
          const tags = {};
          tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend);
          span.addTags(tags);
        }
      }
      return IAST_JSON_TAG_KEY;
    }
    function clearCache() {
      VULNERABILITY_HASHES.clear();
    }
    function startClearCacheTimer() {
      resetVulnerabilityCacheTimer = setInterval(clearCache, RESET_VULNERABILITY_CACHE_INTERVAL);
      resetVulnerabilityCacheTimer.unref();
    }
    function stopClearCacheTimer() {
      if (resetVulnerabilityCacheTimer) {
        clearInterval(resetVulnerabilityCacheTimer);
        resetVulnerabilityCacheTimer = null;
      }
    }
    function isDuplicatedVulnerability(vulnerability) {
      return VULNERABILITY_HASHES.get(`${vulnerability.type}${vulnerability.hash}`);
    }
    function getVulnerabilityCallSiteFrames() {
      return getCallsiteFrames(stackTraceMaxDepth, getVulnerabilityCallSiteFrames);
    }
    function replaceCallSiteFromSourceMap(callsite) {
      if (callsite) {
        const { path, line, column } = getOriginalPathAndLineFromSourceMap(callsite);
        if (path) {
          callsite.file = path;
          callsite.path = path;
        }
        if (line) {
          callsite.line = line;
        }
        if (column) {
          callsite.column = column;
        }
      }
      return callsite;
    }
    function start(config, _tracer) {
      deduplicationEnabled = config.iast.deduplicationEnabled;
      stackTraceEnabled = config.iast.stackTrace.enabled;
      stackTraceMaxDepth = config.appsec.stackTrace.maxDepth;
      maxStackTraces = config.appsec.stackTrace.maxStackTraces;
      vulnerabilitiesFormatter.setRedactVulnerabilities(
        config.iast.redactionEnabled,
        config.iast.redactionNamePattern,
        config.iast.redactionValuePattern
      );
      if (deduplicationEnabled) {
        startClearCacheTimer();
      }
      tracer2 = _tracer;
    }
    function stop() {
      stopClearCacheTimer();
    }
    module2.exports = {
      addVulnerability,
      sendVulnerabilities,
      getVulnerabilityCallSiteFrames,
      replaceCallSiteFromSourceMap,
      clearCache,
      start,
      stop
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/path-line.js
var require_path_line = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/path-line.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var process2 = __require("process");
    var { ddBasePath } = require_util();
    var { getOriginalPathAndLineFromSourceMap } = require_rewriter();
    var pathLine = {
      getNodeModulesPaths,
      getRelativePath,
      getNonDDCallSiteFrames,
      ddBasePath
      // Exported only for test purposes
    };
    var EXCLUDED_PATHS = [
      path.join(path.sep, "node_modules", "dc-polyfill")
    ];
    var EXCLUDED_PATH_PREFIXES = [
      "node:diagnostics_channel",
      "diagnostics_channel",
      "node:child_process",
      "child_process",
      "node:async_hooks",
      "async_hooks"
    ];
    function getNonDDCallSiteFrames(callSiteFrames, externallyExcludedPaths) {
      if (!callSiteFrames) {
        return [];
      }
      const result = [];
      for (const callsite of callSiteFrames) {
        let filepath = callsite.file;
        if (globalThis.__DD_ESBUILD_IAST_WITH_SM) {
          const callsiteLocation = {
            path: getRelativePath(filepath),
            line: callsite.line,
            column: callsite.column
          };
          const { path: originalPath, line, column } = getOriginalPathAndLineFromSourceMap(callsiteLocation);
          callsite.path = filepath = originalPath;
          callsite.line = line;
          callsite.column = column;
        }
        if (!isExcluded(callsite, externallyExcludedPaths) && (!filepath.includes(pathLine.ddBasePath) || globalThis.__DD_ESBUILD_IAST_WITH_NO_SM)) {
          callsite.path = getRelativePath(filepath);
          callsite.isInternal = !path.isAbsolute(filepath);
          result.push(callsite);
        }
      }
      return result;
    }
    function getRelativePath(filepath) {
      return filepath && path.relative(process2.cwd(), filepath);
    }
    function isExcluded(callsite, externallyExcludedPaths) {
      if (callsite.isNative) return true;
      const filename = globalThis.__DD_ESBUILD_IAST_WITH_SM ? callsite.path : callsite.file;
      if (!filename) {
        return true;
      }
      let excludedPaths = EXCLUDED_PATHS;
      if (externallyExcludedPaths) {
        excludedPaths = [...excludedPaths, ...externallyExcludedPaths];
      }
      for (const excludedPath of excludedPaths) {
        if (filename.includes(excludedPath)) {
          return true;
        }
      }
      for (const EXCLUDED_PATH_PREFIX of EXCLUDED_PATH_PREFIXES) {
        if (filename.indexOf(EXCLUDED_PATH_PREFIX) === 0) {
          return true;
        }
      }
      return false;
    }
    function getNodeModulesPaths(...paths) {
      const nodeModulesPaths = [];
      paths.forEach((p) => {
        const pathParts = p.split("/");
        nodeModulesPaths.push(path.join("node_modules", ...pathParts));
      });
      return nodeModulesPaths;
    }
    module2.exports = pathLine;
  }
});

// ../../packages/dd-trace/src/appsec/iast/iast-context.js
var require_iast_context = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/iast-context.js"(exports2, module2) {
    "use strict";
    var IAST_CONTEXT_KEY = Symbol("_dd.iast.context");
    var IAST_TRANSACTION_ID = Symbol("_dd.iast.transactionId");
    function getIastContext(store, topContext) {
      let iastContext = store && store[IAST_CONTEXT_KEY];
      if (!iastContext) {
        iastContext = topContext && topContext[IAST_CONTEXT_KEY];
      }
      return iastContext;
    }
    function getIastStackTraceId(iastContext) {
      if (!iastContext) return "0";
      if (!iastContext.stackTraceId) {
        iastContext.stackTraceId = 0;
      }
      iastContext.stackTraceId += 1;
      return String(iastContext.stackTraceId);
    }
    function saveIastContext(store, topContext, context2) {
      if (store && topContext) {
        store[IAST_CONTEXT_KEY] = context2;
        topContext[IAST_CONTEXT_KEY] = context2;
        return store[IAST_CONTEXT_KEY];
      }
    }
    function cleanIastContext(store, context2, iastContext) {
      if (store) {
        if (!iastContext) {
          iastContext = store[IAST_CONTEXT_KEY];
        }
        store[IAST_CONTEXT_KEY] = null;
      }
      if (context2) {
        if (!iastContext) {
          iastContext = context2[IAST_CONTEXT_KEY];
        }
        context2[IAST_CONTEXT_KEY] = null;
      }
      if (iastContext) {
        if (typeof iastContext === "object") {
          Object.keys(iastContext).forEach((key) => delete iastContext[key]);
        }
        return true;
      }
      return false;
    }
    module2.exports = {
      getIastContext,
      saveIastContext,
      cleanIastContext,
      getIastStackTraceId,
      IAST_CONTEXT_KEY,
      IAST_TRANSACTION_ID
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/overhead-controller.js
var require_overhead_controller = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/overhead-controller.js"(exports2, module2) {
    "use strict";
    var { LRUCache } = require_commonjs();
    var web = require_web3();
    var vulnerabilities = require_vulnerabilities();
    var OVERHEAD_CONTROLLER_CONTEXT_KEY = "oce";
    var REPORT_VULNERABILITY = "REPORT_VULNERABILITY";
    var INTERVAL_RESET_GLOBAL_CONTEXT = 60 * 1e3;
    var GLOBAL_OCE_CONTEXT = {};
    var resetGlobalContextInterval;
    var config = {};
    var availableRequest = 0;
    var globalRouteMap = new LRUCache({ max: 4096 });
    var vulnerabilitiesSize = 0;
    var vulnerabilityIndexes = Object.values(vulnerabilities).reduce((obj, item, index) => {
      obj[item] = index;
      vulnerabilitiesSize++;
      return obj;
    }, {});
    function newCountersArray() {
      return new Array(vulnerabilitiesSize).fill(0);
    }
    function copyFromGlobalMap(route) {
      const vulnerabilityCounters = globalRouteMap.get(route);
      return vulnerabilityCounters ? [...vulnerabilityCounters] : newCountersArray();
    }
    function clearGlobalRouteMap() {
      globalRouteMap.clear();
    }
    var OPERATIONS = {
      REPORT_VULNERABILITY: {
        hasQuota: (context2, vulnerabilityType) => {
          const reserved = context2?.tokens?.[REPORT_VULNERABILITY] > 0;
          if (reserved && context2.route != null) {
            let copyMap = context2.copyMap;
            let localMap = context2.localMap;
            if (context2.loadedRoute !== context2.route) {
              context2.copyMaps ??= {};
              context2.copyMaps[context2.route] ??= copyFromGlobalMap(context2.route);
              context2.localMaps ??= {};
              context2.localMaps[context2.route] ??= newCountersArray();
              context2.loadedRoute = context2.route;
              copyMap = context2.copyMaps[context2.route];
              localMap = context2.localMaps[context2.route];
              context2.copyMap = copyMap;
              context2.localMap = localMap;
            }
            const vulnerabilityIndex = vulnerabilityIndexes[vulnerabilityType];
            const counter = localMap[vulnerabilityIndex]++;
            const storedCounter = copyMap[vulnerabilityIndex];
            if (counter < storedCounter) {
              return false;
            }
          }
          if (reserved) {
            context2.tokens[REPORT_VULNERABILITY]--;
          }
          return reserved;
        },
        name: REPORT_VULNERABILITY,
        initialTokenBucketSize() {
          return typeof config.maxContextOperations === "number" ? config.maxContextOperations : 2;
        },
        initContext: function(context2) {
          context2.tokens[REPORT_VULNERABILITY] = this.initialTokenBucketSize();
        }
      }
    };
    function _getNewContext() {
      const oceContext = {
        tokens: {}
      };
      for (const operation in OPERATIONS) {
        OPERATIONS[operation].initContext(oceContext);
      }
      return oceContext;
    }
    function _getContext(iastContext) {
      if (iastContext?.[OVERHEAD_CONTROLLER_CONTEXT_KEY]) {
        const oceContext = iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY];
        if (!oceContext.webContext) {
          oceContext.webContext = web.getContext(iastContext.req);
          oceContext.method = iastContext.req?.method;
        }
        const currentPaths = oceContext.webContext?.paths;
        if (currentPaths !== oceContext.paths || !oceContext.route) {
          oceContext.paths = currentPaths;
          oceContext.route = "#" + oceContext.method + "#" + (currentPaths?.join("") || "");
        }
        return iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY];
      }
      return GLOBAL_OCE_CONTEXT;
    }
    function consolidateVulnerabilities(iastContext) {
      const context2 = _getContext(iastContext);
      if (!context2.localMaps) return;
      const reserved = context2.tokens?.[REPORT_VULNERABILITY] > 0;
      if (reserved) {
        Object.keys(context2.localMaps).forEach((route) => {
          globalRouteMap.set(route, newCountersArray());
        });
      } else {
        Object.keys(context2.localMaps).forEach((route) => {
          const localMap = context2.localMaps[route];
          const globalMap = globalRouteMap.get(route);
          if (!globalMap) {
            globalRouteMap.set(route, localMap);
            return;
          }
          for (let i = 0; i < vulnerabilitiesSize; i++) {
            if (localMap[i] > globalMap[i]) {
              globalMap[i] = localMap[i];
            }
          }
        });
      }
    }
    function _resetGlobalContext() {
      Object.assign(GLOBAL_OCE_CONTEXT, _getNewContext());
    }
    function acquireRequest(rootSpan) {
      if (availableRequest > 0 && rootSpan) {
        const sampling = config && typeof config.requestSampling === "number" ? config.requestSampling : 30;
        if (rootSpan.context().toSpanId().slice(-2) <= sampling) {
          availableRequest--;
          return true;
        }
      }
      return false;
    }
    function releaseRequest() {
      if (availableRequest < config.maxConcurrentRequests) {
        availableRequest++;
      }
    }
    function hasQuota(operation, iastContext, vulnerabilityType) {
      const oceContext = _getContext(iastContext);
      return operation.hasQuota(oceContext, vulnerabilityType);
    }
    function initializeRequestContext(iastContext) {
      if (iastContext) iastContext[OVERHEAD_CONTROLLER_CONTEXT_KEY] = _getNewContext();
    }
    function configure(cfg) {
      config = cfg;
      availableRequest = config.maxConcurrentRequests;
    }
    function startGlobalContext() {
      if (resetGlobalContextInterval) return;
      _resetGlobalContext();
      resetGlobalContextInterval = setInterval(() => {
        _resetGlobalContext();
      }, INTERVAL_RESET_GLOBAL_CONTEXT);
      resetGlobalContextInterval.unref?.();
    }
    function finishGlobalContext() {
      if (resetGlobalContextInterval) {
        clearInterval(resetGlobalContextInterval);
        resetGlobalContextInterval = null;
      }
    }
    module2.exports = {
      OVERHEAD_CONTROLLER_CONTEXT_KEY,
      OPERATIONS,
      startGlobalContext,
      finishGlobalContext,
      _resetGlobalContext,
      initializeRequestContext,
      hasQuota,
      acquireRequest,
      releaseRequest,
      configure,
      consolidateVulnerabilities,
      clearGlobalRouteMap
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/iast-plugin.js
var require_iast_plugin = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/iast-plugin.js"(exports2, module2) {
    "use strict";
    var { channel } = require_dc_polyfill();
    var Plugin = require_plugin();
    var iastTelemetry = require_telemetry7();
    var { getInstrumentedMetric, getExecutedMetric, TagKey, EXECUTED_SOURCE, formatTags } = require_iast_metric();
    var { storage } = require_datadog_core();
    var { getIastContext } = require_iast_context();
    var instrumentations = require_instrumentations();
    var log = require_log2();
    var IastPluginSubscription = class {
      constructor(moduleName2, channelName, tagValues, tagKey = TagKey.VULNERABILITY_TYPE) {
        this.moduleName = moduleName2;
        this.channelName = channelName;
        tagValues = Array.isArray(tagValues) ? tagValues : [tagValues];
        this.tags = formatTags(tagValues, tagKey);
        this.executedMetric = getExecutedMetric(tagKey);
        this.instrumentedMetric = getInstrumentedMetric(tagKey);
        this.moduleInstrumented = false;
      }
      increaseInstrumented() {
        if (!this.moduleInstrumented) {
          this.moduleInstrumented = true;
          this.tags.forEach((tag) => this.instrumentedMetric.inc(void 0, tag));
        }
      }
      increaseExecuted(iastContext) {
        this.tags.forEach((tag) => this.executedMetric.inc(iastContext, tag));
      }
      matchesModuleInstrumented(name) {
        if (name.startsWith("node:")) {
          name = name.slice(5);
        }
        name = name === "https" ? "http" : name;
        return this.moduleName === name;
      }
    };
    var IastPlugin = class extends Plugin {
      constructor() {
        super();
        this.configured = false;
        this.pluginSubs = [];
      }
      _getTelemetryHandler(iastSub) {
        return () => {
          const iastContext = getIastContext(storage("legacy").getStore());
          iastSub.increaseExecuted(iastContext);
        };
      }
      _execHandlerAndIncMetric({ handler, metric, tags, iastContext = getIastContext(storage("legacy").getStore()) }) {
        try {
          const result = handler();
          if (iastTelemetry.isEnabled()) {
            if (Array.isArray(tags)) {
              tags.forEach((tag) => metric.inc(iastContext, tag));
            } else {
              metric.inc(iastContext, tags);
            }
          }
          return result;
        } catch (e) {
          log.error("[ASM] Error executing handler or increasing metrics", e);
        }
      }
      addSub(iastSub, handler) {
        if (typeof iastSub === "string") {
          super.addSub(iastSub, handler);
        } else {
          iastSub = this._getAndRegisterSubscription(iastSub);
          if (iastSub) {
            super.addSub(iastSub.channelName, handler);
            if (iastTelemetry.isEnabled()) {
              super.addSub(iastSub.channelName, this._getTelemetryHandler(iastSub));
            }
          }
        }
      }
      enable(iastConfig) {
        this.iastConfig = iastConfig;
        this.configure(true);
      }
      disable() {
        this.configure(false);
      }
      onConfigure() {
      }
      configure(config) {
        if (typeof config !== "object") {
          config = { enabled: config };
        }
        if (config.enabled && !this.configured) {
          this.onConfigure();
          this.configured = true;
        }
        if (iastTelemetry.isEnabled()) {
          if (config.enabled) {
            this.enableTelemetry();
          } else {
            this.disableTelemetry();
          }
        }
        super.configure(config);
      }
      _getAndRegisterSubscription({ moduleName: moduleName2, channelName, tag, tagKey }) {
        if (!moduleName2) {
          if (!channelName) return;
          let firstSep = channelName.indexOf(":");
          if (firstSep === -1) {
            moduleName2 = channelName;
          } else {
            if (channelName.startsWith("tracing:")) {
              firstSep = channelName.indexOf(":", "tracing:".length + 1);
            }
            const lastSep = channelName.indexOf(":", firstSep + 1);
            moduleName2 = channelName.slice(firstSep + 1, lastSep === -1 ? channelName.length : lastSep);
          }
        }
        const iastSub = new IastPluginSubscription(moduleName2, channelName, tag, tagKey);
        this.pluginSubs.push(iastSub);
        return iastSub;
      }
      enableTelemetry() {
        if (this.onInstrumentationLoadedListener) return;
        this.onInstrumentationLoadedListener = ({ name }) => this._onInstrumentationLoaded(name);
        const loadChannel = channel("dd-trace:instrumentation:load");
        loadChannel.subscribe(this.onInstrumentationLoadedListener);
        for (const name in instrumentations) {
          this._onInstrumentationLoaded(name);
        }
      }
      disableTelemetry() {
        if (!this.onInstrumentationLoadedListener) return;
        const loadChannel = channel("dd-trace:instrumentation:load");
        if (loadChannel.hasSubscribers) {
          loadChannel.unsubscribe(this.onInstrumentationLoadedListener);
        }
        this.onInstrumentationLoadedListener = null;
      }
      _onInstrumentationLoaded(name) {
        this.pluginSubs.filter((sub) => sub.matchesModuleInstrumented(name)).forEach((sub) => sub.increaseInstrumented());
      }
    };
    var SourceIastPlugin = class extends IastPlugin {
      addSub(iastPluginSub, handler) {
        return super.addSub({ tagKey: TagKey.SOURCE_TYPE, ...iastPluginSub }, handler);
      }
      addInstrumentedSource(moduleName2, tag) {
        this._getAndRegisterSubscription({
          moduleName: moduleName2,
          tag,
          tagKey: TagKey.SOURCE_TYPE
        });
      }
      execSource(sourceHandlerInfo) {
        this._execHandlerAndIncMetric({
          metric: EXECUTED_SOURCE,
          ...sourceHandlerInfo
        });
      }
    };
    var SinkIastPlugin = class extends IastPlugin {
      addSub(iastPluginSub, handler) {
        return super.addSub({ tagKey: TagKey.VULNERABILITY_TYPE, ...iastPluginSub }, handler);
      }
      addNotSinkSub(iastPluginSub, handler) {
        return super.addSub(iastPluginSub, handler);
      }
    };
    module2.exports = {
      SourceIastPlugin,
      SinkIastPlugin,
      IastPlugin
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks-generator.js
var require_secure_marks_generator = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks-generator.js"(exports2, module2) {
    "use strict";
    var next = 0;
    function getNextSecureMark() {
      return 1 << next++ >>> 0;
    }
    function reset() {
      next = 0;
    }
    module2.exports = { getNextSecureMark, reset };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks.js
var require_secure_marks = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/secure-marks.js"(exports2, module2) {
    "use strict";
    var vulnerabilities = require_vulnerabilities();
    var { getNextSecureMark } = require_secure_marks_generator();
    var marks = {};
    Object.keys(vulnerabilities).forEach((vulnerability) => {
      marks[vulnerability + "_MARK"] = getNextSecureMark();
    });
    var asterisk = 0;
    Object.values(marks).forEach((mark) => {
      asterisk |= mark;
    });
    marks.ASTERISK_MARK = asterisk;
    marks.CUSTOM_SECURE_MARK = getNextSecureMark();
    function getMarkFromVulnerabilityType(vulnerabilityType) {
      vulnerabilityType = vulnerabilityType?.trim();
      const mark = vulnerabilityType === "*" ? "ASTERISK_MARK" : vulnerabilityType + "_MARK";
      return marks[mark];
    }
    module2.exports = {
      ...marks,
      getMarkFromVulnerabilityType,
      ALL: marks
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js
var require_vulnerability_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/vulnerability-analyzer.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var { getNonDDCallSiteFrames } = require_path_line();
    var { getIastContext, getIastStackTraceId } = require_iast_context();
    var overheadController = require_overhead_controller();
    var { SinkIastPlugin } = require_iast_plugin();
    var {
      addVulnerability,
      getVulnerabilityCallSiteFrames,
      replaceCallSiteFromSourceMap
    } = require_vulnerability_reporter();
    var { getMarkFromVulnerabilityType } = require_secure_marks();
    var { SUPPRESSED_VULNERABILITIES } = require_iast_metric();
    var Analyzer = class extends SinkIastPlugin {
      constructor(type) {
        super();
        this._type = type;
        this._secureMark = getMarkFromVulnerabilityType(type);
      }
      _isVulnerable(value, context2) {
        return false;
      }
      _isExcluded(location) {
        return false;
      }
      _report(value, context2, meta) {
        const evidence = this._getEvidence(value, context2, meta);
        this._reportEvidence(value, context2, evidence);
      }
      _reportEvidence(value, context2, evidence) {
        const callSiteFrames = getVulnerabilityCallSiteFrames();
        const nonDDCallSiteFrames = getNonDDCallSiteFrames(callSiteFrames, this._getExcludedPaths());
        const location = this._getLocation(value, nonDDCallSiteFrames);
        if (!this._isExcluded(location)) {
          const originalLocation = this._getOriginalLocation(location);
          const spanId = context2?.rootSpan?.context().toSpanId();
          const stackId = getIastStackTraceId(context2);
          const vulnerability = this._createVulnerability(
            this._type,
            evidence,
            spanId,
            originalLocation,
            stackId
          );
          addVulnerability(context2, vulnerability, nonDDCallSiteFrames);
        }
      }
      _reportIfVulnerable(value, context2, meta) {
        if (this._isVulnerable(value, context2) && this._checkOCE(context2, value)) {
          this._report(value, context2, meta);
          return true;
        }
        return false;
      }
      _getEvidence(value) {
        return { value };
      }
      _getLocation(value, callSiteFrames) {
        return callSiteFrames[0];
      }
      _getOriginalLocation(location) {
        const locationFromSourceMap = replaceCallSiteFromSourceMap(location);
        const originalLocation = {};
        if (locationFromSourceMap?.path) {
          originalLocation.path = locationFromSourceMap.path;
        }
        if (locationFromSourceMap?.line) {
          originalLocation.line = locationFromSourceMap.line;
        }
        if (location?.class_name) {
          originalLocation.class = location.class_name;
        }
        if (location?.function) {
          originalLocation.method = location.function;
        }
        return originalLocation;
      }
      _getExcludedPaths() {
      }
      _isInvalidContext(store, iastContext) {
        return store && !iastContext;
      }
      analyze(value, store = storage("legacy").getStore(), meta) {
        const iastContext = getIastContext(store);
        if (this._isInvalidContext(store, iastContext)) return;
        this._reportIfVulnerable(value, iastContext, meta);
      }
      analyzeAll(...values) {
        const store = storage("legacy").getStore();
        const iastContext = getIastContext(store);
        if (this._isInvalidContext(store, iastContext)) return;
        for (const value of values) {
          if (this._isVulnerable(value, iastContext)) {
            if (this._checkOCE(iastContext, value)) {
              this._report(value, iastContext);
            }
            break;
          }
        }
      }
      _checkOCE(context2) {
        return overheadController.hasQuota(overheadController.OPERATIONS.REPORT_VULNERABILITY, context2, this._type);
      }
      _createVulnerability(type, evidence, spanId, location, stackId) {
        if (type && evidence) {
          const _spanId = spanId || 0;
          return {
            type,
            evidence,
            location: {
              spanId: _spanId,
              stackId,
              ...location
            },
            hash: this._createHash(this._createHashSource(type, evidence, location))
          };
        }
        return null;
      }
      _createHashSource(type, evidence, location) {
        return location ? `${type}:${location.path}:${location.line}` : type;
      }
      _createHash(hashSource) {
        let hash = 0;
        let offset = 0;
        const size = hashSource.length;
        for (let i = 0; i < size; i++) {
          hash = (hash << 5) - hash + hashSource.charCodeAt(offset++);
        }
        return hash;
      }
      _getSuppressedMetricTag() {
        if (!this._suppressedMetricTag) {
          this._suppressedMetricTag = SUPPRESSED_VULNERABILITIES.formatTags(this._type)[0];
        }
        return this._suppressedMetricTag;
      }
      _incrementSuppressedMetric(iastContext) {
        SUPPRESSED_VULNERABILITIES.inc(iastContext, this._getSuppressedMetricTag());
      }
      addSub(iastSubOrChannelName, handler) {
        const iastSub = typeof iastSubOrChannelName === "string" ? { channelName: iastSubOrChannelName } : iastSubOrChannelName;
        super.addSub({ tag: this._type, ...iastSub }, handler);
      }
    };
    module2.exports = Analyzer;
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/source-types.js
var require_source_types = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/source-types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      HTTP_REQUEST_BODY: "http.request.body",
      HTTP_REQUEST_COOKIE_VALUE: "http.request.cookie.value",
      HTTP_REQUEST_COOKIE_NAME: "http.request.cookie.name",
      HTTP_REQUEST_HEADER_NAME: "http.request.header.name",
      HTTP_REQUEST_HEADER_VALUE: "http.request.header",
      HTTP_REQUEST_PARAMETER: "http.request.parameter",
      HTTP_REQUEST_PATH_PARAM: "http.request.path.parameter",
      HTTP_REQUEST_URI: "http.request.uri",
      KAFKA_MESSAGE_KEY: "kafka.message.key",
      KAFKA_MESSAGE_VALUE: "kafka.message.value",
      SQL_ROW_VALUE: "sql.row.value"
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/operations-taint-object.js
var require_operations_taint_object = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/operations-taint-object.js"(exports2, module2) {
    "use strict";
    var TaintedUtils = __require("@datadog/native-iast-taint-tracking");
    var { IAST_TRANSACTION_ID } = require_iast_context();
    var { HTTP_REQUEST_PARAMETER } = require_source_types();
    var log = require_log2();
    var SEPARATOR = "\0";
    function taintObject(iastContext, object, type) {
      let result = object;
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      if (transactionId) {
        const queue = [{ parent: null, property: null, value: object }];
        const visited = /* @__PURE__ */ new WeakSet();
        while (queue.length > 0) {
          const { parent, property, value, key } = queue.pop();
          if (value === null) {
            continue;
          }
          try {
            if (typeof value === "string") {
              const tainted = TaintedUtils.newTaintedString(transactionId, value, property, type);
              if (parent) {
                parent[key] = tainted;
              } else {
                result = tainted;
              }
            } else if (
              // eslint-disable-next-line eslint-rules/eslint-safe-typeof-object
              typeof value === "object" && !visited.has(value)
            ) {
              visited.add(value);
              for (const key2 of Object.keys(value)) {
                queue.push({ parent: value, property: property ? `${property}.${key2}` : key2, value: value[key2], key: key2 });
              }
            }
          } catch (e) {
            log.error("[ASM] Error in taintObject when visiting property : %s", property, e);
          }
        }
      }
      return result;
    }
    function taintQueryWithCache(iastContext, query) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      if (!transactionId || !query) return query;
      iastContext.queryCache ??= /* @__PURE__ */ new Map();
      traverseAndTaint(query, "", iastContext.queryCache, transactionId);
      return query;
    }
    function traverseAndTaint(node, path, cache, transactionId) {
      if (node == null) return node;
      if (typeof node === "string") {
        const cachedValue = cache.get(path);
        if (cachedValue === node) {
          return cachedValue;
        }
        const tainted = TaintedUtils.newTaintedString(transactionId, node, path, HTTP_REQUEST_PARAMETER);
        cache.set(path, tainted);
        return tainted;
      }
      if (typeof node === "object") {
        const keys = Array.isArray(node) ? node.keys() : Object.keys(node);
        for (const key of keys) {
          const childPath = path ? `${path}${SEPARATOR}${key}` : String(key);
          const tainted = traverseAndTaint(node[key], childPath, cache, transactionId);
          node[key] = tainted;
        }
      }
      return node;
    }
    module2.exports = {
      taintObject,
      taintQueryWithCache
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js
var require_taint_tracking_impl = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/taint-tracking-impl.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var TaintedUtils = __require("@datadog/native-iast-taint-tracking");
    var { storage } = require_datadog_core();
    var iastContextFunctions = require_iast_context();
    var { EXECUTED_PROPAGATION } = require_iast_metric();
    var { isDebugAllowed } = require_verbosity();
    var { taintObject } = require_operations_taint_object();
    var log = require_log2();
    var mathRandomCallCh = dc.channel("datadog:random:call");
    var evalCallCh = dc.channel("datadog:eval:call");
    var JSON_VALUE = "json.value";
    function noop(res) {
      return res;
    }
    var TaintTrackingNoop = {
      concat: noop,
      eval: noop,
      join: noop,
      parse: noop,
      plusOperator: noop,
      random: noop,
      replace: noop,
      slice: noop,
      substr: noop,
      substring: noop,
      stringCase: noop,
      tplOperator: noop,
      trim: noop,
      trimEnd: noop
    };
    function getTransactionId(iastContext) {
      return iastContext?.[iastContextFunctions.IAST_TRANSACTION_ID];
    }
    function getContextDefault() {
      const store = storage("legacy").getStore();
      return iastContextFunctions.getIastContext(store);
    }
    function getContextDebug() {
      const iastContext = getContextDefault();
      EXECUTED_PROPAGATION.inc(iastContext);
      return iastContext;
    }
    function getFilteredCsiFn(cb, filter, getContext) {
      return function csiCall(res, fn, target, ...rest) {
        try {
          if (filter(res, fn, target)) {
            return res;
          }
          const context2 = getContext();
          const transactionId = getTransactionId(context2);
          if (transactionId) {
            return cb(transactionId, res, target, ...rest);
          }
        } catch (e) {
          log.error("[ASM] Error invoking CSI %s", target, e);
        }
        return res;
      };
    }
    function notString() {
      return Array.prototype.some.call(arguments, (p) => typeof p !== "string");
    }
    function isValidCsiMethod(fn, protos) {
      return protos.includes(fn);
    }
    function getCsiFn(cb, getContext, ...protos) {
      let filter;
      if (!protos || protos.length === 0) {
        filter = (res, fn, target) => notString(res, target);
      } else if (protos.length === 1) {
        const protoFn = protos[0];
        filter = (res, fn, target) => notString(res, target) || fn !== protoFn;
      } else {
        filter = (res, fn, target) => notString(res, target) || !isValidCsiMethod(fn, protos);
      }
      return getFilteredCsiFn(cb, filter, getContext);
    }
    function csiMethodsDefaults(names, excluded, getContext) {
      const impl = {};
      names.forEach((name) => {
        if (excluded.includes(name)) return;
        impl[name] = getCsiFn(
          (transactionId, res, target, ...rest) => TaintedUtils[name](transactionId, res, target, ...rest),
          getContext,
          String.prototype[name]
        );
      });
      return impl;
    }
    function csiMethodsOverrides(getContext) {
      return {
        plusOperator: function(res, op1, op2) {
          try {
            if (notString(res) || notString(op1) && notString(op2)) {
              return res;
            }
            const iastContext = getContext();
            const transactionId = getTransactionId(iastContext);
            if (transactionId) {
              return TaintedUtils.concat(transactionId, res, op1, op2);
            }
          } catch (e) {
            log.error("[ASM] Error invoking CSI plusOperator", e);
          }
          return res;
        },
        tplOperator: function(res, ...rest) {
          try {
            const iastContext = getContext();
            const transactionId = getTransactionId(iastContext);
            if (transactionId) {
              return TaintedUtils.concat(transactionId, res, ...rest);
            }
          } catch (e) {
            log.error("[ASM] Error invoking CSI tplOperator", e);
          }
          return res;
        },
        stringCase: getCsiFn(
          (transactionId, res, target) => TaintedUtils.stringCase(transactionId, res, target),
          getContext,
          String.prototype.toLowerCase,
          String.prototype.toUpperCase
        ),
        trim: getCsiFn(
          (transactionId, res, target) => TaintedUtils.trim(transactionId, res, target),
          getContext,
          String.prototype.trim,
          String.prototype.trimStart
        ),
        random: function(res, fn) {
          if (mathRandomCallCh.hasSubscribers) {
            mathRandomCallCh.publish({ fn });
          }
          return res;
        },
        eval: function(res, fn, target, script) {
          if (evalCallCh.hasSubscribers && fn === globalThis.eval) {
            evalCallCh.publish({ script });
          }
          return res;
        },
        parse: function(res, fn, target, json) {
          if (fn === JSON.parse) {
            try {
              const iastContext = getContext();
              const transactionId = getTransactionId(iastContext);
              if (transactionId) {
                const ranges = TaintedUtils.getRanges(transactionId, json);
                if (ranges?.length > 0) {
                  const range = ranges.find((range2) => range2.iinfo?.type);
                  res = taintObject(iastContext, res, range?.iinfo.type || JSON_VALUE);
                }
              }
            } catch (e) {
              log.error("[ASM] Error invoking CSI JSON.parse", e);
            }
          }
          return res;
        },
        join: function(res, fn, target, separator) {
          if (fn === Array.prototype.join) {
            try {
              const iastContext = getContext();
              const transactionId = getTransactionId(iastContext);
              if (transactionId) {
                res = TaintedUtils.arrayJoin(transactionId, res, target, separator);
              }
            } catch (e) {
              log.error("[ASM] Error invoking CSI join", e);
            }
          }
          return res;
        }
      };
    }
    function createImplWith(getContext) {
      const methodNames = Object.keys(TaintTrackingNoop);
      const overrides = csiMethodsOverrides(getContext);
      return {
        ...csiMethodsDefaults(methodNames, Object.keys(overrides), getContext),
        ...overrides
      };
    }
    function getTaintTrackingImpl(telemetryVerbosity, dummy = false) {
      if (dummy) return TaintTrackingNoop;
      return isDebugAllowed(telemetryVerbosity) ? createImplWith(getContextDebug) : createImplWith(getContextDefault);
    }
    function getTaintTrackingNoop() {
      return getTaintTrackingImpl(null, true);
    }
    var lodashFns = {
      join: TaintedUtils.arrayJoin,
      toLower: TaintedUtils.stringCase,
      toUpper: TaintedUtils.stringCase,
      trim: TaintedUtils.trim,
      trimEnd: TaintedUtils.trimEnd,
      trimStart: TaintedUtils.trim
    };
    function getLodashTaintedUtilFn(lodashFn) {
      return lodashFns[lodashFn] || ((transactionId, result) => result);
    }
    function lodashTaintTrackingHandler(message) {
      try {
        if (!message.result) return;
        const context2 = getContextDefault();
        const transactionId = getTransactionId(context2);
        if (transactionId) {
          message.result = getLodashTaintedUtilFn(message.operation)(transactionId, message.result, ...message.arguments);
        }
      } catch (e) {
        log.error("[ASM] Error invoking CSI lodash %s", message.operation, e);
      }
    }
    module2.exports = {
      getTaintTrackingImpl,
      getTaintTrackingNoop,
      lodashTaintTrackingHandler
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/operations.js
var require_operations = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/operations.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var TaintedUtils = __require("@datadog/native-iast-taint-tracking");
    var { IAST_TRANSACTION_ID } = require_iast_context();
    var iastTelemetry = require_telemetry7();
    var { REQUEST_TAINTED } = require_iast_metric();
    var { isInfoAllowed } = require_verbosity();
    var {
      getTaintTrackingImpl,
      getTaintTrackingNoop,
      lodashTaintTrackingHandler
    } = require_taint_tracking_impl();
    var { taintObject, taintQueryWithCache } = require_operations_taint_object();
    var lodashOperationCh = dc.channel("datadog:lodash:operation");
    function createTransaction(id, iastContext) {
      if (id && iastContext) {
        iastContext[IAST_TRANSACTION_ID] = TaintedUtils.createTransaction(id);
      }
    }
    var onRemoveTransaction = (transactionId, iastContext) => {
    };
    function onRemoveTransactionInformationTelemetry(transactionId, iastContext) {
      const metrics2 = TaintedUtils.getMetrics(transactionId, iastTelemetry.verbosity);
      if (metrics2?.requestCount) {
        REQUEST_TAINTED.inc(iastContext, metrics2.requestCount);
      }
    }
    function removeTransaction(iastContext) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      if (transactionId) {
        onRemoveTransaction(transactionId, iastContext);
        TaintedUtils.removeTransaction(transactionId);
        delete iastContext[IAST_TRANSACTION_ID];
      }
    }
    function newTaintedString(iastContext, string, name, type) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      return transactionId ? TaintedUtils.newTaintedString(transactionId, string, name, type) : string;
    }
    function newTaintedObject(iastContext, obj, name, type) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      return transactionId ? TaintedUtils.newTaintedObject(transactionId, obj, name, type) : obj;
    }
    function isTainted(iastContext, string) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      return transactionId ? TaintedUtils.isTainted(transactionId, string) : false;
    }
    function getRanges(iastContext, string) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      return transactionId ? TaintedUtils.getRanges(transactionId, string) : [];
    }
    function addSecureMark(iastContext, string, mark, createNewTainted = true) {
      const transactionId = iastContext?.[IAST_TRANSACTION_ID];
      if (transactionId) {
        return TaintedUtils.addSecureMarksToTaintedString(transactionId, string, mark, createNewTainted);
      }
      return string;
    }
    function enableTaintOperations(telemetryVerbosity) {
      if (isInfoAllowed(telemetryVerbosity)) {
        onRemoveTransaction = onRemoveTransactionInformationTelemetry;
      }
      global._ddiast = getTaintTrackingImpl(telemetryVerbosity);
      lodashOperationCh.subscribe(lodashTaintTrackingHandler);
    }
    function disableTaintOperations() {
      global._ddiast = getTaintTrackingNoop();
      lodashOperationCh.unsubscribe(lodashTaintTrackingHandler);
    }
    function setMaxTransactions(transactions) {
      if (!transactions) {
        return;
      }
      TaintedUtils.setMaxTransactions(transactions);
    }
    module2.exports = {
      addSecureMark,
      createTransaction,
      removeTransaction,
      newTaintedString,
      newTaintedObject,
      taintObject,
      taintQueryWithCache,
      isTainted,
      getRanges,
      enableTaintOperations,
      disableTaintOperations,
      setMaxTransactions,
      IAST_TRANSACTION_ID
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js
var require_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/injection-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { getRanges } = require_operations();
    var { SQL_ROW_VALUE } = require_source_types();
    var InjectionAnalyzer = class extends Analyzer {
      _isVulnerable(value, iastContext) {
        let ranges = value && getRanges(iastContext, value);
        if (ranges?.length > 0) {
          ranges = this._filterSecureRanges(ranges, value);
          if (!ranges?.length) {
            this._incrementSuppressedMetric(iastContext);
          }
          return this._areRangesVulnerable(ranges);
        }
        return false;
      }
      _getEvidence(value, iastContext) {
        const ranges = getRanges(iastContext, value);
        return { value, ranges };
      }
      _areRangesVulnerable(ranges) {
        return ranges?.some((range) => range.iinfo.type !== SQL_ROW_VALUE);
      }
      _filterSecureRanges(ranges, value) {
        return ranges?.filter((range) => !this._isRangeSecure(range, value));
      }
      _isRangeSecure(range, _value) {
        const { secureMarks } = range;
        return (secureMarks & this._secureMark) === this._secureMark;
      }
    };
    module2.exports = InjectionAnalyzer;
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/stored-injection-analyzer.js
var require_stored_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/stored-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var StoredInjectionAnalyzer = class extends InjectionAnalyzer {
      _areRangesVulnerable(ranges) {
        return ranges?.length > 0;
      }
    };
    module2.exports = StoredInjectionAnalyzer;
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/code-injection-analyzer.js
var require_code_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/code-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var { CODE_INJECTION } = require_vulnerabilities();
    var StoredInjectionAnalyzer = require_stored_injection_analyzer();
    var { INSTRUMENTED_SINK } = require_iast_metric();
    var { storage } = require_datadog_core();
    var { getIastContext } = require_iast_context();
    var CodeInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(CODE_INJECTION);
        this.evalInstrumentedInc = false;
      }
      onConfigure() {
        this.addSub("datadog:eval:call", ({ script }) => {
          if (!this.evalInstrumentedInc) {
            const store = storage("legacy").getStore();
            const iastContext = getIastContext(store);
            const tags = INSTRUMENTED_SINK.formatTags(CODE_INJECTION);
            for (const tag of tags) {
              INSTRUMENTED_SINK.inc(iastContext, tag);
            }
            this.evalInstrumentedInc = true;
          }
          this.analyze(script);
        });
        this.addSub("datadog:vm:run-script:start", ({ code }) => this.analyze(code));
        this.addSub("datadog:vm:source-text-module:start", ({ code }) => this.analyze(code));
      }
    };
    module2.exports = new CodeInjectionAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js
var require_command_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/command-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { COMMAND_INJECTION } = require_vulnerabilities();
    var CommandInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(COMMAND_INJECTION);
      }
      onConfigure() {
        this.addSub("tracing:datadog:child_process:execution:start", ({ command }) => this.analyze(command));
      }
    };
    module2.exports = new CommandInjectionAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-base-analyzer.js
var require_hardcoded_base_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-base-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { getRelativePath } = require_path_line();
    var HardcodedBaseAnalyzer = class extends Analyzer {
      constructor(type, allRules = [], valueOnlyRules = []) {
        super(type);
        this.allRules = allRules;
        this.valueOnlyRules = valueOnlyRules;
      }
      onConfigure() {
        this.addSub("datadog:secrets:result", (secrets) => {
          this.analyze(secrets);
        });
      }
      analyze(secrets) {
        if (!secrets?.file || !secrets.literals) return;
        const { allRules, valueOnlyRules } = this;
        const matches = [];
        for (const literal of secrets.literals) {
          const { value, locations } = literal;
          if (!value || !locations) continue;
          for (const location of locations) {
            let match;
            if (location.ident) {
              const fullValue = `${location.ident}=${value}`;
              match = allRules.find((rule) => fullValue.match(rule.regex));
            } else {
              match = valueOnlyRules.find((rule) => value.match(rule.regex));
            }
            if (match) {
              matches.push({ location, ruleId: match.id });
            }
          }
        }
        if (matches.length) {
          const file = getRelativePath(secrets.file);
          matches.forEach((match) => this._report({
            file,
            line: match.location.line,
            column: match.location.column,
            ident: match.location.ident,
            data: match.ruleId
          }));
        }
      }
      _getEvidence(value) {
        return { value: `${value.data}` };
      }
      _getLocation(value) {
        return {
          path: value.file,
          line: value.line,
          column: value.column,
          isInternal: false
        };
      }
    };
    module2.exports = HardcodedBaseAnalyzer;
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-rule-type.js
var require_hardcoded_rule_type = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-rule-type.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ValueOnly: "ValueOnly",
      NameAndValue: "NameAndValue"
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-rules.js
var require_hardcoded_password_rules = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-rules.js"(exports2, module2) {
    "use strict";
    var { NameAndValue } = require_hardcoded_rule_type();
    module2.exports = [
      {
        id: "hardcoded-password",
        regex: /(?:pwd|pswd|pass|secret)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-z\-_.=]{10,150})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      }
    ];
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-analyzer.js
var require_hardcoded_password_analyzer2 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-password-analyzer.js"(exports2, module2) {
    "use strict";
    var { HARDCODED_PASSWORD } = require_vulnerabilities();
    var HardcodedBaseAnalyzer = require_hardcoded_base_analyzer();
    var allRules = require_hardcoded_password_rules();
    var HardcodedPasswordAnalyzer = class extends HardcodedBaseAnalyzer {
      constructor() {
        super(HARDCODED_PASSWORD, allRules);
      }
      _getEvidence(value) {
        return { value: `${value.ident}` };
      }
    };
    module2.exports = new HardcodedPasswordAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-rules.js
var require_hardcoded_secret_rules = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-rules.js"(exports2, module2) {
    "use strict";
    var { ValueOnly, NameAndValue } = require_hardcoded_rule_type();
    module2.exports = [
      {
        id: "adafruit-api-key",
        regex: /(?:adafruit)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "adobe-client-id",
        regex: /(?:adobe)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "adobe-client-secret",
        regex: /\b((p8e-)[a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "age-secret-key",
        regex: /AGE-SECRET-KEY-1[QPZRY9X8GF2TVDW0S3JN54KHCE6MUA7L]{58}/,
        type: ValueOnly
      },
      {
        id: "airtable-api-key",
        regex: /(?:airtable)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{17})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "algolia-api-key",
        regex: /(?:algolia)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "alibaba-access-key-id",
        regex: /\b((LTAI)[a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "asana-client-id",
        regex: /(?:asana)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "asana-client-secret",
        regex: /(?:asana)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "atlassian-api-token",
        regex: /(?:atlassian|confluence|jira)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "authress-service-client-access-key",
        regex: /\b((?:sc|ext|scauth|authress)_[a-z0-9]{5,30}\.[a-z0-9]{4,6}\.acc[_-][a-z0-9-]{10,32}\.[a-z0-9+/_=-]{30,120})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "aws-access-token",
        regex: /\b((A3T[A-Z0-9]|AKIA|AGPA|AIDA|AROA|AIPA|ANPA|ANVA|ASIA)[A-Z0-9]{16})(?:['"\s\x60;]|$)/,
        type: ValueOnly
      },
      {
        id: "beamer-api-token",
        regex: /(?:beamer)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(b_[a-z0-9=_-]{44})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "bitbucket-client-id",
        regex: /(?:bitbucket)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "bitbucket-client-secret",
        regex: /(?:bitbucket)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "bittrex-access-key",
        regex: /(?:bittrex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "clojars-api-token",
        regex: /(CLOJARS_)[a-z0-9]{60}/i,
        type: ValueOnly
      },
      {
        id: "codecov-access-token",
        regex: /(?:codecov)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "coinbase-access-token",
        regex: /(?:coinbase)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "confluent-access-token",
        regex: /(?:confluent)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "confluent-secret-key",
        regex: /(?:confluent)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "contentful-delivery-api-token",
        regex: /(?:contentful)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{43})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "databricks-api-token",
        regex: /\b(dapi[a-h0-9]{32})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "datadog-access-token",
        regex: /(?:datadog)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "defined-networking-api-token",
        regex: /(?:dnkey)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(dnkey-[a-z0-9=_-]{26}-[a-z0-9=_-]{52})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "digitalocean-access-token",
        regex: /\b(doo_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "digitalocean-pat",
        regex: /\b(dop_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "digitalocean-refresh-token",
        regex: /\b(dor_v1_[a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "discord-api-token",
        regex: /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "discord-client-id",
        regex: /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{18})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "discord-client-secret",
        regex: /(?:discord)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "doppler-api-token",
        regex: /(dp\.pt\.)[a-z0-9]{43}/i,
        type: ValueOnly
      },
      {
        id: "droneci-access-token",
        regex: /(?:droneci)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "dropbox-api-token",
        regex: /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{15})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "dropbox-long-lived-api-token",
        regex: /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{11}(AAAAAAAAAA)[a-z0-9\-_=]{43})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "dropbox-short-lived-api-token",
        regex: /(?:dropbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(sl\.[a-z0-9\-=_]{135})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "duffel-api-token",
        regex: /duffel_(test|live)_[a-z0-9_\-=]{43}/i,
        type: ValueOnly
      },
      {
        id: "dynatrace-api-token",
        regex: /dt0c01\.[a-z0-9]{24}\.[a-z0-9]{64}/i,
        type: ValueOnly
      },
      {
        id: "easypost-api-token",
        regex: /\bEZAK[a-z0-9]{54}/i,
        type: ValueOnly
      },
      {
        id: "etsy-access-token",
        regex: /(?:etsy)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "facebook",
        regex: /(?:facebook)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "fastly-api-token",
        regex: /(?:fastly)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "finicity-api-token",
        regex: /(?:finicity)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "finicity-client-secret",
        regex: /(?:finicity)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "finnhub-access-token",
        regex: /(?:finnhub)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "flickr-access-token",
        regex: /(?:flickr)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "flutterwave-public-key",
        regex: /FLWPUBK_TEST-[a-h0-9]{32}-X/i,
        type: ValueOnly
      },
      {
        id: "frameio-api-token",
        regex: /fio-u-[a-z0-9\-_=]{64}/i,
        type: ValueOnly
      },
      {
        id: "freshbooks-access-token",
        regex: /(?:freshbooks)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "gcp-api-key",
        regex: /\b(AIza[0-9a-z\-_]{35})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "github-app-token",
        regex: /(ghu|ghs)_[0-9a-zA-Z]{36}/,
        type: ValueOnly
      },
      {
        id: "github-fine-grained-pat",
        regex: /github_pat_[0-9a-zA-Z_]{82}/,
        type: ValueOnly
      },
      {
        id: "github-oauth",
        regex: /gho_[0-9a-zA-Z]{36}/,
        type: ValueOnly
      },
      {
        id: "github-pat",
        regex: /ghp_[0-9a-zA-Z]{36}/,
        type: ValueOnly
      },
      {
        id: "gitlab-pat",
        regex: /glpat-[0-9a-zA-Z\-_]{20}/,
        type: ValueOnly
      },
      {
        id: "gitlab-ptt",
        regex: /glptt-[0-9a-f]{40}/,
        type: ValueOnly
      },
      {
        id: "gitlab-rrt",
        regex: /GR1348941[0-9a-zA-Z\-_]{20}/,
        type: ValueOnly
      },
      {
        id: "gitter-access-token",
        regex: /(?:gitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "gocardless-api-token",
        regex: /(?:gocardless)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(live_[a-z0-9\-_=]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "grafana-api-key",
        regex: /\b(eyJrIjoi[a-z0-9]{70,400}={0,2})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "grafana-cloud-api-token",
        regex: /\b(glc_[a-z0-9+/]{32,400}={0,2})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "grafana-service-account-token",
        regex: /\b(glsa_[a-z0-9]{32}_[a-f0-9]{8})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "hashicorp-tf-api-token",
        regex: /[a-z0-9]{14}\.atlasv1\.[a-z0-9\-_=]{60,70}/i,
        type: ValueOnly
      },
      {
        id: "heroku-api-key",
        regex: /(?:heroku)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "hubspot-api-key",
        regex: /(?:hubspot)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "intercom-api-key",
        regex: /(?:intercom)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{60})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "jfrog-api-key",
        regex: /(?:jfrog|artifactory|bintray|xray)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{73})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "jwt",
        regex: /\b(ey[a-zA-Z0-9]{17,}\.ey[a-zA-Z0-9/_-]{17,}\.(?:[a-zA-Z0-9/_-]{10,}={0,2})?)(?:['"\s\x60;]|$)/,
        type: ValueOnly
      },
      {
        id: "kraken-access-token",
        regex: /(?:kraken)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9/=_+-]{80,90})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "kucoin-access-token",
        regex: /(?:kucoin)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "launchdarkly-access-token",
        regex: /(?:launchdarkly)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "linear-api-key",
        regex: /lin_api_[a-z0-9]{40}/i,
        type: ValueOnly
      },
      {
        id: "linkedin-client-secret",
        regex: /(?:linkedin|linked-in)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "lob-pub-api-key",
        regex: /(?:lob)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}((test|live)_pub_[a-f0-9]{31})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mailchimp-api-key",
        regex: /(?:mailchimp)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{32}-us20)(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mailgun-private-api-token",
        regex: /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(key-[a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mailgun-pub-key",
        regex: /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(pubkey-[a-f0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mailgun-signing-key",
        regex: /(?:mailgun)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-h0-9]{32}-[a-h0-9]{8}-[a-h0-9]{8})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mapbox-api-token",
        regex: /(?:mapbox)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(pk\.[a-z0-9]{60}\.[a-z0-9]{22})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "mattermost-access-token",
        regex: /(?:mattermost)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{26})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "messagebird-api-token",
        regex: /(?:messagebird|message-bird|message_bird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{25})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "netlify-access-token",
        regex: /(?:netlify)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{40,46})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "new-relic-browser-api-token",
        regex: /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(NRJS-[a-f0-9]{19})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "new-relic-user-api-id",
        regex: /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "new-relic-user-api-key",
        regex: /(?:new-relic|newrelic|new_relic)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(NRAK-[a-z0-9]{27})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "npm-access-token",
        regex: /\b(npm_[a-z0-9]{36})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "nytimes-access-token",
        regex: /(?:nytimes|new-york-times,|newyorktimes)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "okta-access-token",
        regex: /(?:okta)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9=_-]{42})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "openai-api-key",
        regex: /\b(sk-[a-z0-9]{20}T3BlbkFJ[a-z0-9]{20})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "plaid-api-token",
        regex: /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(access-(?:sandbox|development|production)-[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "plaid-client-id",
        regex: /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{24})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "plaid-secret-key",
        regex: /(?:plaid)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{30})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "planetscale-api-token",
        regex: /\b(pscale_tkn_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "planetscale-oauth-token",
        regex: /\b(pscale_oauth_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "planetscale-password",
        regex: /\b(pscale_pw_[a-z0-9=\-_.]{32,64})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "postman-api-token",
        regex: /\b(PMAK-[a-f0-9]{24}-[a-f0-9]{34})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "prefect-api-token",
        regex: /\b(pnu_[a-z0-9]{36})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "private-key",
        regex: /-----BEGIN[ A-Z0-9_-]{0,100}PRIVATE KEY( BLOCK)?-----[\s\S]*KEY( BLOCK)?----/i,
        type: ValueOnly
      },
      {
        id: "pulumi-api-token",
        regex: /\b(pul-[a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "pypi-upload-token",
        regex: /pypi-AgEIcHlwaS5vcmc[A-Za-z0-9\-_]{50,1000}/,
        type: ValueOnly
      },
      {
        id: "rapidapi-access-token",
        regex: /(?:rapidapi)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9_-]{50})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "readme-api-token",
        regex: /\b(rdme_[a-z0-9]{70})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "rubygems-api-token",
        regex: /\b(rubygems_[a-f0-9]{48})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "scalingo-api-token",
        regex: /tk-us-[a-zA-Z0-9-_]{48}/,
        type: ValueOnly
      },
      {
        id: "sendbird-access-id",
        regex: /(?:sendbird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "sendbird-access-token",
        regex: /(?:sendbird)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "sendgrid-api-token",
        regex: /\b(SG\.[a-z0-9=_\-.]{66})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "sendinblue-api-token",
        regex: /\b(xkeysib-[a-f0-9]{64}-[a-z0-9]{16})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "sentry-access-token",
        regex: /(?:sentry)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "shippo-api-token",
        regex: /\b(shippo_(live|test)_[a-f0-9]{40})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "shopify-access-token",
        regex: /shpat_[a-fA-F0-9]{32}/,
        type: ValueOnly
      },
      {
        id: "shopify-custom-access-token",
        regex: /shpca_[a-fA-F0-9]{32}/,
        type: ValueOnly
      },
      {
        id: "shopify-private-app-access-token",
        regex: /shppa_[a-fA-F0-9]{32}/,
        type: ValueOnly
      },
      {
        id: "shopify-shared-secret",
        regex: /shpss_[a-fA-F0-9]{32}/,
        type: ValueOnly
      },
      {
        id: "sidekiq-secret",
        regex: /(?:BUNDLE_ENTERPRISE__CONTRIBSYS__COM|BUNDLE_GEMS__CONTRIBSYS__COM)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-f0-9]{8}:[a-f0-9]{8})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "slack-app-token",
        regex: /(xapp-\d-[A-Z0-9]+-\d+-[a-z0-9]+)/i,
        type: ValueOnly
      },
      {
        id: "slack-bot-token",
        regex: /(xoxb-[0-9]{10,13}-[0-9]{10,13}[a-zA-Z0-9-]*)/,
        type: ValueOnly
      },
      {
        id: "slack-config-access-token",
        regex: /(xoxe.xox[bp]-\d-[A-Z0-9]{163,166})/i,
        type: ValueOnly
      },
      {
        id: "slack-config-refresh-token",
        regex: /(xoxe-\d-[A-Z0-9]{146})/i,
        type: ValueOnly
      },
      {
        id: "slack-legacy-bot-token",
        regex: /(xoxb-[0-9]{8,14}-[a-zA-Z0-9]{18,26})/,
        type: ValueOnly
      },
      {
        id: "slack-legacy-token",
        regex: /(xox[os]-\d+-\d+-\d+-[a-fA-F\d]+)/,
        type: ValueOnly
      },
      {
        id: "slack-legacy-workspace-token",
        regex: /(xox[ar]-(?:\d-)?[0-9a-zA-Z]{8,48})/,
        type: ValueOnly
      },
      {
        id: "slack-user-token",
        regex: /(xox[pe](?:-[0-9]{10,13}){3}-[a-zA-Z0-9-]{28,34})/,
        type: ValueOnly
      },
      {
        id: "slack-webhook-url",
        regex: /(https?:\/\/)?hooks.slack.com\/(services|workflows)\/[A-Za-z0-9+/]{43,46}/,
        type: ValueOnly
      },
      {
        id: "snyk-api-token",
        regex: /(?:snyk)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "square-access-token",
        regex: /\b(sq0atp-[0-9a-z\-_]{22})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "square-secret",
        regex: /\b(sq0csp-[0-9a-z\-_]{43})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "squarespace-access-token",
        regex: /(?:squarespace)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "stripe-access-token",
        regex: /(sk|pk)_(test|live)_[0-9a-z]{10,32}/i,
        type: ValueOnly
      },
      {
        id: "sumologic-access-token",
        regex: /(?:sumo)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{64})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "telegram-bot-api-token",
        regex: /(?:^|[^0-9])([0-9]{5,16}:A[a-z0-9_-]{34})(?:$|[^a-z0-9_-])/i,
        type: ValueOnly
      },
      {
        id: "travisci-access-token",
        regex: /(?:travis)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{22})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "trello-access-token",
        regex: /(?:trello)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z-0-9]{32})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twilio-api-key",
        regex: /SK[0-9a-fA-F]{32}/,
        type: ValueOnly
      },
      {
        id: "twitch-api-token",
        regex: /(?:twitch)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{30})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twitter-access-secret",
        regex: /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{45})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twitter-access-token",
        regex: /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([0-9]{15,25}-[a-z0-9]{20,40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twitter-api-key",
        regex: /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{25})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twitter-api-secret",
        regex: /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{50})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "twitter-bearer-token",
        regex: /(?:twitter)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(A{22}[a-z0-9%]{80,100})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "typeform-api-token",
        regex: /(?:typeform)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(tfp_[a-z0-9\-_.=]{59})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "vault-batch-token",
        regex: /\b(hvb\.[a-z0-9_-]{138,212})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "vault-service-token",
        regex: /\b(hvs\.[a-z0-9_-]{90,100})(?:['"\s\x60;]|$)/i,
        type: ValueOnly
      },
      {
        id: "yandex-access-token",
        regex: /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(t1\.[A-Z0-9a-z_-]+[=]{0,2}\.[A-Z0-9a-z_-]{86}[=]{0,2})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "yandex-api-key",
        regex: /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(AQVN[a-z0-9_-]{35,38})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "yandex-aws-access-token",
        regex: /(?:yandex)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}(YC[a-z0-9_-]{38})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      },
      {
        id: "zendesk-secret-key",
        regex: /(?:zendesk)(?:[0-9a-z\-_\t.]{0,20})(?:[\s|']|[\s|""]){0,3}(?:=|>|:{1,3}=|\|\|:|<=|=>|:|\?=)(?:'|""|\s|=|\x60){0,5}([a-z0-9]{40})(?:['"\s\x60;]|$)/i,
        type: NameAndValue
      }
    ];
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-analyzer.js
var require_hardcoded_secret_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hardcoded-secret-analyzer.js"(exports2, module2) {
    "use strict";
    var { HARDCODED_SECRET } = require_vulnerabilities();
    var HardcodedBaseAnalyzer = require_hardcoded_base_analyzer();
    var { ValueOnly } = require_hardcoded_rule_type();
    var allRules = require_hardcoded_secret_rules();
    var HardcodedSecretAnalyzer = class extends HardcodedBaseAnalyzer {
      constructor() {
        super(HARDCODED_SECRET, allRules, allRules.filter((rule) => rule.type === ValueOnly));
      }
    };
    module2.exports = new HardcodedSecretAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/missing-header-analyzer.js
var require_missing_header_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/missing-header-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var SC_MOVED_PERMANENTLY = 301;
    var SC_MOVED_TEMPORARILY = 302;
    var SC_NOT_MODIFIED = 304;
    var SC_TEMPORARY_REDIRECT = 307;
    var SC_NOT_FOUND = 404;
    var SC_GONE = 410;
    var SC_INTERNAL_SERVER_ERROR = 500;
    var IGNORED_RESPONSE_STATUS_LIST = /* @__PURE__ */ new Set([
      SC_MOVED_PERMANENTLY,
      SC_MOVED_TEMPORARILY,
      SC_NOT_MODIFIED,
      SC_TEMPORARY_REDIRECT,
      SC_NOT_FOUND,
      SC_GONE,
      SC_INTERNAL_SERVER_ERROR
    ]);
    var HTML_CONTENT_TYPES = ["text/html", "application/xhtml+xml"];
    var MissingHeaderAnalyzer = class extends Analyzer {
      constructor(type, headerName) {
        super(type);
        this.headerName = headerName;
      }
      onConfigure() {
        this.addSub({
          channelName: "datadog:iast:response-end",
          moduleName: "http"
        }, (data) => this.analyze(data));
      }
      _getHeaderValues(res, storedHeaders, headerName) {
        headerName = headerName.toLowerCase();
        const headerValue = res.getHeader(headerName) || storedHeaders[headerName];
        if (Array.isArray(headerValue)) {
          return headerValue;
        }
        return headerValue ? [headerValue.toString()] : [];
      }
      _getLocation() {
      }
      _checkOCE(context2) {
        return true;
      }
      _createHashSource(type, evidence, location) {
        return `${type}:${this.config.tracerConfig.service}`;
      }
      _getEvidence({ res, storedHeaders }) {
        const headerValues = this._getHeaderValues(res, storedHeaders, this.headerName);
        let value;
        if (headerValues.length === 1) {
          value = headerValues[0];
        } else if (headerValues.length > 0) {
          value = JSON.stringify(headerValues);
        }
        return { value };
      }
      _isVulnerable({ req, res, storedHeaders }, context2) {
        if (!IGNORED_RESPONSE_STATUS_LIST.has(res.statusCode) && this._isResponseHtml(res, storedHeaders)) {
          return this._isVulnerableFromRequestAndResponse(req, res, storedHeaders);
        }
        return false;
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        return false;
      }
      _isResponseHtml(res, storedHeaders) {
        const contentTypes = this._getHeaderValues(res, storedHeaders, "content-type");
        return contentTypes.some((contentType) => {
          return contentType && HTML_CONTENT_TYPES.some((htmlContentType) => {
            return htmlContentType === contentType || contentType.startsWith(htmlContentType + ";");
          });
        });
      }
    };
    module2.exports = { MissingHeaderAnalyzer };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/hsts-header-missing-analyzer.js
var require_hsts_header_missing_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/hsts-header-missing-analyzer.js"(exports2, module2) {
    "use strict";
    var { HSTS_HEADER_MISSING } = require_vulnerabilities();
    var { MissingHeaderAnalyzer } = require_missing_header_analyzer();
    var HSTS_HEADER_NAME = "Strict-Transport-Security";
    var HEADER_VALID_PREFIX = "max-age";
    var HstsHeaderMissingAnalyzer = class extends MissingHeaderAnalyzer {
      constructor() {
        super(HSTS_HEADER_MISSING, HSTS_HEADER_NAME);
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        const headerValues = this._getHeaderValues(res, storedHeaders, HSTS_HEADER_NAME);
        return this._isHttpsProtocol(req) && (headerValues.length === 0 || headerValues.some((headerValue) => !this._isHeaderValid(headerValue)));
      }
      _isHeaderValid(headerValue) {
        headerValue = headerValue.trim();
        if (!headerValue?.startsWith(HEADER_VALID_PREFIX)) {
          return false;
        }
        const semicolonIndex = headerValue.indexOf(";");
        const timestampString = headerValue.slice(
          HEADER_VALID_PREFIX.length + 1,
          semicolonIndex === -1 ? headerValue.length : semicolonIndex
        );
        const timestamp = Number.parseInt(timestampString);
        return timestamp > 0 && timestamp == timestampString;
      }
      _isHttpsProtocol(req) {
        return req.protocol === "https" || req.headers["x-forwarded-proto"] === "https";
      }
    };
    module2.exports = new HstsHeaderMissingAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/cookie-analyzer.js
var require_cookie_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/cookie-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { getNodeModulesPaths } = require_path_line();
    var EXCLUDED_PATHS = [
      // Express
      getNodeModulesPaths("express/lib/response.js"),
      // Fastify
      getNodeModulesPaths("fastify/lib/reply.js"),
      getNodeModulesPaths("fastify/lib/hooks.js"),
      getNodeModulesPaths("@fastify/cookie/plugin.js")
    ];
    var CookieAnalyzer = class extends Analyzer {
      constructor(type, propertyToBeSafe) {
        super(type);
        this.propertyToBeSafe = propertyToBeSafe.toLowerCase();
      }
      onConfigure() {
        this.addSub(
          { channelName: "datadog:iast:set-cookie", moduleName: "http" },
          (cookieInfo) => this.analyze(cookieInfo)
        );
      }
      _isVulnerable({ cookieProperties, cookieValue }) {
        return cookieValue && !(cookieProperties && cookieProperties.map((x) => x.toLowerCase().trim()).includes(this.propertyToBeSafe));
      }
      _getEvidence({ cookieName }) {
        return { value: cookieName };
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS;
      }
      _checkOCE(context2, value) {
        if (value && value.location) {
          return true;
        }
        return super._checkOCE(context2, value);
      }
      _getLocation(value, callSiteFrames) {
        if (!value) {
          return super._getLocation(value, callSiteFrames);
        }
        if (value.location) {
          return value.location;
        }
        const location = super._getLocation(value, callSiteFrames);
        value.location = location;
        return location;
      }
    };
    module2.exports = CookieAnalyzer;
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/insecure-cookie-analyzer.js
var require_insecure_cookie_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/insecure-cookie-analyzer.js"(exports2, module2) {
    "use strict";
    var { INSECURE_COOKIE } = require_vulnerabilities();
    var CookieAnalyzer = require_cookie_analyzer();
    var InsecureCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(INSECURE_COOKIE, "secure");
      }
    };
    module2.exports = new InsecureCookieAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js
var require_ldap_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/ldap-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { LDAP_INJECTION } = require_vulnerabilities();
    var { getNodeModulesPaths } = require_path_line();
    var EXCLUDED_PATHS = getNodeModulesPaths("ldapjs-promise");
    var LdapInjectionAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(LDAP_INJECTION);
      }
      onConfigure() {
        this.addSub("datadog:ldapjs:client:search", ({ base, filter }) => this.analyzeAll(base, filter));
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS;
      }
    };
    module2.exports = new LdapInjectionAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/no-httponly-cookie-analyzer.js
var require_no_httponly_cookie_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/no-httponly-cookie-analyzer.js"(exports2, module2) {
    "use strict";
    var { NO_HTTPONLY_COOKIE } = require_vulnerabilities();
    var CookieAnalyzer = require_cookie_analyzer();
    var NoHttponlyCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(NO_HTTPONLY_COOKIE, "HttpOnly");
      }
    };
    module2.exports = new NoHttponlyCookieAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/no-samesite-cookie-analyzer.js
var require_no_samesite_cookie_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/no-samesite-cookie-analyzer.js"(exports2, module2) {
    "use strict";
    var { NO_SAMESITE_COOKIE } = require_vulnerabilities();
    var CookieAnalyzer = require_cookie_analyzer();
    var NoSamesiteCookieAnalyzer = class extends CookieAnalyzer {
      constructor() {
        super(NO_SAMESITE_COOKIE, "SameSite=strict");
      }
    };
    module2.exports = new NoSamesiteCookieAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/utils.js
var require_utils11 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/utils.js"(exports2, module2) {
    "use strict";
    function iterateObjectStrings(target, fn, levelKeys = [], depth = 20, visited = /* @__PURE__ */ new Set()) {
      if (target !== null && typeof target === "object") {
        if (visited.has(target)) return;
        visited.add(target);
        Object.keys(target).forEach((key) => {
          const nextLevelKeys = [...levelKeys, key];
          const val = target[key];
          if (typeof val === "string") {
            fn(val, nextLevelKeys, target, key);
          } else if (depth > 0) {
            iterateObjectStrings(val, fn, nextLevelKeys, depth - 1, visited);
          }
        });
      }
    }
    module2.exports = {
      iterateObjectStrings
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/nosql-injection-mongodb-analyzer.js
var require_nosql_injection_mongodb_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/nosql-injection-mongodb-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { NOSQL_MONGODB_INJECTION } = require_vulnerabilities();
    var { getRanges, addSecureMark } = require_operations();
    var { getNodeModulesPaths } = require_path_line();
    var { storage } = require_datadog_core();
    var { getIastContext } = require_iast_context();
    var { HTTP_REQUEST_PARAMETER, HTTP_REQUEST_BODY } = require_source_types();
    var EXCLUDED_PATHS_FROM_STACK = getNodeModulesPaths("mongodb", "mongoose", "mquery");
    var { NOSQL_MONGODB_INJECTION_MARK } = require_secure_marks();
    var { iterateObjectStrings } = require_utils11();
    var SAFE_OPERATORS = /* @__PURE__ */ new Set([
      "$eq",
      "$gt",
      "$gte",
      "$in",
      "$lt",
      "$lte",
      "$ne",
      "$nin",
      "$exists",
      "$type",
      "$mod",
      "$bitsAllClear",
      "$bitsAllSet",
      "$bitsAnyClear",
      "$bitsAnySet"
    ]);
    var NosqlInjectionMongodbAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(NOSQL_MONGODB_INJECTION);
        this.sanitizedObjects = /* @__PURE__ */ new WeakSet();
      }
      onConfigure() {
        this.configureSanitizers();
        const onStart = ({ filters }) => {
          const store = storage("legacy").getStore();
          if (store && !store.nosqlAnalyzed && filters?.length) {
            filters.forEach((filter) => {
              this.analyze({ filter }, store);
            });
          }
          return store;
        };
        const onStartAndEnterWithStore = (message) => {
          const store = onStart(message || {});
          if (store) {
            storage("legacy").enterWith({ ...store, nosqlAnalyzed: true, nosqlParentStore: store });
          }
        };
        const onFinish = () => {
          const store = storage("legacy").getStore();
          if (store?.nosqlParentStore) {
            storage("legacy").enterWith(store.nosqlParentStore);
          }
        };
        this.addSub("datadog:mongodb:collection:filter:start", onStart);
        this.addSub("datadog:mongoose:model:filter:start", onStartAndEnterWithStore);
        this.addSub("datadog:mongoose:model:filter:finish", onFinish);
        this.addSub("datadog:mquery:filter:prepare", onStart);
        this.addSub("tracing:datadog:mquery:filter:start", onStartAndEnterWithStore);
        this.addSub("tracing:datadog:mquery:filter:asyncEnd", onFinish);
      }
      configureSanitizers() {
        this.addNotSinkSub("datadog:express-mongo-sanitize:filter:finish", ({ sanitizedProperties, req }) => {
          const store = storage("legacy").getStore();
          const iastContext = getIastContext(store);
          if (iastContext) {
            sanitizedProperties.forEach((key) => {
              iterateObjectStrings(req[key], function(value, levelKeys) {
                if (typeof value === "string") {
                  let parentObj = req[key];
                  const levelsLength = levelKeys.length;
                  for (let i = 0; i < levelsLength; i++) {
                    const currentLevelKey = levelKeys[i];
                    if (i === levelsLength - 1) {
                      parentObj[currentLevelKey] = addSecureMark(iastContext, value, NOSQL_MONGODB_INJECTION_MARK);
                    } else {
                      parentObj = parentObj[currentLevelKey];
                    }
                  }
                }
              });
            });
          }
        });
        this.addNotSinkSub("datadog:express-mongo-sanitize:sanitize:finish", ({ sanitizedObject }) => {
          const store = storage("legacy").getStore();
          const iastContext = getIastContext(store);
          if (iastContext) {
            iterateObjectStrings(sanitizedObject, function(value, levelKeys, parent, lastKey) {
              try {
                parent[lastKey] = addSecureMark(iastContext, value, NOSQL_MONGODB_INJECTION_MARK);
              } catch {
              }
            });
          }
        });
        this.addNotSinkSub("datadog:mongoose:sanitize-filter:finish", ({ sanitizedObject }) => {
          this.sanitizedObjects.add(sanitizedObject);
        });
      }
      _isVulnerableRange(range, value) {
        const rangeIsWholeValue = range.start === 0 && range.end === value?.length;
        if (!rangeIsWholeValue) return false;
        const rangeType = range?.iinfo?.type;
        return rangeType === HTTP_REQUEST_PARAMETER || rangeType === HTTP_REQUEST_BODY;
      }
      _isVulnerable(value, iastContext) {
        if (value?.filter && iastContext) {
          let isVulnerable = false;
          if (this.sanitizedObjects.has(value.filter)) {
            return false;
          }
          const rangesByKey = {};
          const allRanges = [];
          iterateMongodbQueryStrings(value.filter, (val, nextLevelKeys) => {
            let ranges = getRanges(iastContext, val);
            if (ranges?.length === 1) {
              ranges = this._filterSecureRanges(ranges);
              if (!ranges.length) {
                this._incrementSuppressedMetric(iastContext);
                return;
              }
              const range = ranges[0];
              if (!this._isVulnerableRange(range, val)) {
                return;
              }
              isVulnerable = true;
              rangesByKey[nextLevelKeys.join(".")] = ranges;
              allRanges.push(range);
            }
          });
          if (isVulnerable) {
            value.rangesToApply = rangesByKey;
            value.ranges = allRanges;
          }
          return isVulnerable;
        }
        return false;
      }
      _getEvidence(value, iastContext) {
        return { value: value.filter, rangesToApply: value.rangesToApply, ranges: value.ranges };
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS_FROM_STACK;
      }
    };
    function iterateMongodbQueryStrings(target, fn, levelKeys = [], depth = 10, visited = /* @__PURE__ */ new Set()) {
      if (target !== null && typeof target === "object") {
        if (visited.has(target)) return;
        visited.add(target);
        Object.keys(target).forEach((key) => {
          if (SAFE_OPERATORS.has(key)) return;
          const nextLevelKeys = [...levelKeys, key];
          const val = target[key];
          if (typeof val === "string") {
            fn(val, nextLevelKeys, target, key);
          } else if (depth > 0) {
            iterateMongodbQueryStrings(val, fn, nextLevelKeys, depth - 1, visited);
          }
        });
      }
    }
    module2.exports = new NosqlInjectionMongodbAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js
var require_path_traversal_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/path-traversal-analyzer.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var InjectionAnalyzer = require_injection_analyzer();
    var { getIastContext } = require_iast_context();
    var { storage } = require_datadog_core();
    var { PATH_TRAVERSAL } = require_vulnerabilities();
    var ignoredOperations = /* @__PURE__ */ new Set(["dir.close", "close"]);
    var PathTraversalAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(PATH_TRAVERSAL);
        this.exclusionList = [
          path.join("node_modules", "send") + path.sep
        ];
        this.internalExclusionList = [
          "node:fs",
          "node:internal/fs",
          String.raw`node:internal\fs`,
          "fs.js",
          "internal/fs",
          String.raw`internal\fs`
        ];
      }
      onConfigure() {
        this.addSub("apm:fs:operation:start", (obj) => {
          const store = storage("legacy").getStore();
          const outOfReqOrChild = !store?.fs?.root;
          if (ignoredOperations.has(obj.operation) || outOfReqOrChild) return;
          const pathArguments = [];
          if (obj.dest) {
            pathArguments.push(obj.dest);
          }
          if (obj.existingPath) {
            pathArguments.push(obj.existingPath);
          }
          if (obj.file) {
            pathArguments.push(obj.file);
          }
          if (obj.newPath) {
            pathArguments.push(obj.newPath);
          }
          if (obj.oldPath) {
            pathArguments.push(obj.oldPath);
          }
          if (obj.path) {
            pathArguments.push(obj.path);
          }
          if (obj.prefix) {
            pathArguments.push(obj.prefix);
          }
          if (obj.src) {
            pathArguments.push(obj.src);
          }
          if (obj.target) {
            pathArguments.push(obj.target);
          }
          this.analyze(pathArguments);
        });
      }
      _isExcluded(location) {
        if (location?.path) {
          return location.isInternal ? this.internalExclusionList.some((elem) => location.path.includes(elem)) : this.exclusionList.some((elem) => location.path.includes(elem));
        }
        return true;
      }
      analyze(value) {
        const iastContext = getIastContext(storage("legacy").getStore());
        if (!iastContext) {
          return;
        }
        if (value && value.constructor === Array) {
          for (const val of value) {
            if (this._isVulnerable(val, iastContext) && this._checkOCE(iastContext)) {
              this._report(val, iastContext);
              break;
            }
          }
        }
      }
    };
    module2.exports = new PathTraversalAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js
var require_sql_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/sql-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var { SQL_INJECTION } = require_vulnerabilities();
    var { getRanges } = require_operations();
    var { storage } = require_datadog_core();
    var { getNodeModulesPaths } = require_path_line();
    var StoredInjectionAnalyzer = require_stored_injection_analyzer();
    var EXCLUDED_PATHS = getNodeModulesPaths("mysql", "mysql2", "sequelize", "pg-pool", "knex");
    var SqlInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(SQL_INJECTION);
      }
      onConfigure() {
        this.addSub("apm:mysql:query:start", ({ sql }) => this.analyze(sql, void 0, "MYSQL"));
        this.addSub("datadog:mysql2:outerquery:start", ({ sql }) => this.analyze(sql, void 0, "MYSQL"));
        this.addSub(
          "apm:pg:query:start",
          ({ originalText, query }) => this.analyze(originalText || query.text, void 0, "POSTGRES")
        );
        this.addBind(
          "datadog:sequelize:query:start",
          ({ sql, dialect }) => this.getStoreAndAnalyze(sql, dialect.toUpperCase())
        );
        this.addSub("datadog:sequelize:query:finish", () => this.returnToParentStore());
        this.addBind("datadog:pg:pool:query:start", ({ query }) => this.getStoreAndAnalyze(query.text, "POSTGRES"));
        this.addSub("datadog:pg:pool:query:finish", () => this.returnToParentStore());
        this.addSub("datadog:mysql:pool:query:start", ({ sql }) => this.setStoreAndAnalyze(sql, "MYSQL"));
        this.addSub("datadog:mysql:pool:query:finish", () => this.returnToParentStore());
        this.addBind("datadog:knex:raw:start", (context2) => {
          const { sql, dialect: knexDialect } = context2;
          const dialect = this.normalizeKnexDialect(knexDialect);
          const currentStore = this.getStoreAndAnalyze(sql, dialect);
          context2.currentStore = currentStore;
          return currentStore;
        });
        this.addBind("datadog:knex:raw:subscribes", ({ currentStore }) => currentStore);
        this.addBind("datadog:knex:raw:finish", ({ currentStore }) => currentStore?.sqlParentStore);
      }
      setStoreAndAnalyze(query, dialect) {
        const store = this.getStoreAndAnalyze(query, dialect);
        if (store) {
          storage("legacy").enterWith(store);
        }
      }
      getStoreAndAnalyze(query, dialect) {
        const parentStore = storage("legacy").getStore();
        if (parentStore) {
          this.analyze(query, parentStore, dialect);
          return { ...parentStore, sqlAnalyzed: true, sqlParentStore: parentStore };
        }
      }
      returnToParentStore(store = storage("legacy").getStore()) {
        if (store && store.sqlParentStore) {
          storage("legacy").enterWith(store.sqlParentStore);
        }
      }
      _getEvidence(value, iastContext, dialect) {
        const ranges = getRanges(iastContext, value);
        return { value, ranges, dialect };
      }
      analyze(value, store, dialect) {
        store = store || storage("legacy").getStore();
        if (!(store && store.sqlAnalyzed)) {
          super.analyze(value, store, dialect);
        }
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS;
      }
      normalizeKnexDialect(knexDialect) {
        if (knexDialect === "postgresql") {
          return "POSTGRES";
        }
        if (knexDialect === "sqlite3") {
          return "SQLITE";
        }
        if (typeof knexDialect === "string") {
          return knexDialect.toUpperCase();
        }
      }
    };
    module2.exports = new SqlInjectionAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/ssrf-analyzer.js
var require_ssrf_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/ssrf-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { SSRF } = require_vulnerabilities();
    var SSRFAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(SSRF);
      }
      onConfigure() {
        this.addSub("apm:http:client:request:start", ({ args }) => {
          if (typeof args.originalUrl === "string") {
            this.analyze(args.originalUrl);
          } else if (args.options && args.options.host) {
            this.analyze(args.options.host);
          }
        });
        this.addSub("apm:http2:client:connect:start", ({ authority }) => {
          if (authority && typeof authority === "string") {
            this.analyze(authority);
          }
        });
      }
      _isRangeSecure(range, value) {
        const fragmentIndex = value.indexOf("#");
        if (fragmentIndex !== -1 && range.start >= fragmentIndex) {
          return true;
        }
        return super._isRangeSecure(range, value);
      }
    };
    module2.exports = new SSRFAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/template-injection-analyzer.js
var require_template_injection_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/template-injection-analyzer.js"(exports2, module2) {
    "use strict";
    var { TEMPLATE_INJECTION } = require_vulnerabilities();
    var StoredInjectionAnalyzer = require_stored_injection_analyzer();
    var TemplateInjectionAnalyzer = class extends StoredInjectionAnalyzer {
      constructor() {
        super(TEMPLATE_INJECTION);
      }
      onConfigure() {
        this.addSub("datadog:handlebars:compile:start", ({ source }) => this.analyze(source));
        this.addSub("datadog:handlebars:register-partial:start", ({ partial }) => this.analyze(partial));
        this.addSub("datadog:pug:compile:start", ({ source }) => this.analyze(source));
      }
    };
    module2.exports = new TemplateInjectionAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/unvalidated-redirect-analyzer.js
var require_unvalidated_redirect_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/unvalidated-redirect-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { UNVALIDATED_REDIRECT } = require_vulnerabilities();
    var { getNodeModulesPaths } = require_path_line();
    var { getRanges } = require_operations();
    var {
      HTTP_REQUEST_BODY,
      HTTP_REQUEST_PARAMETER
    } = require_source_types();
    var EXCLUDED_PATHS = [
      getNodeModulesPaths("express/lib/response.js"),
      getNodeModulesPaths("fastify/lib/reply.js")
    ];
    var VULNERABLE_SOURCE_TYPES = /* @__PURE__ */ new Set([
      HTTP_REQUEST_BODY,
      HTTP_REQUEST_PARAMETER
    ]);
    var UnvalidatedRedirectAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(UNVALIDATED_REDIRECT);
      }
      onConfigure() {
        this.addSub("datadog:http:server:response:set-header:finish", ({ name, value }) => this.analyze(name, value));
        this.addSub("datadog:fastify:set-header:finish", ({ name, value }) => this.analyze(name, value));
      }
      analyze(name, value) {
        if (!this.isLocationHeader(name) || typeof value !== "string") return;
        super.analyze(value);
      }
      isLocationHeader(name) {
        return name && name.trim().toLowerCase() === "location";
      }
      _isVulnerable(value, iastContext) {
        if (!value) return false;
        const ranges = getRanges(iastContext, value);
        return ranges?.length > 0 && this._hasUnsafeRange(ranges);
      }
      _hasUnsafeRange(ranges) {
        return ranges.some(
          (range) => this._isVulnerableRange(range)
        );
      }
      _isVulnerableRange(range) {
        return VULNERABLE_SOURCE_TYPES.has(range.iinfo.type);
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS;
      }
    };
    module2.exports = new UnvalidatedRedirectAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/untrusted-deserialization-analyzer.js
var require_untrusted_deserialization_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/untrusted-deserialization-analyzer.js"(exports2, module2) {
    "use strict";
    var InjectionAnalyzer = require_injection_analyzer();
    var { UNTRUSTED_DESERIALIZATION } = require_vulnerabilities();
    var UntrustedDeserializationAnalyzer = class extends InjectionAnalyzer {
      constructor() {
        super(UNTRUSTED_DESERIALIZATION);
      }
      onConfigure() {
        this.addSub("datadog:node-serialize:unserialize:start", ({ obj }) => this.analyze(obj));
      }
    };
    module2.exports = new UntrustedDeserializationAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js
var require_weak_cipher_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/weak-cipher-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { WEAK_CIPHER } = require_vulnerabilities();
    var INSECURE_CIPHERS = new Set([
      "des",
      "des-cbc",
      "des-cfb",
      "des-cfb1",
      "des-cfb8",
      "des-ecb",
      "des-ede",
      "des-ede-cbc",
      "des-ede-cfb",
      "des-ede-ecb",
      "des-ede-ofb",
      "des-ede3",
      "des-ede3-cbc",
      "des-ede3-cfb",
      "des-ede3-cfb1",
      "des-ede3-cfb8",
      "des-ede3-ecb",
      "des-ede3-ofb",
      "des-ofb",
      "des3",
      "des3-wrap",
      "rc2",
      "rc2-128",
      "rc2-40",
      "rc2-40-cbc",
      "rc2-64",
      "rc2-64-cbc",
      "rc2-cbc",
      "rc2-cfb",
      "rc2-ecb",
      "rc2-ofb",
      "blowfish",
      "rc4",
      "rc4-40",
      "rc4-hmac-md5"
    ].map((algorithm) => algorithm.toLowerCase()));
    var WeakCipherAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_CIPHER);
      }
      onConfigure() {
        this.addSub("datadog:crypto:cipher:start", ({ algorithm }) => this.analyze(algorithm));
      }
      _isVulnerable(algorithm) {
        if (algorithm && typeof algorithm === "string") {
          return INSECURE_CIPHERS.has(algorithm.toLowerCase());
        }
        return false;
      }
    };
    module2.exports = new WeakCipherAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js
var require_weak_hash_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/weak-hash-analyzer.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var { getNodeModulesPaths } = require_path_line();
    var Analyzer = require_vulnerability_analyzer();
    var { WEAK_HASH } = require_vulnerabilities();
    var INSECURE_HASH_ALGORITHMS = new Set([
      "md4",
      "md4WithRSAEncryption",
      "RSA-MD4",
      "RSA-MD5",
      "md5",
      "md5-sha1",
      "ssl3-md5",
      "md5WithRSAEncryption",
      "RSA-SHA1",
      "RSA-SHA1-2",
      "sha1",
      "md5-sha1",
      "sha1WithRSAEncryption",
      "ssl3-sha1"
    ].map((algorithm) => algorithm.toLowerCase()));
    var EXCLUDED_LOCATIONS = getNodeModulesPaths(
      "etag/index.js",
      "@mikro-orm/core/utils/Utils.js",
      "mongodb/lib/core/connection/connection.js",
      "mysql2/lib/auth_41.js",
      "pusher/lib/utils.js",
      "redlock/dist/cjs",
      "sqreen/lib/package-reader/index.js",
      "ws/lib/websocket-server.js",
      "google-gax/build/src/grpc.js",
      "cookie-signature/index.js",
      "express-session/index.js"
    );
    var EXCLUDED_PATHS_FROM_STACK = [
      path.join("node_modules", "object-hash", path.sep),
      path.join("node_modules", "aws-sdk", "lib", "util.js"),
      path.join("node_modules", "keygrip", path.sep)
    ];
    var WeakHashAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_HASH);
      }
      onConfigure() {
        this.addSub("datadog:crypto:hashing:start", ({ algorithm }) => this.analyze(algorithm));
      }
      _isVulnerable(algorithm) {
        if (typeof algorithm === "string") {
          return INSECURE_HASH_ALGORITHMS.has(algorithm.toLowerCase());
        }
        return false;
      }
      _isExcluded(location) {
        if (!location) return false;
        return EXCLUDED_LOCATIONS.some((excludedLocation) => {
          return location.path.includes(excludedLocation);
        });
      }
      _getExcludedPaths() {
        return EXCLUDED_PATHS_FROM_STACK;
      }
    };
    module2.exports = new WeakHashAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/weak-randomness-analyzer.js
var require_weak_randomness_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/weak-randomness-analyzer.js"(exports2, module2) {
    "use strict";
    var Analyzer = require_vulnerability_analyzer();
    var { WEAK_RANDOMNESS } = require_vulnerabilities();
    var WeakRandomnessAnalyzer = class extends Analyzer {
      constructor() {
        super(WEAK_RANDOMNESS);
      }
      onConfigure() {
        this.addSub("datadog:random:call", ({ fn }) => this.analyze(fn));
      }
      _isVulnerable(fn) {
        return fn === Math.random;
      }
    };
    module2.exports = new WeakRandomnessAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/xcontenttype-header-missing-analyzer.js
var require_xcontenttype_header_missing_analyzer = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/xcontenttype-header-missing-analyzer.js"(exports2, module2) {
    "use strict";
    var { XCONTENTTYPE_HEADER_MISSING } = require_vulnerabilities();
    var { MissingHeaderAnalyzer } = require_missing_header_analyzer();
    var XCONTENTTYPEOPTIONS_HEADER_NAME = "X-Content-Type-Options";
    var XcontenttypeHeaderMissingAnalyzer = class extends MissingHeaderAnalyzer {
      constructor() {
        super(XCONTENTTYPE_HEADER_MISSING, XCONTENTTYPEOPTIONS_HEADER_NAME);
      }
      _isVulnerableFromRequestAndResponse(req, res, storedHeaders) {
        const headerValues = this._getHeaderValues(res, storedHeaders, XCONTENTTYPEOPTIONS_HEADER_NAME);
        return headerValues.length === 0 || headerValues.some((headerValue) => headerValue.trim().toLowerCase() !== "nosniff");
      }
    };
    module2.exports = new XcontenttypeHeaderMissingAnalyzer();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/analyzers.js
var require_analyzers = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/analyzers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CODE_INJECTION_ANALYZER: require_code_injection_analyzer(),
      COMMAND_INJECTION_ANALYZER: require_command_injection_analyzer(),
      HARCODED_PASSWORD_ANALYZER: require_hardcoded_password_analyzer2(),
      HARCODED_SECRET_ANALYZER: require_hardcoded_secret_analyzer(),
      HSTS_HEADER_MISSING_ANALYZER: require_hsts_header_missing_analyzer(),
      INSECURE_COOKIE_ANALYZER: require_insecure_cookie_analyzer(),
      LDAP_ANALYZER: require_ldap_injection_analyzer(),
      NO_HTTPONLY_COOKIE_ANALYZER: require_no_httponly_cookie_analyzer(),
      NO_SAMESITE_COOKIE_ANALYZER: require_no_samesite_cookie_analyzer(),
      NOSQL_MONGODB_INJECTION: require_nosql_injection_mongodb_analyzer(),
      PATH_TRAVERSAL_ANALYZER: require_path_traversal_analyzer(),
      SQL_INJECTION_ANALYZER: require_sql_injection_analyzer(),
      SSRF: require_ssrf_analyzer(),
      TEMPLATE_INJECTION_ANALYZER: require_template_injection_analyzer(),
      UNVALIDATED_REDIRECT_ANALYZER: require_unvalidated_redirect_analyzer(),
      UNTRUSTED_DESERIALIZATION_ANALYZER: require_untrusted_deserialization_analyzer(),
      WEAK_CIPHER_ANALYZER: require_weak_cipher_analyzer(),
      WEAK_HASH_ANALYZER: require_weak_hash_analyzer(),
      WEAK_RANDOMNESS_ANALYZER: require_weak_randomness_analyzer(),
      XCONTENTTYPE_HEADER_MISSING_ANALYZER: require_xcontenttype_header_missing_analyzer()
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/set-cookies-header-interceptor.js
var require_set_cookies_header_interceptor = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/set-cookies-header-interceptor.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var { setCookieChannel } = require_channels2();
    var SetCookiesHeaderInterceptor = class extends Plugin {
      constructor() {
        super();
        this.cookiesInRequest = /* @__PURE__ */ new WeakMap();
        this.addSub(
          "datadog:http:server:response:set-header:finish",
          ({ name, value, res }) => this._handleCookies(name, value, res)
        );
        this.addSub(
          "datadog:fastify:set-header:finish",
          ({ name, value, res }) => this._handleCookies(name, value, res)
        );
      }
      _handleCookies(name, value, res) {
        if (name.toLowerCase() === "set-cookie") {
          let allCookies = value;
          if (typeof value === "string") {
            allCookies = [value];
          }
          const alreadyCheckedCookies = this._getAlreadyCheckedCookiesInResponse(res);
          let location;
          allCookies.forEach((cookieString) => {
            if (!alreadyCheckedCookies.includes(cookieString)) {
              alreadyCheckedCookies.push(cookieString);
              const parsedCookie = this._parseCookie(cookieString, location);
              setCookieChannel.publish(parsedCookie);
              location = parsedCookie.location;
            }
          });
        }
      }
      _parseCookie(cookieString, location) {
        const cookieParts = cookieString.split(";");
        const nameValueParts = cookieParts[0].split("=");
        const cookieName = nameValueParts[0];
        const cookieValue = nameValueParts.slice(1).join("=");
        const cookieProperties = cookieParts.slice(1).map((part) => part.trim());
        return { cookieName, cookieValue, cookieProperties, cookieString, location };
      }
      _getAlreadyCheckedCookiesInResponse(res) {
        let alreadyCheckedCookies = this.cookiesInRequest.get(res);
        if (!alreadyCheckedCookies) {
          alreadyCheckedCookies = [];
          this.cookiesInRequest.set(res, alreadyCheckedCookies);
        }
        return alreadyCheckedCookies;
      }
    };
    module2.exports = new SetCookiesHeaderInterceptor();
  }
});

// ../../packages/dd-trace/src/appsec/iast/analyzers/index.js
var require_analyzers2 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/analyzers/index.js"(exports2, module2) {
    "use strict";
    var analyzers = require_analyzers();
    var setCookiesHeaderInterceptor = require_set_cookies_header_interceptor();
    function enableAllAnalyzers(tracerConfig) {
      setCookiesHeaderInterceptor.configure({ enabled: true, tracerConfig });
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure({ enabled: true, tracerConfig });
      }
    }
    function disableAllAnalyzers() {
      setCookiesHeaderInterceptor.configure(false);
      for (const analyzer in analyzers) {
        analyzers[analyzer].configure(false);
      }
    }
    module2.exports = {
      enableAllAnalyzers,
      disableAllAnalyzers
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js
var require_plugin2 = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/plugin.js"(exports2, module2) {
    "use strict";
    var { SourceIastPlugin } = require_iast_plugin();
    var { getIastContext } = require_iast_context();
    var { storage } = require_datadog_core();
    var { taintObject, newTaintedString, getRanges, taintQueryWithCache } = require_operations();
    var {
      HTTP_REQUEST_BODY,
      HTTP_REQUEST_COOKIE_VALUE,
      HTTP_REQUEST_COOKIE_NAME,
      HTTP_REQUEST_HEADER_VALUE,
      HTTP_REQUEST_HEADER_NAME,
      HTTP_REQUEST_PARAMETER,
      HTTP_REQUEST_PATH_PARAM,
      HTTP_REQUEST_URI,
      SQL_ROW_VALUE
    } = require_source_types();
    var { EXECUTED_SOURCE } = require_iast_metric();
    var REQ_HEADER_TAGS = EXECUTED_SOURCE.formatTags(HTTP_REQUEST_HEADER_VALUE, HTTP_REQUEST_HEADER_NAME);
    var REQ_URI_TAGS = EXECUTED_SOURCE.formatTags(HTTP_REQUEST_URI);
    var TaintTrackingPlugin = class extends SourceIastPlugin {
      constructor() {
        super();
        this._type = "taint-tracking";
        this._taintedURLs = /* @__PURE__ */ new WeakMap();
      }
      configure(config) {
        super.configure(config);
        let rowsToTaint = this.iastConfig?.dbRowsToTaint;
        if (typeof rowsToTaint !== "number") {
          rowsToTaint = 1;
        }
        this._rowsToTaint = rowsToTaint;
      }
      onConfigure() {
        this.addBodyParsingSubscriptions();
        this.addQueryParameterSubscriptions();
        this.addCookieSubscriptions();
        this.addDatabaseSubscriptions();
        this.addPathParameterSubscriptions();
        this.addGraphQLSubscriptions();
        this.addURLParsingSubscriptions();
        this.addInstrumentedSource("http", [HTTP_REQUEST_HEADER_VALUE, HTTP_REQUEST_HEADER_NAME]);
      }
      addBodyParsingSubscriptions() {
        const onRequestBody = ({ req }) => {
          const iastContext = getIastContext(storage("legacy").getStore());
          if (iastContext && iastContext.body !== req.body) {
            this._taintTrackingHandler(HTTP_REQUEST_BODY, req, "body", iastContext);
            iastContext.body = req.body;
          }
        };
        this.addSub(
          { channelName: "datadog:body-parser:read:finish", tag: HTTP_REQUEST_BODY },
          onRequestBody
        );
        this.addSub(
          { channelName: "datadog:multer:read:finish", tag: HTTP_REQUEST_BODY },
          onRequestBody
        );
        this.addSub(
          { channelName: "datadog:fastify:body-parser:finish", tag: HTTP_REQUEST_BODY },
          ({ body }) => {
            const iastContext = getIastContext(storage("legacy").getStore());
            if (iastContext && iastContext.body !== body) {
              this._taintTrackingHandler(HTTP_REQUEST_BODY, body);
              iastContext.body = body;
            }
          }
        );
        this.addSub(
          { channelName: "apm:express:middleware:next", tag: HTTP_REQUEST_BODY },
          ({ req }) => {
            if (req && req.body !== null && typeof req.body === "object") {
              const iastContext = getIastContext(storage("legacy").getStore());
              if (iastContext && iastContext.body !== req.body) {
                this._taintTrackingHandler(HTTP_REQUEST_BODY, req, "body", iastContext);
                iastContext.body = req.body;
              }
            }
          }
        );
      }
      addQueryParameterSubscriptions() {
        this.addSub(
          { channelName: "datadog:query:read:finish", tag: HTTP_REQUEST_PARAMETER },
          ({ query }) => this._taintTrackingHandler(HTTP_REQUEST_PARAMETER, query)
        );
        this.addSub(
          { channelName: "datadog:fastify:query-params:finish", tag: HTTP_REQUEST_PARAMETER },
          ({ query }) => {
            this._taintTrackingHandler(HTTP_REQUEST_PARAMETER, query);
          }
        );
        this.addSub(
          { channelName: "datadog:express:query:finish", tag: HTTP_REQUEST_PARAMETER },
          ({ query }) => {
            const iastContext = getIastContext(storage("legacy").getStore());
            if (!iastContext || !query) return;
            taintQueryWithCache(iastContext, query);
          }
        );
      }
      addCookieSubscriptions() {
        this.addSub(
          { channelName: "datadog:cookie:parse:finish", tag: [HTTP_REQUEST_COOKIE_VALUE, HTTP_REQUEST_COOKIE_NAME] },
          ({ cookies }) => this._cookiesTaintTrackingHandler(cookies)
        );
        this.addSub(
          { channelName: "datadog:fastify-cookie:read:finish", tag: [HTTP_REQUEST_COOKIE_VALUE, HTTP_REQUEST_COOKIE_NAME] },
          ({ cookies }) => this._cookiesTaintTrackingHandler(cookies)
        );
      }
      addDatabaseSubscriptions() {
        this.addSub(
          { channelName: "datadog:sequelize:query:finish", tag: SQL_ROW_VALUE },
          ({ result }) => this._taintDatabaseResult(result, "sequelize", getIastContext(storage("legacy").getStore()))
        );
        this.addSub(
          { channelName: "apm:pg:query:finish", tag: SQL_ROW_VALUE },
          ({ result, currentStore }) => this._taintDatabaseResult(result, "pg", getIastContext(currentStore))
        );
      }
      addPathParameterSubscriptions() {
        const pathParamHandler = ({ req }) => {
          if (req && req.params !== null && typeof req.params === "object") {
            this._taintTrackingHandler(HTTP_REQUEST_PATH_PARAM, req, "params");
          }
        };
        this.addSub(
          { channelName: "datadog:express:process_params:start", tag: HTTP_REQUEST_PATH_PARAM },
          pathParamHandler
        );
        this.addSub(
          { channelName: "datadog:router:param:start", tag: HTTP_REQUEST_PATH_PARAM },
          pathParamHandler
        );
        this.addSub(
          { channelName: "datadog:fastify:path-params:finish", tag: HTTP_REQUEST_PATH_PARAM },
          ({ req, params }) => {
            if (req) {
              this._taintTrackingHandler(HTTP_REQUEST_PATH_PARAM, params);
            }
          }
        );
      }
      addGraphQLSubscriptions() {
        this.addSub(
          { channelName: "apm:graphql:resolve:start", tag: HTTP_REQUEST_BODY },
          (data) => {
            const iastContext = getIastContext(storage("legacy").getStore());
            const source = data.rootCtx?.source;
            const ranges = source && getRanges(iastContext, source);
            if (ranges?.length) {
              this._taintTrackingHandler(ranges[0].iinfo.type, data.args, null, iastContext);
            }
          }
        );
      }
      addURLParsingSubscriptions() {
        const urlResultTaintedProperties = ["host", "origin", "hostname"];
        this.addSub(
          { channelName: "datadog:url:parse:finish" },
          ({ input, base, parsed, isURL }) => {
            const iastContext = getIastContext(storage("legacy").getStore());
            const ranges = getRanges(iastContext, base || input);
            if (ranges?.length) {
              if (isURL) {
                this._taintedURLs.set(parsed, ranges[0]);
              } else {
                urlResultTaintedProperties.forEach((param) => {
                  this._taintTrackingHandler(ranges[0].iinfo.type, parsed, param, iastContext);
                });
              }
            }
          }
        );
        this.addSub(
          { channelName: "datadog:url:getter:finish" },
          (context2) => {
            if (!urlResultTaintedProperties.includes(context2.property)) return;
            const origRange = this._taintedURLs.get(context2.urlObject);
            if (!origRange) return;
            const iastContext = getIastContext(storage("legacy").getStore());
            if (!iastContext) return;
            context2.result = newTaintedString(iastContext, context2.result, origRange.iinfo.parameterName, origRange.iinfo.type);
          }
        );
      }
      _taintTrackingHandler(type, target, property, iastContext = getIastContext(storage("legacy").getStore())) {
        if (!property) {
          taintObject(iastContext, target, type);
        } else if (target[property]) {
          target[property] = taintObject(iastContext, target[property], type);
        }
      }
      _cookiesTaintTrackingHandler(target) {
        const iastContext = getIastContext(storage("legacy").getStore());
        taintObject(iastContext, target, HTTP_REQUEST_COOKIE_VALUE);
      }
      taintHeaders(headers, iastContext) {
        this.execSource({
          handler: () => taintObject(iastContext, headers, HTTP_REQUEST_HEADER_VALUE),
          tags: REQ_HEADER_TAGS,
          iastContext
        });
      }
      taintUrl(req, iastContext) {
        this.execSource({
          handler: function() {
            req.url = newTaintedString(iastContext, req.url, HTTP_REQUEST_URI, HTTP_REQUEST_URI);
          },
          tags: REQ_URI_TAGS,
          iastContext
        });
      }
      taintRequest(req, iastContext) {
        this.taintHeaders(req.headers, iastContext);
        this.taintUrl(req, iastContext);
      }
      _taintDatabaseResult(result, dbOrigin, iastContext, name) {
        if (!iastContext) return result;
        if (this._rowsToTaint === 0) return result;
        if (Array.isArray(result)) {
          for (let i = 0; i < result.length && i < this._rowsToTaint; i++) {
            const nextName = name ? `${name}.${i}` : String(i);
            result[i] = this._taintDatabaseResult(result[i], dbOrigin, iastContext, nextName);
          }
        } else if (result && typeof result === "object") {
          if (dbOrigin === "sequelize" && result.dataValues) {
            result.dataValues = this._taintDatabaseResult(result.dataValues, dbOrigin, iastContext, name);
          } else {
            for (const key in result) {
              const nextName = name ? `${name}.${key}` : key;
              result[key] = this._taintDatabaseResult(result[key], dbOrigin, iastContext, nextName);
            }
          }
        } else if (typeof result === "string") {
          result = newTaintedString(iastContext, result, name, SQL_ROW_VALUE);
        }
        return result;
      }
    };
    module2.exports = new TaintTrackingPlugin();
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/plugins/kafka.js
var require_kafka = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/plugins/kafka.js"(exports2, module2) {
    "use strict";
    var shimmer = require_datadog_shimmer();
    var { getIastContext } = require_iast_context();
    var { KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE } = require_source_types();
    var { newTaintedObject, newTaintedString } = require_operations();
    var { SourceIastPlugin } = require_iast_plugin();
    var KafkaConsumerIastPlugin = class extends SourceIastPlugin {
      onConfigure() {
        this.addSub(
          { channelName: "dd-trace:kafkajs:consumer:afterStart", tag: [KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE] },
          ({ message, currentStore }) => this.taintKafkaMessage(message, currentStore)
        );
      }
      getToStringWrap(toString2, iastContext, type) {
        return function() {
          const res = toString2.apply(this, arguments);
          return newTaintedString(iastContext, res, void 0, type);
        };
      }
      taintKafkaMessage(message, currentStore) {
        const iastContext = getIastContext(currentStore);
        if (iastContext && message) {
          const { key, value } = message;
          if (key !== null && typeof key === "object") {
            shimmer.wrap(
              key,
              "toString",
              (toString2) => this.getToStringWrap(toString2, iastContext, KAFKA_MESSAGE_KEY)
            );
            newTaintedObject(iastContext, key, void 0, KAFKA_MESSAGE_KEY);
          }
          if (value !== null && typeof value === "object") {
            shimmer.wrap(
              value,
              "toString",
              (toString2) => this.getToStringWrap(toString2, iastContext, KAFKA_MESSAGE_VALUE)
            );
            newTaintedObject(iastContext, value, void 0, KAFKA_MESSAGE_VALUE);
          }
        }
      }
    };
    module2.exports = new KafkaConsumerIastPlugin();
  }
});

// ../../packages/dd-trace/src/appsec/iast/context/context-plugin.js
var require_context_plugin = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/context/context-plugin.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var iastContextFunctions = require_iast_context();
    var overheadController = require_overhead_controller();
    var { IastPlugin } = require_iast_plugin();
    var { IAST_ENABLED_TAG_KEY } = require_tags4();
    var { createTransaction, removeTransaction } = require_operations();
    var vulnerabilityReporter = require_vulnerability_reporter();
    var { TagKey } = require_iast_metric();
    var IastContextPlugin = class extends IastPlugin {
      startCtxOn(channelName, tag) {
        super.addSub(channelName, (message) => this.startContext(message?.currentStore));
        this._getAndRegisterSubscription({
          channelName,
          tag,
          tagKey: TagKey.SOURCE_TYPE
        });
      }
      finishCtxOn(channelName) {
        super.addSub(channelName, (message) => this.finishContext());
      }
      getRootSpan(store) {
        return store?.span;
      }
      getTopContext() {
        return {};
      }
      newIastContext(rootSpan) {
        return { rootSpan };
      }
      addIastEnabledTag(isRequestAcquired, rootSpan) {
        if (rootSpan?.addTags) {
          rootSpan.addTags({
            [IAST_ENABLED_TAG_KEY]: isRequestAcquired ? 1 : 0
          });
        }
      }
      startContext(store = storage("legacy").getStore()) {
        let isRequestAcquired = false;
        let iastContext;
        if (store) {
          const topContext = this.getTopContext();
          const rootSpan = this.getRootSpan(store);
          isRequestAcquired = overheadController.acquireRequest(rootSpan);
          if (isRequestAcquired) {
            iastContext = iastContextFunctions.saveIastContext(store, topContext, this.newIastContext(rootSpan));
            createTransaction(rootSpan.context().toSpanId(), iastContext);
            overheadController.initializeRequestContext(iastContext);
          }
          this.addIastEnabledTag(isRequestAcquired, rootSpan);
        }
        return {
          isRequestAcquired,
          iastContext,
          store
        };
      }
      finishContext() {
        const store = storage("legacy").getStore();
        if (store) {
          const topContext = this.getTopContext();
          const iastContext = iastContextFunctions.getIastContext(store, topContext);
          const rootSpan = iastContext?.rootSpan;
          if (iastContext && rootSpan) {
            vulnerabilityReporter.sendVulnerabilities(iastContext.vulnerabilities, rootSpan);
            removeTransaction(iastContext);
          }
          if (iastContextFunctions.cleanIastContext(store, topContext, iastContext)) {
            overheadController.releaseRequest();
          }
        }
      }
    };
    module2.exports = IastContextPlugin;
  }
});

// ../../packages/dd-trace/src/appsec/iast/context/kafka-ctx-plugin.js
var require_kafka_ctx_plugin = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/context/kafka-ctx-plugin.js"(exports2, module2) {
    "use strict";
    var { KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE } = require_source_types();
    var IastContextPlugin = require_context_plugin();
    var KafkaContextPlugin = class extends IastContextPlugin {
      onConfigure() {
        this.startCtxOn("dd-trace:kafkajs:consumer:afterStart", [KAFKA_MESSAGE_KEY, KAFKA_MESSAGE_VALUE]);
        this.finishCtxOn("dd-trace:kafkajs:consumer:beforeFinish");
      }
    };
    module2.exports = new KafkaContextPlugin();
  }
});

// ../../packages/dd-trace/src/appsec/iast/taint-tracking/index.js
var require_taint_tracking = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/taint-tracking/index.js"(exports2, module2) {
    "use strict";
    var {
      createTransaction,
      removeTransaction,
      setMaxTransactions,
      enableTaintOperations,
      disableTaintOperations
    } = require_operations();
    var taintTrackingPlugin = require_plugin2();
    var kafkaConsumerPlugin = require_kafka();
    var kafkaContextPlugin = require_kafka_ctx_plugin();
    module2.exports = {
      enableTaintTracking(config, telemetryVerbosity) {
        enableTaintOperations(telemetryVerbosity);
        taintTrackingPlugin.enable(config);
        kafkaContextPlugin.enable(config);
        kafkaConsumerPlugin.enable(config);
        setMaxTransactions(config.maxConcurrentRequests);
      },
      disableTaintTracking() {
        disableTaintOperations();
        taintTrackingPlugin.disable();
        kafkaContextPlugin.disable();
        kafkaConsumerPlugin.disable();
      },
      setMaxTransactions,
      createTransaction,
      removeTransaction,
      taintTrackingPlugin
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/security-controls/parser.js
var require_parser = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/security-controls/parser.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { getMarkFromVulnerabilityType, CUSTOM_SECURE_MARK } = require_secure_marks();
    var SECURITY_CONTROL_DELIMITER = ";";
    var SECURITY_CONTROL_FIELD_DELIMITER = ":";
    var SECURITY_CONTROL_ELEMENT_DELIMITER = ",";
    var INPUT_VALIDATOR_TYPE = "INPUT_VALIDATOR";
    var SANITIZER_TYPE = "SANITIZER";
    var validTypes = /* @__PURE__ */ new Set([INPUT_VALIDATOR_TYPE, SANITIZER_TYPE]);
    function parse(securityControlsConfiguration) {
      const controls = /* @__PURE__ */ new Map();
      securityControlsConfiguration?.replaceAll(/[\r\n\t\v\f]*/g, "").split(SECURITY_CONTROL_DELIMITER).map(parseControl).filter((control) => !!control).forEach((control) => {
        if (!controls.has(control.file)) {
          controls.set(control.file, []);
        }
        controls.get(control.file).push(control);
      });
      return controls;
    }
    function parseControl(control) {
      if (!control) return;
      const fields = control.split(SECURITY_CONTROL_FIELD_DELIMITER);
      if (fields.length < 3 || fields.length > 5) {
        log.warn("[ASM] Security control configuration is invalid: %s", control);
        return;
      }
      let [type, marks, file, method, parameters] = fields;
      type = type.trim().toUpperCase();
      if (!validTypes.has(type)) {
        log.warn("[ASM] Invalid security control type: %s", type);
        return;
      }
      let secureMarks = CUSTOM_SECURE_MARK;
      getSecureMarks(marks).forEach((mark) => {
        secureMarks |= mark;
      });
      if (secureMarks === CUSTOM_SECURE_MARK) {
        log.warn("[ASM] Invalid security control mark: %s", marks);
        return;
      }
      file = file?.trim();
      method = method?.trim();
      try {
        parameters = getParameters(parameters);
      } catch {
        log.warn("[ASM] Invalid non-numeric security control parameter %s", parameters);
        return;
      }
      return { type, secureMarks, file, method, parameters };
    }
    function getSecureMarks(marks) {
      return marks?.split(SECURITY_CONTROL_ELEMENT_DELIMITER).map(getMarkFromVulnerabilityType).filter((mark) => !!mark);
    }
    function getParameters(parameters) {
      return parameters?.split(SECURITY_CONTROL_ELEMENT_DELIMITER).map((param) => {
        const parsedParam = Number.parseInt(param, 10);
        if (Number.isNaN(parsedParam)) {
          throw new TypeError("Invalid non-numeric security control parameter");
        }
        return parsedParam;
      });
    }
    module2.exports = {
      parse,
      INPUT_VALIDATOR_TYPE,
      SANITIZER_TYPE
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/security-controls/index.js
var require_security_controls = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/security-controls/index.js"(exports2, module2) {
    "use strict";
    var path = __require("path");
    var dc = require_dc_polyfill();
    var { storage } = require_datadog_core();
    var shimmer = require_datadog_shimmer();
    var log = require_log2();
    var { parse, SANITIZER_TYPE } = require_parser();
    var TaintTrackingOperations = require_operations();
    var { getIastContext } = require_iast_context();
    var { iterateObjectStrings } = require_utils11();
    var moduleLoadStartChannel = dc.channel("dd-trace:moduleLoadStart");
    var moduleLoadEndChannel = dc.channel("dd-trace:moduleLoadEnd");
    var controls;
    var controlsKeys;
    var hooks;
    function configure(iastConfig) {
      if (!iastConfig?.securityControlsConfiguration) return;
      try {
        controls = parse(iastConfig.securityControlsConfiguration);
        if (controls?.size > 0) {
          hooks = /* @__PURE__ */ new WeakSet();
          controlsKeys = [...controls.keys()];
          moduleLoadStartChannel.subscribe(onModuleLoaded);
          moduleLoadEndChannel.subscribe(onModuleLoaded);
        }
      } catch (e) {
        log.error("[ASM] Error configuring IAST Security Controls", e);
      }
    }
    function onModuleLoaded(payload) {
      if (!payload?.module || hooks?.has(payload.module)) return;
      const { filename, module: module3 } = payload;
      const controlsByFile = getControls(filename);
      if (controlsByFile) {
        const hook = hookModule(filename, module3, controlsByFile);
        payload.module = hook;
        hooks.add(hook);
      }
    }
    function getControls(filename) {
      if (filename.startsWith("file://")) {
        filename = filename.slice(7);
      }
      let key = path.isAbsolute(filename) ? path.relative(process.cwd(), filename) : filename;
      key = key.replaceAll(path.sep, path.posix.sep);
      if (key.includes("node_modules")) {
        key = controlsKeys.find((file) => key.endsWith(file));
      }
      return controls.get(key);
    }
    function hookModule(filename, module3, controlsByFile) {
      try {
        controlsByFile.forEach(({ type, method, parameters, secureMarks }) => {
          const { target, parent, methodName } = resolve(method, module3);
          if (!target) {
            log.error("[ASM] Unable to resolve IAST security control %s:%s", filename, method);
            return;
          }
          const wrapper = type === SANITIZER_TYPE ? wrapSanitizer(target, secureMarks) : wrapInputValidator(target, parameters, secureMarks);
          if (methodName) {
            parent[methodName] = wrapper;
          } else {
            module3 = wrapper;
          }
        });
      } catch (e) {
        log.error("[ASM] Error initializing IAST security control for %s", filename, e);
      }
      return module3;
    }
    function resolve(path2, obj, separator = ".") {
      if (!path2) {
        return obj?.default ? { target: obj.default, parent: obj, methodName: "default" } : { target: obj, parent: obj };
      }
      const properties = path2.split(separator);
      let parent;
      let methodName;
      const target = properties.reduce((prev, curr) => {
        parent = prev;
        methodName = curr;
        return prev?.[curr];
      }, obj);
      return { target, parent, methodName };
    }
    function wrapSanitizer(target, secureMarks) {
      return shimmer.wrapFunction(target, (orig) => function() {
        const result = orig.apply(this, arguments);
        try {
          return addSecureMarks(result, secureMarks);
        } catch (e) {
          log.error("[ASM] Error adding Secure mark for sanitizer", e);
        }
        return result;
      });
    }
    function wrapInputValidator(target, parameters, secureMarks) {
      const allParameters = !parameters?.length;
      return shimmer.wrapFunction(target, (orig) => function() {
        try {
          [...arguments].forEach((arg, index) => {
            if (allParameters || parameters.includes(index)) {
              addSecureMarks(arg, secureMarks, false);
            }
          });
        } catch (e) {
          log.error("[ASM] Error adding Secure mark for input validator", e);
        }
        return orig.apply(this, arguments);
      });
    }
    function addSecureMarks(value, secureMarks, createNewTainted = true) {
      if (!value) return;
      const store = storage("legacy").getStore();
      const iastContext = getIastContext(store);
      if (typeof value === "string") {
        return TaintTrackingOperations.addSecureMark(iastContext, value, secureMarks, createNewTainted);
      }
      iterateObjectStrings(value, (value2, levelKeys, parent, lastKey) => {
        try {
          const securedTainted = TaintTrackingOperations.addSecureMark(iastContext, value2, secureMarks, createNewTainted);
          if (createNewTainted) {
            parent[lastKey] = securedTainted;
          }
        } catch {
        }
      });
      return value;
    }
    function disable() {
      if (moduleLoadStartChannel.hasSubscribers) moduleLoadStartChannel.unsubscribe(onModuleLoaded);
      if (moduleLoadEndChannel.hasSubscribers) moduleLoadEndChannel.unsubscribe(onModuleLoaded);
      controls = void 0;
      controlsKeys = void 0;
      hooks = void 0;
    }
    module2.exports = {
      configure,
      disable
    };
  }
});

// ../../packages/dd-trace/src/appsec/iast/index.js
var require_iast = __commonJS({
  "../../packages/dd-trace/src/appsec/iast/index.js"(exports2, module2) {
    "use strict";
    var vulnerabilityReporter = require_vulnerability_reporter();
    var { enableAllAnalyzers, disableAllAnalyzers } = require_analyzers2();
    var web = require_web3();
    var { storage } = require_datadog_core();
    var overheadController = require_overhead_controller();
    var dc = require_dc_polyfill();
    var iastContextFunctions = require_iast_context();
    var {
      enableTaintTracking,
      disableTaintTracking,
      createTransaction,
      removeTransaction,
      taintTrackingPlugin
    } = require_taint_tracking();
    var { IAST_ENABLED_TAG_KEY } = require_tags4();
    var iastTelemetry = require_telemetry7();
    var { enable: enableFsPlugin, disable: disableFsPlugin, IAST_MODULE } = require_fs_plugin();
    var securityControls = require_security_controls();
    var { incomingHttpRequestStart, incomingHttpRequestEnd, responseWriteHead } = require_channels2();
    var collectedResponseHeaders = /* @__PURE__ */ new WeakMap();
    var iastResponseEnd = dc.channel("datadog:iast:response-end");
    var isEnabled = false;
    function enable(config, _tracer) {
      if (isEnabled) return;
      iastTelemetry.configure(config, config.iast?.telemetryVerbosity);
      enableFsPlugin(IAST_MODULE);
      enableAllAnalyzers(config);
      enableTaintTracking(config.iast, iastTelemetry.verbosity);
      incomingHttpRequestStart.subscribe(onIncomingHttpRequestStart);
      incomingHttpRequestEnd.subscribe(onIncomingHttpRequestEnd);
      responseWriteHead.subscribe(onResponseWriteHeadCollect);
      overheadController.configure(config.iast);
      overheadController.startGlobalContext();
      securityControls.configure(config.iast);
      vulnerabilityReporter.start(config, _tracer);
      isEnabled = true;
    }
    function disable() {
      if (!isEnabled) return;
      isEnabled = false;
      iastTelemetry.stop();
      disableFsPlugin(IAST_MODULE);
      disableAllAnalyzers();
      disableTaintTracking();
      overheadController.finishGlobalContext();
      if (incomingHttpRequestStart.hasSubscribers) incomingHttpRequestStart.unsubscribe(onIncomingHttpRequestStart);
      if (incomingHttpRequestEnd.hasSubscribers) incomingHttpRequestEnd.unsubscribe(onIncomingHttpRequestEnd);
      if (responseWriteHead.hasSubscribers) responseWriteHead.unsubscribe(onResponseWriteHeadCollect);
      vulnerabilityReporter.stop();
    }
    function onIncomingHttpRequestStart(data) {
      if (data?.req) {
        const store = storage("legacy").getStore();
        if (store) {
          const topContext = web.getContext(data.req);
          if (topContext) {
            const rootSpan = topContext.span;
            const isRequestAcquired = overheadController.acquireRequest(rootSpan);
            if (isRequestAcquired) {
              const iastContext = iastContextFunctions.saveIastContext(store, topContext, { rootSpan, req: data.req });
              createTransaction(rootSpan.context().toSpanId(), iastContext);
              overheadController.initializeRequestContext(iastContext);
              iastTelemetry.onRequestStart(iastContext);
              taintTrackingPlugin.taintRequest(data.req, iastContext);
            }
            if (rootSpan.addTags) {
              rootSpan.addTags({
                [IAST_ENABLED_TAG_KEY]: isRequestAcquired ? 1 : 0
              });
            }
          }
        }
      }
    }
    function onIncomingHttpRequestEnd(data) {
      if (data?.req) {
        const store = storage("legacy").getStore();
        const topContext = web.getContext(data.req);
        const iastContext = iastContextFunctions.getIastContext(store, topContext);
        if (iastContext?.rootSpan) {
          const storedHeaders = collectedResponseHeaders.get(data.res) || {};
          iastResponseEnd.publish({ ...data, storedHeaders });
          if (Object.keys(storedHeaders).length) {
            collectedResponseHeaders.delete(data.res);
          }
          const vulnerabilities = iastContext.vulnerabilities;
          const rootSpan = iastContext.rootSpan;
          vulnerabilityReporter.sendVulnerabilities(vulnerabilities, rootSpan);
          overheadController.consolidateVulnerabilities(iastContext);
          removeTransaction(iastContext);
          iastTelemetry.onRequestEnd(iastContext, iastContext.rootSpan);
        }
        if (iastContextFunctions.cleanIastContext(store, topContext, iastContext)) {
          overheadController.releaseRequest();
        }
      }
    }
    function onResponseWriteHeadCollect({ res, responseHeaders = {} }) {
      if (!res) return;
      if (Object.keys(responseHeaders).length) {
        collectedResponseHeaders.set(res, responseHeaders);
      }
    }
    module2.exports = { enable, disable, onIncomingHttpRequestEnd, onIncomingHttpRequestStart };
  }
});

// ../../packages/dd-trace/src/llmobs/constants/text.js
var require_text = __commonJS({
  "../../packages/dd-trace/src/llmobs/constants/text.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      DROPPED_VALUE_TEXT: "[This value has been dropped because this span's size exceeds the 1MB size limit.]",
      UNSERIALIZABLE_VALUE_TEXT: "Unserializable value"
    };
  }
});

// ../../packages/dd-trace/src/llmobs/span_processor.js
var require_span_processor3 = __commonJS({
  "../../packages/dd-trace/src/llmobs/span_processor.js"(exports2, module2) {
    "use strict";
    var {
      SPAN_KIND,
      MODEL_NAME,
      MODEL_PROVIDER,
      METADATA,
      INPUT_MESSAGES,
      INPUT_VALUE,
      INTEGRATION,
      OUTPUT_MESSAGES,
      INPUT_DOCUMENTS,
      OUTPUT_DOCUMENTS,
      OUTPUT_VALUE,
      METRICS,
      ML_APP,
      TAGS,
      PARENT_ID_KEY,
      SESSION_ID,
      NAME
    } = require_tags3();
    var { UNSERIALIZABLE_VALUE_TEXT } = require_text();
    var {
      ERROR_MESSAGE,
      ERROR_TYPE,
      ERROR_STACK
    } = require_constants3();
    var telemetry = require_telemetry4();
    var LLMObsTagger = require_tagger2();
    var tracerVersion = require_package().version;
    var logger = require_log2();
    var util = __require("node:util");
    var LLMObservabilitySpan = class {
      constructor() {
        this.input = [];
        this.output = [];
        this._tags = {};
      }
      getTag(key) {
        return this._tags[key];
      }
    };
    var LLMObsSpanProcessor = class {
      /** @type {import('../config')} */
      #config;
      /** @type {((span: LLMObservabilitySpan) => LLMObservabilitySpan | null) | null} */
      #userSpanProcessor;
      /** @type {import('./writers/spans')} */
      #writer;
      constructor(config) {
        this.#config = config;
      }
      setUserSpanProcessor(userSpanProcessor) {
        this.#userSpanProcessor = userSpanProcessor;
      }
      setWriter(writer) {
        this.#writer = writer;
      }
      // TODO: instead of relying on the tagger's weakmap registry, can we use some namespaced storage correlation?
      process({ span }) {
        if (!this.#config.llmobs.enabled) return;
        if (!LLMObsTagger.tagMap.has(span)) return;
        try {
          const formattedEvent = this.format(span);
          telemetry.incrementLLMObsSpanFinishedCount(span);
          if (formattedEvent == null) return;
          this.#writer.append(formattedEvent);
        } catch (e) {
          logger.warn(`
        Failed to append span to LLM Observability writer, likely due to an unserializable property.
        Span won't be sent to LLM Observability: ${e.message}
      `);
        }
      }
      format(span) {
        const llmObsSpan = new LLMObservabilitySpan();
        let inputType, outputType;
        const spanTags = span.context()._tags;
        const mlObsTags = LLMObsTagger.tagMap.get(span);
        const spanKind = mlObsTags[SPAN_KIND];
        const meta = { "span.kind": spanKind, input: {}, output: {} };
        const input = {};
        const output = {};
        if (["llm", "embedding"].includes(spanKind)) {
          meta.model_name = mlObsTags[MODEL_NAME] || "custom";
          meta.model_provider = (mlObsTags[MODEL_PROVIDER] || "custom").toLowerCase();
        }
        if (mlObsTags[METADATA]) {
          this.#addObject(mlObsTags[METADATA], meta.metadata = {});
        }
        if (spanKind === "llm" && mlObsTags[INPUT_MESSAGES]) {
          llmObsSpan.input = mlObsTags[INPUT_MESSAGES];
          inputType = "messages";
        } else if (spanKind === "embedding" && mlObsTags[INPUT_DOCUMENTS]) {
          input.documents = mlObsTags[INPUT_DOCUMENTS];
        } else if (mlObsTags[INPUT_VALUE]) {
          llmObsSpan.input = [{ role: "", content: mlObsTags[INPUT_VALUE] }];
          inputType = "value";
        }
        if (spanKind === "llm" && mlObsTags[OUTPUT_MESSAGES]) {
          llmObsSpan.output = mlObsTags[OUTPUT_MESSAGES];
          outputType = "messages";
        } else if (spanKind === "retrieval" && mlObsTags[OUTPUT_DOCUMENTS]) {
          output.documents = mlObsTags[OUTPUT_DOCUMENTS];
        } else if (mlObsTags[OUTPUT_VALUE]) {
          llmObsSpan.output = [{ role: "", content: mlObsTags[OUTPUT_VALUE] }];
          outputType = "value";
        }
        const error = spanTags.error || spanTags[ERROR_TYPE];
        if (error) {
          meta[ERROR_MESSAGE] = spanTags[ERROR_MESSAGE] || error.message || error.code;
          meta[ERROR_TYPE] = spanTags[ERROR_TYPE] || error.name;
          meta[ERROR_STACK] = spanTags[ERROR_STACK] || error.stack;
        }
        const metrics2 = mlObsTags[METRICS] || {};
        const mlApp = mlObsTags[ML_APP];
        const sessionId = mlObsTags[SESSION_ID];
        const parentId = mlObsTags[PARENT_ID_KEY];
        const name = mlObsTags[NAME] || span._name;
        const tags = this.#getTags(span, mlApp, sessionId, error);
        llmObsSpan._tags = tags;
        const processedSpan = this.#runProcessor(llmObsSpan);
        if (processedSpan === null) return null;
        if (processedSpan.input) {
          if (inputType === "messages") {
            input.messages = processedSpan.input;
          } else if (inputType === "value") {
            input.value = processedSpan.input[0].content;
          }
        }
        if (processedSpan.output) {
          if (outputType === "messages") {
            output.messages = processedSpan.output;
          } else if (outputType === "value") {
            output.value = processedSpan.output[0].content;
          }
        }
        if (input) meta.input = input;
        if (output) meta.output = output;
        const llmObsSpanEvent = {
          trace_id: span.context().toTraceId(true),
          span_id: span.context().toSpanId(),
          parent_id: parentId,
          name,
          tags: this.#objectTagsToStringArrayTags(tags),
          start_ns: Math.round(span._startTime * 1e6),
          duration: Math.round(span._duration * 1e6),
          status: error ? "error" : "ok",
          meta,
          metrics: metrics2,
          _dd: {
            span_id: span.context().toSpanId(),
            trace_id: span.context().toTraceId(true)
          }
        };
        if (sessionId) llmObsSpanEvent.session_id = sessionId;
        return llmObsSpanEvent;
      }
      // For now, this only applies to metadata, as we let users annotate this field with any object
      // However, we want to protect against circular references or BigInts (unserializable)
      // This function can be reused for other fields if needed
      // Messages, Documents, and Metrics are safeguarded in `llmobs/tagger.js`
      #addObject(obj, carrier) {
        const seenObjects = /* @__PURE__ */ new WeakSet();
        seenObjects.add(obj);
        const isCircular = (value) => {
          if (typeof value !== "object") return false;
          if (seenObjects.has(value)) return true;
          seenObjects.add(value);
          return false;
        };
        const add = (obj2, carrier2) => {
          for (const key in obj2) {
            const value = obj2[key];
            if (!Object.hasOwn(obj2, key)) continue;
            if (typeof value === "bigint" || isCircular(value)) {
              logger.warn(`Unserializable property found in metadata: ${key}`);
              carrier2[key] = UNSERIALIZABLE_VALUE_TEXT;
              continue;
            }
            if (value !== null && typeof value === "object") {
              add(value, carrier2[key] = {});
            } else {
              carrier2[key] = value;
            }
          }
        };
        add(obj, carrier);
      }
      #getTags(span, mlApp, sessionId, error) {
        let tags = {
          ...this.#config.parsedDdTags,
          version: this.#config.version,
          env: this.#config.env,
          service: this.#config.service,
          source: "integration",
          ml_app: mlApp,
          "ddtrace.version": tracerVersion,
          error: Number(!!error) || 0,
          language: "javascript"
        };
        const errType = span.context()._tags[ERROR_TYPE] || error?.name;
        if (errType) tags.error_type = errType;
        if (sessionId) tags.session_id = sessionId;
        const integration = LLMObsTagger.tagMap.get(span)?.[INTEGRATION];
        if (integration) tags.integration = integration;
        const existingTags = LLMObsTagger.tagMap.get(span)?.[TAGS] || {};
        if (existingTags) tags = { ...tags, ...existingTags };
        return tags;
      }
      #objectTagsToStringArrayTags(tags) {
        return Object.entries(tags).map(([key, value]) => `${key}:${value ?? ""}`);
      }
      /**
       * Runs the user span processor, emitting telemetry and adding some guardrails against invalid return types
       * @param {LLMObservabilitySpan} span
       * @returns {LLMObservabilitySpan | null}
       */
      #runProcessor(span) {
        const processor = this.#userSpanProcessor;
        if (!processor) return span;
        let error = false;
        try {
          const processedLLMObsSpan = processor(span);
          if (processedLLMObsSpan === null) return null;
          if (!(processedLLMObsSpan instanceof LLMObservabilitySpan)) {
            error = true;
            logger.warn("User span processor must return an instance of an LLMObservabilitySpan or null, dropping span.");
            return null;
          }
          return processedLLMObsSpan;
        } catch (e) {
          logger.error(`[LLMObs] Error in LLMObs span processor (${util.inspect(processor)}): ${util.inspect(e)}`);
          error = true;
        } finally {
          telemetry.recordLLMObsUserProcessorCalled(error);
        }
      }
    };
    module2.exports = LLMObsSpanProcessor;
  }
});

// ../../packages/dd-trace/src/llmobs/constants/writers.js
var require_writers = __commonJS({
  "../../packages/dd-trace/src/llmobs/constants/writers.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      EVP_PROXY_AGENT_BASE_PATH: "/evp_proxy/v2/",
      EVP_SUBDOMAIN_HEADER_NAME: "X-Datadog-EVP-Subdomain",
      SPANS_EVENT_TYPE: "span",
      SPANS_INTAKE: "llmobs-intake",
      SPANS_ENDPOINT: "/api/v2/llmobs",
      EVALUATIONS_INTAKE: "api",
      EVALUATIONS_EVENT_TYPE: "evaluation_metric",
      EVALUATIONS_ENDPOINT: "/api/intake/llm-obs/v1/eval-metric",
      EVP_PAYLOAD_SIZE_LIMIT: 5 << 20,
      // 5MB (actual limit is 5.1MB)
      EVP_EVENT_SIZE_LIMIT: (1 << 20) - 1024
      // 999KB (actual limit is 1MB)
    };
  }
});

// ../../packages/dd-trace/src/llmobs/writers/util.js
var require_util14 = __commonJS({
  "../../packages/dd-trace/src/llmobs/writers/util.js"(exports2, module2) {
    "use strict";
    var logger = require_log2();
    var { EVP_PROXY_AGENT_BASE_PATH } = require_writers();
    var telemetry = require_telemetry4();
    var AgentInfoExporter = require_agent_info_exporter();
    var agentInfoExporter;
    function setAgentStrategy(config, setWritersAgentlessValue) {
      const agentlessEnabled = config.llmobs.agentlessEnabled;
      if (agentlessEnabled != null) {
        setWritersAgentlessValue(agentlessEnabled);
        return;
      }
      if (!agentInfoExporter) {
        agentInfoExporter = new AgentInfoExporter(config);
      }
      agentInfoExporter.getAgentInfo((err, agentInfo) => {
        if (err) {
          setWritersAgentlessValue(true);
          return;
        }
        const endpoints = agentInfo.endpoints;
        const hasEndpoint = Array.isArray(endpoints) && endpoints.includes(EVP_PROXY_AGENT_BASE_PATH);
        setWritersAgentlessValue(!hasEndpoint);
      });
    }
    function parseResponseAndLog(err, code, eventsLength, url, eventType) {
      if (code === 403 && err.message.includes("API key is invalid")) {
        logger.error(
          "[LLMObs] The provided Datadog API key is invalid (likely due to an API key and DD_SITE mismatch). Please verify your API key and DD_SITE are correct."
        );
        telemetry.recordDroppedPayload(eventsLength, eventType, "request_error");
      } else if (err) {
        logger.error(
          "Error sending %d LLMObs %s events to %s: %s",
          eventsLength,
          eventType,
          url,
          err.message,
          err
        );
        telemetry.recordDroppedPayload(eventsLength, eventType, "request_error");
      } else if (code >= 300) {
        logger.error(
          "Error sending %d LLMObs %s events to %s: %s",
          eventsLength,
          eventType,
          url,
          code
        );
        telemetry.recordDroppedPayload(eventsLength, eventType, "http_error");
      } else {
        logger.debug(`Sent ${eventsLength} LLMObs ${eventType} events to ${url}`);
      }
    }
    module2.exports = {
      setAgentStrategy,
      parseResponseAndLog
    };
  }
});

// ../../packages/dd-trace/src/llmobs/writers/base.js
var require_base3 = __commonJS({
  "../../packages/dd-trace/src/llmobs/writers/base.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var { getEnvironmentVariable } = require_config_helper();
    var { URL: URL2, format } = __require("node:url");
    var path = __require("node:path");
    var logger = require_log2();
    var { encodeUnicode } = require_util8();
    var telemetry = require_telemetry4();
    var log = require_log2();
    var {
      EVP_SUBDOMAIN_HEADER_NAME,
      EVP_PROXY_AGENT_BASE_PATH
    } = require_writers();
    var { parseResponseAndLog } = require_util14();
    var BaseLLMObsWriter = class {
      constructor({ interval, timeout, eventType, config, endpoint, intake }) {
        this._interval = interval ?? getEnvironmentVariable("_DD_LLMOBS_FLUSH_INTERVAL") ?? 1e3;
        this._timeout = timeout ?? getEnvironmentVariable("_DD_LLMOBS_TIMEOUT") ?? 5e3;
        this._eventType = eventType;
        this._buffer = [];
        this._bufferLimit = 1e3;
        this._bufferSize = 0;
        this._config = config;
        this._endpoint = endpoint;
        this._intake = intake;
        this._periodic = setInterval(() => {
          this.flush();
        }, this._interval).unref();
        this._beforeExitHandler = () => {
          this.destroy();
        };
        process.once("beforeExit", this._beforeExitHandler);
        this._destroyed = false;
      }
      get url() {
        if (this._agentless == null) return null;
        const baseUrl = this._baseUrl.href;
        const endpoint = this._endpoint;
        const [protocol, rest] = baseUrl.split("://");
        return protocol + "://" + path.join(rest, endpoint);
      }
      append(event, byteLength) {
        if (this._buffer.length >= this._bufferLimit) {
          logger.warn(`${this.constructor.name} event buffer full (limit is ${this._bufferLimit}), dropping event`);
          telemetry.recordDroppedPayload(1, this._eventType, "buffer_full");
          return;
        }
        this._bufferSize += byteLength || Buffer.byteLength(JSON.stringify(event));
        this._buffer.push(event);
      }
      flush() {
        const noAgentStrategy = this._agentless == null;
        if (this._buffer.length === 0 || noAgentStrategy) {
          return;
        }
        const events = this._buffer;
        this._buffer = [];
        this._bufferSize = 0;
        const payload = this._encode(this.makePayload(events));
        log.debug("Encoded LLMObs payload: %s", payload);
        const options = this._getOptions();
        request2(payload, options, (err, resp, code) => {
          parseResponseAndLog(err, code, events.length, this.url, this._eventType);
        });
      }
      makePayload(events) {
      }
      destroy() {
        if (!this._destroyed) {
          logger.debug(`Stopping ${this.constructor.name}`);
          clearInterval(this._periodic);
          process.removeListener("beforeExit", this._beforeExitHandler);
          this.flush();
          this._destroyed = true;
        }
      }
      setAgentless(agentless) {
        this._agentless = agentless;
        const { url, endpoint } = this._getUrlAndPath();
        this._baseUrl = url;
        this._endpoint = endpoint;
        logger.debug(`Configuring ${this.constructor.name} to ${this.url}`);
      }
      _getUrlAndPath() {
        if (this._agentless) {
          return {
            url: new URL2(format({
              protocol: "https:",
              hostname: `${this._intake}.${this._config.site}`
            })),
            endpoint: this._endpoint
          };
        }
        const { hostname, port } = this._config;
        const overrideOriginEnv = getEnvironmentVariable("_DD_LLMOBS_OVERRIDE_ORIGIN");
        const overrideOriginUrl = overrideOriginEnv && new URL2(overrideOriginEnv);
        const base = overrideOriginUrl ?? this._config.url ?? new URL2(format({
          protocol: "http:",
          hostname,
          port
        }));
        return {
          url: base,
          endpoint: path.join(EVP_PROXY_AGENT_BASE_PATH, this._endpoint)
        };
      }
      _getOptions() {
        const options = {
          headers: {
            "Content-Type": "application/json"
          },
          method: "POST",
          timeout: this._timeout,
          url: this._baseUrl,
          path: this._endpoint
        };
        if (this._agentless) {
          options.headers["DD-API-KEY"] = this._config.apiKey || "";
        } else {
          options.headers[EVP_SUBDOMAIN_HEADER_NAME] = this._intake;
        }
        return options;
      }
      _encode(payload) {
        return JSON.stringify(payload, (key, value) => {
          if (typeof value === "string") {
            return encodeUnicode(value);
          }
          return value;
        }).replaceAll(String.raw`\\u`, String.raw`\u`);
      }
    };
    module2.exports = BaseLLMObsWriter;
  }
});

// ../../packages/dd-trace/src/llmobs/writers/evaluations.js
var require_evaluations = __commonJS({
  "../../packages/dd-trace/src/llmobs/writers/evaluations.js"(exports2, module2) {
    "use strict";
    var {
      EVALUATIONS_ENDPOINT,
      EVALUATIONS_EVENT_TYPE,
      EVALUATIONS_INTAKE
    } = require_writers();
    var BaseWriter = require_base3();
    var LLMObsEvalMetricsWriter = class extends BaseWriter {
      constructor(config) {
        super({
          config,
          intake: EVALUATIONS_INTAKE,
          eventType: EVALUATIONS_EVENT_TYPE,
          endpoint: EVALUATIONS_ENDPOINT
        });
      }
      makePayload(events) {
        return {
          data: {
            type: this._eventType,
            attributes: {
              metrics: events
            }
          }
        };
      }
    };
    module2.exports = LLMObsEvalMetricsWriter;
  }
});

// ../../packages/dd-trace/src/llmobs/writers/spans.js
var require_spans = __commonJS({
  "../../packages/dd-trace/src/llmobs/writers/spans.js"(exports2, module2) {
    "use strict";
    var {
      EVP_EVENT_SIZE_LIMIT,
      EVP_PAYLOAD_SIZE_LIMIT,
      SPANS_ENDPOINT,
      SPANS_EVENT_TYPE,
      SPANS_INTAKE
    } = require_writers();
    var { DROPPED_VALUE_TEXT } = require_text();
    var { DROPPED_IO_COLLECTION_ERROR } = require_tags3();
    var BaseWriter = require_base3();
    var telemetry = require_telemetry4();
    var logger = require_log2();
    var tracerVersion = require_package().version;
    var LLMObsSpanWriter = class extends BaseWriter {
      constructor(config) {
        super({
          config,
          eventType: SPANS_EVENT_TYPE,
          intake: SPANS_INTAKE,
          endpoint: SPANS_ENDPOINT
        });
      }
      append(event) {
        const eventSizeBytes = Buffer.byteLength(JSON.stringify(event));
        telemetry.recordLLMObsRawSpanSize(event, eventSizeBytes);
        const shouldTruncate = eventSizeBytes > EVP_EVENT_SIZE_LIMIT;
        let processedEventSizeBytes = eventSizeBytes;
        if (shouldTruncate) {
          logger.warn(`Dropping event input/output because its size (${eventSizeBytes}) exceeds the 1MB event size limit`);
          event = this._truncateSpanEvent(event);
          processedEventSizeBytes = Buffer.byteLength(JSON.stringify(event));
        }
        telemetry.recordLLMObsSpanSize(event, processedEventSizeBytes, shouldTruncate);
        if (this._bufferSize + eventSizeBytes > EVP_PAYLOAD_SIZE_LIMIT) {
          logger.debug("Flushing queue because queuing next event will exceed EvP payload limit");
          this.flush();
        }
        super.append(event, processedEventSizeBytes);
      }
      makePayload(events) {
        return events.map((event) => ({
          "_dd.stage": "raw",
          "_dd.tracer_version": tracerVersion,
          event_type: this._eventType,
          spans: [event]
        }));
      }
      _truncateSpanEvent(event) {
        event.meta.input = { value: DROPPED_VALUE_TEXT };
        event.meta.output = { value: DROPPED_VALUE_TEXT };
        event.collection_errors = [DROPPED_IO_COLLECTION_ERROR];
        return event;
      }
    };
    module2.exports = LLMObsSpanWriter;
  }
});

// ../../packages/dd-trace/src/llmobs/index.js
var require_llmobs = __commonJS({
  "../../packages/dd-trace/src/llmobs/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var {
      ML_APP,
      PROPAGATED_ML_APP_KEY,
      PROPAGATED_PARENT_ID_KEY
    } = require_tags3();
    var { storage } = require_storage4();
    var telemetry = require_telemetry4();
    var LLMObsSpanProcessor = require_span_processor3();
    var { channel } = require_dc_polyfill();
    var spanProcessCh = channel("dd-trace:span:process");
    var evalMetricAppendCh = channel("llmobs:eval-metric:append");
    var flushCh = channel("llmobs:writers:flush");
    var injectCh = channel("dd-trace:span:inject");
    var registerUserSpanProcessorCh = channel("llmobs:register-processor");
    var LLMObsEvalMetricsWriter = require_evaluations();
    var LLMObsTagger = require_tagger2();
    var LLMObsSpanWriter = require_spans();
    var { setAgentStrategy } = require_util14();
    var util = __require("node:util");
    var spanProcessor;
    var spanWriter;
    var evalWriter;
    var globalTracerConfig;
    function enable(config) {
      globalTracerConfig = config;
      const startTime = performance.now();
      evalWriter = new LLMObsEvalMetricsWriter(config);
      spanWriter = new LLMObsSpanWriter(config);
      evalMetricAppendCh.subscribe(handleEvalMetricAppend);
      flushCh.subscribe(handleFlush);
      registerUserSpanProcessorCh.subscribe(handleRegisterProcessor);
      spanProcessor = new LLMObsSpanProcessor(config);
      spanProcessor.setWriter(spanWriter);
      spanProcessCh.subscribe(handleSpanProcess);
      injectCh.subscribe(handleLLMObsParentIdInjection);
      setAgentStrategy(config, (useAgentless) => {
        if (useAgentless && !(config.apiKey && config.site)) {
          throw new Error(
            "Cannot send LLM Observability data without a running agent or without both a Datadog API key and site.\nEnsure these configurations are set before running your application."
          );
        }
        evalWriter?.setAgentless(useAgentless);
        spanWriter?.setAgentless(useAgentless);
        telemetry.recordLLMObsEnabled(startTime, config);
        log.debug(`[LLMObs] Enabled LLM Observability with configuration: ${util.inspect(config.llmobs)}`);
      });
    }
    function disable() {
      if (evalMetricAppendCh.hasSubscribers) evalMetricAppendCh.unsubscribe(handleEvalMetricAppend);
      if (flushCh.hasSubscribers) flushCh.unsubscribe(handleFlush);
      if (spanProcessCh.hasSubscribers) spanProcessCh.unsubscribe(handleSpanProcess);
      if (injectCh.hasSubscribers) injectCh.unsubscribe(handleLLMObsParentIdInjection);
      if (registerUserSpanProcessorCh.hasSubscribers) registerUserSpanProcessorCh.unsubscribe(handleRegisterProcessor);
      spanWriter?.destroy();
      evalWriter?.destroy();
      spanProcessor?.setWriter(null);
      spanWriter = null;
      evalWriter = null;
      log.debug("[LLMObs] Disabled LLM Observability");
    }
    function handleLLMObsParentIdInjection({ carrier }) {
      const parent = storage.getStore()?.span;
      const mlObsSpanTags = LLMObsTagger.tagMap.get(parent);
      const parentContext = parent?.context();
      const parentId = parentContext?.toSpanId();
      const mlApp = mlObsSpanTags?.[ML_APP] || parentContext?._trace?.tags?.[PROPAGATED_ML_APP_KEY] || globalTracerConfig.llmobs.mlApp;
      if (parentId) carrier["x-datadog-tags"] += `,${PROPAGATED_PARENT_ID_KEY}=${parentId}`;
      if (mlApp) carrier["x-datadog-tags"] += `,${PROPAGATED_ML_APP_KEY}=${mlApp}`;
    }
    function handleFlush() {
      let err = "";
      try {
        spanWriter.flush();
        evalWriter.flush();
      } catch (e) {
        err = "writer_flush_error";
        log.warn("Failed to flush LLMObs spans and evaluation metrics:", e.message);
      }
      telemetry.recordUserFlush(err);
    }
    function handleRegisterProcessor(userSpanProcessor) {
      spanProcessor.setUserSpanProcessor(userSpanProcessor);
    }
    function handleSpanProcess(data) {
      spanProcessor.process(data);
    }
    function handleEvalMetricAppend(payload) {
      try {
        evalWriter.append(payload);
      } catch (e) {
        log.warn(
          // eslint-disable-next-line @stylistic/max-len
          "Failed to append evaluation metric to LLM Observability writer, likely due to an unserializable property. Evaluation metrics won't be sent to LLM Observability:",
          e.message
        );
      }
    }
    module2.exports = { enable, disable };
  }
});

// ../../packages/dd-trace/src/openfeature/writers/base.js
var require_base4 = __commonJS({
  "../../packages/dd-trace/src/openfeature/writers/base.js"(exports2, module2) {
    "use strict";
    var request2 = require_request();
    var { safeJSONStringify } = require_util3();
    var { URL: URL2, format } = __require("node:url");
    var log = require_log2();
    var BaseFFEWriter = class {
      /**
       * @param {BaseFFEWriterOptions} options - Writer configuration options
       */
      constructor({ interval, timeout, config, endpoint, agentUrl, payloadSizeLimit, eventSizeLimit, headers }) {
        this._interval = interval ?? 1e3;
        this._timeout = timeout ?? 5e3;
        this._buffer = [];
        this._bufferLimit = 1e3;
        this._bufferSize = 0;
        this._config = config;
        this._endpoint = endpoint;
        this._baseUrl = agentUrl ?? this._getAgentUrl();
        this._payloadSizeLimit = payloadSizeLimit;
        this._eventSizeLimit = eventSizeLimit;
        this._headers = headers || {};
        this._requestOptions = {
          headers: {
            ...this._headers,
            "Content-Type": "application/json"
          },
          method: "POST",
          timeout: this._timeout,
          url: this._baseUrl,
          path: this._endpoint
        };
        this._periodic = setInterval(() => {
          this.flush();
        }, this._interval).unref();
        this._beforeExitHandler = () => {
          this.destroy();
        };
        process.once("beforeExit", this._beforeExitHandler);
        this._destroyed = false;
        this._droppedEvents = 0;
      }
      /**
       * Appends an event array to the buffer
       * @param {Array|Object} events - Event object(s) to append to buffer
       */
      append(events) {
        const eventArray = Array.isArray(events) ? events : [events];
        for (const event of eventArray) {
          if (this._buffer.length >= this._bufferLimit) {
            log.warn(`${this.constructor.name} event buffer full (limit is ${this._bufferLimit}), dropping event`);
            this._droppedEvents++;
            continue;
          }
          const eventSizeBytes = Buffer.byteLength(JSON.stringify(event));
          if (this._eventSizeLimit && eventSizeBytes > this._eventSizeLimit) {
            log.warn(`${this.constructor.name} event size
          ${eventSizeBytes} bytes exceeds limit ${this._eventSizeLimit}, dropping event`);
            this._droppedEvents++;
            continue;
          }
          if (this._payloadSizeLimit && this._bufferSize + eventSizeBytes > this._payloadSizeLimit) {
            log.debug(() => `${this.constructor.name}
        buffer size would exceed ${this._payloadSizeLimit} bytes, flushing first`);
            this.flush();
          }
          this._bufferSize += eventSizeBytes;
          this._buffer.push(event);
        }
      }
      /**
       * Flushes all buffered events to the agent
       */
      flush() {
        if (this._buffer.length === 0) {
          return;
        }
        const events = this._buffer;
        this._buffer = [];
        this._bufferSize = 0;
        const payload = this._encode(this.makePayload(events));
        log.debug(() => `${this.constructor.name} flushing payload: ${safeJSONStringify(payload)}`);
        request2(payload, this._requestOptions, (err, resp, code) => {
          if (err) {
            log.error(`Failed to send events to ${this._baseUrl.href}${this._endpoint}: ${err.message}`);
          } else if (code >= 200 && code < 300) {
            log.debug(() => `Successfully sent ${events.length} events`);
          } else {
            log.warn(`Events request returned status ${code}`);
          }
        });
      }
      /**
       * Override in subclass to customize payload structure
       * @param {Array} events - Array of events to be sent
       * @returns {object} Formatted payload
       */
      makePayload(events) {
        return events;
      }
      /**
       * Cleans up resources and flushes remaining events
       */
      destroy() {
        if (!this._destroyed) {
          log.debug(() => `Stopping ${this.constructor.name}`);
          clearInterval(this._periodic);
          process.removeListener("beforeExit", this._beforeExitHandler);
          this.flush();
          this._destroyed = true;
          if (this._droppedEvents > 0) {
            log.warn(`${this.constructor.name} dropped ${this._droppedEvents} events due to buffer overflow`);
          }
        }
      }
      /**
       * @private
       * @returns {URL} Constructs agent URL from config
       */
      _getAgentUrl() {
        const { hostname, port } = this._config;
        return this._config.url ?? new URL2(format({
          protocol: "http:",
          hostname: hostname || "localhost",
          port: port || 8126
        }));
      }
      /**
       * @private
       * @param {Array<object>} payload - Payload to encode
       * @returns {string} JSON-stringified payload
       */
      _encode(payload) {
        return JSON.stringify(payload);
      }
    };
    module2.exports = BaseFFEWriter;
  }
});

// ../../packages/dd-trace/src/openfeature/writers/exposures.js
var require_exposures = __commonJS({
  "../../packages/dd-trace/src/openfeature/writers/exposures.js"(exports2, module2) {
    "use strict";
    var BaseFFEWriter = require_base4();
    var {
      EXPOSURES_ENDPOINT,
      EVP_PROXY_AGENT_BASE_PATH,
      EVP_SUBDOMAIN_HEADER_NAME,
      EVP_SUBDOMAIN_VALUE,
      EVP_PAYLOAD_SIZE_LIMIT,
      EVP_EVENT_SIZE_LIMIT
    } = require_constants();
    var ExposuresWriter = class extends BaseFFEWriter {
      /**
       * @param {import('../../config')} config - Tracer configuration object
       */
      constructor(config) {
        const basePath = EVP_PROXY_AGENT_BASE_PATH.replace(/\/+$/, "");
        const endpoint = EXPOSURES_ENDPOINT.replace(/^\/+/, "");
        const fullEndpoint = `${basePath}/${endpoint}`;
        super({
          config,
          endpoint: fullEndpoint,
          payloadSizeLimit: EVP_PAYLOAD_SIZE_LIMIT,
          eventSizeLimit: EVP_EVENT_SIZE_LIMIT,
          headers: {
            [EVP_SUBDOMAIN_HEADER_NAME]: EVP_SUBDOMAIN_VALUE
          }
        });
        this._enabled = false;
        this._pendingEvents = [];
        this._context = this._buildContext();
      }
      /**
       * @param {boolean} enabled - Whether to enable the writer
       */
      setEnabled(enabled) {
        this._enabled = enabled;
        if (enabled && this._pendingEvents.length > 0) {
          super.append(this._pendingEvents);
          this._pendingEvents = [];
        }
      }
      /**
       * Appends exposure event(s) to the buffer
       * @param {ExposureEvent|ExposureEvent[]} events - Exposure event(s) to append
       */
      append(events) {
        if (!this._enabled) {
          if (Array.isArray(events)) {
            this._pendingEvents.push(...events);
          } else {
            this._pendingEvents.push(events);
          }
          return;
        }
        super.append(events);
      }
      /**
       * Flushes buffered exposure events to the agent
       */
      flush() {
        if (!this._enabled) {
          return;
        }
        super.flush();
      }
      /**
       * Formats exposure events with service context metadata
       * @param {Array<ExposureEvent>} events - Array of exposure events
       * @returns {ExposureEventPayload} Formatted payload with service context
       */
      makePayload(events) {
        const formattedEvents = events.map((event) => this._formatExposureEvent(event));
        return {
          context: this._context,
          exposures: formattedEvents
        };
      }
      /**
       * Builds service context metadata
       * @private
       * @returns {ExposureContext} Service context
       */
      _buildContext() {
        const context2 = {
          service_name: this._config.service || "unknown"
        };
        if (this._config.version !== void 0) {
          context2.version = this._config.version;
        }
        if (this._config.env !== void 0) {
          context2.env = this._config.env;
        }
        return context2;
      }
      /**
       * @private
       * @param {ExposureEvent} event - Raw exposure event
       * @returns {ExposureEvent} Formatted exposure event
       */
      _formatExposureEvent(event) {
        const formattedEvent = {
          timestamp: event.timestamp || Date.now(),
          allocation: {
            key: event.allocation?.key || event["allocation.key"]
          },
          flag: {
            key: event.flag?.key || event["flag.key"]
          },
          variant: {
            key: event.variant?.key || event["variant.key"]
          },
          subject: {
            id: event.subject?.id || event["subject.id"],
            type: event.subject?.type,
            attributes: event.subject?.attributes
          }
        };
        return formattedEvent;
      }
    };
    module2.exports = ExposuresWriter;
  }
});

// ../../packages/dd-trace/src/openfeature/writers/util.js
var require_util15 = __commonJS({
  "../../packages/dd-trace/src/openfeature/writers/util.js"(exports2, module2) {
    "use strict";
    var logger = require_log2();
    var { EVP_PROXY_AGENT_BASE_PATH } = require_constants();
    var AgentInfoExporter = require_agent_info_exporter();
    var agentInfoExporter;
    function setAgentStrategy(config, setWriterEnabledValue) {
      if (!agentInfoExporter) {
        agentInfoExporter = new AgentInfoExporter(config);
      }
      agentInfoExporter.getAgentInfo((err, agentInfo) => {
        if (err) {
          logger.debug("FFE Writer disabled - error getting agent info:", err.message);
          setWriterEnabledValue(false);
          return;
        }
        const endpoints = agentInfo.endpoints;
        const normalizedPath = EVP_PROXY_AGENT_BASE_PATH.replace(/\/+$/, "");
        const hasEndpoint = Array.isArray(endpoints) && endpoints.includes(normalizedPath) || endpoints.includes(normalizedPath + "/");
        if (hasEndpoint) {
          logger.debug("FFE Writer enabled - agent has EVP proxy support");
          setWriterEnabledValue(true);
        } else {
          logger.debug("FFE Writer disabled - agent does not have EVP proxy support");
          setWriterEnabledValue(false);
        }
      });
    }
    module2.exports = {
      setAgentStrategy
    };
  }
});

// ../../packages/dd-trace/src/openfeature/index.js
var require_openfeature = __commonJS({
  "../../packages/dd-trace/src/openfeature/index.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var ExposuresWriter = require_exposures();
    var { setAgentStrategy } = require_util15();
    var { channel } = require_dc_polyfill();
    var exposureSubmitCh = channel("ffe:exposure:submit");
    var flushCh = channel("ffe:writers:flush");
    var exposuresWriter = null;
    function _handleExposureSubmit(exposureEvents) {
      if (!exposuresWriter) return;
      exposuresWriter.append(exposureEvents);
    }
    function _handleFlush() {
      exposuresWriter?.flush();
    }
    function enable(config) {
      if (exposuresWriter) {
        log.warn(exposuresWriter.constructor.name + " already enabled");
        return;
      }
      exposuresWriter = new ExposuresWriter(config);
      exposureSubmitCh.subscribe(_handleExposureSubmit);
      flushCh.subscribe(_handleFlush);
      setAgentStrategy(config, (hasAgent) => {
        exposuresWriter?.setEnabled(hasAgent);
      });
      log.debug("OpenFeature module enabled");
    }
    function disable() {
      if (!exposuresWriter) return;
      if (exposureSubmitCh.hasSubscribers) {
        exposureSubmitCh.unsubscribe(_handleExposureSubmit);
      }
      if (flushCh.hasSubscribers) {
        flushCh.unsubscribe(_handleFlush);
      }
      exposuresWriter.destroy?.();
      exposuresWriter = null;
      log.debug("OpenFeature module disabled");
    }
    module2.exports = {
      enable,
      disable
    };
  }
});

// ../../packages/dd-trace/src/crashtracking/crashtracker.js
var require_crashtracker = __commonJS({
  "../../packages/dd-trace/src/crashtracking/crashtracker.js"(exports2, module2) {
    "use strict";
    var libdatadog = require_libdatadog();
    var binding = libdatadog.load("crashtracker");
    var log = require_log2();
    var defaults = require_config_defaults();
    var { URL: URL2 } = __require("url");
    var pkg = require_package();
    var Crashtracker = class {
      #started = false;
      configure(config) {
        if (!this.#started) return;
        try {
          binding.updateConfig(this.#getConfig(config));
          binding.updateMetadata(this.#getMetadata(config));
        } catch (e) {
          log.error("Error configuring crashtracker", e);
        }
      }
      start(config) {
        if (this.#started) return this.configure(config);
        this.#started = true;
        try {
          binding.init(
            this.#getConfig(config),
            this.#getReceiverConfig(),
            this.#getMetadata(config)
          );
        } catch (e) {
          log.error("Error initialising crashtracker", e);
        }
      }
      withProfilerSerializing(f) {
        binding.beginProfilerSerializing();
        try {
          return f();
        } finally {
          binding.endProfilerSerializing();
        }
      }
      // TODO: Send only configured values when defaults are fixed.
      #getConfig(config) {
        const { hostname = defaults.hostname, port = defaults.port } = config;
        const url = config.url || new URL2(`http://${hostname}:${port}`);
        return {
          additional_files: [],
          create_alt_stack: true,
          use_alt_stack: true,
          endpoint: {
            // TODO: Use the string directly when deserialization is fixed.
            url: {
              scheme: url.protocol.slice(0, -1),
              authority: url.protocol === "unix:" ? Buffer.from(url.pathname).toString("hex") : url.host,
              path_and_query: ""
            },
            timeout_ms: 3e3
          },
          timeout_ms: 5e3,
          // TODO: Use `EnabledWithSymbolsInReceiver` instead for Linux when fixed.
          resolve_frames: "EnabledWithInprocessSymbols"
        };
      }
      #getMetadata(config) {
        const tags = Object.keys(config.tags).map((key) => `${key}:${config.tags[key]}`);
        return {
          library_name: pkg.name,
          library_version: pkg.version,
          family: "nodejs",
          tags: [
            ...tags,
            "is_crash:true",
            "language:javascript",
            `library_version:${pkg.version}`,
            "runtime:nodejs",
            `runtime_version:${process.versions.node}`,
            "severity:crash"
          ]
        };
      }
      #getReceiverConfig() {
        return {
          args: [],
          env: [],
          path_to_receiver_binary: libdatadog.find("crashtracker-receiver", true),
          stderr_filename: null,
          stdout_filename: null
        };
      }
    };
    module2.exports = new Crashtracker();
  }
});

// ../../packages/dd-trace/src/crashtracking/noop.js
var require_noop5 = __commonJS({
  "../../packages/dd-trace/src/crashtracking/noop.js"(exports2, module2) {
    "use strict";
    var NoopCrashtracker = class {
      configure() {
      }
      start() {
      }
      withProfilerSerializing(f) {
        return f();
      }
    };
    module2.exports = new NoopCrashtracker();
  }
});

// ../../packages/dd-trace/src/crashtracking/index.js
var require_crashtracking = __commonJS({
  "../../packages/dd-trace/src/crashtracking/index.js"(exports2, module2) {
    "use strict";
    var { isMainThread } = __require("worker_threads");
    var log = require_log2();
    if (isMainThread) {
      try {
        module2.exports = require_crashtracker();
      } catch (e) {
        log.warn(e.message);
        module2.exports = require_noop5();
      }
    } else {
      module2.exports = require_noop5();
    }
  }
});

// ../../packages/dd-trace/src/heap_snapshots.js
var require_heap_snapshots = __commonJS({
  "../../packages/dd-trace/src/heap_snapshots.js"(exports2, module2) {
    "use strict";
    var { join } = __require("path");
    var { setImmediate: setImmediate2, setTimeout: setTimeout2 } = __require("timers/promises");
    var { format } = __require("util");
    var { writeHeapSnapshot } = __require("v8");
    var { threadId } = __require("worker_threads");
    var log = require_log2();
    async function scheduleSnapshot(config, total) {
      if (total > config.heapSnapshot.count) return;
      await setTimeout2(config.heapSnapshot.interval * 1e3, null, { ref: false });
      await clearMemory();
      writeHeapSnapshot(getName(config.heapSnapshot.destination));
      await scheduleSnapshot(config, total + 1);
    }
    async function clearMemory() {
      if (!globalThis.gc) return;
      globalThis.gc();
      await setImmediate2();
      globalThis.gc();
    }
    function pad(value) {
      return String(value).padStart(2, 0);
    }
    function getName(destination) {
      const date = /* @__PURE__ */ new Date();
      const filename = format(
        "Heap-%s%s%s-%s%s%s-%s-%s.heapsnapshot",
        date.getFullYear(),
        pad(date.getMonth()),
        pad(date.getDate()),
        pad(date.getHours()),
        pad(date.getMinutes()),
        pad(date.getSeconds()),
        process.pid,
        threadId
      );
      return join(destination, filename);
    }
    module2.exports = {
      async start(config) {
        const destination = config.heapSnapshot.destination;
        try {
          await scheduleSnapshot(config, 1);
          log.debug("Wrote heap snapshots to %s.", destination);
        } catch (e) {
          log.error("Failed to write heap snapshots to %s.", destination, e);
        }
      }
    };
  }
});

// ../../packages/dd-trace/src/profiling/ssi-heuristics.js
var require_ssi_heuristics = __commonJS({
  "../../packages/dd-trace/src/profiling/ssi-heuristics.js"(exports2, module2) {
    "use strict";
    var dc = require_dc_polyfill();
    var log = require_log2();
    var DEFAULT_LONG_LIVED_THRESHOLD = 3e4;
    var SSIHeuristics = class {
      constructor(config) {
        const longLivedThreshold = config.profiling.longLivedThreshold || DEFAULT_LONG_LIVED_THRESHOLD;
        if (typeof longLivedThreshold !== "number" || longLivedThreshold <= 0) {
          this.longLivedThreshold = DEFAULT_LONG_LIVED_THRESHOLD;
          log.warn(
            "Invalid SSIHeuristics.longLivedThreshold value: %s. Using default value:",
            config.profiling.longLivedThreshold,
            DEFAULT_LONG_LIVED_THRESHOLD
          );
        } else {
          this.longLivedThreshold = longLivedThreshold;
        }
        this.hasSentProfiles = false;
        this.noSpan = true;
        this.shortLived = true;
      }
      start() {
        setTimeout(() => {
          this.shortLived = false;
          this._maybeTriggered();
        }, this.longLivedThreshold).unref();
        this._onSpanCreated = this._onSpanCreated.bind(this);
        dc.subscribe("dd-trace:span:start", this._onSpanCreated);
        this._onAppClosing = this._onAppClosing.bind(this);
        dc.subscribe("datadog:telemetry:app-closing", this._onAppClosing);
      }
      onTriggered(callback) {
        switch (typeof callback) {
          case "undefined":
          case "function":
            this.triggeredCallback = callback;
            process.nextTick(() => {
              this._maybeTriggered();
            });
            break;
          default:
            throw new TypeError("callback must be a function or undefined");
        }
      }
      _maybeTriggered() {
        if (!this.shortLived && !this.noSpan && typeof this.triggeredCallback === "function") {
          this.triggeredCallback.call(null);
        }
      }
      _onSpanCreated() {
        this.noSpan = false;
        this._maybeTriggered();
        dc.unsubscribe("dd-trace:span:start", this._onSpanCreated);
      }
      _onAppClosing() {
        dc.unsubscribe("datadog:telemetry:app-closing", this._onAppClosing);
        if (this.noSpan) {
          dc.unsubscribe("dd-trace:span:start", this._onSpanCreated);
        }
      }
    };
    module2.exports = { SSIHeuristics };
  }
});

// ../../packages/dd-trace/src/ci-visibility/test-api-manual/test-api-manual-plugin.js
var require_test_api_manual_plugin = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/test-api-manual/test-api-manual-plugin.js"(exports2, module2) {
    "use strict";
    var CiPlugin = require_ci_plugin();
    var {
      TEST_STATUS,
      finishAllTraceSpans,
      getTestSuitePath
    } = require_test();
    var { storage } = require_datadog_core();
    var TestApiManualPlugin = class extends CiPlugin {
      static id = "test-api-manual";
      constructor(...args) {
        super(...args);
        this._isEnvDataCalcualted = false;
        this.sourceRoot = process.cwd();
        this.unconfiguredAddSub("dd-trace:ci:manual:test:start", ({ testName, testSuite }) => {
          const store = storage("legacy").getStore();
          const testSuiteRelative = getTestSuitePath(testSuite, this.sourceRoot);
          const testSpan = this.startTestSpan(testName, testSuiteRelative);
          this.enter(testSpan, store);
        });
        this.unconfiguredAddSub("dd-trace:ci:manual:test:finish", ({ status, error }) => {
          const store = storage("legacy").getStore();
          const testSpan = store && store.span;
          if (testSpan) {
            testSpan.setTag(TEST_STATUS, status);
            if (error) {
              testSpan.setTag("error", error);
            }
            testSpan.finish();
            finishAllTraceSpans(testSpan);
          }
        });
        this.unconfiguredAddSub("dd-trace:ci:manual:test:addTags", (tags) => {
          const store = storage("legacy").getStore();
          const testSpan = store && store.span;
          if (testSpan) {
            testSpan.addTags(tags);
          }
        });
      }
      // To lazily calculate env data.
      unconfiguredAddSub(channelName, handler) {
        this.addSub(channelName, (...args) => {
          if (!this._isEnvDataCalcualted) {
            this._isEnvDataCalcualted = true;
            this.configure(this._config, true);
          }
          return handler(...args);
        });
      }
      configure(config, shouldGetEnvironmentData) {
        this._config = config;
        super.configure(config, shouldGetEnvironmentData);
      }
    };
    module2.exports = TestApiManualPlugin;
  }
});

// ../../packages/dd-trace/src/ci-visibility/log-submission/log-submission-plugin.js
var require_log_submission_plugin = __commonJS({
  "../../packages/dd-trace/src/ci-visibility/log-submission/log-submission-plugin.js"(exports2, module2) {
    "use strict";
    var Plugin = require_plugin();
    var log = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    function getWinstonLogSubmissionParameters(config) {
      const { site, service } = config;
      const defaultParameters = {
        host: `http-intake.logs.${site}`,
        path: `/api/v2/logs?ddsource=winston&service=${service}`,
        ssl: true,
        headers: {
          "DD-API-KEY": getEnvironmentVariable("DD_API_KEY")
        }
      };
      if (!getEnvironmentVariable("DD_AGENTLESS_LOG_SUBMISSION_URL")) {
        return defaultParameters;
      }
      try {
        const url = new URL(getEnvironmentVariable("DD_AGENTLESS_LOG_SUBMISSION_URL"));
        return {
          host: url.hostname,
          port: url.port,
          ssl: url.protocol === "https:",
          path: defaultParameters.path,
          headers: defaultParameters.headers
        };
      } catch {
        log.error("Could not parse DD_AGENTLESS_LOG_SUBMISSION_URL");
        return defaultParameters;
      }
    }
    var LogSubmissionPlugin = class extends Plugin {
      static id = "log-submission";
      constructor(...args) {
        super(...args);
        this.addSub("ci:log-submission:winston:configure", (httpClass) => {
          this.HttpClass = httpClass;
        });
        this.addSub("ci:log-submission:winston:add-transport", (logger) => {
          logger.add(new this.HttpClass(getWinstonLogSubmissionParameters(this.config)));
        });
      }
    };
    module2.exports = LogSubmissionPlugin;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js
var require_LogRecord = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/types/LogRecord.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SeverityNumber = void 0;
    var SeverityNumber;
    (function(SeverityNumber2) {
      SeverityNumber2[SeverityNumber2["UNSPECIFIED"] = 0] = "UNSPECIFIED";
      SeverityNumber2[SeverityNumber2["TRACE"] = 1] = "TRACE";
      SeverityNumber2[SeverityNumber2["TRACE2"] = 2] = "TRACE2";
      SeverityNumber2[SeverityNumber2["TRACE3"] = 3] = "TRACE3";
      SeverityNumber2[SeverityNumber2["TRACE4"] = 4] = "TRACE4";
      SeverityNumber2[SeverityNumber2["DEBUG"] = 5] = "DEBUG";
      SeverityNumber2[SeverityNumber2["DEBUG2"] = 6] = "DEBUG2";
      SeverityNumber2[SeverityNumber2["DEBUG3"] = 7] = "DEBUG3";
      SeverityNumber2[SeverityNumber2["DEBUG4"] = 8] = "DEBUG4";
      SeverityNumber2[SeverityNumber2["INFO"] = 9] = "INFO";
      SeverityNumber2[SeverityNumber2["INFO2"] = 10] = "INFO2";
      SeverityNumber2[SeverityNumber2["INFO3"] = 11] = "INFO3";
      SeverityNumber2[SeverityNumber2["INFO4"] = 12] = "INFO4";
      SeverityNumber2[SeverityNumber2["WARN"] = 13] = "WARN";
      SeverityNumber2[SeverityNumber2["WARN2"] = 14] = "WARN2";
      SeverityNumber2[SeverityNumber2["WARN3"] = 15] = "WARN3";
      SeverityNumber2[SeverityNumber2["WARN4"] = 16] = "WARN4";
      SeverityNumber2[SeverityNumber2["ERROR"] = 17] = "ERROR";
      SeverityNumber2[SeverityNumber2["ERROR2"] = 18] = "ERROR2";
      SeverityNumber2[SeverityNumber2["ERROR3"] = 19] = "ERROR3";
      SeverityNumber2[SeverityNumber2["ERROR4"] = 20] = "ERROR4";
      SeverityNumber2[SeverityNumber2["FATAL"] = 21] = "FATAL";
      SeverityNumber2[SeverityNumber2["FATAL2"] = 22] = "FATAL2";
      SeverityNumber2[SeverityNumber2["FATAL3"] = 23] = "FATAL3";
      SeverityNumber2[SeverityNumber2["FATAL4"] = 24] = "FATAL4";
    })(SeverityNumber = exports2.SeverityNumber || (exports2.SeverityNumber = {}));
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js
var require_NoopLogger = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/NoopLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP_LOGGER = exports2.NoopLogger = void 0;
    var NoopLogger = class {
      emit(_logRecord) {
      }
    };
    exports2.NoopLogger = NoopLogger;
    exports2.NOOP_LOGGER = new NoopLogger();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js
var require_NoopLoggerProvider = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/NoopLoggerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOOP_LOGGER_PROVIDER = exports2.NoopLoggerProvider = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var NoopLoggerProvider = class {
      getLogger(_name, _version, _options) {
        return new NoopLogger_1.NoopLogger();
      }
    };
    exports2.NoopLoggerProvider = NoopLoggerProvider;
    exports2.NOOP_LOGGER_PROVIDER = new NoopLoggerProvider();
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js
var require_ProxyLogger = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/ProxyLogger.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyLogger = void 0;
    var NoopLogger_1 = require_NoopLogger();
    var ProxyLogger = class {
      constructor(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      /**
       * Emit a log record. This method should only be used by log appenders.
       *
       * @param logRecord
       */
      emit(logRecord) {
        this._getLogger().emit(logRecord);
      }
      /**
       * Try to get a logger from the proxy logger provider.
       * If the proxy logger provider has no delegate, return a noop logger.
       */
      _getLogger() {
        if (this._delegate) {
          return this._delegate;
        }
        const logger = this._provider._getDelegateLogger(this.name, this.version, this.options);
        if (!logger) {
          return NoopLogger_1.NOOP_LOGGER;
        }
        this._delegate = logger;
        return this._delegate;
      }
    };
    exports2.ProxyLogger = ProxyLogger;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js
var require_ProxyLoggerProvider = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/ProxyLoggerProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProxyLoggerProvider = void 0;
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLogger_1 = require_ProxyLogger();
    var ProxyLoggerProvider = class {
      getLogger(name, version, options) {
        var _a;
        return (_a = this._getDelegateLogger(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyLogger_1.ProxyLogger(this, name, version, options);
      }
      /**
       * Get the delegate logger provider.
       * Used by tests only.
       * @internal
       */
      _getDelegate() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
      }
      /**
       * Set the delegate logger provider
       * @internal
       */
      _setDelegate(delegate) {
        this._delegate = delegate;
      }
      /**
       * @internal
       */
      _getDelegateLogger(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getLogger(name, version, options);
      }
    };
    exports2.ProxyLoggerProvider = ProxyLoggerProvider;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js
var require_globalThis2 = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/platform/node/globalThis.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    exports2._globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js
var require_node2 = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/platform/node/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    var globalThis_1 = require_globalThis2();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return globalThis_1._globalThis;
    } });
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/platform/index.js
var require_platform2 = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/platform/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2._globalThis = void 0;
    var node_1 = require_node2();
    Object.defineProperty(exports2, "_globalThis", { enumerable: true, get: function() {
      return node_1._globalThis;
    } });
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js
var require_global_utils = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/internal/global-utils.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.API_BACKWARDS_COMPATIBILITY_VERSION = exports2.makeGetter = exports2._global = exports2.GLOBAL_LOGS_API_KEY = void 0;
    var platform_1 = require_platform2();
    exports2.GLOBAL_LOGS_API_KEY = Symbol.for("io.opentelemetry.js.api.logs");
    exports2._global = platform_1._globalThis;
    function makeGetter(requiredVersion, instance, fallback) {
      return (version) => version === requiredVersion ? instance : fallback;
    }
    exports2.makeGetter = makeGetter;
    exports2.API_BACKWARDS_COMPATIBILITY_VERSION = 1;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/api/logs.js
var require_logs2 = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/api/logs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LogsAPI = void 0;
    var global_utils_1 = require_global_utils();
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    var LogsAPI = class _LogsAPI {
      constructor() {
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
      static getInstance() {
        if (!this._instance) {
          this._instance = new _LogsAPI();
        }
        return this._instance;
      }
      setGlobalLoggerProvider(provider) {
        if (global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) {
          return this.getLoggerProvider();
        }
        global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY] = (0, global_utils_1.makeGetter)(global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION, provider, NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER);
        this._proxyLoggerProvider._setDelegate(provider);
        return provider;
      }
      /**
       * Returns the global logger provider.
       *
       * @returns LoggerProvider
       */
      getLoggerProvider() {
        var _a, _b;
        return (_b = (_a = global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY]) === null || _a === void 0 ? void 0 : _a.call(global_utils_1._global, global_utils_1.API_BACKWARDS_COMPATIBILITY_VERSION)) !== null && _b !== void 0 ? _b : this._proxyLoggerProvider;
      }
      /**
       * Returns a logger from the global logger provider.
       *
       * @returns Logger
       */
      getLogger(name, version, options) {
        return this.getLoggerProvider().getLogger(name, version, options);
      }
      /** Remove the global logger provider */
      disable() {
        delete global_utils_1._global[global_utils_1.GLOBAL_LOGS_API_KEY];
        this._proxyLoggerProvider = new ProxyLoggerProvider_1.ProxyLoggerProvider();
      }
    };
    exports2.LogsAPI = LogsAPI;
  }
});

// ../../node_modules/@opentelemetry/api-logs/build/src/index.js
var require_src75 = __commonJS({
  "../../node_modules/@opentelemetry/api-logs/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logs = exports2.ProxyLoggerProvider = exports2.ProxyLogger = exports2.NoopLoggerProvider = exports2.NOOP_LOGGER_PROVIDER = exports2.NoopLogger = exports2.NOOP_LOGGER = exports2.SeverityNumber = void 0;
    var LogRecord_1 = require_LogRecord();
    Object.defineProperty(exports2, "SeverityNumber", { enumerable: true, get: function() {
      return LogRecord_1.SeverityNumber;
    } });
    var NoopLogger_1 = require_NoopLogger();
    Object.defineProperty(exports2, "NOOP_LOGGER", { enumerable: true, get: function() {
      return NoopLogger_1.NOOP_LOGGER;
    } });
    Object.defineProperty(exports2, "NoopLogger", { enumerable: true, get: function() {
      return NoopLogger_1.NoopLogger;
    } });
    var NoopLoggerProvider_1 = require_NoopLoggerProvider();
    Object.defineProperty(exports2, "NOOP_LOGGER_PROVIDER", { enumerable: true, get: function() {
      return NoopLoggerProvider_1.NOOP_LOGGER_PROVIDER;
    } });
    Object.defineProperty(exports2, "NoopLoggerProvider", { enumerable: true, get: function() {
      return NoopLoggerProvider_1.NoopLoggerProvider;
    } });
    var ProxyLogger_1 = require_ProxyLogger();
    Object.defineProperty(exports2, "ProxyLogger", { enumerable: true, get: function() {
      return ProxyLogger_1.ProxyLogger;
    } });
    var ProxyLoggerProvider_1 = require_ProxyLoggerProvider();
    Object.defineProperty(exports2, "ProxyLoggerProvider", { enumerable: true, get: function() {
      return ProxyLoggerProvider_1.ProxyLoggerProvider;
    } });
    var logs_1 = require_logs2();
    exports2.logs = logs_1.LogsAPI.getInstance();
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/logger.js
var require_logger = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/logger.js"(exports2, module2) {
    "use strict";
    var { sanitizeAttributes } = require_src();
    var { context: context2 } = (init_esm(), __toCommonJS(esm_exports));
    var packageVersion = require_package().version;
    var Logger = class {
      #instrumentationScope;
      /**
       * Creates a new Logger instance.
       *
       * @param {LoggerProvider} loggerProvider - Parent logger provider
       * @param {InstrumentationScope} [instrumentationScope] - Instrumentation scope information (newer API)
       * @param {Object} [instrumentationLibrary] - Instrumentation library information (legacy API) [DEPRECATED in v1.3.0]
       * @param {InstrumentationScope} [instrumentationScope.name] - Library name (defaults to 'dd-trace-js')
       * @param {InstrumentationScope} [instrumentationScope.version] - Library version (defaults to tracer version)
       * @param {string} [instrumentationLibrary.name] - Library name (legacy, defaults to 'dd-trace-js')
       * @param {string} [instrumentationLibrary.version] - Library version (legacy, defaults to tracer version)
       */
      constructor(loggerProvider, instrumentationScope, instrumentationLibrary) {
        this.loggerProvider = loggerProvider;
        const scope = instrumentationScope || instrumentationLibrary;
        this.#instrumentationScope = {
          name: scope?.name || "dd-trace-js",
          version: scope?.version || packageVersion,
          schemaUrl: scope?.schemaUrl || ""
        };
      }
      /**
       * Emits a log record.
       *
       * @param {LogRecord} logRecord - The log record to emit
       * @returns {void}
       */
      emit(logRecord) {
        if (this.loggerProvider.isShutdown || !this.loggerProvider.processor) {
          return;
        }
        if (logRecord.attributes) {
          logRecord.attributes = sanitizeAttributes(logRecord.attributes);
        }
        if (!logRecord.timestamp) {
          logRecord.timestamp = Number(process.hrtime.bigint());
        }
        if (!logRecord.context) {
          logRecord.context = context2.active();
        }
        this.loggerProvider.processor.onEmit(logRecord, this.#instrumentationScope);
      }
    };
    module2.exports = Logger;
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/logger_provider.js
var require_logger_provider = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/logger_provider.js"(exports2, module2) {
    "use strict";
    var { logs } = require_src75();
    var { context: context2 } = (init_esm(), __toCommonJS(esm_exports));
    var Logger = require_logger();
    var log = require_log2();
    var ContextManager = require_context_manager();
    var LoggerProvider = class {
      #loggers;
      #contextManager;
      /**
       * Creates a new LoggerProvider instance with a single processor for Datadog Agent export.
       *
       * @param {Object} [options] - LoggerProvider options
       * @param {BatchLogRecordProcessor} [options.processor] - Single LogRecordProcessor instance for
       *   exporting logs to Datadog Agent
       */
      constructor(options = {}) {
        this.processor = options.processor;
        this.#loggers = /* @__PURE__ */ new Map();
        this.#contextManager = new ContextManager();
        this.isShutdown = false;
      }
      /**
       * Gets or creates a logger instance.
       *
       * @param {string|Object} nameOrOptions - Logger name or options object
       * @param {string} [version] - Logger version (when nameOrOptions is a string)
       * @param {Object} [options] - Additional options (when nameOrOptions is a string)
       * @returns {Logger} Logger instance
       */
      getLogger(nameOrOptions, version, options = {}) {
        if (this.isShutdown) {
          return this.#createNoOpLogger();
        }
        let name, loggerOptions;
        if (typeof nameOrOptions === "string") {
          name = nameOrOptions;
          loggerOptions = { version, ...options };
        } else {
          name = nameOrOptions.name;
          loggerOptions = nameOrOptions;
        }
        const loggerVersion = loggerOptions.version || "";
        const loggerSchemaUrl = loggerOptions?.schemaUrl || "";
        const key = `${name}@${loggerVersion}`;
        if (!this.#loggers.has(key)) {
          this.#loggers.set(key, new Logger(this, { name, version: loggerVersion, schemaUrl: loggerSchemaUrl }));
        }
        return this.#loggers.get(key);
      }
      /**
       * Registers this logger provider as the global provider.
       */
      register() {
        if (this.isShutdown) {
          log.warn("Cannot register after shutdown");
          return;
        }
        context2.setGlobalContextManager(this.#contextManager);
        logs.setGlobalLoggerProvider(this);
      }
      /**
       * Forces a flush of all pending log records.
       * @returns {undefined} Promise that resolves when flush is n ssue cncomplete
       */
      forceFlush() {
        if (!this.isShutdown) {
          return this.processor?.forceFlush();
        }
      }
      /**
       * Shuts down the logger provider and all associated processors.
       * @returns {undefined} Promise that resolves when shutdown is complete
       */
      shutdown() {
        if (!this.isShutdown) {
          this.isShutdown = true;
        }
      }
      /**
       * Creates a no-op logger for use when the provider is shutdown.
       * @returns {Logger} A no-op logger instance
       * @private
       */
      #createNoOpLogger() {
        return {
          instrumentationScope: {
            name: "dd-trace-js",
            version: ""
          },
          emit: () => {
          },
          debug: () => {
          },
          info: () => {
          },
          warn: () => {
          },
          error: () => {
          },
          fatal: () => {
          }
        };
      }
    };
    module2.exports = LoggerProvider;
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/batch_log_processor.js
var require_batch_log_processor = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/batch_log_processor.js"(exports2, module2) {
    "use strict";
    var BatchLogRecordProcessor = class {
      #logRecords;
      #timer;
      #batchTimeout;
      #maxExportBatchSize;
      /**
       * Creates a new BatchLogRecordProcessor instance.
       *
       * @param {OtlpHttpLogExporter} exporter - Log processor for exporting batches to Datadog Agent
       * @param {number} batchTimeout - Timeout in milliseconds for batch processing
       * @param {number} maxExportBatchSize - Maximum number of log records per batch
       */
      constructor(exporter, batchTimeout, maxExportBatchSize) {
        this.exporter = exporter;
        this.#batchTimeout = batchTimeout;
        this.#maxExportBatchSize = maxExportBatchSize;
        this.#logRecords = [];
        this.#timer = null;
      }
      /**
       * Processes a single log record.
       *
       * @param {LogRecord} logRecord - The enriched log record with trace correlation and metadata
       * @param {InstrumentationScope} instrumentationScope - The instrumentation library
       */
      onEmit(logRecord, instrumentationScope) {
        this.#logRecords.push({ ...logRecord, instrumentationScope });
        if (this.#logRecords.length >= this.#maxExportBatchSize) {
          this.#export();
        } else if (this.#logRecords.length === 1) {
          this.#startTimer();
        }
      }
      /**
       * Forces an immediate flush of all pending log records.
       * @returns {undefined} Promise that resolves when flush is complete
       */
      forceFlush() {
        this.#export();
      }
      /**
       * Starts the batch timeout timer.
       * @private
       */
      #startTimer() {
        if (this.#timer) {
          return;
        }
        this.#timer = setTimeout(() => {
          this.#export();
        }, this.#batchTimeout);
      }
      /**
       * Exports the current batch of log records.
       * @private
       */
      #export() {
        const logRecords = this.#logRecords.slice(0, this.#maxExportBatchSize);
        this.#logRecords = this.#logRecords.slice(this.#maxExportBatchSize);
        this.#clearTimer();
        this.exporter.export(logRecords, () => {
        });
      }
      /**
       * Clears the batch timeout timer.
       * @private
       */
      #clearTimer() {
        if (this.#timer) {
          clearTimeout(this.#timer);
          this.#timer = null;
        }
      }
    };
    module2.exports = BatchLogRecordProcessor;
  }
});

// ../../packages/dd-trace/src/opentelemetry/otlp/otlp_http_exporter_base.js
var require_otlp_http_exporter_base = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/otlp/otlp_http_exporter_base.js"(exports2, module2) {
    "use strict";
    var http = __require("http");
    var { URL: URL2 } = __require("url");
    var log = require_log2();
    var telemetryMetrics = require_metrics();
    var tracerMetrics = telemetryMetrics.manager.namespace("tracers");
    var OtlpHttpExporterBase = class {
      #telemetryTags;
      /**
       * Creates a new OtlpHttpExporterBase instance.
       *
       * @param {string} url - OTLP endpoint URL
       * @param {string} headers - Additional HTTP headers as comma-separated key=value string
       * @param {number} timeout - Request timeout in milliseconds
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {string} defaultPath - Default path to use if URL has no path
       * @param {string} signalType - Signal type for error messages (e.g., 'logs', 'metrics')
       */
      constructor(url, headers, timeout, protocol, defaultPath, signalType) {
        const parsedUrl = new URL2(url);
        this.protocol = protocol;
        this.signalType = signalType;
        const path = parsedUrl.pathname === "/" ? defaultPath : parsedUrl.pathname;
        const isJson = protocol === "http/json";
        this.options = {
          hostname: parsedUrl.hostname,
          port: parsedUrl.port,
          path: path + parsedUrl.search,
          method: "POST",
          timeout,
          headers: {
            "Content-Type": isJson ? "application/json" : "application/x-protobuf",
            ...this.#parseAdditionalHeaders(headers)
          }
        };
        this.#telemetryTags = [
          "protocol:http",
          `encoding:${isJson ? "json" : "protobuf"}`
        ];
      }
      /**
       * Gets the telemetry tags for this exporter.
       * @returns {Array<string>} Telemetry tags
       * @protected
       */
      _getTelemetryTags() {
        return this.#telemetryTags;
      }
      /**
       * Records telemetry metrics for exported data.
       * @param {string} metricName - Name of the metric to record
       * @param {number} count - Count to increment
       * @param {Array<string>} [tags] - Optional custom tags (defaults to this exporter's tags)
       * @protected
       */
      _recordTelemetry(metricName, count, tags) {
        const telemetryTags = tags || this.#telemetryTags;
        tracerMetrics.count(metricName, telemetryTags).inc(count);
      }
      /**
       * Sends the payload via HTTP request.
       * @param {Buffer|string} payload - The payload to send
       * @param {Function} resultCallback - Callback for the result
       * @protected
       */
      _sendPayload(payload, resultCallback) {
        const options = {
          ...this.options,
          headers: {
            ...this.options.headers,
            "Content-Length": payload.length
          }
        };
        const req = http.request(options, (res) => {
          let data = "";
          res.on("data", (chunk) => {
            data += chunk;
          });
          res.on("end", () => {
            if (res.statusCode >= 200 && res.statusCode < 300) {
              resultCallback({ code: 0 });
            } else {
              const error = new Error(`HTTP ${res.statusCode}: ${data}`);
              resultCallback({ code: 1, error });
            }
          });
        });
        req.on("error", (error) => {
          log.error(`Error sending OTLP ${this.signalType}:`, error);
          resultCallback({ code: 1, error });
        });
        req.on("timeout", () => {
          req.destroy();
          const error = new Error("Request timeout");
          resultCallback({ code: 1, error });
        });
        req.write(payload);
        req.end();
      }
      /**
       * Parses additional HTTP headers from a comma-separated string.
       * @param {string} headersString - Comma-separated key=value pairs
       * @returns {Record<string, string>} Parsed headers object
       * @private
       */
      #parseAdditionalHeaders(headersString) {
        const headers = {};
        let key = "";
        let value = "";
        let readingKey = true;
        for (const char of headersString) {
          if (readingKey) {
            if (char === "=") {
              readingKey = false;
              key = key.trim();
            } else {
              key += char;
            }
          } else if (char === ",") {
            value = value.trim();
            if (key && value) {
              headers[key] = value;
            }
            key = "";
            value = "";
            readingKey = true;
          } else {
            value += char;
          }
        }
        if (!readingKey) {
          value = value.trim();
          if (value) {
            headers[key] = value;
          }
        }
        return headers;
      }
      /**
       * Shuts down the exporter.
       * Subclasses can override to add cleanup logic.
       */
      shutdown() {
      }
    };
    module2.exports = OtlpHttpExporterBase;
  }
});

// ../../packages/dd-trace/src/opentelemetry/otlp/otlp_transformer_base.js
var require_otlp_transformer_base = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/otlp/otlp_transformer_base.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var OtlpTransformerBase = class {
      #resourceAttributes;
      /**
       * Creates a new OtlpTransformerBase instance.
       *
       * @param {Attributes} resourceAttributes - Resource attributes
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {string} signalType - Signal type for warning messages (e.g., 'logs', 'metrics')
       */
      constructor(resourceAttributes, protocol, signalType) {
        this.#resourceAttributes = this._transformAttributes(resourceAttributes);
        if (protocol === "grpc") {
          log.warn(`OTLP gRPC protocol is not supported for ${signalType}. Defaulting to http/protobuf. gRPC protobuf support may be added in a future release.`);
          protocol = "http/protobuf";
        }
        this.protocol = protocol;
      }
      /**
       * Groups items by instrumentation scope (name, version, schemaUrl, and attributes).
       * @param {Array} items - Array of items to group
       * @returns {Map<string, Array>} Map of instrumentation scope key to items
       * @protected
       */
      _groupByInstrumentationScope(items) {
        const grouped = /* @__PURE__ */ new Map();
        for (const item of items) {
          const instrumentationScope = item.instrumentationScope || { name: "", version: "", schemaUrl: "", attributes: {} };
          const attrsKey = JSON.stringify(instrumentationScope.attributes || {});
          const key = `${instrumentationScope.name}@${instrumentationScope.version}@${instrumentationScope.schemaUrl}@${attrsKey}`;
          const group = grouped.get(key);
          if (group === void 0) {
            grouped.set(key, [item]);
          } else {
            group.push(item);
          }
        }
        return grouped;
      }
      /**
       * Transforms resource attributes to OTLP resource format.
       * @returns {Object} OTLP resource object
       * @protected
       */
      _transformResource() {
        return {
          attributes: this.#resourceAttributes,
          droppedAttributesCount: 0
        };
      }
      /**
       * Transforms attributes to OTLP KeyValue format.
       * @param {Object} attributes - Attributes to transform
       * @returns {Object[]} Array of OTLP KeyValue objects
       * @protected
       */
      _transformAttributes(attributes) {
        if (!attributes) return [];
        return Object.entries(attributes).map(([key, value]) => ({
          key,
          value: this._transformAnyValue(value)
        }));
      }
      /**
       * Transforms attributes to JSON format (simplified).
       * @param {Object} attributes - Attributes to transform
       * @returns {Object[]} Array of OTLP KeyValue objects with string values
       * @protected
       */
      _attributesToJson(attributes) {
        if (!attributes) return [];
        return Object.entries(attributes).map(([key, value]) => ({
          key,
          value: { stringValue: String(value) }
        }));
      }
      /**
       * Transforms any value to OTLP AnyValue format.
       * @param {any} value - Value to transform
       * @returns {Object} OTLP AnyValue object
       * @protected
       */
      _transformAnyValue(value) {
        if (typeof value === "string") {
          return { stringValue: value };
        } else if (typeof value === "number") {
          if (Number.isInteger(value)) {
            return { intValue: value };
          }
          return { doubleValue: value };
        } else if (typeof value === "boolean") {
          return { boolValue: value };
        } else if (Array.isArray(value)) {
          return {
            arrayValue: {
              values: value.map((v) => this._transformAnyValue(v))
            }
          };
        } else if (value && typeof value === "object") {
          return {
            kvlistValue: {
              values: Object.entries(value).map(([k, v]) => ({
                key: k,
                value: this._transformAnyValue(v)
              }))
            }
          };
        }
        return { stringValue: String(value) };
      }
      /**
       * Serializes data to protobuf format.
       * @param {Object} protoType - Protobuf type from protobuf_loader
       * @param {Object} data - Data to serialize
       * @returns {Buffer} Protobuf-encoded data
       * @protected
       */
      _serializeToProtobuf(protoType, data) {
        const message = protoType.create(data);
        const buffer = protoType.encode(message).finish();
        return buffer;
      }
      /**
       * Serializes data to JSON format.
       * @param {Object} data - Data to serialize
       * @returns {Buffer} JSON-encoded data
       * @protected
       */
      _serializeToJson(data) {
        return Buffer.from(JSON.stringify(data));
      }
    };
    module2.exports = OtlpTransformerBase;
  }
});

// ../../node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "../../node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString2();
          if (codegen.verbose)
            console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length)
          formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, function replace($0, $1) {
          var value = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value));
            case "i":
              return String(Math.floor(value));
            case "j":
              return JSON.stringify(value);
            case "s":
              return String(value);
          }
          return "%";
        });
        if (formatOffset !== formatParams.length)
          throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      function toString2(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      Codegen.toString = toString2;
      return Codegen;
    }
    codegen.verbose = false;
  }
});

// ../../node_modules/@protobufjs/fetch/index.js
var require_fetch4 = __commonJS({
  "../../node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch2;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch2(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options)
        options = {};
      if (!callback)
        return asPromise(fetch2, this, filename, options);
      if (!options.xhr && fs && fs.readFile)
        return fs.readFile(filename, function fetchReadFileCallback(err, contents) {
          return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
        });
      return fetch2.xhr(filename, options, callback);
    }
    fetch2.xhr = function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4)
          return void 0;
        if (xhr.status !== 0 && xhr.status !== 200)
          return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i)
              buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      };
      if (options.binary) {
        if ("overrideMimeType" in xhr)
          xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    };
  }
});

// ../../node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "../../node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path = exports2;
    var isAbsolute = (
      /**
       * Tests if the specified path is absolute.
       * @param {string} path Path to test
       * @returns {boolean} `true` if path is absolute
       */
      path.isAbsolute = function isAbsolute2(path2) {
        return /^(?:\/|\w+:)/.test(path2);
      }
    );
    var normalize = (
      /**
       * Normalizes the specified path.
       * @param {string} path Path to normalize
       * @returns {string} Normalized path
       */
      path.normalize = function normalize2(path2) {
        path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
        if (absolute)
          prefix = parts.shift() + "/";
        for (var i = 0; i < parts.length; ) {
          if (parts[i] === "..") {
            if (i > 0 && parts[i - 1] !== "..")
              parts.splice(--i, 2);
            else if (absolute)
              parts.splice(i, 1);
            else
              ++i;
          } else if (parts[i] === ".")
            parts.splice(i, 1);
          else
            ++i;
        }
        return prefix + parts.join("/");
      }
    );
    path.resolve = function resolve(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized)
        includePath = normalize(includePath);
      if (isAbsolute(includePath))
        return includePath;
      if (!alreadyNormalized)
        originPath = normalize(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize(originPath + "/" + includePath) : includePath;
    };
  }
});

// ../../node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "../../node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util = require_util16();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    };
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length))
        return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i)
        obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id)
            return true;
      }
      return false;
    };
    Namespace.isReservedName = function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i)
          if (reserved[i] === name)
            return true;
      }
      return false;
    };
    function Namespace(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
      this._lookupCache = {};
      this._needsRecursiveFeatureResolution = true;
      this._needsRecursiveResolve = true;
    }
    function clearCache(namespace2) {
      namespace2._nestedArray = null;
      namespace2._lookupCache = {};
      var parent = namespace2;
      while (parent = parent.parent) {
        parent._lookupCache = {};
      }
      return namespace2;
    }
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: function() {
        return this._nestedArray || (this._nestedArray = util.toArray(this.nested));
      }
    });
    Namespace.prototype.toJSON = function toJSON(toJSONOptions) {
      return util.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    };
    Namespace.prototype.addJSON = function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add(
            // most to least likely
            (nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      }
      return this;
    };
    Namespace.prototype.get = function get3(name) {
      return this.nested && this.nested[name] || null;
    };
    Namespace.prototype.getEnum = function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum)
        return this.nested[name].values;
      throw Error("no such enum: " + name);
    };
    Namespace.prototype.add = function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace))
        throw TypeError("object must be a valid nested object");
      if (!this.nested)
        this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i)
              object.add(nested[i]);
            this.remove(prev);
            if (!this.nested)
              this.nested = {};
            object.setOptions(prev.options, true);
          } else
            throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      if (!(this instanceof Type || this instanceof Service || this instanceof Enum || this instanceof Field)) {
        if (!object._edition) {
          object._edition = object._defaultEdition;
        }
      }
      this._needsRecursiveFeatureResolution = true;
      this._needsRecursiveResolve = true;
      var parent = this;
      while (parent = parent.parent) {
        parent._needsRecursiveFeatureResolution = true;
        parent._needsRecursiveResolve = true;
      }
      object.onAdd(this);
      return clearCache(this);
    };
    Namespace.prototype.remove = function remove(object) {
      if (!(object instanceof ReflectionObject))
        throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this)
        throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length)
        this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    };
    Namespace.prototype.define = function define2(path, json) {
      if (util.isString(path))
        path = path.split(".");
      else if (!Array.isArray(path))
        throw TypeError("illegal path");
      if (path && path.length && path[0] === "")
        throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace))
            throw Error("path conflicts with non-namespace objects");
        } else
          ptr.add(ptr = new Namespace(part));
      }
      if (json)
        ptr.addJSON(json);
      return ptr;
    };
    Namespace.prototype.resolveAll = function resolveAll() {
      if (!this._needsRecursiveResolve) return this;
      this._resolveFeaturesRecursive(this._edition);
      var nested = this.nestedArray, i = 0;
      this.resolve();
      while (i < nested.length)
        if (nested[i] instanceof Namespace)
          nested[i++].resolveAll();
        else
          nested[i++].resolve();
      this._needsRecursiveResolve = false;
      return this;
    };
    Namespace.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
      if (!this._needsRecursiveFeatureResolution) return this;
      this._needsRecursiveFeatureResolution = false;
      edition = this._edition || edition;
      ReflectionObject.prototype._resolveFeaturesRecursive.call(this, edition);
      this.nestedArray.forEach((nested) => {
        nested._resolveFeaturesRecursive(edition);
      });
      return this;
    };
    Namespace.prototype.lookup = function lookup(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes))
        filterTypes = [filterTypes];
      if (util.isString(path) && path.length) {
        if (path === ".")
          return this.root;
        path = path.split(".");
      } else if (!path.length)
        return this;
      var flatPath = path.join(".");
      if (path[0] === "")
        return this.root.lookup(path.slice(1), filterTypes);
      var found = this.root._fullyQualifiedObjects && this.root._fullyQualifiedObjects["." + flatPath];
      if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
        return found;
      }
      found = this._lookupImpl(path, flatPath);
      if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
        return found;
      }
      if (parentAlreadyChecked)
        return null;
      var current = this;
      while (current.parent) {
        found = current.parent._lookupImpl(path, flatPath);
        if (found && (!filterTypes || filterTypes.indexOf(found.constructor) > -1)) {
          return found;
        }
        current = current.parent;
      }
      return null;
    };
    Namespace.prototype._lookupImpl = function lookup(path, flatPath) {
      if (Object.prototype.hasOwnProperty.call(this._lookupCache, flatPath)) {
        return this._lookupCache[flatPath];
      }
      var found = this.get(path[0]);
      var exact = null;
      if (found) {
        if (path.length === 1) {
          exact = found;
        } else if (found instanceof Namespace) {
          path = path.slice(1);
          exact = found._lookupImpl(path, path.join("."));
        }
      } else {
        for (var i = 0; i < this.nestedArray.length; ++i)
          if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i]._lookupImpl(path, flatPath)))
            exact = found;
      }
      this._lookupCache[flatPath] = exact;
      return exact;
    };
    Namespace.prototype.lookupType = function lookupType(path) {
      var found = this.lookup(path, [Type]);
      if (!found)
        throw Error("no such type: " + path);
      return found;
    };
    Namespace.prototype.lookupEnum = function lookupEnum(path) {
      var found = this.lookup(path, [Enum]);
      if (!found)
        throw Error("no such Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupTypeOrEnum = function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [Type, Enum]);
      if (!found)
        throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    };
    Namespace.prototype.lookupService = function lookupService(path) {
      var found = this.lookup(path, [Service]);
      if (!found)
        throw Error("no such Service '" + path + "' in " + this);
      return found;
    };
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// ../../node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "../../node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types3();
    var util = require_util16();
    function MapField(name, id, keyType, type, options, comment) {
      Field.call(this, name, id, type, void 0, void 0, options, comment);
      if (!util.isString(keyType))
        throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    MapField.fromJSON = function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    };
    MapField.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    MapField.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (types.mapKey[this.keyType] === void 0)
        throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    };
    MapField.d = function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function")
        fieldValueType = util.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object")
        fieldValueType = util.decorateEnum(fieldValueType).name;
      return function mapFieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      };
    };
  }
});

// ../../node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "../../node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util = require_util16();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util.isString(type)))
        throw TypeError("type must be a string");
      if (!util.isString(requestType))
        throw TypeError("requestType must be a string");
      if (!util.isString(responseType))
        throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    Method.fromJSON = function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    };
    Method.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    };
    Method.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    };
  }
});

// ../../node_modules/protobufjs/src/service.js
var require_service2 = __commonJS({
  "../../node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util = require_util16();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    Service.fromJSON = function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods)
        for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i)
          service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested)
        service.addJSON(json.nested);
      if (json.edition)
        service._edition = json.edition;
      service.comment = json.comment;
      service._defaultEdition = "proto3";
      return service;
    };
    Service.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: function() {
        return this._methodsArray || (this._methodsArray = util.toArray(this.methods));
      }
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    Service.prototype.get = function get3(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    };
    Service.prototype.resolveAll = function resolveAll() {
      if (!this._needsRecursiveResolve) return this;
      Namespace.prototype.resolve.call(this);
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i)
        methods[i].resolve();
      return this;
    };
    Service.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
      if (!this._needsRecursiveFeatureResolution) return this;
      edition = this._edition || edition;
      Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
      this.methodsArray.forEach((method) => {
        method._resolveFeaturesRecursive(edition);
      });
      return this;
    };
    Service.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Service.prototype.remove = function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Service.prototype.create = function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util.codegen(["r", "c"], util.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    };
  }
});

// ../../node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "../../node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util = require_minimal();
    function Message(properties) {
      if (properties)
        for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
          this[keys[i]] = properties[keys[i]];
    }
    Message.create = function create(properties) {
      return this.$type.create(properties);
    };
    Message.encode = function encode(message, writer) {
      return this.$type.encode(message, writer);
    };
    Message.encodeDelimited = function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    };
    Message.decode = function decode(reader) {
      return this.$type.decode(reader);
    };
    Message.decodeDelimited = function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    };
    Message.verify = function verify(message) {
      return this.$type.verify(message);
    };
    Message.fromObject = function fromObject(object) {
      return this.$type.fromObject(object);
    };
    Message.toObject = function toObject(message, options) {
      return this.$type.toObject(message, options);
    };
    Message.prototype.toJSON = function toJSON() {
      return this.$type.toObject(this, util.toJSONOptions);
    };
  }
});

// ../../node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "../../node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types3();
    var util = require_util16();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    function decoder(mtype) {
      var gen = util.codegen(["r", "l", "e"], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()")("if(t===e)")("break")("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
          else gen("k=null");
          if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
          else gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
          else gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0) gen(field.delimited ? "%s.push(types[%i].decode(r,undefined,((t&~7)|4)))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0) gen(field.delimited ? "%s=types[%i].decode(r,undefined,((t&~7)|4))" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
  }
});

// ../../node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "../../node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util = require_util16();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    function verifier(mtype) {
      var gen = util.codegen(["m"], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length) gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util.safeProp(field.name);
        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen("}");
      }
      return gen("return null");
    }
  }
});

// ../../node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "../../node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util = require_util16();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.fromObject = function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util.codegen(["d"], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    };
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    converter.toObject = function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util.compareFieldsById);
      if (!fields.length)
        return util.codegen()("return {}");
      var gen = util.codegen(["m", "o"], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i)
        if (!fields[i].partOf)
          (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util.safeProp(field.name);
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    };
  }
});

// ../../node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "../../node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      },
      toObject: function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type)
            message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }
    };
  }
});

// ../../node_modules/protobufjs/src/type.js
var require_type2 = __commonJS({
  "../../node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service2();
    var Message = require_message();
    var Reader = require_reader();
    var Writer = require_writer2();
    var util = require_util16();
    var encoder = require_encoder2();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: function() {
          if (this._fieldsById)
            return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id])
              throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: function() {
          return this._fieldsArray || (this._fieldsArray = util.toArray(this.fields));
        }
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: function() {
          return this._oneofsArray || (this._oneofsArray = util.toArray(this.oneofs));
        }
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        },
        set: function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i)
            this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i)
            ctorProperties[this._oneofsArray[i].resolve().name] = {
              get: util.oneOfGetter(this._oneofsArray[i].oneof),
              set: util.oneOfSetter(this._oneofsArray[i].oneof)
            };
          if (i)
            Object.defineProperties(ctor.prototype, ctorProperties);
        }
      }
    });
    Type.generateConstructor = function generateConstructor(mtype) {
      var gen = util.codegen(["p"], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i)
        if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util.safeProp(field.name));
        else if (field.repeated) gen("this%s=[]", util.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    };
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    Type.fromJSON = function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i)
        type.add(
          (typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]])
        );
      if (json.oneofs)
        for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i)
          type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested)
        for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
          var nested = json.nested[names[i]];
          type.add(
            // most to least likely
            (nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested)
          );
        }
      if (json.extensions && json.extensions.length)
        type.extensions = json.extensions;
      if (json.reserved && json.reserved.length)
        type.reserved = json.reserved;
      if (json.group)
        type.group = true;
      if (json.comment)
        type.comment = json.comment;
      if (json.edition)
        type._edition = json.edition;
      type._defaultEdition = "proto3";
      return type;
    };
    Type.prototype.toJSON = function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Type.prototype.resolveAll = function resolveAll() {
      if (!this._needsRecursiveResolve) return this;
      Namespace.prototype.resolveAll.call(this);
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length)
        oneofs[i++].resolve();
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length)
        fields[i++].resolve();
      return this;
    };
    Type.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
      if (!this._needsRecursiveFeatureResolution) return this;
      edition = this._edition || edition;
      Namespace.prototype._resolveFeaturesRecursive.call(this, edition);
      this.oneofsArray.forEach((oneof) => {
        oneof._resolveFeatures(edition);
      });
      this.fieldsArray.forEach((field) => {
        field._resolveFeatures(edition);
      });
      return this;
    };
    Type.prototype.get = function get3(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    };
    Type.prototype.add = function add(object) {
      if (this.get(object.name))
        throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id])
          throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id))
          throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name))
          throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent)
          object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs)
          this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    };
    Type.prototype.remove = function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object)
          throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    };
    Type.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Type.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
    Type.prototype.create = function create(properties) {
      return new this.ctor(properties);
    };
    Type.prototype.setup = function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i)
        types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types,
        util
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util
      });
      this.verify = verifier(this)({
        types,
        util
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util
      });
      this.toObject = converter.toObject(this)({
        types,
        util
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    };
    Type.prototype.encode = function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    };
    Type.prototype.encodeDelimited = function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    };
    Type.prototype.decode = function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    };
    Type.prototype.decodeDelimited = function decodeDelimited(reader) {
      if (!(reader instanceof Reader))
        reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    };
    Type.prototype.verify = function verify_setup(message) {
      return this.setup().verify(message);
    };
    Type.prototype.fromObject = function fromObject(object) {
      return this.setup().fromObject(object);
    };
    Type.prototype.toObject = function toObject(message, options) {
      return this.setup().toObject(message, options);
    };
    Type.d = function decorateType(typeName) {
      return function typeDecorator(target) {
        util.decorateType(target, typeName);
      };
    };
  }
});

// ../../node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "../../node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util = require_util16();
    var Type;
    var parse;
    var common;
    function Root(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
      this._edition = "proto2";
      this._fullyQualifiedObjects = {};
    }
    Root.fromJSON = function fromJSON(json, root) {
      if (!root)
        root = new Root();
      if (json.options)
        root.setOptions(json.options);
      return root.addJSON(json.nested).resolveAll();
    };
    Root.prototype.resolvePath = util.path.resolve;
    Root.prototype.fetch = util.fetch;
    function SYNC() {
    }
    Root.prototype.load = function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback) {
        return util.asPromise(load, self2, filename, options);
      }
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback) {
          return;
        }
        if (sync) {
          throw err;
        }
        if (root) {
          root.resolveAll();
        }
        var cb = callback;
        callback = null;
        cb(err, root);
      }
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common) return altname;
        }
        return null;
      }
      function process2(filename2, source) {
        try {
          if (util.isString(source) && source.charAt(0) === "{")
            source = JSON.parse(source);
          if (!util.isString(source))
            self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse.filename = filename2;
            var parsed = parse(source, self2, options), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2]))
                  fetch2(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2)
                if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2]))
                  fetch2(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued) {
          finish(null, self2);
        }
      }
      function fetch2(filename2, weak) {
        filename2 = getBundledFileName(filename2) || filename2;
        if (self2.files.indexOf(filename2) > -1) {
          return;
        }
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync) {
            process2(filename2, common[filename2]);
          } else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak)
              finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback) {
              return;
            }
            if (err) {
              if (!weak)
                finish(err);
              else if (!queued)
                finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      var queued = 0;
      if (util.isString(filename)) {
        filename = [filename];
      }
      for (var i = 0, resolved; i < filename.length; ++i)
        if (resolved = self2.resolvePath("", filename[i]))
          fetch2(resolved);
      if (sync) {
        self2.resolveAll();
        return self2;
      }
      if (!queued) {
        finish(null, self2);
      }
      return self2;
    };
    Root.prototype.loadSync = function loadSync(filename, options) {
      if (!util.isNode)
        throw Error("not supported");
      return this.load(filename, options, SYNC);
    };
    Root.prototype.resolveAll = function resolveAll() {
      if (!this._needsRecursiveResolve) return this;
      if (this.deferred.length)
        throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
          return "'extend " + field.extend + "' in " + field.parent.fullName;
        }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    };
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        if (extendedType.get(sisterField.name)) {
          return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    Root.prototype._handleAdd = function _handleAdd(object) {
      if (object instanceof Field) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object))
            this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type)
          for (var i = 0; i < this.deferred.length; )
            if (tryHandleExtension(this, this.deferred[i]))
              this.deferred.splice(i, 1);
            else
              ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j)
          this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name))
          object.parent[object.name] = object;
      }
      if (object instanceof Type || object instanceof Enum || object instanceof Field) {
        this._fullyQualifiedObjects[object.fullName] = object;
      }
    };
    Root.prototype._handleRemove = function _handleRemove(object) {
      if (object instanceof Field) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1)
              this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i)
          this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name))
          delete object.parent[object.name];
      }
      delete this._fullyQualifiedObjects[object.fullName];
    };
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse = parse_;
      common = common_;
    };
  }
});

// ../../node_modules/protobufjs/src/util.js
var require_util16 = __commonJS({
  "../../node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util.codegen = require_codegen();
    util.fetch = require_fetch4();
    util.path = require_path();
    util.fs = util.inquire("fs");
    util.toArray = function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length)
          array[index] = object[keys[index++]];
        return array;
      }
      return [];
    };
    util.toObject = function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0)
          object[key] = val;
      }
      return object;
    };
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util.isReserved = function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    };
    util.safeProp = function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util.isReserved(prop))
        return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    };
    util.ucFirst = function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    };
    var camelCaseRe = /_([a-z])/g;
    util.camelCase = function camelCase(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    };
    util.compareFieldsById = function compareFieldsById(a, b) {
      return a.id - b.id;
    };
    util.decorateType = function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type)
        Type = require_type2();
      var type = new Type(typeName || ctor.name);
      util.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", { value: type, enumerable: false });
      Object.defineProperty(ctor.prototype, "$type", { value: type, enumerable: false });
      return type;
    };
    var decorateEnumIndex = 0;
    util.decorateEnum = function decorateEnum(object) {
      if (object.$type)
        return object.$type;
      if (!Enum)
        Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", { value: enm, enumerable: false });
      return enm;
    };
    util.setProperty = function setProperty(dst, path, value, ifNotSet) {
      function setProp(dst2, path2, value2) {
        var part = path2.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst2;
        }
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value2);
        } else {
          var prevValue = dst2[part];
          if (prevValue && ifNotSet)
            return dst2;
          if (prevValue)
            value2 = [].concat(prevValue).concat(value2);
          dst2[part] = value2;
        }
        return dst2;
      }
      if (typeof dst !== "object")
        throw TypeError("dst must be an object");
      if (!path)
        throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value);
    };
    Object.defineProperty(util, "decorateRoot", {
      get: function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }
    });
  }
});

// ../../node_modules/protobufjs/src/types.js
var require_types3 = __commonJS({
  "../../node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util = require_util16();
    var s = [
      "double",
      // 0
      "float",
      // 1
      "int32",
      // 2
      "uint32",
      // 3
      "sint32",
      // 4
      "fixed32",
      // 5
      "sfixed32",
      // 6
      "int64",
      // 7
      "uint64",
      // 8
      "sint64",
      // 9
      "fixed64",
      // 10
      "sfixed64",
      // 11
      "bool",
      // 12
      "string",
      // 13
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// ../../node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "../../node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types3();
    var util = require_util16();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = function fromJSON(name, json) {
      var field = new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
      if (json.edition)
        field._edition = json.edition;
      field._defaultEdition = "proto3";
      return field;
    };
    function Field(name, id, type, rule, extend, options, comment) {
      if (util.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util.isInteger(id) || id < 0)
        throw TypeError("id must be a non-negative integer");
      if (!util.isString(type))
        throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase()))
        throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util.isString(extend))
        throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this.comment = comment;
    }
    Object.defineProperty(Field.prototype, "required", {
      get: function() {
        return this._features.field_presence === "LEGACY_REQUIRED";
      }
    });
    Object.defineProperty(Field.prototype, "optional", {
      get: function() {
        return !this.required;
      }
    });
    Object.defineProperty(Field.prototype, "delimited", {
      get: function() {
        return this.resolvedType instanceof Type && this._features.message_encoding === "DELIMITED";
      }
    });
    Object.defineProperty(Field.prototype, "packed", {
      get: function() {
        return this._features.repeated_field_encoding === "PACKED";
      }
    });
    Object.defineProperty(Field.prototype, "hasPresence", {
      get: function() {
        if (this.repeated || this.map) {
          return false;
        }
        return this.partOf || // oneofs
        this.declaringField || this.extensionField || // extensions
        this._features.field_presence !== "IMPLICIT";
      }
    });
    Field.prototype.setOption = function setOption(name, value, ifNotSet) {
      return ReflectionObject.prototype.setOption.call(this, name, value, ifNotSet);
    };
    Field.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "edition",
        this._editionToJSON(),
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    Field.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type)
          this.typeDefault = null;
        else
          this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string")
          this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum))
          delete this.options.packed;
        if (!Object.keys(this.options).length)
          this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze)
          Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util.base64.test(this.typeDefault))
          util.base64.decode(this.typeDefault, buf = util.newBuffer(util.base64.length(this.typeDefault)), 0);
        else
          util.utf8.write(this.typeDefault, buf = util.newBuffer(util.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map)
        this.defaultValue = util.emptyObject;
      else if (this.repeated)
        this.defaultValue = util.emptyArray;
      else
        this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type)
        this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    };
    Field.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures(edition) {
      if (edition !== "proto2" && edition !== "proto3") {
        return {};
      }
      var features = {};
      if (this.rule === "required") {
        features.field_presence = "LEGACY_REQUIRED";
      }
      if (this.parent && types.defaults[this.type] === void 0) {
        var type = this.parent.get(this.type.split(".").pop());
        if (type && type instanceof Type && type.group) {
          features.message_encoding = "DELIMITED";
        }
      }
      if (this.getOption("packed") === true) {
        features.repeated_field_encoding = "PACKED";
      } else if (this.getOption("packed") === false) {
        features.repeated_field_encoding = "EXPANDED";
      }
      return features;
    };
    Field.prototype._resolveFeatures = function _resolveFeatures(edition) {
      return ReflectionObject.prototype._resolveFeatures.call(this, this._edition || edition);
    };
    Field.d = function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function")
        fieldType = util.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object")
        fieldType = util.decorateEnum(fieldType).name;
      return function fieldDecorator(prototype, fieldName) {
        util.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, { "default": defaultValue }));
      };
    };
    Field._configure = function configure(Type_) {
      Type = Type_;
    };
  }
});

// ../../node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "../../node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util = require_util16();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames)))
        throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    OneOf.fromJSON = function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    };
    OneOf.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    };
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i)
          if (!oneof.fieldsArray[i].parent)
            oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    OneOf.prototype.add = function add(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent)
        field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    };
    OneOf.prototype.remove = function remove(field) {
      if (!(field instanceof Field))
        throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0)
        throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1)
        this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    };
    OneOf.prototype.onAdd = function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    };
    OneOf.prototype.onRemove = function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i)
        if ((field = this.fieldsArray[i]).parent)
          field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    };
    Object.defineProperty(OneOf.prototype, "isProto3Optional", {
      get: function() {
        if (this.fieldsArray == null || this.fieldsArray.length !== 1) {
          return false;
        }
        var field = this.fieldsArray[0];
        return field.options != null && field.options["proto3_optional"] === true;
      }
    });
    OneOf.d = function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length)
        fieldNames[index] = arguments[index++];
      return function oneOfDecorator(prototype, oneofName) {
        util.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util.oneOfGetter(fieldNames),
          set: util.oneOfSetter(fieldNames)
        });
      };
    };
  }
});

// ../../node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "../../node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var OneOf = require_oneof();
    var util = require_util16();
    var Root;
    var editions2023Defaults = { enum_type: "OPEN", field_presence: "EXPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
    var proto2Defaults = { enum_type: "CLOSED", field_presence: "EXPLICIT", json_format: "LEGACY_BEST_EFFORT", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "EXPANDED", utf8_validation: "NONE" };
    var proto3Defaults = { enum_type: "OPEN", field_presence: "IMPLICIT", json_format: "ALLOW", message_encoding: "LENGTH_PREFIXED", repeated_field_encoding: "PACKED", utf8_validation: "VERIFY" };
    function ReflectionObject(name, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (options && !util.isObject(options))
        throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this._edition = null;
      this._defaultEdition = "proto2";
      this._features = {};
      this._featuresResolved = false;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: function() {
          var ptr = this;
          while (ptr.parent !== null)
            ptr = ptr.parent;
          return ptr;
        }
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: function() {
          var path = [this.name], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    function toJSON() {
      throw Error();
    };
    ReflectionObject.prototype.onAdd = function onAdd(parent) {
      if (this.parent && this.parent !== parent)
        this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root)
        root._handleAdd(this);
    };
    ReflectionObject.prototype.onRemove = function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root)
        root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    };
    ReflectionObject.prototype.resolve = function resolve() {
      if (this.resolved)
        return this;
      if (this.root instanceof Root)
        this.resolved = true;
      return this;
    };
    ReflectionObject.prototype._resolveFeaturesRecursive = function _resolveFeaturesRecursive(edition) {
      return this._resolveFeatures(this._edition || edition);
    };
    ReflectionObject.prototype._resolveFeatures = function _resolveFeatures(edition) {
      if (this._featuresResolved) {
        return;
      }
      var defaults = {};
      if (!edition) {
        throw new Error("Unknown edition for " + this.fullName);
      }
      var protoFeatures = Object.assign(
        this.options ? Object.assign({}, this.options.features) : {},
        this._inferLegacyProtoFeatures(edition)
      );
      if (this._edition) {
        if (edition === "proto2") {
          defaults = Object.assign({}, proto2Defaults);
        } else if (edition === "proto3") {
          defaults = Object.assign({}, proto3Defaults);
        } else if (edition === "2023") {
          defaults = Object.assign({}, editions2023Defaults);
        } else {
          throw new Error("Unknown edition: " + edition);
        }
        this._features = Object.assign(defaults, protoFeatures || {});
        this._featuresResolved = true;
        return;
      }
      if (this.partOf instanceof OneOf) {
        var lexicalParentFeaturesCopy = Object.assign({}, this.partOf._features);
        this._features = Object.assign(lexicalParentFeaturesCopy, protoFeatures || {});
      } else if (this.declaringField) {
      } else if (this.parent) {
        var parentFeaturesCopy = Object.assign({}, this.parent._features);
        this._features = Object.assign(parentFeaturesCopy, protoFeatures || {});
      } else {
        throw new Error("Unable to find a parent for " + this.fullName);
      }
      if (this.extensionField) {
        this.extensionField._features = this._features;
      }
      this._featuresResolved = true;
    };
    ReflectionObject.prototype._inferLegacyProtoFeatures = function _inferLegacyProtoFeatures() {
      return {};
    };
    ReflectionObject.prototype.getOption = function getOption(name) {
      if (this.options)
        return this.options[name];
      return void 0;
    };
    ReflectionObject.prototype.setOption = function setOption(name, value, ifNotSet) {
      if (!this.options)
        this.options = {};
      if (/^features\./.test(name)) {
        util.setProperty(this.options, name, value, ifNotSet);
      } else if (!ifNotSet || this.options[name] === void 0) {
        if (this.getOption(name) !== value) this.resolved = false;
        this.options[name] = value;
      }
      return this;
    };
    ReflectionObject.prototype.setParsedOption = function setParsedOption(name, value, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util.setProperty(newValue, propName, value);
        } else {
          opt = {};
          opt[name] = util.setProperty({}, propName, value);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value;
        parsedOptions.push(newOpt);
      }
      return this;
    };
    ReflectionObject.prototype.setOptions = function setOptions(options, ifNotSet) {
      if (options)
        for (var keys = Object.keys(options), i = 0; i < keys.length; ++i)
          this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    };
    ReflectionObject.prototype.toString = function toString2() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length)
        return className + " " + fullName;
      return className;
    };
    ReflectionObject.prototype._editionToJSON = function _editionToJSON() {
      if (!this._edition || this._edition === "proto3") {
        return void 0;
      }
      return this._edition;
    };
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// ../../node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "../../node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util = require_util16();
    function Enum(name, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object")
        throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this._valuesFeatures = {};
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i)
          if (typeof values[keys[i]] === "number")
            this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    Enum.prototype._resolveFeatures = function _resolveFeatures(edition) {
      edition = this._edition || edition;
      ReflectionObject.prototype._resolveFeatures.call(this, edition);
      Object.keys(this.values).forEach((key) => {
        var parentFeaturesCopy = Object.assign({}, this._features);
        this._valuesFeatures[key] = Object.assign(parentFeaturesCopy, this.valuesOptions && this.valuesOptions[key] && this.valuesOptions[key].features);
      });
      return this;
    };
    Enum.fromJSON = function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      if (json.edition)
        enm._edition = json.edition;
      enm._defaultEdition = "proto3";
      return enm;
    };
    Enum.prototype.toJSON = function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util.toObject([
        "edition",
        this._editionToJSON(),
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    };
    Enum.prototype.add = function add(name, id, comment, options) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      if (!util.isInteger(id))
        throw TypeError("id must be an integer");
      if (this.values[name] !== void 0)
        throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id))
        throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name))
        throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias))
          throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else
        this.valuesById[this.values[name] = id] = name;
      if (options) {
        if (this.valuesOptions === void 0)
          this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
      }
      this.comments[name] = comment || null;
      return this;
    };
    Enum.prototype.remove = function remove(name) {
      if (!util.isString(name))
        throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null)
        throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      if (this.valuesOptions)
        delete this.valuesOptions[name];
      return this;
    };
    Enum.prototype.isReservedId = function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    };
    Enum.prototype.isReservedName = function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    };
  }
});

// ../../node_modules/protobufjs/src/encoder.js
var require_encoder2 = __commonJS({
  "../../node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types3();
    var util = require_util16();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.delimited ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    function encoder(mtype) {
      var gen = util.codegen(["m", "w"], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0)
              genTypePartial(gen, field, index, ref + "[i]");
            else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0)
            genTypePartial(gen, field, index, ref);
          else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
  }
});

// ../../node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "../../node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root)
        root = new protobuf.Root();
      return root.load(filename, callback);
    }
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root)
        root = new protobuf.Root();
      return root.loadSync(filename);
    }
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder2();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type2();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service2();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types3();
    protobuf.util = require_util16();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// ../../node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "../../node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      function readString() {
        var re2 = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re2.lastIndex = offset - 1;
        var match = re2.exec(source);
        if (!match)
          throw illegal("string");
        offset = re2.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      function charAt(pos) {
        return source.charAt(pos);
      }
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i)
          lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/\//.test(lineText);
        return isComment;
      }
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      function next() {
        if (stack.length > 0)
          return stack.shift();
        if (stringDelim)
          return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length)
            return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length)
              return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset - 1)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim)
          while (end < length && !delimRe.test(charAt(end)))
            ++end;
        var token = source.substring(offset, offset = end);
        if (token === '"' || token === "'")
          stringDelim = token;
        return token;
      }
      function push(token) {
        stack.push(token);
      }
      function peek() {
        if (!stack.length) {
          var token = next();
          if (token === null)
            return null;
          push(token);
        }
        return stack[0];
      }
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional)
          throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: function() {
          return line;
        }
      });
    }
  }
});

// ../../node_modules/protobufjs/src/parse.js
var require_parse3 = __commonJS({
  "../../node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse;
    parse.filename = null;
    parse.defaults = { keepCase: false };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type2();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service2();
    var Method = require_method();
    var ReflectionObject = require_object();
    var types = require_types3();
    var util = require_util16();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    function parse(source, root, options) {
      if (!(root instanceof Root)) {
        options = root;
        root = new Root();
      }
      if (!options)
        options = parse.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, edition = "proto2";
      var ptr = root;
      var topLevelObjects = [];
      var topLevelOptions = {};
      var applyCase = options.keepCase ? function(name) {
        return name;
      } : util.camelCase;
      function resolveFileFeatures() {
        topLevelObjects.forEach((obj) => {
          obj._edition = edition;
          Object.keys(topLevelOptions).forEach((opt) => {
            if (obj.getOption(opt) !== void 0) return;
            obj.setOption(opt, topLevelOptions[opt], true);
          });
        });
      }
      function illegal(token2, name, insideTryCatch) {
        var filename = parse.filename;
        if (!insideTryCatch)
          parse.filename = null;
        return Error("illegal " + (name || "token") + " '" + token2 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      function readString() {
        var values = [], token2;
        do {
          if ((token2 = next()) !== '"' && token2 !== "'")
            throw illegal(token2);
          values.push(next());
          skip(token2);
          token2 = peek();
        } while (token2 === '"' || token2 === "'");
        return values.join("");
      }
      function readValue(acceptTypeRef) {
        var token2 = next();
        switch (token2) {
          case "'":
          case '"':
            push(token2);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(
            token2,
            /* insideTryCatch */
            true
          );
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token2))
            return token2;
          throw illegal(token2, "value");
        }
      }
      function readRanges(target, acceptStrings) {
        var token2, start;
        do {
          if (acceptStrings && ((token2 = peek()) === '"' || token2 === "'")) {
            var str = readString();
            target.push(str);
            if (edition >= 2023) {
              throw illegal(str, "id");
            }
          } else {
            try {
              target.push([start = parseId(next()), skip("to", true) ? parseId(next()) : start]);
            } catch (err) {
              if (acceptStrings && typeRefRe.test(token2) && edition >= 2023) {
                target.push(token2);
              } else {
                throw err;
              }
            }
          }
        } while (skip(",", true));
        var dummy = { options: void 0 };
        dummy.setOption = function(name, value) {
          if (this.options === void 0) this.options = {};
          this.options[name] = value;
        };
        ifBlock(
          dummy,
          function parseRange_block(token3) {
            if (token3 === "option") {
              parseOption(dummy, token3);
              skip(";");
            } else
              throw illegal(token3);
          },
          function parseRange_line() {
            parseInlineOptions(dummy);
          }
        );
      }
      function parseNumber(token2, insideTryCatch) {
        var sign = 1;
        if (token2.charAt(0) === "-") {
          sign = -1;
          token2 = token2.substring(1);
        }
        switch (token2) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token2))
          return sign * parseInt(token2, 10);
        if (base16Re.test(token2))
          return sign * parseInt(token2, 16);
        if (base8Re.test(token2))
          return sign * parseInt(token2, 8);
        if (numberRe.test(token2))
          return sign * parseFloat(token2);
        throw illegal(token2, "number", insideTryCatch);
      }
      function parseId(token2, acceptNegative) {
        switch (token2) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token2.charAt(0) === "-")
          throw illegal(token2, "id");
        if (base10NegRe.test(token2))
          return parseInt(token2, 10);
        if (base16NegRe.test(token2))
          return parseInt(token2, 16);
        if (base8NegRe.test(token2))
          return parseInt(token2, 8);
        throw illegal(token2, "id");
      }
      function parsePackage() {
        if (pkg !== void 0)
          throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg))
          throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      function parseImport() {
        var token2 = peek();
        var whichImports;
        switch (token2) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          // eslint-disable-next-line no-fallthrough
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token2 = readString();
        skip(";");
        whichImports.push(token2);
      }
      function parseSyntax() {
        skip("=");
        edition = readString();
        if (edition < 2023)
          throw illegal(edition, "syntax");
        skip(";");
      }
      function parseEdition() {
        skip("=");
        edition = readString();
        const supportedEditions = ["2023"];
        if (!supportedEditions.includes(edition))
          throw illegal(edition, "edition");
        skip(";");
      }
      function parseCommon(parent, token2) {
        switch (token2) {
          case "option":
            parseOption(parent, token2);
            skip(";");
            return true;
          case "message":
            parseType(parent, token2);
            return true;
          case "enum":
            parseEnum(parent, token2);
            return true;
          case "service":
            parseService(parent, token2);
            return true;
          case "extend":
            parseExtension(parent, token2);
            return true;
        }
        return false;
      }
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse.filename;
        }
        if (skip("{", true)) {
          var token2;
          while ((token2 = next()) !== "}")
            fnIf(token2);
          skip(";", true);
        } else {
          if (fnElse)
            fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment))
            obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      function parseType(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "type name");
        var type = new Type(token2);
        ifBlock(type, function parseType_block(token3) {
          if (parseCommon(type, token3))
            return;
          switch (token3) {
            case "map":
              parseMapField(type, token3);
              break;
            case "required":
              if (edition !== "proto2")
                throw illegal(token3);
            /* eslint-disable no-fallthrough */
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (edition === "proto3") {
                parseField(type, "proto3_optional");
              } else if (edition !== "proto2") {
                throw illegal(token3);
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token3);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (edition === "proto2" || !typeRefRe.test(token3)) {
                throw illegal(token3);
              }
              push(token3);
              parseField(type, "optional");
              break;
          }
        });
        parent.add(type);
        if (parent === ptr) {
          topLevelObjects.push(type);
        }
      }
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        while (type.endsWith(".") || peek().startsWith(".")) {
          type += next();
        }
        if (!typeRefRe.test(type))
          throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        name = applyCase(name);
        skip("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, function parseField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseField_line() {
          parseInlineOptions(field);
        });
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (parent === ptr) {
          topLevelObjects.push(field);
        }
      }
      function parseGroup(parent, rule) {
        if (edition >= 2023) {
          throw illegal("group");
        }
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        var fieldName = util.lcFirst(name);
        if (name === fieldName)
          name = util.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse.filename;
        ifBlock(type, function parseGroup_block(token2) {
          switch (token2) {
            case "option":
              parseOption(type, token2);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token2);
              break;
            case "optional":
              if (edition === "proto3") {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token2);
              break;
            case "enum":
              parseEnum(type, token2);
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            /* istanbul ignore next */
            default:
              throw illegal(token2);
          }
        });
        parent.add(type).add(field);
      }
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0)
          throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType))
          throw illegal(valueType, "type");
        skip(">");
        var name = next();
        if (!nameRe.test(name))
          throw illegal(name, "name");
        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, function parseMapField_block(token2) {
          if (token2 === "option") {
            parseOption(field, token2);
            skip(";");
          } else
            throw illegal(token2);
        }, function parseMapField_line() {
          parseInlineOptions(field);
        });
        parent.add(field);
      }
      function parseOneOf(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var oneof = new OneOf(applyCase(token2));
        ifBlock(oneof, function parseOneOf_block(token3) {
          if (token3 === "option") {
            parseOption(oneof, token3);
            skip(";");
          } else {
            push(token3);
            parseField(oneof, "optional");
          }
        });
        parent.add(oneof);
      }
      function parseEnum(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var enm = new Enum(token2);
        ifBlock(enm, function parseEnum_block(token3) {
          switch (token3) {
            case "option":
              parseOption(enm, token3);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              if (enm.reserved === void 0) enm.reserved = [];
              break;
            default:
              parseEnumValue(enm, token3);
          }
        });
        parent.add(enm);
        if (parent === ptr) {
          topLevelObjects.push(enm);
        }
      }
      function parseEnumValue(parent, token2) {
        if (!nameRe.test(token2))
          throw illegal(token2, "name");
        skip("=");
        var value = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.getOption = function(name) {
          return this.options[name];
        };
        dummy.setOption = function(name, value2) {
          ReflectionObject.prototype.setOption.call(dummy, name, value2);
        };
        dummy.setParsedOption = function() {
          return void 0;
        };
        ifBlock(dummy, function parseEnumValue_block(token3) {
          if (token3 === "option") {
            parseOption(dummy, token3);
            skip(";");
          } else
            throw illegal(token3);
        }, function parseEnumValue_line() {
          parseInlineOptions(dummy);
        });
        parent.add(token2, value, dummy.comment, dummy.parsedOptions || dummy.options);
      }
      function parseOption(parent, token2) {
        var option;
        var propName;
        var isOption = true;
        if (token2 === "option") {
          token2 = next();
        }
        while (token2 !== "=") {
          if (token2 === "(") {
            var parensValue = next();
            skip(")");
            token2 = "(" + parensValue + ")";
          }
          if (isOption) {
            isOption = false;
            if (token2.includes(".") && !token2.includes("(")) {
              var tokens = token2.split(".");
              option = tokens[0] + ".";
              token2 = tokens[1];
              continue;
            }
            option = token2;
          } else {
            propName = propName ? propName += token2 : token2;
          }
          token2 = next();
        }
        var name = propName ? option.concat(propName) : option;
        var optionValue = parseOptionValue(parent, name);
        propName = propName && propName[0] === "." ? propName.slice(1) : propName;
        option = option && option[option.length - 1] === "." ? option.slice(0, -1) : option;
        setParsedOption(parent, option, optionValue, propName);
      }
      function parseOptionValue(parent, name) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token = next())) {
              throw illegal(token, "name");
            }
            if (token === null) {
              throw illegal(token, "end of input");
            }
            var value;
            var propName = token;
            skip(":", true);
            if (peek() === "{") {
              value = parseOptionValue(parent, name + "." + token);
            } else if (peek() === "[") {
              value = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent, name + "." + token, lastValue);
                }
              }
            } else {
              value = readValue(true);
              setOption(parent, name + "." + token, value);
            }
            var prevValue = objectResult[propName];
            if (prevValue)
              value = [].concat(prevValue).concat(value);
            objectResult[propName] = value;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      function setOption(parent, name, value) {
        if (ptr === parent && /^features\./.test(name)) {
          topLevelOptions[name] = value;
          return;
        }
        if (parent.setOption)
          parent.setOption(name, value);
      }
      function setParsedOption(parent, name, value, propName) {
        if (parent.setParsedOption)
          parent.setParsedOption(name, value, propName);
      }
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      function parseService(parent, token2) {
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "service name");
        var service = new Service(token2);
        ifBlock(service, function parseService_block(token3) {
          if (parseCommon(service, token3)) {
            return;
          }
          if (token3 === "rpc")
            parseMethod(service, token3);
          else
            throw illegal(token3);
        });
        parent.add(service);
        if (parent === ptr) {
          topLevelObjects.push(service);
        }
      }
      function parseMethod(parent, token2) {
        var commentText = cmnt();
        var type = token2;
        if (!nameRe.test(token2 = next()))
          throw illegal(token2, "name");
        var name = token2, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true))
          requestStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        requestType = token2;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true))
          responseStream = true;
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2);
        responseType = token2;
        skip(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, function parseMethod_block(token3) {
          if (token3 === "option") {
            parseOption(method, token3);
            skip(";");
          } else
            throw illegal(token3);
        });
        parent.add(method);
      }
      function parseExtension(parent, token2) {
        if (!typeRefRe.test(token2 = next()))
          throw illegal(token2, "reference");
        var reference = token2;
        ifBlock(null, function parseExtension_block(token3) {
          switch (token3) {
            case "required":
            case "repeated":
              parseField(parent, token3, reference);
              break;
            case "optional":
              if (edition === "proto3") {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (edition === "proto2" || !typeRefRe.test(token3))
                throw illegal(token3);
              push(token3);
              parseField(parent, "optional", reference);
              break;
          }
        });
      }
      var token;
      while ((token = next()) !== null) {
        switch (token) {
          case "package":
            if (!head)
              throw illegal(token);
            parsePackage();
            break;
          case "import":
            if (!head)
              throw illegal(token);
            parseImport();
            break;
          case "syntax":
            if (!head)
              throw illegal(token);
            parseSyntax();
            break;
          case "edition":
            if (!head)
              throw illegal(token);
            parseEdition();
            break;
          case "option":
            parseOption(ptr, token);
            skip(";", true);
            break;
          default:
            if (parseCommon(ptr, token)) {
              head = false;
              continue;
            }
            throw illegal(token);
        }
      }
      resolveFileFeatures();
      parse.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        root
      };
    }
  }
});

// ../../node_modules/protobufjs/src/common.js
var require_common4 = __commonJS({
  "../../node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = { nested: { google: { nested: { protobuf: { nested: json } } } } };
      }
      common[name] = json;
    }
    common("any", {
      /**
       * Properties of a google.protobuf.Any message.
       * @interface IAny
       * @type {Object}
       * @property {string} [typeUrl]
       * @property {Uint8Array} [bytes]
       * @memberof common
       */
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      /**
       * Properties of a google.protobuf.Duration message.
       * @interface IDuration
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      /**
       * Properties of a google.protobuf.Timestamp message.
       * @interface ITimestamp
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Timestamp: timeType
    });
    common("empty", {
      /**
       * Properties of a google.protobuf.Empty message.
       * @interface IEmpty
       * @memberof common
       */
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      /**
       * Properties of a google.protobuf.Struct message.
       * @interface IStruct
       * @type {Object}
       * @property {Object.<string,IValue>} [fields]
       * @memberof common
       */
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Value message.
       * @interface IValue
       * @type {Object}
       * @property {string} [kind]
       * @property {0} [nullValue]
       * @property {number} [numberValue]
       * @property {string} [stringValue]
       * @property {boolean} [boolValue]
       * @property {IStruct} [structValue]
       * @property {IListValue} [listValue]
       * @memberof common
       */
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      /**
       * Properties of a google.protobuf.ListValue message.
       * @interface IListValue
       * @type {Object}
       * @property {Array.<IValue>} [values]
       * @memberof common
       */
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      /**
       * Properties of a google.protobuf.DoubleValue message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.FloatValue message.
       * @interface IFloatValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int64Value message.
       * @interface IInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt64Value message.
       * @interface IUInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int32Value message.
       * @interface IInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt32Value message.
       * @interface IUInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BoolValue message.
       * @interface IBoolValue
       * @type {Object}
       * @property {boolean} [value]
       * @memberof common
       */
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.StringValue message.
       * @interface IStringValue
       * @type {Object}
       * @property {string} [value]
       * @memberof common
       */
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BytesValue message.
       * @interface IBytesValue
       * @type {Object}
       * @property {Uint8Array} [value]
       * @memberof common
       */
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      /**
       * Properties of a google.protobuf.FieldMask message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = function get3(file) {
      return common[file] || null;
    };
  }
});

// ../../node_modules/protobufjs/src/index.js
var require_src76 = __commonJS({
  "../../node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse3();
    protobuf.common = require_common4();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// ../../node_modules/protobufjs/index.js
var require_protobufjs2 = __commonJS({
  "../../node_modules/protobufjs/index.js"(exports2, module2) {
    (function() {
      "use strict";
      module2.exports = require_src76();
    })(...arguments);
    {
      const dc = require_dc_polyfill();
      const ch = dc.channel("dd-trace:bundler:load");
      const mod2 = module2.exports;
      const payload = {
        module: mod2,
        version: "7.5.4",
        package: "protobufjs",
        path: "protobufjs"
      };
      ch.publish(payload);
      module2.exports = payload.module;
    }
  }
});

// ../../packages/dd-trace/src/opentelemetry/otlp/protobuf_loader.js
var require_protobuf_loader = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/otlp/protobuf_loader.js"(exports2, module2) {
    "use strict";
    var protobuf = require_protobufjs2();
    var path = __require("path");
    var _root = null;
    var protoLogsService = null;
    var protoSeverityNumber = null;
    var protoMetricsService = null;
    var protoAggregationTemporality = null;
    function getProtobufTypes() {
      if (_root) {
        return {
          protoLogsService,
          protoSeverityNumber,
          protoMetricsService,
          protoAggregationTemporality
        };
      }
      const protoDir = __dirname;
      const protoFiles = [
        "common.proto",
        "resource.proto",
        "logs.proto",
        "logs_service.proto",
        "metrics.proto",
        "metrics_service.proto"
      ].map((file) => path.join(protoDir, file));
      _root = protobuf.loadSync(protoFiles);
      protoLogsService = _root.lookupType("opentelemetry.proto.collector.logs.v1.ExportLogsServiceRequest");
      protoSeverityNumber = _root.lookupEnum("opentelemetry.proto.logs.v1.SeverityNumber");
      protoMetricsService = _root.lookupType("opentelemetry.proto.collector.metrics.v1.ExportMetricsServiceRequest");
      protoAggregationTemporality = _root.lookupEnum("opentelemetry.proto.metrics.v1.AggregationTemporality");
      return {
        protoLogsService,
        protoSeverityNumber,
        protoMetricsService,
        protoAggregationTemporality
      };
    }
    module2.exports = {
      getProtobufTypes
    };
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/otlp_transformer.js
var require_otlp_transformer = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/otlp_transformer.js"(exports2, module2) {
    "use strict";
    var OtlpTransformerBase = require_otlp_transformer_base();
    var { SeverityNumber } = require_src75();
    var { getProtobufTypes } = require_protobuf_loader();
    var { trace: trace2 } = (init_esm(), __toCommonJS(esm_exports));
    var SEVERITY_MAP = {
      [SeverityNumber.TRACE]: "SEVERITY_NUMBER_TRACE",
      [SeverityNumber.TRACE2]: "SEVERITY_NUMBER_TRACE2",
      [SeverityNumber.TRACE3]: "SEVERITY_NUMBER_TRACE3",
      [SeverityNumber.TRACE4]: "SEVERITY_NUMBER_TRACE4",
      [SeverityNumber.DEBUG]: "SEVERITY_NUMBER_DEBUG",
      [SeverityNumber.DEBUG2]: "SEVERITY_NUMBER_DEBUG2",
      [SeverityNumber.DEBUG3]: "SEVERITY_NUMBER_DEBUG3",
      [SeverityNumber.DEBUG4]: "SEVERITY_NUMBER_DEBUG4",
      [SeverityNumber.INFO]: "SEVERITY_NUMBER_INFO",
      [SeverityNumber.INFO2]: "SEVERITY_NUMBER_INFO2",
      [SeverityNumber.INFO3]: "SEVERITY_NUMBER_INFO3",
      [SeverityNumber.INFO4]: "SEVERITY_NUMBER_INFO4",
      [SeverityNumber.WARN]: "SEVERITY_NUMBER_WARN",
      [SeverityNumber.WARN2]: "SEVERITY_NUMBER_WARN2",
      [SeverityNumber.WARN3]: "SEVERITY_NUMBER_WARN3",
      [SeverityNumber.WARN4]: "SEVERITY_NUMBER_WARN4",
      [SeverityNumber.ERROR]: "SEVERITY_NUMBER_ERROR",
      [SeverityNumber.ERROR2]: "SEVERITY_NUMBER_ERROR2",
      [SeverityNumber.ERROR3]: "SEVERITY_NUMBER_ERROR3",
      [SeverityNumber.ERROR4]: "SEVERITY_NUMBER_ERROR4",
      [SeverityNumber.FATAL]: "SEVERITY_NUMBER_FATAL",
      [SeverityNumber.FATAL2]: "SEVERITY_NUMBER_FATAL2",
      [SeverityNumber.FATAL3]: "SEVERITY_NUMBER_FATAL3",
      [SeverityNumber.FATAL4]: "SEVERITY_NUMBER_FATAL4"
    };
    var OtlpTransformer = class extends OtlpTransformerBase {
      /**
       * Creates a new OtlpTransformer instance.
       *
       * @param {import('@opentelemetry/api').Attributes} resourceAttributes - Resource attributes
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       */
      constructor(resourceAttributes, protocol) {
        super(resourceAttributes, protocol, "logs");
      }
      /**
       * Transforms log records to OTLP format based on the configured protocol.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} Transformed log records in the appropriate format
       */
      transformLogRecords(logRecords) {
        if (this.protocol === "http/json") {
          return this.#transformToJson(logRecords);
        }
        return this.#transformToProtobuf(logRecords);
      }
      /**
       * Transforms log records to protobuf format.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} Protobuf-encoded log records
       * @private
       */
      #transformToProtobuf(logRecords) {
        const { protoLogsService } = getProtobufTypes();
        const logsData = {
          resourceLogs: [{
            resource: this._transformResource(),
            scopeLogs: this.#transformScope(logRecords)
          }]
        };
        return this._serializeToProtobuf(protoLogsService, logsData);
      }
      /**
       * Transforms log records to JSON format.
       * @param {LogRecord[]} logRecords - Array of enriched log records to transform
       * @returns {Buffer} JSON-encoded log records
       * @private
       */
      #transformToJson(logRecords) {
        const logsData = {
          resourceLogs: [{
            resource: this._transformResource(),
            scopeLogs: this.#transformScope(logRecords)
          }]
        };
        return this._serializeToJson(logsData);
      }
      /**
       * Creates scope logs grouped by instrumentation library.
       * @param {LogRecord[]} logRecords - Array of log records to transform
       * @returns {Object[]} Array of scope log objects
       * @private
       */
      #transformScope(logRecords) {
        const groupedRecords = this._groupByInstrumentationScope(logRecords);
        const scopeLogs = [];
        for (const records of groupedRecords.values()) {
          const schemaUrl = records[0]?.instrumentationScope?.schemaUrl || "";
          scopeLogs.push({
            scope: {
              name: records[0]?.instrumentationScope?.name || "dd-trace-js",
              version: records[0]?.instrumentationScope?.version || "",
              attributes: [],
              droppedAttributesCount: 0
            },
            schemaUrl,
            logRecords: records.map((record) => this.#transformLogRecord(record))
          });
        }
        return scopeLogs;
      }
      /**
       * Transforms a single log record to OTLP format.
       * @param {LogRecord} logRecord - Log record to transform
       * @returns {Object} OTLP log record object
       * @private
       */
      #transformLogRecord(logRecord) {
        const spanContext = this.#extractSpanContext(logRecord.context);
        const result = {
          timeUnixNano: logRecord.timestamp,
          body: this.#transformBody(logRecord.body)
        };
        if (logRecord.observedTimestamp) {
          result.observedTimeUnixNano = logRecord.observedTimestamp;
        }
        if (logRecord.severityNumber !== void 0) {
          result.severityNumber = this.#mapSeverityNumber(logRecord.severityNumber);
        }
        if (logRecord.severityText) {
          result.severityText = logRecord.severityText;
        }
        if (logRecord.attributes) {
          result.attributes = this._transformAttributes(logRecord.attributes);
        }
        if (spanContext?.traceFlags !== void 0) {
          result.flags = spanContext.traceFlags;
        }
        if (spanContext?.traceId && spanContext.traceId !== "00000000000000000000000000000000") {
          result.traceId = this.#hexToBytes(spanContext.traceId);
        }
        if (spanContext?.spanId && spanContext.spanId !== "0000000000000000") {
          result.spanId = this.#hexToBytes(spanContext.spanId);
        }
        return result;
      }
      /**
       * Extracts span context from the log record's context.
       * @param {Object} logContext - The log record's context
       * @returns {Object|null} Span context or null if not available
       * @private
       */
      #extractSpanContext(logContext) {
        if (!logContext) return null;
        const activeSpan = trace2.getSpan(logContext);
        if (activeSpan) {
          return activeSpan.spanContext();
        }
        return null;
      }
      /**
       * Maps OpenTelemetry severity number to protobuf severity number.
       * @param {number} severityNumber - OpenTelemetry severity number
       * @returns {number} Protobuf severity number
       * @private
       */
      #mapSeverityNumber(severityNumber) {
        const { protoSeverityNumber } = getProtobufTypes();
        const severityName = SEVERITY_MAP[severityNumber] || "SEVERITY_NUMBER_INFO";
        return protoSeverityNumber.values[severityName];
      }
      /**
       * Converts a hex string to a Buffer.
       * @param {string} hexString - Hex string to convert
       * @returns {Buffer} Buffer containing the hex data
       * @private
       */
      #hexToBytes(hexString) {
        const cleanHex = hexString ? hexString.startsWith("0x") ? hexString.slice(2) : hexString : "";
        const paddedHex = cleanHex.length % 2 === 0 ? cleanHex : "0" + cleanHex;
        return Buffer.from(paddedHex, "hex");
      }
      /**
       * Transforms log body to OTLP AnyValue format.
       * @param {any} body - Log body to transform
       * @returns {Object} OTLP AnyValue object
       * @private
       */
      #transformBody(body) {
        if (typeof body === "string") {
          return { stringValue: body };
        } else if (typeof body === "number") {
          if (Number.isInteger(body)) {
            return { intValue: body };
          }
          return { doubleValue: body };
        } else if (typeof body === "boolean") {
          return { boolValue: body };
        } else if (body && typeof body === "object") {
          return {
            kvlistValue: {
              values: Object.entries(body).map(([key, value]) => ({
                key,
                value: this._transformAnyValue(value)
              }))
            }
          };
        }
        return { stringValue: String(body) };
      }
    };
    module2.exports = OtlpTransformer;
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/otlp_http_log_exporter.js
var require_otlp_http_log_exporter = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/otlp_http_log_exporter.js"(exports2, module2) {
    "use strict";
    var OtlpHttpExporterBase = require_otlp_http_exporter_base();
    var OtlpTransformer = require_otlp_transformer();
    var OtlpHttpLogExporter = class extends OtlpHttpExporterBase {
      /**
       * Creates a new OtlpHttpLogExporter instance.
       *
       * @param {string} url - OTLP endpoint URL
       * @param {string} headers - Additional HTTP headers as comma-separated key=value string
       * @param {number} timeout - Request timeout in milliseconds
       * @param {string} protocol - OTLP protocol (http/protobuf or http/json)
       * @param {Resource} resource - Resource attributes
       */
      constructor(url, headers, timeout, protocol, resource) {
        super(url, headers, timeout, protocol, "/v1/logs", "logs");
        this.transformer = new OtlpTransformer(resource, protocol);
      }
      /**
       * Exports log records via OTLP over HTTP.
       *
       * @param {LogRecord[]} logRecords - Array of enriched log records to export
       * @param {Function} resultCallback - Callback function for export result
       */
      export(logRecords, resultCallback) {
        if (logRecords.length === 0) {
          resultCallback({ code: 0 });
          return;
        }
        const payload = this.transformer.transformLogRecords(logRecords);
        this._sendPayload(payload, resultCallback);
        this._recordTelemetry("otel.log_records", logRecords.length);
      }
    };
    module2.exports = OtlpHttpLogExporter;
  }
});

// ../../packages/dd-trace/src/opentelemetry/logs/index.js
var require_logs3 = __commonJS({
  "../../packages/dd-trace/src/opentelemetry/logs/index.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var LoggerProvider = require_logger_provider();
    var BatchLogRecordProcessor = require_batch_log_processor();
    var OtlpHttpLogExporter = require_otlp_http_log_exporter();
    function initializeOpenTelemetryLogs(config) {
      const resourceAttributes = {
        "service.name": config.service,
        "service.version": config.version,
        "deployment.environment": config.env
      };
      if (config.tags) {
        const filteredTags = { ...config.tags };
        delete filteredTags.service;
        delete filteredTags.version;
        delete filteredTags.env;
        Object.assign(resourceAttributes, filteredTags);
      }
      if (config.reportHostname) {
        resourceAttributes["host.name"] = os.hostname();
      }
      const exporter = new OtlpHttpLogExporter(
        config.otelLogsUrl,
        config.otelLogsHeaders,
        config.otelLogsTimeout,
        config.otelLogsProtocol,
        resourceAttributes
      );
      const processor = new BatchLogRecordProcessor(
        exporter,
        config.otelLogsBatchTimeout,
        config.otelLogsMaxExportBatchSize
      );
      const loggerProvider = new LoggerProvider({ processor });
      loggerProvider.register();
    }
    module2.exports = {
      LoggerProvider,
      initializeOpenTelemetryLogs
    };
  }
});

// ../../node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "../../node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = (/* @__PURE__ */ new Date()).getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = (/* @__PURE__ */ new Date()).getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// ../../node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "../../node_modules/retry/lib/retry.js"(exports2) {
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// ../../node_modules/retry/index.js
var require_retry2 = __commonJS({
  "../../node_modules/retry/index.js"(exports2, module2) {
    module2.exports = require_retry();
  }
});

// ../../packages/dd-trace/src/profiling/libuv-size.js
var require_libuv_size = __commonJS({
  "../../packages/dd-trace/src/profiling/libuv-size.js"(exports2, module2) {
    "use strict";
    var { getEnvironmentVariable } = require_config_helper();
    var os = __require("node:os");
    function getLibuvThreadPoolSize(envVar) {
      if (envVar === void 0) {
        return;
      }
      const s = Number.parseInt(envVar, 10);
      return Number.isNaN(s) ? 0 : s;
    }
    var libuvThreadPoolSize = getLibuvThreadPoolSize(getEnvironmentVariable("UV_THREADPOOL_SIZE"));
    function getEffectiveLibuvThreadCount(size) {
      if (size === void 0) {
        return 4;
      } else if (size < 0 || size > 1024) {
        return 1024;
      } else if (size === 0) {
        return 1;
      }
      return size;
    }
    var effectiveLibuvThreadCount = getEffectiveLibuvThreadCount(libuvThreadPoolSize);
    function availableParallelism() {
      return typeof os.availableParallelism === "function" ? os.availableParallelism() : os.cpus().length;
    }
    module2.exports = {
      availableParallelism,
      effectiveLibuvThreadCount,
      libuvThreadPoolSize,
      // Only used for testing
      getLibuvThreadPoolSize,
      getEffectiveLibuvThreadCount
    };
  }
});

// ../../packages/dd-trace/src/profiling/exporters/event_serializer.js
var require_event_serializer = __commonJS({
  "../../packages/dd-trace/src/profiling/exporters/event_serializer.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var perf = __require("perf_hooks").performance;
    var version = require_package().version;
    var { availableParallelism, libuvThreadPoolSize } = require_libuv_size();
    var EventSerializer = class {
      constructor({ env, host, service, version: version2, libraryInjected, activation } = {}) {
        this._env = env;
        this._host = host;
        this._service = service;
        this._appVersion = version2;
        this._libraryInjected = !!libraryInjected;
        this._activation = activation || "unknown";
      }
      typeToFile(type) {
        return `${type}.pprof`;
      }
      getEventJSON({ profiles, infos, start, end, tags = {}, endpointCounts }) {
        return JSON.stringify({
          attachments: Object.keys(profiles).map((t) => this.typeToFile(t)),
          start: start.toISOString(),
          end: end.toISOString(),
          family: "node",
          version: "4",
          tags_profiler: [
            "language:javascript",
            "runtime:nodejs",
            `runtime_arch:${process.arch}`,
            `runtime_os:${process.platform}`,
            `runtime_version:${process.version}`,
            `process_id:${process.pid}`,
            `profiler_version:${version}`,
            "format:pprof",
            ...Object.entries(tags).map(([key, value]) => `${key}:${value}`)
          ].join(","),
          endpoint_counts: endpointCounts,
          info: {
            application: {
              env: this._env,
              service: this._service,
              start_time: new Date(perf.nodeTiming.nodeStart + perf.timeOrigin).toISOString(),
              version: this._appVersion
            },
            platform: {
              hostname: this._host,
              kernel_name: os.type(),
              kernel_release: os.release(),
              kernel_version: os.version()
            },
            profiler: {
              activation: this._activation,
              ssi: {
                mechanism: this._libraryInjected ? "injected_agent" : "none"
              },
              version,
              ...infos
            },
            runtime: {
              available_processors: availableParallelism(),
              // Using `nodejs` for consistency with the existing `runtime` tag.
              // Note that the event `family` property uses `node`, as that's what's
              // proscribed by the Intake API, but that's an internal enum and is
              // not customer visible.
              engine: "nodejs",
              libuv_threadpool_size: libuvThreadPoolSize,
              // strip off leading 'v'. This makes the format consistent with other
              // runtimes (e.g. Ruby) but not with the existing `runtime_version` tag.
              // We'll keep it like this as we want cross-engine consistency. We
              // also aren't changing the format of the existing tag as we don't want
              // to break it.
              version: process.version.slice(1)
            }
          }
        });
      }
    };
    module2.exports = { EventSerializer };
  }
});

// ../../packages/dd-trace/src/profiling/exporters/agent.js
var require_agent2 = __commonJS({
  "../../packages/dd-trace/src/profiling/exporters/agent.js"(exports2, module2) {
    "use strict";
    var retry = require_retry2();
    var { request: httpRequest } = __require("http");
    var { request: httpsRequest } = __require("https");
    var { EventSerializer } = require_event_serializer();
    var docker = require_docker();
    var FormData = require_form_data();
    var { storage } = require_datadog_core();
    var version = require_package().version;
    var { urlToHttpOptions } = __require("url");
    var perf = __require("perf_hooks").performance;
    var telemetryMetrics = require_metrics();
    var profilersNamespace = telemetryMetrics.manager.namespace("profilers");
    var statusCodeCounters = [];
    var requestCounter = profilersNamespace.count("profile_api.requests", []);
    var sizeDistribution = profilersNamespace.distribution("profile_api.bytes", []);
    var durationDistribution = profilersNamespace.distribution("profile_api.ms", []);
    var statusCodeErrorCounter = profilersNamespace.count("profile_api.errors", ["type:status_code"]);
    var networkErrorCounter = profilersNamespace.count("profile_api.errors", ["type:network"]);
    function countStatusCode(statusCode) {
      let counter = statusCodeCounters[statusCode];
      if (counter === void 0) {
        counter = statusCodeCounters[statusCode] = profilersNamespace.count(
          "profile_api.responses",
          [`status_code:${statusCode}`]
        );
      }
      counter.inc();
    }
    function sendRequest(options, form, callback) {
      const request2 = options.protocol === "https:" ? httpsRequest : httpRequest;
      const store = storage("legacy").getStore();
      storage("legacy").enterWith({ noop: true });
      requestCounter.inc();
      const start = perf.now();
      const req = request2(options, (res) => {
        durationDistribution.track(perf.now() - start);
        countStatusCode(res.statusCode);
        if (res.statusCode >= 400) {
          statusCodeErrorCounter.inc();
          const error = new Error(`HTTP Error ${res.statusCode}`);
          error.status = res.statusCode;
          callback(error);
        } else {
          callback(null, res);
        }
      });
      req.on("error", (err) => {
        networkErrorCounter.inc();
        callback(err);
      });
      if (form) {
        sizeDistribution.track(form.size());
        form.pipe(req);
      }
      storage("legacy").enterWith(store);
    }
    function getBody(stream, callback) {
      const chunks = [];
      stream.on("error", (err) => {
        networkErrorCounter.inc();
        callback(err);
      });
      stream.on("data", (chunk) => chunks.push(chunk));
      stream.on("end", () => {
        callback(null, Buffer.concat(chunks));
      });
    }
    function computeRetries(uploadTimeout) {
      let tries = 0;
      while (tries < 2 || uploadTimeout > 1e3) {
        tries++;
        uploadTimeout /= 2;
      }
      return [tries, Math.floor(uploadTimeout)];
    }
    var AgentExporter = class extends EventSerializer {
      constructor(config = {}) {
        super(config);
        const { url, logger, uploadTimeout } = config;
        this._url = url;
        this._logger = logger;
        const [backoffTries, backoffTime] = computeRetries(uploadTimeout);
        this._backoffTime = backoffTime;
        this._backoffTries = backoffTries;
      }
      export(exportSpec) {
        const { profiles } = exportSpec;
        const fields = [];
        const event = this.getEventJSON(exportSpec);
        fields.push(["event", event, {
          filename: "event.json",
          contentType: "application/json"
        }]);
        this._logger.debug(() => {
          return `Building agent export report:
${event}`;
        });
        for (const [type, buffer] of Object.entries(profiles)) {
          this._logger.debug(() => {
            const bytes = buffer.toString("hex").match(/../g).join(" ");
            return `Adding ${type} profile to agent export: ` + bytes;
          });
          const filename = this.typeToFile(type);
          fields.push([filename, buffer, {
            filename,
            contentType: "application/octet-stream"
          }]);
        }
        return new Promise((resolve, reject) => {
          const operation = retry.operation({
            randomize: true,
            minTimeout: this._backoffTime,
            retries: this._backoffTries,
            unref: true
          });
          operation.attempt((attempt) => {
            const form = new FormData();
            for (const [key, value, options2] of fields) {
              form.append(key, value, options2);
            }
            const options = {
              method: "POST",
              path: "/profiling/v1/input",
              headers: {
                "DD-EVP-ORIGIN": "dd-trace-js",
                "DD-EVP-ORIGIN-VERSION": version,
                ...form.getHeaders()
              },
              timeout: this._backoffTime * 2 ** attempt
            };
            docker.inject(options.headers);
            if (this._url.protocol === "unix:") {
              options.socketPath = this._url.pathname;
            } else {
              const httpOptions = urlToHttpOptions(this._url);
              options.protocol = httpOptions.protocol;
              options.hostname = httpOptions.hostname;
              options.port = httpOptions.port;
            }
            this._logger.debug(() => {
              return `Submitting profiler agent report attempt #${attempt} to: ${JSON.stringify(options)}`;
            });
            sendRequest(options, form, (err, response) => {
              if (err) {
                const { status } = err;
                if ((typeof status !== "number" || status >= 500 || status === 429) && operation.retry(err)) {
                  this._logger.warn(`Error from the agent: ${err.message}`);
                } else {
                  reject(err);
                }
                return;
              }
              getBody(response, (err2, body) => {
                if (err2) {
                  this._logger.warn(`Error reading agent response: ${err2.message}`);
                } else {
                  this._logger.debug(() => {
                    const bytes = (body.toString("hex").match(/../g) || []).join(" ");
                    return `Agent export response: ${bytes}`;
                  });
                }
              });
              resolve();
            });
          });
        });
      }
    };
    module2.exports = { AgentExporter, computeRetries };
  }
});

// ../../packages/dd-trace/src/profiling/exporters/file.js
var require_file2 = __commonJS({
  "../../packages/dd-trace/src/profiling/exporters/file.js"(exports2, module2) {
    "use strict";
    var fs = __require("fs");
    var { promisify } = __require("util");
    var { threadId } = __require("worker_threads");
    var writeFile = promisify(fs.writeFile);
    var { EventSerializer } = require_event_serializer();
    var pad = (n) => String(n).padStart(2, "0");
    function formatDateTime(t) {
      return `${t.getUTCFullYear()}${pad(t.getUTCMonth() + 1)}${pad(t.getUTCDate())}T${pad(t.getUTCHours())}${pad(t.getUTCMinutes())}${pad(t.getUTCSeconds())}Z`;
    }
    var FileExporter = class extends EventSerializer {
      constructor(config = {}) {
        super(config);
        const { pprofPrefix } = config;
        this._pprofPrefix = pprofPrefix || "";
      }
      export(exportSpec) {
        const { profiles, end } = exportSpec;
        const types = Object.keys(profiles);
        const dateStr = formatDateTime(end);
        const tasks = types.map((type) => {
          return writeFile(`${this._pprofPrefix}${type}_worker_${threadId}_${dateStr}.pprof`, profiles[type]);
        });
        tasks.push(writeFile(`event_worker_${threadId}_${dateStr}.json`, this.getEventJSON(exportSpec)));
        return Promise.all(tasks);
      }
    };
    module2.exports = { FileExporter };
  }
});

// ../../packages/dd-trace/src/profiling/loggers/console.js
var require_console = __commonJS({
  "../../packages/dd-trace/src/profiling/loggers/console.js"(exports2, module2) {
    "use strict";
    var mapping = {
      error: 3,
      warn: 4,
      info: 6,
      debug: 7
    };
    var ConsoleLogger = class {
      constructor(options = {}) {
        this._level = mapping[options.level] || mapping.error;
      }
      debug(message) {
        this._log("debug", message);
      }
      info(message) {
        this._log("info", message);
      }
      warn(message) {
        this._log("warn", message);
      }
      error(message) {
        this._log("error", message);
      }
      _log(level, message) {
        if (mapping[level] > this._level) return;
        console[level](message);
      }
    };
    module2.exports = { ConsoleLogger };
  }
});

// ../../packages/dd-trace/src/profiling/profilers/shared.js
var require_shared = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/shared.js"(exports2, module2) {
    "use strict";
    var { isMainThread, threadId } = __require("worker_threads");
    var END_TIMESTAMP_LABEL = "end_timestamp_ns";
    var THREAD_NAME_LABEL = "thread name";
    var OS_THREAD_ID_LABEL = "os thread id";
    var THREAD_ID_LABEL = "thread id";
    var SPAN_ID_LABEL = "span id";
    var LOCAL_ROOT_SPAN_ID_LABEL = "local root span id";
    var threadNamePrefix = isMainThread ? "Main" : `Worker #${threadId}`;
    var eventLoopThreadName = `${threadNamePrefix} Event Loop`;
    function getThreadLabels() {
      const pprof = __require("@datadog/pprof");
      const nativeThreadId = pprof.getNativeThreadId();
      return {
        [THREAD_NAME_LABEL]: eventLoopThreadName,
        [THREAD_ID_LABEL]: `${threadId}`,
        [OS_THREAD_ID_LABEL]: `${nativeThreadId}`
      };
    }
    function cacheThreadLabels() {
      let labels;
      return () => {
        if (!labels) {
          labels = getThreadLabels();
        }
        return labels;
      };
    }
    function getNonJSThreadsLabels() {
      return { [THREAD_NAME_LABEL]: "Non-JS threads", [THREAD_ID_LABEL]: "NA", [OS_THREAD_ID_LABEL]: "NA" };
    }
    function encodeProfileAsync(profile) {
      return profile.encodeAsync().then(Buffer.from);
    }
    module2.exports = {
      END_TIMESTAMP_LABEL,
      THREAD_NAME_LABEL,
      THREAD_ID_LABEL,
      OS_THREAD_ID_LABEL,
      SPAN_ID_LABEL,
      LOCAL_ROOT_SPAN_ID_LABEL,
      threadNamePrefix,
      eventLoopThreadName,
      getNonJSThreadsLabels,
      getThreadLabels: cacheThreadLabels(),
      encodeProfileAsync
    };
  }
});

// ../../packages/dd-trace/src/profiling/webspan-utils.js
var require_webspan_utils = __commonJS({
  "../../packages/dd-trace/src/profiling/webspan-utils.js"(exports2, module2) {
    "use strict";
    var { HTTP_METHOD, HTTP_ROUTE, RESOURCE_NAME, SPAN_TYPE } = require_tags();
    var { WEB } = require_types();
    function isWebServerSpan(tags) {
      return tags[SPAN_TYPE] === WEB;
    }
    function endpointNameFromTags(tags) {
      return tags[RESOURCE_NAME] || [
        tags[HTTP_METHOD],
        tags[HTTP_ROUTE]
      ].filter(Boolean).join(" ");
    }
    function getStartedSpans(context2) {
      return context2._trace.started;
    }
    module2.exports = {
      isWebServerSpan,
      endpointNameFromTags,
      getStartedSpans
    };
  }
});

// ../../packages/dd-trace/src/profiling/profilers/wall.js
var require_wall = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/wall.js"(exports2, module2) {
    "use strict";
    var { storage } = require_datadog_core();
    var dc = require_dc_polyfill();
    var runtimeMetrics = require_runtime_metrics2();
    var telemetryMetrics = require_metrics();
    var {
      END_TIMESTAMP_LABEL,
      SPAN_ID_LABEL,
      LOCAL_ROOT_SPAN_ID_LABEL,
      getNonJSThreadsLabels,
      getThreadLabels,
      encodeProfileAsync
    } = require_shared();
    var TRACE_ENDPOINT_LABEL = "trace endpoint";
    var { isWebServerSpan, endpointNameFromTags, getStartedSpans } = require_webspan_utils();
    var beforeCh;
    var enterCh = dc.channel("dd-trace:storage:enter");
    var spanFinishCh = dc.channel("dd-trace:span:finish");
    var profilerTelemetryMetrics = telemetryMetrics.manager.namespace("profilers");
    var ProfilingContext = Symbol("NativeWallProfiler.ProfilingContext");
    var kSampleCount;
    function getActiveSpan2() {
      const store = storage("legacy").getStore();
      return store && store.span;
    }
    function toBigInt(spanId) {
      return spanId !== null && typeof spanId === "object" ? spanId.toBigInt() : spanId;
    }
    function updateContext(context2) {
      if (context2.spanId !== void 0) {
        context2.spanId = toBigInt(context2.spanId);
      }
      if (context2.rootSpanId !== void 0) {
        context2.rootSpanId = toBigInt(context2.rootSpanId);
      }
      if (context2.webTags !== void 0 && context2.endpoint === void 0) {
        context2.endpoint = endpointNameFromTags(context2.webTags);
      }
    }
    var channelsActivated = false;
    function ensureChannelsActivated(asyncContextFrameEnabled) {
      if (channelsActivated) return;
      const shimmer = require_datadog_shimmer();
      const asyncHooks = __require("async_hooks");
      if (!asyncContextFrameEnabled) {
        const { createHook } = asyncHooks;
        beforeCh = dc.channel("dd-trace:storage:before");
        createHook({ before: () => beforeCh.publish() }).enable();
      }
      const { AsyncLocalStorage } = asyncHooks;
      let inRun = false;
      shimmer.wrap(AsyncLocalStorage.prototype, "enterWith", function(original) {
        return function(...args) {
          const retVal = original.apply(this, args);
          if (!inRun) enterCh.publish();
          return retVal;
        };
      });
      if (!asyncContextFrameEnabled) {
        shimmer.wrap(AsyncLocalStorage.prototype, "run", function(original) {
          return function(store, callback, ...args) {
            const wrappedCb = shimmer.wrapFunction(callback, (cb) => function(...args2) {
              inRun = false;
              enterCh.publish();
              const retVal2 = cb.apply(this, args2);
              inRun = true;
              return retVal2;
            });
            inRun = true;
            const retVal = original.call(this, store, wrappedCb, ...args);
            enterCh.publish();
            inRun = false;
            return retVal;
          };
        });
      }
      channelsActivated = true;
    }
    var NativeWallProfiler = class {
      #asyncContextFrameEnabled = false;
      #captureSpanData = false;
      #codeHotspotsEnabled = false;
      #cpuProfilingEnabled = false;
      #endpointCollectionEnabled = false;
      #flushIntervalMillis = 0;
      #logger;
      #mapper;
      #pprof;
      #samplingIntervalMicros = 0;
      #started = false;
      #telemetryHeartbeatIntervalMillis = 0;
      #timelineEnabled = false;
      #v8ProfilerBugWorkaroundEnabled = false;
      #withContexts = false;
      // Bind these to this so they can be used as callbacks
      #boundEnter = this.#enter.bind(this);
      #boundSpanFinished = this.#spanFinished.bind(this);
      #boundGenerateLabels = this._generateLabels.bind(this);
      get type() {
        return "wall";
      }
      constructor(options = {}) {
        this.#asyncContextFrameEnabled = !!options.asyncContextFrameEnabled;
        this.#codeHotspotsEnabled = !!options.codeHotspotsEnabled;
        this.#cpuProfilingEnabled = !!options.cpuProfilingEnabled;
        this.#endpointCollectionEnabled = !!options.endpointCollectionEnabled;
        this.#flushIntervalMillis = options.flushInterval || 60 * 1e3;
        this.#logger = options.logger;
        this.#samplingIntervalMicros = (options.samplingInterval || 1e3 / 99) * 1e3;
        this.#telemetryHeartbeatIntervalMillis = options.heartbeatInterval || 60 * 1e3;
        this.#timelineEnabled = !!options.timelineEnabled;
        this.#v8ProfilerBugWorkaroundEnabled = !!options.v8ProfilerBugWorkaroundEnabled;
        this.#captureSpanData = this.#codeHotspotsEnabled || this.#endpointCollectionEnabled;
        this.#withContexts = this.#captureSpanData || this.#timelineEnabled || this.#cpuProfilingEnabled;
      }
      codeHotspotsEnabled() {
        return this.#codeHotspotsEnabled;
      }
      endpointCollectionEnabled() {
        return this.#endpointCollectionEnabled;
      }
      start({ mapper } = {}) {
        if (this.#started) return;
        this.#mapper = mapper;
        this.#pprof = __require("@datadog/pprof");
        kSampleCount = this.#pprof.time.constants.kSampleCount;
        if (!process._startProfilerIdleNotifier) {
          process._startProfilerIdleNotifier = () => {
          };
        }
        if (!process._stopProfilerIdleNotifier) {
          process._stopProfilerIdleNotifier = () => {
          };
        }
        this.#pprof.time.start({
          collectCpuTime: this.#cpuProfilingEnabled,
          durationMillis: this.#flushIntervalMillis,
          intervalMicros: this.#samplingIntervalMicros,
          lineNumbers: false,
          sourceMapper: this.#mapper,
          useCPED: this.#asyncContextFrameEnabled,
          withContexts: this.#withContexts,
          workaroundV8Bug: this.#v8ProfilerBugWorkaroundEnabled
        });
        if (this.#withContexts) {
          if (!this.#asyncContextFrameEnabled) {
            this.#setNewContext();
          }
          if (this.#captureSpanData) {
            this._profilerState = this.#pprof.time.getState();
            this._lastSampleCount = 0;
            ensureChannelsActivated(this.#asyncContextFrameEnabled);
            if (this.#asyncContextFrameEnabled) {
              this.#setupTelemetryMetrics();
            } else {
              beforeCh.subscribe(this.#boundEnter);
            }
            enterCh.subscribe(this.#boundEnter);
            spanFinishCh.subscribe(this.#boundSpanFinished);
          }
        }
        this.#started = true;
      }
      #setupTelemetryMetrics() {
        const asyncContextsLiveGauge = profilerTelemetryMetrics.gauge("wall.async_contexts_live");
        const asyncContextsUsedGauge = profilerTelemetryMetrics.gauge("wall.async_contexts_used");
        this._contextCountGaugeUpdater = setInterval(() => {
          const { totalAsyncContextCount, usedAsyncContextCount } = this.#pprof.time.getMetrics();
          asyncContextsLiveGauge.mark(totalAsyncContextCount);
          asyncContextsUsedGauge.mark(usedAsyncContextCount);
        }, this.#telemetryHeartbeatIntervalMillis);
        this._contextCountGaugeUpdater.unref();
      }
      #enter() {
        if (!this.#started) return;
        const span = getActiveSpan2();
        const sampleContext = span ? this.#getProfilingContext(span) : {};
        if (this.#asyncContextFrameEnabled) {
          this.#pprof.time.setContext(sampleContext);
        } else {
          const sampleCount = this._profilerState[kSampleCount];
          if (sampleCount !== this._lastSampleCount) {
            this._lastSampleCount = sampleCount;
            const context2 = this._currentContext.ref;
            this.#setNewContext();
            updateContext(context2);
          }
          this._currentContext.ref = sampleContext;
        }
      }
      #getProfilingContext(span) {
        let profilingContext = span[ProfilingContext];
        if (profilingContext === void 0) {
          const context2 = span.context();
          const startedSpans = getStartedSpans(context2);
          let spanId;
          let rootSpanId;
          if (this.#codeHotspotsEnabled) {
            spanId = context2._spanId;
            rootSpanId = startedSpans.length ? startedSpans[0].context()._spanId : context2._spanId;
          }
          let webTags;
          if (this.#endpointCollectionEnabled) {
            const tags = context2._tags;
            if (isWebServerSpan(tags)) {
              webTags = tags;
            } else {
              const parentId = context2._parentId;
              for (let i = startedSpans.length; --i >= 0; ) {
                const ispan = startedSpans[i];
                if (ispan.context()._spanId === parentId) {
                  webTags = this.#getProfilingContext(ispan).webTags;
                  break;
                }
              }
            }
          }
          profilingContext = { spanId, rootSpanId, webTags };
          span[ProfilingContext] = profilingContext;
        }
        return profilingContext;
      }
      #setNewContext() {
        this.#pprof.time.setContext(
          this._currentContext = {
            ref: {}
          }
        );
      }
      #spanFinished(span) {
        if (span[ProfilingContext] !== void 0) {
          span[ProfilingContext] = void 0;
        }
      }
      #reportV8bug(maybeBug) {
        const tag = `v8_profiler_bug_workaround_enabled:${this.#v8ProfilerBugWorkaroundEnabled}`;
        const metric = `v8_cpu_profiler${maybeBug ? "_maybe" : ""}_stuck_event_loop`;
        this.#logger?.warn(`Wall profiler: ${maybeBug ? "possible " : ""}v8 profiler stuck event loop detected.`);
        runtimeMetrics.increment(`runtime.node.profiler.${metric}`, tag, true);
        profilerTelemetryMetrics.count(metric, [tag]).inc();
      }
      #stop(restart) {
        if (!this.#started) return;
        if (this.#captureSpanData && !this.#asyncContextFrameEnabled) {
          this.#enter();
          this._lastSampleCount = 0;
        }
        const lowCardinalityLabels = Object.keys(getThreadLabels());
        lowCardinalityLabels.push(TRACE_ENDPOINT_LABEL);
        const profile = this.#pprof.time.stop(restart, this.#boundGenerateLabels, lowCardinalityLabels);
        if (restart) {
          const v8BugDetected = this.#pprof.time.v8ProfilerStuckEventLoopDetected();
          if (v8BugDetected !== 0) {
            this.#reportV8bug(v8BugDetected === 1);
          }
        } else {
          clearInterval(this._contextCountGaugeUpdater);
          if (this.#captureSpanData) {
            if (!this.#asyncContextFrameEnabled) {
              beforeCh.unsubscribe(this.#boundEnter);
            }
            enterCh.unsubscribe(this.#boundEnter);
            spanFinishCh.unsubscribe(this.#boundSpanFinished);
            this._profilerState = void 0;
          }
          this.#started = false;
        }
        return profile;
      }
      _generateLabels({ node, context: context2 }) {
        if (node.name === this.#pprof.time.constants.NON_JS_THREADS_FUNCTION_NAME) {
          return getNonJSThreadsLabels();
        }
        if (context2 == null) {
          return getThreadLabels();
        }
        const labels = { ...getThreadLabels() };
        if (this.#timelineEnabled) {
          labels[END_TIMESTAMP_LABEL] = context2.timestamp * 1000n;
        }
        const asyncId = context2.asyncId;
        if (asyncId !== void 0 && asyncId !== -1) {
          labels["async id"] = asyncId;
        }
        const ref = this.#asyncContextFrameEnabled ? context2.context : context2.context?.ref;
        if (typeof ref !== "object") {
          return labels;
        }
        const { spanId, rootSpanId, webTags, endpoint } = ref;
        if (spanId !== void 0) {
          labels[SPAN_ID_LABEL] = toBigInt(spanId);
        }
        if (rootSpanId !== void 0) {
          labels[LOCAL_ROOT_SPAN_ID_LABEL] = toBigInt(rootSpanId);
        }
        if (webTags !== void 0 && Object.keys(webTags).length !== 0) {
          labels[TRACE_ENDPOINT_LABEL] = endpointNameFromTags(webTags);
        } else if (endpoint) {
          labels[TRACE_ENDPOINT_LABEL] = endpoint;
        }
        return labels;
      }
      profile(restart) {
        return this.#stop(restart);
      }
      getInfo() {
        const { totalAsyncContextCount, usedAsyncContextCount } = this.#pprof.time.getMetrics();
        return {
          totalAsyncContextCount,
          usedAsyncContextCount
        };
      }
      encode(profile) {
        return encodeProfileAsync(profile);
      }
      stop() {
        this.#stop(false);
      }
      isStarted() {
        return this.#started;
      }
    };
    module2.exports = NativeWallProfiler;
  }
});

// ../../packages/dd-trace/src/profiling/constants.js
var require_constants5 = __commonJS({
  "../../packages/dd-trace/src/profiling/constants.js"(exports2, module2) {
    "use strict";
    var snapshotKinds = Object.freeze({
      PERIODIC: "periodic",
      ON_SHUTDOWN: "on_shutdown",
      ON_OUT_OF_MEMORY: "on_oom"
    });
    var oomExportStrategies = Object.freeze({
      PROCESS: "process",
      ASYNC_CALLBACK: "async",
      LOGS: "logs"
    });
    module2.exports = { snapshotKinds, oomExportStrategies };
  }
});

// ../../packages/dd-trace/src/profiling/profilers/space.js
var require_space = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/space.js"(exports2, module2) {
    "use strict";
    var { oomExportStrategies } = require_constants5();
    var { encodeProfileAsync, getThreadLabels } = require_shared();
    function strategiesToCallbackMode(strategies, callbackMode) {
      return strategies.includes(oomExportStrategies.ASYNC_CALLBACK) ? callbackMode.Async : 0;
    }
    var STACK_DEPTH = 64;
    var NativeSpaceProfiler = class {
      #mapper;
      #oomMonitoring;
      #pprof;
      #samplingInterval = 512 * 1024;
      #started = false;
      constructor(options = {}) {
        this.#samplingInterval = options.heapSamplingInterval || 512 * 1024;
        this.#oomMonitoring = options.oomMonitoring || {};
      }
      get type() {
        return "space";
      }
      start({ mapper, nearOOMCallback } = {}) {
        if (this.#started) return;
        this.#mapper = mapper;
        this.#pprof = __require("@datadog/pprof");
        this.#pprof.heap.start(this.#samplingInterval, STACK_DEPTH);
        if (this.#oomMonitoring.enabled) {
          const strategies = this.#oomMonitoring.exportStrategies;
          this.#pprof.heap.monitorOutOfMemory(
            this.#oomMonitoring.heapLimitExtensionSize,
            this.#oomMonitoring.maxHeapExtensionCount,
            strategies.includes(oomExportStrategies.LOGS),
            strategies.includes(oomExportStrategies.PROCESS) ? this.#oomMonitoring.exportCommand : [],
            (profile) => nearOOMCallback(this.type, this.#pprof.encodeSync(profile), this.getInfo()),
            strategiesToCallbackMode(strategies, this.#pprof.heap.CallbackMode)
          );
        }
        this.#started = true;
      }
      profile(restart) {
        const profile = this.#pprof.heap.profile(void 0, this.#mapper, getThreadLabels);
        if (!restart) {
          this.stop();
        }
        return profile;
      }
      getInfo() {
        return {};
      }
      encode(profile) {
        return encodeProfileAsync(profile);
      }
      stop() {
        if (!this.#started) return;
        this.#pprof.heap.stop();
        this.#started = false;
      }
      isStarted() {
        return this.#started;
      }
    };
    module2.exports = NativeSpaceProfiler;
  }
});

// ../../node_modules/pprof-format/dist/commonjs/index.js
var require_commonjs2 = __commonJS({
  "../../node_modules/pprof-format/dist/commonjs/index.js"(exports2) {
    "use strict";
    var __classPrivateFieldGet = exports2 && exports2.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _StringTable_encodings;
    var _StringTable_positions;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Profile = exports2.Function = exports2.Location = exports2.Line = exports2.Mapping = exports2.Sample = exports2.Label = exports2.ValueType = exports2.StringTable = exports2.emptyTableToken = void 0;
    var lowMaxBig = 2n ** 32n - 1n;
    var lowMax = 2 ** 32 - 1;
    var lowMaxPlus1 = lowMax + 1;
    var toUtf8 = typeof Buffer === "undefined" ? (value) => new TextEncoder().encode(value) : (value) => Buffer.from(value, "utf8");
    function countNumberBytes(buffer) {
      if (!buffer.length)
        return 0;
      let i = 0;
      while (i < buffer.length && buffer[i++] >= 128)
        ;
      return i;
    }
    function decodeBigNumber(buffer) {
      if (!buffer.length)
        return BigInt(0);
      let value = BigInt(buffer[0] & 127);
      let i = 0;
      while (buffer[i++] >= 128) {
        value |= BigInt(buffer[i] & 127) << BigInt(7 * i);
      }
      return value;
    }
    function makeValue(value, offset = 0) {
      return { value, offset };
    }
    function getValue(mode, buffer) {
      switch (mode) {
        case kTypeVarInt:
          for (let i = 0; i < buffer.length; i++) {
            if (!(buffer[i] & 128)) {
              return makeValue(buffer.slice(0, i + 1));
            }
          }
          return makeValue(buffer);
        case kTypeLengthDelim: {
          const offset = countNumberBytes(buffer);
          const size = decodeNumber(buffer);
          return makeValue(buffer.slice(offset, Number(size) + offset), offset);
        }
        default:
          throw new Error(`Unrecognized value type: ${mode}`);
      }
    }
    function lowBits(number) {
      return typeof number !== "bigint" ? (number >>> 0) % lowMaxPlus1 : Number(number & lowMaxBig);
    }
    function highBits(number) {
      return typeof number !== "bigint" ? number / lowMaxPlus1 >>> 0 : Number(number >> 32n & lowMaxBig);
    }
    function long(number) {
      const sign = number < 0;
      if (sign)
        number = -number;
      let lo = lowBits(number);
      let hi = highBits(number);
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > lowMax) {
          lo = 0;
          if (++hi > lowMax) {
            hi = 0;
          }
        }
      }
      return [hi, lo];
    }
    var kTypeVarInt = 0;
    var kTypeLengthDelim = 2;
    function decodeNumber(buffer) {
      const size = countNumberBytes(buffer);
      if (size > 4)
        return decodeBigNumber(buffer);
      if (!buffer.length)
        return 0;
      let value = buffer[0] & 127;
      let i = 0;
      while (buffer[i++] >= 128) {
        value |= (buffer[i] & 127) << 7 * i;
      }
      return value;
    }
    function decodeNumbers(buffer) {
      const values = [];
      let start = 0;
      for (let i = 0; i < buffer.length; i++) {
        if ((buffer[i] & 128) === 0) {
          values.push(decodeNumber(buffer.slice(start, i + 1)));
          start = i + 1;
        }
      }
      return values;
    }
    function push(value, list) {
      if (list == null) {
        return [value];
      }
      list.push(value);
      return list;
    }
    function measureNumber(number) {
      if (number === 0 || number === 0n)
        return 0;
      const [hi, lo] = long(number);
      const a = lo;
      const b = (lo >>> 28 | hi << 4) >>> 0;
      const c = hi >>> 24;
      if (c !== 0) {
        return c < 128 ? 9 : 10;
      }
      if (b !== 0) {
        if (b < 16384) {
          return b < 128 ? 5 : 6;
        }
        return b < 2097152 ? 7 : 8;
      }
      if (a < 16384) {
        return a < 128 ? 1 : 2;
      }
      return a < 2097152 ? 3 : 4;
    }
    function measureValue(value) {
      if (typeof value === "undefined")
        return 0;
      if (typeof value === "number" || typeof value === "bigint") {
        return measureNumber(value) || 1;
      }
      return value.length;
    }
    function measureArray(list) {
      let size = 0;
      for (const item of list) {
        size += measureValue(item);
      }
      return size;
    }
    function measureNumberField(number) {
      const length = measureNumber(number);
      return length ? 1 + length : 0;
    }
    function measureNumberArrayField(values) {
      let total = 0;
      for (const value of values) {
        total += measureNumber(value) || 1;
      }
      return total ? 1 + measureNumber(total) + total : 0;
    }
    function measureLengthDelimField(value) {
      const length = measureValue(value);
      return length ? 1 + measureNumber(length) + length : 0;
    }
    function measureLengthDelimArrayField(values) {
      let total = 0;
      for (const value of values) {
        total += measureLengthDelimField(value);
      }
      return total;
    }
    function encodeNumber(buffer, i, number) {
      if (number === 0 || number === 0n) {
        buffer[i++] = 0;
        return i;
      }
      let [hi, lo] = long(number);
      while (hi) {
        buffer[i++] = lo & 127 | 128;
        lo = (lo >>> 7 | hi << 25) >>> 0;
        hi >>>= 7;
      }
      while (lo > 127) {
        buffer[i++] = lo & 127 | 128;
        lo = lo >>> 7;
      }
      buffer[i++] = lo;
      return i;
    }
    exports2.emptyTableToken = Symbol();
    var StringTable = class _StringTable {
      constructor(tok) {
        this.strings = new Array();
        _StringTable_encodings.set(this, new Array());
        _StringTable_positions.set(this, /* @__PURE__ */ new Map());
        if (tok !== exports2.emptyTableToken) {
          this.dedup("");
        }
      }
      get encodedLength() {
        let size = 0;
        for (const encoded of __classPrivateFieldGet(this, _StringTable_encodings, "f")) {
          size += encoded.length;
        }
        return size;
      }
      _encodeToBuffer(buffer, offset) {
        for (const encoded of __classPrivateFieldGet(this, _StringTable_encodings, "f")) {
          buffer.set(encoded, offset);
          offset += encoded.length;
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.encodedLength)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static _encodeStringFromUtf8(stringBuffer) {
        const buffer = new Uint8Array(1 + stringBuffer.length + (measureNumber(stringBuffer.length) || 1));
        let offset = 0;
        buffer[offset++] = 50;
        offset = encodeNumber(buffer, offset, stringBuffer.length);
        if (stringBuffer.length > 0) {
          buffer.set(stringBuffer, offset++);
        }
        return buffer;
      }
      static _encodeString(string) {
        return _StringTable._encodeStringFromUtf8(toUtf8(string));
      }
      dedup(string) {
        if (typeof string === "number")
          return string;
        if (!__classPrivateFieldGet(this, _StringTable_positions, "f").has(string)) {
          const pos = this.strings.push(string) - 1;
          __classPrivateFieldGet(this, _StringTable_positions, "f").set(string, pos);
          __classPrivateFieldGet(this, _StringTable_encodings, "f").push(_StringTable._encodeString(string));
        }
        return __classPrivateFieldGet(this, _StringTable_positions, "f").get(string);
      }
      _decodeString(buffer) {
        const string = new TextDecoder().decode(buffer);
        __classPrivateFieldGet(this, _StringTable_positions, "f").set(string, this.strings.push(string) - 1);
        __classPrivateFieldGet(this, _StringTable_encodings, "f").push(_StringTable._encodeStringFromUtf8(buffer));
      }
    };
    exports2.StringTable = StringTable;
    _StringTable_encodings = /* @__PURE__ */ new WeakMap(), _StringTable_positions = /* @__PURE__ */ new WeakMap();
    function decode(buffer, decoder) {
      const data = {};
      let index = 0;
      while (index < buffer.length) {
        const field = buffer[index] >> 3;
        const mode = buffer[index] & 7;
        index++;
        const { offset, value } = getValue(mode, buffer.slice(index));
        index += value.length + offset;
        decoder(data, field, value);
      }
      return data;
    }
    var ValueType2 = class _ValueType {
      static create(data) {
        return data instanceof _ValueType ? data : new _ValueType(data);
      }
      constructor(data) {
        this.type = data.type || 0;
        this.unit = data.unit || 0;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.type);
        total += measureNumberField(this.unit);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.type) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.type);
        }
        if (this.unit) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.unit);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.type = decodeNumber(buffer);
            break;
          case 2:
            data.unit = decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.ValueType = ValueType2;
    var Label = class _Label {
      static create(data) {
        return data instanceof _Label ? data : new _Label(data);
      }
      constructor(data) {
        this.key = data.key || 0;
        this.str = data.str || 0;
        this.num = data.num || 0;
        this.numUnit = data.numUnit || 0;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.key);
        total += measureNumberField(this.str);
        total += measureNumberField(this.num);
        total += measureNumberField(this.numUnit);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.key) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.key);
        }
        if (this.str) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.str);
        }
        if (this.num) {
          buffer[offset++] = 24;
          offset = encodeNumber(buffer, offset, this.num);
        }
        if (this.numUnit) {
          buffer[offset++] = 32;
          offset = encodeNumber(buffer, offset, this.numUnit);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.key = decodeNumber(buffer);
            break;
          case 2:
            data.str = decodeNumber(buffer);
            break;
          case 3:
            data.num = decodeNumber(buffer);
            break;
          case 4:
            data.numUnit = decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Label = Label;
    var Sample = class _Sample {
      static create(data) {
        return data instanceof _Sample ? data : new _Sample(data);
      }
      constructor(data) {
        this.locationId = data.locationId || [];
        this.value = data.value || [];
        this.label = (data.label || []).map(Label.create);
      }
      get length() {
        let total = 0;
        total += measureNumberArrayField(this.locationId);
        total += measureNumberArrayField(this.value);
        total += measureLengthDelimArrayField(this.label);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.locationId.length) {
          buffer[offset++] = 10;
          offset = encodeNumber(buffer, offset, measureArray(this.locationId));
          for (const locationId of this.locationId) {
            offset = encodeNumber(buffer, offset, locationId);
          }
        }
        if (this.value.length) {
          buffer[offset++] = 18;
          offset = encodeNumber(buffer, offset, measureArray(this.value));
          for (const value of this.value) {
            offset = encodeNumber(buffer, offset, value);
          }
        }
        for (const label of this.label) {
          buffer[offset++] = 26;
          offset = encodeNumber(buffer, offset, label.length);
          offset = label._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.locationId = decodeNumbers(buffer);
            break;
          case 2:
            data.value = decodeNumbers(buffer);
            break;
          case 3:
            data.label = push(Label.decode(buffer), data.label);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Sample = Sample;
    var Mapping = class _Mapping {
      static create(data) {
        return data instanceof _Mapping ? data : new _Mapping(data);
      }
      constructor(data) {
        this.id = data.id || 0;
        this.memoryStart = data.memoryStart || 0;
        this.memoryLimit = data.memoryLimit || 0;
        this.fileOffset = data.fileOffset || 0;
        this.filename = data.filename || 0;
        this.buildId = data.buildId || 0;
        this.hasFunctions = !!data.hasFunctions;
        this.hasFilenames = !!data.hasFilenames;
        this.hasLineNumbers = !!data.hasLineNumbers;
        this.hasInlineFrames = !!data.hasInlineFrames;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.id);
        total += measureNumberField(this.memoryStart);
        total += measureNumberField(this.memoryLimit);
        total += measureNumberField(this.fileOffset);
        total += measureNumberField(this.filename);
        total += measureNumberField(this.buildId);
        total += measureNumberField(this.hasFunctions ? 1 : 0);
        total += measureNumberField(this.hasFilenames ? 1 : 0);
        total += measureNumberField(this.hasLineNumbers ? 1 : 0);
        total += measureNumberField(this.hasInlineFrames ? 1 : 0);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.id) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.id);
        }
        if (this.memoryStart) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.memoryStart);
        }
        if (this.memoryLimit) {
          buffer[offset++] = 24;
          offset = encodeNumber(buffer, offset, this.memoryLimit);
        }
        if (this.fileOffset) {
          buffer[offset++] = 32;
          offset = encodeNumber(buffer, offset, this.fileOffset);
        }
        if (this.filename) {
          buffer[offset++] = 40;
          offset = encodeNumber(buffer, offset, this.filename);
        }
        if (this.buildId) {
          buffer[offset++] = 48;
          offset = encodeNumber(buffer, offset, this.buildId);
        }
        if (this.hasFunctions) {
          buffer[offset++] = 56;
          offset = encodeNumber(buffer, offset, 1);
        }
        if (this.hasFilenames) {
          buffer[offset++] = 64;
          offset = encodeNumber(buffer, offset, 1);
        }
        if (this.hasLineNumbers) {
          buffer[offset++] = 72;
          offset = encodeNumber(buffer, offset, 1);
        }
        if (this.hasInlineFrames) {
          buffer[offset++] = 80;
          offset = encodeNumber(buffer, offset, 1);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.id = decodeNumber(buffer);
            break;
          case 2:
            data.memoryStart = decodeNumber(buffer);
            break;
          case 3:
            data.memoryLimit = decodeNumber(buffer);
            break;
          case 4:
            data.fileOffset = decodeNumber(buffer);
            break;
          case 5:
            data.filename = decodeNumber(buffer);
            break;
          case 6:
            data.buildId = decodeNumber(buffer);
            break;
          case 7:
            data.hasFunctions = !!decodeNumber(buffer);
            break;
          case 8:
            data.hasFilenames = !!decodeNumber(buffer);
            break;
          case 9:
            data.hasLineNumbers = !!decodeNumber(buffer);
            break;
          case 10:
            data.hasInlineFrames = !!decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Mapping = Mapping;
    var Line = class _Line {
      static create(data) {
        return data instanceof _Line ? data : new _Line(data);
      }
      constructor(data) {
        this.functionId = data.functionId || 0;
        this.line = data.line || 0;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.functionId);
        total += measureNumberField(this.line);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.functionId) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.functionId);
        }
        if (this.line) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.line);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.functionId = decodeNumber(buffer);
            break;
          case 2:
            data.line = decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Line = Line;
    var Location = class _Location {
      static create(data) {
        return data instanceof _Location ? data : new _Location(data);
      }
      constructor(data) {
        this.id = data.id || 0;
        this.mappingId = data.mappingId || 0;
        this.address = data.address || 0;
        this.line = (data.line || []).map(Line.create);
        this.isFolded = !!data.isFolded;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.id);
        total += measureNumberField(this.mappingId);
        total += measureNumberField(this.address);
        total += measureLengthDelimArrayField(this.line);
        total += measureNumberField(this.isFolded ? 1 : 0);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.id) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.id);
        }
        if (this.mappingId) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.mappingId);
        }
        if (this.address) {
          buffer[offset++] = 24;
          offset = encodeNumber(buffer, offset, this.address);
        }
        for (const line of this.line) {
          buffer[offset++] = 34;
          offset = encodeNumber(buffer, offset, line.length);
          offset = line._encodeToBuffer(buffer, offset);
        }
        if (this.isFolded) {
          buffer[offset++] = 40;
          offset = encodeNumber(buffer, offset, 1);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.id = decodeNumber(buffer);
            break;
          case 2:
            data.mappingId = decodeNumber(buffer);
            break;
          case 3:
            data.address = decodeNumber(buffer);
            break;
          case 4:
            data.line = push(Line.decode(buffer), data.line);
            break;
          case 5:
            data.isFolded = !!decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Location = Location;
    var Function2 = class _Function {
      static create(data) {
        return data instanceof _Function ? data : new _Function(data);
      }
      constructor(data) {
        this.id = data.id || 0;
        this.name = data.name || 0;
        this.systemName = data.systemName || 0;
        this.filename = data.filename || 0;
        this.startLine = data.startLine || 0;
      }
      get length() {
        let total = 0;
        total += measureNumberField(this.id);
        total += measureNumberField(this.name);
        total += measureNumberField(this.systemName);
        total += measureNumberField(this.filename);
        total += measureNumberField(this.startLine);
        return total;
      }
      _encodeToBuffer(buffer, offset = 0) {
        if (this.id) {
          buffer[offset++] = 8;
          offset = encodeNumber(buffer, offset, this.id);
        }
        if (this.name) {
          buffer[offset++] = 16;
          offset = encodeNumber(buffer, offset, this.name);
        }
        if (this.systemName) {
          buffer[offset++] = 24;
          offset = encodeNumber(buffer, offset, this.systemName);
        }
        if (this.filename) {
          buffer[offset++] = 32;
          offset = encodeNumber(buffer, offset, this.filename);
        }
        if (this.startLine) {
          buffer[offset++] = 40;
          offset = encodeNumber(buffer, offset, this.startLine);
        }
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.id = decodeNumber(buffer);
            break;
          case 2:
            data.name = decodeNumber(buffer);
            break;
          case 3:
            data.systemName = decodeNumber(buffer);
            break;
          case 4:
            data.filename = decodeNumber(buffer);
            break;
          case 5:
            data.startLine = decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Function = Function2;
    var Profile = class {
      constructor(data = {}) {
        this.sampleType = (data.sampleType || []).map(ValueType2.create);
        this.sample = (data.sample || []).map(Sample.create);
        this.mapping = (data.mapping || []).map(Mapping.create);
        this.location = (data.location || []).map(Location.create);
        this.function = (data.function || []).map(Function2.create);
        this.stringTable = data.stringTable || new StringTable();
        this.dropFrames = data.dropFrames || 0;
        this.keepFrames = data.keepFrames || 0;
        this.timeNanos = data.timeNanos || 0;
        this.durationNanos = data.durationNanos || 0;
        this.periodType = data.periodType ? ValueType2.create(data.periodType) : void 0;
        this.period = data.period || 0;
        this.comment = data.comment || [];
        this.defaultSampleType = data.defaultSampleType || 0;
      }
      get length() {
        let total = 0;
        total += measureLengthDelimArrayField(this.sampleType);
        total += measureLengthDelimArrayField(this.sample);
        total += measureLengthDelimArrayField(this.mapping);
        total += measureLengthDelimArrayField(this.location);
        total += measureLengthDelimArrayField(this.function);
        total += this.stringTable.encodedLength;
        total += measureNumberField(this.dropFrames);
        total += measureNumberField(this.keepFrames);
        total += measureNumberField(this.timeNanos);
        total += measureNumberField(this.durationNanos);
        total += measureLengthDelimField(this.periodType);
        total += measureNumberField(this.period);
        total += measureNumberArrayField(this.comment);
        total += measureNumberField(this.defaultSampleType);
        return total;
      }
      _encodeSampleTypesToBuffer(buffer, offset = 0) {
        for (const sampleType of this.sampleType) {
          buffer[offset++] = 10;
          offset = encodeNumber(buffer, offset, sampleType.length);
          offset = sampleType._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      _encodeSamplesToBuffer(buffer, offset = 0) {
        for (const sample of this.sample) {
          buffer[offset++] = 18;
          offset = encodeNumber(buffer, offset, sample.length);
          offset = sample._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      _encodeMappingsToBuffer(buffer, offset = 0) {
        for (const mapping of this.mapping) {
          buffer[offset++] = 26;
          offset = encodeNumber(buffer, offset, mapping.length);
          offset = mapping._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      _encodeLocationsToBuffer(buffer, offset = 0) {
        for (const location of this.location) {
          buffer[offset++] = 34;
          offset = encodeNumber(buffer, offset, location.length);
          offset = location._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      _encodeFunctionsToBuffer(buffer, offset = 0) {
        for (const fun of this.function) {
          buffer[offset++] = 42;
          offset = encodeNumber(buffer, offset, fun.length);
          offset = fun._encodeToBuffer(buffer, offset);
        }
        return offset;
      }
      _encodeBasicValuesToBuffer(buffer, offset = 0) {
        if (this.dropFrames) {
          buffer[offset++] = 56;
          offset = encodeNumber(buffer, offset, this.dropFrames);
        }
        if (this.keepFrames) {
          buffer[offset++] = 64;
          offset = encodeNumber(buffer, offset, this.keepFrames);
        }
        if (this.timeNanos) {
          buffer[offset++] = 72;
          offset = encodeNumber(buffer, offset, this.timeNanos);
        }
        if (this.durationNanos) {
          buffer[offset++] = 80;
          offset = encodeNumber(buffer, offset, this.durationNanos);
        }
        if (typeof this.periodType !== "undefined") {
          buffer[offset++] = 90;
          offset = encodeNumber(buffer, offset, this.periodType.length);
          offset = this.periodType._encodeToBuffer(buffer, offset);
        }
        if (this.period) {
          buffer[offset++] = 96;
          offset = encodeNumber(buffer, offset, this.period);
        }
        if (this.comment.length) {
          buffer[offset++] = 106;
          offset = encodeNumber(buffer, offset, measureArray(this.comment));
          for (const comment of this.comment) {
            offset = encodeNumber(buffer, offset, comment);
          }
        }
        if (this.defaultSampleType) {
          buffer[offset++] = 112;
          offset = encodeNumber(buffer, offset, this.defaultSampleType);
        }
        return offset;
      }
      _encodeToBuffer(buffer, offset = 0) {
        offset = this._encodeSampleTypesToBuffer(buffer, offset);
        offset = this._encodeSamplesToBuffer(buffer, offset);
        offset = this._encodeMappingsToBuffer(buffer, offset);
        offset = this._encodeLocationsToBuffer(buffer, offset);
        offset = this._encodeFunctionsToBuffer(buffer, offset);
        offset = this.stringTable._encodeToBuffer(buffer, offset);
        offset = this._encodeBasicValuesToBuffer(buffer, offset);
        return offset;
      }
      async _encodeToBufferAsync(buffer, offset = 0) {
        offset = this._encodeSampleTypesToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this._encodeSamplesToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this._encodeMappingsToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this._encodeLocationsToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this._encodeFunctionsToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this.stringTable._encodeToBuffer(buffer, offset);
        await new Promise(setImmediate);
        offset = this._encodeBasicValuesToBuffer(buffer, offset);
        return offset;
      }
      encode(buffer = new Uint8Array(this.length)) {
        this._encodeToBuffer(buffer, 0);
        return buffer;
      }
      async encodeAsync(buffer = new Uint8Array(this.length)) {
        await this._encodeToBufferAsync(buffer, 0);
        return buffer;
      }
      static decodeValue(data, field, buffer) {
        switch (field) {
          case 1:
            data.sampleType = push(ValueType2.decode(buffer), data.sampleType);
            break;
          case 2:
            data.sample = push(Sample.decode(buffer), data.sample);
            break;
          case 3:
            data.mapping = push(Mapping.decode(buffer), data.mapping);
            break;
          case 4:
            data.location = push(Location.decode(buffer), data.location);
            break;
          case 5:
            data.function = push(Function2.decode(buffer), data.function);
            break;
          case 6: {
            if (data.stringTable === void 0) {
              data.stringTable = new StringTable(exports2.emptyTableToken);
            }
            data.stringTable._decodeString(buffer);
            break;
          }
          case 7:
            data.dropFrames = decodeNumber(buffer);
            break;
          case 8:
            data.keepFrames = decodeNumber(buffer);
            break;
          case 9:
            data.timeNanos = decodeNumber(buffer);
            break;
          case 10:
            data.durationNanos = decodeNumber(buffer);
            break;
          case 11:
            data.periodType = ValueType2.decode(buffer);
            break;
          case 12:
            data.period = decodeNumber(buffer);
            break;
          case 13:
            data.comment = decodeNumbers(buffer);
            break;
          case 14:
            data.defaultSampleType = decodeNumber(buffer);
            break;
        }
      }
      static decode(buffer) {
        return new this(decode(buffer, this.decodeValue));
      }
    };
    exports2.Profile = Profile;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/poisson.js
var require_poisson = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/poisson.js"(exports2, module2) {
    "use strict";
    var PoissonProcessSamplingFilter = class {
      #currentSamplingInstant = 0;
      #nextSamplingInstant;
      #samplingInterval;
      #resetInterval;
      #now;
      #lastNow = Number.NEGATIVE_INFINITY;
      #samplingInstantCount = 0;
      constructor({ samplingInterval, now, resetInterval }) {
        if (samplingInterval <= 0) {
          throw new RangeError(`samplingInterval (${samplingInterval}) must be greater than 0`);
        }
        if (resetInterval < samplingInterval) {
          throw new RangeError(
            `resetInterval (${resetInterval}) must be greater than samplingInterval (${samplingInterval})`
          );
        }
        if (typeof now !== "function") {
          throw new TypeError("now must be a function");
        }
        this.#samplingInterval = samplingInterval;
        this.#resetInterval = resetInterval;
        this.#now = now;
        this.#nextSamplingInstant = this.#callNow();
        this.#setNextSamplingInstant();
      }
      get currentSamplingInstant() {
        return this.#currentSamplingInstant;
      }
      get nextSamplingInstant() {
        return this.#nextSamplingInstant;
      }
      get samplingInstantCount() {
        return this.#samplingInstantCount;
      }
      #callNow() {
        const nowValue = this.#now();
        if (typeof nowValue !== "number") {
          throw new TypeError("now() must return a number");
        }
        if (nowValue < this.#lastNow) {
          throw new RangeError("now() must return a value greater than or equal to the last returned value");
        }
        this.#lastNow = nowValue;
        return nowValue;
      }
      filter(event) {
        const endTime = event.startTime + event.duration;
        if (endTime >= this.#nextSamplingInstant) {
          const cappedEndTime = Math.min(endTime, this.#callNow());
          const earliestContinuousPast = cappedEndTime - this.#resetInterval;
          if (this.#nextSamplingInstant < earliestContinuousPast) {
            this.#nextSamplingInstant = earliestContinuousPast;
          }
          while (cappedEndTime >= this.#nextSamplingInstant) {
            this.#setNextSamplingInstant();
          }
        }
        return event.startTime < this.#currentSamplingInstant;
      }
      #setNextSamplingInstant() {
        this.#currentSamplingInstant = this.#nextSamplingInstant;
        this.#nextSamplingInstant -= Math.log(1 - Math.random()) * this.#samplingInterval;
        this.#samplingInstantCount++;
      }
    };
    module2.exports = PoissonProcessSamplingFilter;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/event.js
var require_event = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/event.js"(exports2, module2) {
    "use strict";
    var TracingPlugin = require_tracing();
    var { performance: performance2 } = __require("perf_hooks");
    var EventPlugin = class extends TracingPlugin {
      #eventHandler;
      #eventFilter;
      #dataSymbol;
      #entryType;
      constructor(eventHandler, eventFilter) {
        super();
        this.#eventHandler = eventHandler;
        this.#eventFilter = eventFilter;
        this.#entryType = this.constructor.entryType;
        this.#dataSymbol = Symbol(`dd-trace.profiling.event.${this.#entryType}.${this.constructor.operation}`);
      }
      start(ctx) {
        ctx[this.#dataSymbol] = performance2.now();
      }
      error(ctx) {
        ctx[this.#dataSymbol] = void 0;
      }
      finish(ctx) {
        const startTime = ctx[this.#dataSymbol];
        if (startTime === void 0) {
          return;
        }
        ctx[this.#dataSymbol] = void 0;
        if (this.ignoreEvent(ctx)) {
          return;
        }
        const duration = performance2.now() - startTime;
        const event = {
          entryType: this.#entryType,
          startTime,
          duration
        };
        if (!this.#eventFilter(event)) {
          return;
        }
        const context2 = (ctx.currentStore?.span || this.activeSpan)?.context();
        event._ddSpanId = context2?.toBigIntSpanId();
        event._ddRootSpanId = context2?._trace.started[0]?.context().toBigIntSpanId() || event._ddSpanId;
        this.#eventHandler(this.extendEvent(event, ctx));
      }
      ignoreEvent() {
        return false;
      }
    };
    module2.exports = EventPlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/dns.js
var require_dns2 = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/dns.js"(exports2, module2) {
    "use strict";
    var EventPlugin = require_event();
    var DNSPlugin = class extends EventPlugin {
      static id = "dns";
      static entryType = "dns";
    };
    module2.exports = DNSPlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookup.js
var require_dns_lookup = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookup.js"(exports2, module2) {
    "use strict";
    var DNSPlugin = require_dns2();
    var DNSLookupPlugin = class extends DNSPlugin {
      static operation = "lookup";
      extendEvent(event, startEvent) {
        event.name = "lookup";
        event.detail = { hostname: startEvent.args[0] };
        return event;
      }
    };
    module2.exports = DNSLookupPlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookupservice.js
var require_dns_lookupservice = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_lookupservice.js"(exports2, module2) {
    "use strict";
    var DNSPlugin = require_dns2();
    var DNSLookupServicePlugin = class extends DNSPlugin {
      static operation = "lookup_service";
      extendEvent(event, startEvent) {
        event.name = "lookupService";
        event.detail = { host: startEvent.args[0], port: startEvent.args[1] };
        return event;
      }
    };
    module2.exports = DNSLookupServicePlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_resolve.js
var require_dns_resolve = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_resolve.js"(exports2, module2) {
    "use strict";
    var DNSPlugin = require_dns2();
    var queryNames = /* @__PURE__ */ new Map();
    var DNSResolvePlugin = class extends DNSPlugin {
      static operation = "resolve";
      extendEvent(event, startEvent) {
        const rrtype = startEvent.args[1];
        let name = queryNames.get(rrtype);
        if (!name) {
          name = `query${rrtype}`;
          queryNames.set(rrtype, name);
        }
        event.name = name;
        event.detail = { host: startEvent.args[0] };
        return event;
      }
    };
    module2.exports = DNSResolvePlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_reverse.js
var require_dns_reverse = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/dns_reverse.js"(exports2, module2) {
    "use strict";
    var DNSPlugin = require_dns2();
    var DNSReversePlugin = class extends DNSPlugin {
      static operation = "reverse";
      extendEvent(event, startEvent) {
        event.name = "getHostByAddr";
        event.detail = { host: startEvent.args[0] };
        return event;
      }
    };
    module2.exports = DNSReversePlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/fs.js
var require_fs2 = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/fs.js"(exports2, module2) {
    "use strict";
    var EventPlugin = require_event();
    var allowedParams = /* @__PURE__ */ new Set([
      "atime",
      "dest",
      "existingPath",
      "fd",
      "file",
      "flag",
      "gid",
      "len",
      "length",
      "mode",
      "mtime",
      "newPath",
      "offset",
      "oldPath",
      "operation",
      "options",
      "path",
      "position",
      "prefix",
      "src",
      "target",
      "type",
      "uid"
    ]);
    var FilesystemPlugin = class extends EventPlugin {
      static id = "fs";
      static operation = "operation";
      static entryType = "fs";
      ignoreEvent(event) {
        return event.operation?.endsWith("Sync");
      }
      extendEvent(event, detail) {
        const d = { ...detail };
        Object.entries(d).forEach(([k, v]) => {
          if (!(allowedParams.has(k) && (typeof v === "string" || typeof v === "number"))) {
            delete d[k];
          }
        });
        event.detail = d;
        return event;
      }
    };
    module2.exports = FilesystemPlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/event_plugins/net.js
var require_net2 = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/event_plugins/net.js"(exports2, module2) {
    "use strict";
    var EventPlugin = require_event();
    var NetPlugin = class extends EventPlugin {
      static id = "net";
      static operation = "tcp";
      static entryType = "net";
      extendEvent(event, { options }) {
        event.name = "connect";
        event.detail = options;
        return event;
      }
    };
    module2.exports = NetPlugin;
  }
});

// ../../packages/dd-trace/src/profiling/profilers/events.js
var require_events = __commonJS({
  "../../packages/dd-trace/src/profiling/profilers/events.js"(exports2, module2) {
    "use strict";
    var { performance: performance2, constants, PerformanceObserver } = __require("perf_hooks");
    var { END_TIMESTAMP_LABEL, SPAN_ID_LABEL, LOCAL_ROOT_SPAN_ID_LABEL, encodeProfileAsync } = require_shared();
    var { Function: Function2, Label, Line, Location, Profile, Sample, StringTable, ValueType: ValueType2 } = require_commonjs2();
    var PoissonProcessSamplingFilter = require_poisson();
    var { availableParallelism, effectiveLibuvThreadCount } = require_libuv_size();
    var MS_TO_NS = 1e6;
    var POISSON_RESET_FACTOR = 2;
    var pprofValueType = "timeline";
    var pprofValueUnit = "nanoseconds";
    var dateOffset = BigInt(Math.round(performance2.timeOrigin * MS_TO_NS));
    function labelFromStr(stringTable, key, valStr) {
      return new Label({ key, str: stringTable.dedup(safeToString(valStr)) });
    }
    function safeToString(val) {
      switch (typeof val) {
        case "string":
          return val;
        case "object":
          return "[object]";
        case "function":
          return "[function]";
        default:
          return String(val);
      }
    }
    function labelFromStrStr(stringTable, keyStr, valStr) {
      return labelFromStr(stringTable, stringTable.dedup(keyStr), valStr);
    }
    function getMaxSamples(options) {
      const flushInterval = options.flushInterval || 65 * 1e3;
      const maxCpuSamples = flushInterval / options.samplingInterval;
      const factor = Math.max(1, Math.min(availableParallelism(), effectiveLibuvThreadCount)) + 2;
      return Math.min(1e5, Math.floor(maxCpuSamples * factor));
    }
    var GCDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable;
        this.reasonLabelKey = stringTable.dedup("gc reason");
        this.kindLabels = [];
        this.reasonLabels = [];
        this.flagObj = {};
        const kindLabelKey = stringTable.dedup("gc type");
        for (const [key, value] of Object.entries(constants)) {
          if (key.startsWith("NODE_PERFORMANCE_GC_FLAGS_")) {
            this.flagObj[key.slice(26).toLowerCase()] = value;
          } else if (key.startsWith("NODE_PERFORMANCE_GC_")) {
            const kind = key.slice(20).toLowerCase();
            this.kindLabels[value] = labelFromStr(stringTable, kindLabelKey, kind);
          }
        }
      }
      decorateSample(sampleInput, item) {
        const { kind, flags } = item.detail;
        sampleInput.label.push(this.kindLabels[kind]);
        const reasonLabel = this.getReasonLabel(flags);
        if (reasonLabel) {
          sampleInput.label.push(reasonLabel);
        }
      }
      getReasonLabel(flags) {
        if (flags === 0) {
          return null;
        }
        let reasonLabel = this.reasonLabels[flags];
        if (!reasonLabel) {
          const reasons = [];
          for (const [key, value] of Object.entries(this.flagObj)) {
            if (value & flags) {
              reasons.push(key);
            }
          }
          const reasonStr = reasons.join(",");
          reasonLabel = labelFromStr(this.stringTable, this.reasonLabelKey, reasonStr);
          this.reasonLabels[flags] = reasonLabel;
        }
        return reasonLabel;
      }
    };
    var DNSDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable;
        this.operationNameLabelKey = stringTable.dedup("operation");
        this.hostLabelKey = stringTable.dedup("host");
        this.addressLabelKey = stringTable.dedup("address");
        this.portLabelKey = stringTable.dedup("port");
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label;
        const stringTable = this.stringTable;
        function addLabel(labelNameKey, labelValue) {
          labels.push(labelFromStr(stringTable, labelNameKey, labelValue));
        }
        const op = item.name;
        addLabel(this.operationNameLabelKey, item.name);
        const detail = item.detail;
        switch (op) {
          case "lookup":
            addLabel(this.hostLabelKey, detail.hostname);
            break;
          case "lookupService":
            addLabel(this.addressLabelKey, detail.host);
            labels.push(new Label({ key: this.portLabelKey, num: detail.port }));
            break;
          case "getHostByAddr":
            addLabel(this.addressLabelKey, detail.host);
            break;
          default:
            if (op.startsWith("query")) {
              addLabel(this.hostLabelKey, detail.host);
            }
        }
      }
    };
    var NetDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable;
        this.operationNameLabelKey = stringTable.dedup("operation");
        this.hostLabelKey = stringTable.dedup("host");
        this.portLabelKey = stringTable.dedup("port");
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label;
        const stringTable = this.stringTable;
        function addLabel(labelNameKey, labelValue) {
          labels.push(labelFromStr(stringTable, labelNameKey, labelValue));
        }
        const op = item.name;
        addLabel(this.operationNameLabelKey, op);
        if (op === "connect") {
          const detail = item.detail;
          addLabel(this.hostLabelKey, detail.host);
          labels.push(new Label({ key: this.portLabelKey, num: detail.port }));
        }
      }
    };
    var FilesystemDecorator = class {
      constructor(stringTable) {
        this.stringTable = stringTable;
      }
      decorateSample(sampleInput, item) {
        const labels = sampleInput.label;
        const stringTable = this.stringTable;
        Object.entries(item.detail).forEach(([k, v]) => {
          switch (typeof v) {
            case "string":
              labels.push(labelFromStrStr(stringTable, k, v));
              break;
            case "number":
              labels.push(new Label({ key: stringTable.dedup(k), num: v }));
          }
        });
      }
    };
    var decoratorTypes = {
      fs: FilesystemDecorator,
      dns: DNSDecorator,
      gc: GCDecorator,
      net: NetDecorator
    };
    var EventSerializer = class {
      #sampleCount = 0;
      constructor(maxSamples) {
        this.stringTable = new StringTable();
        this.samples = [];
        this.locations = [];
        this.functions = [];
        this.decorators = {};
        this.maxSamples = maxSamples;
        const fn = new Function2({ id: this.functions.length + 1, name: this.stringTable.dedup("") });
        this.functions.push(fn);
        const line = new Line({ functionId: fn.id });
        const location = new Location({ id: this.locations.length + 1, line: [line] });
        this.locations.push(location);
        this.locationId = [location.id];
        this.timestampLabelKey = this.stringTable.dedup(END_TIMESTAMP_LABEL);
        this.spanIdKey = this.stringTable.dedup(SPAN_ID_LABEL);
        this.rootSpanIdKey = this.stringTable.dedup(LOCAL_ROOT_SPAN_ID_LABEL);
      }
      addEvent(item) {
        if (this.samples.length < this.maxSamples) {
          const sample = this.#createSample(item);
          if (sample !== void 0) {
            this.samples.push(sample);
            this.#sampleCount++;
          }
        } else {
          this.#sampleCount++;
          const replacementIndex = Math.floor(Math.random() * this.#sampleCount);
          if (replacementIndex < this.maxSamples) {
            const sample = this.#createSample(item);
            if (sample === void 0) {
              this.#sampleCount--;
            } else {
              this.samples[replacementIndex] = sample;
            }
          }
        }
      }
      #createSample(item) {
        const { entryType, startTime, duration, _ddSpanId, _ddRootSpanId } = item;
        let decorator = this.decorators[entryType];
        if (!decorator) {
          const DecoratorCtor = decoratorTypes[entryType];
          if (DecoratorCtor) {
            decorator = new DecoratorCtor(this.stringTable);
            decorator.eventTypeLabel = labelFromStrStr(this.stringTable, "event", entryType);
            this.decorators[entryType] = decorator;
          } else {
            return;
          }
        }
        const endTime = startTime + duration;
        const label = [
          decorator.eventTypeLabel,
          new Label({ key: this.timestampLabelKey, num: dateOffset + BigInt(Math.round(endTime * MS_TO_NS)) })
        ];
        if (_ddSpanId) {
          label.push(
            new Label({ key: this.spanIdKey, num: _ddSpanId })
          );
        }
        if (_ddRootSpanId) {
          label.push(new Label({ key: this.rootSpanIdKey, num: _ddRootSpanId }));
        }
        const sampleInput = {
          value: [Math.round(duration * MS_TO_NS)],
          locationId: this.locationId,
          label
        };
        decorator.decorateSample(sampleInput, item);
        return new Sample(sampleInput);
      }
      createProfile(startDate, endDate) {
        const timeValueType = new ValueType2({
          type: this.stringTable.dedup(pprofValueType),
          unit: this.stringTable.dedup(pprofValueUnit)
        });
        return new Profile({
          sampleType: [timeValueType],
          timeNanos: endDate.getTime() * MS_TO_NS,
          periodType: timeValueType,
          period: 1,
          durationNanos: (endDate.getTime() - startDate.getTime()) * MS_TO_NS,
          sample: this.samples,
          location: this.locations,
          function: this.functions,
          stringTable: this.stringTable
        });
      }
    };
    function add(items) {
      for (const item of items.getEntries()) {
        this.eventHandler(item);
      }
    }
    var NodeApiEventSource = class {
      constructor(eventHandler, entryTypes) {
        this.eventHandler = eventHandler;
        this.observer = void 0;
        this.entryTypes = entryTypes || Object.keys(decoratorTypes);
      }
      start() {
        if (this.observer) return;
        this.observer = new PerformanceObserver(add.bind(this));
        this.observer.observe({ entryTypes: this.entryTypes });
      }
      stop() {
        if (this.observer) {
          this.observer.disconnect();
          this.observer = void 0;
        }
      }
    };
    var DatadogInstrumentationEventSource = class {
      constructor(eventHandler, eventFilter) {
        const plugins = [
          require_dns_lookup(),
          require_dns_lookupservice(),
          require_dns_resolve(),
          require_dns_reverse(),
          require_fs2(),
          require_net2()
        ];
        this.plugins = plugins.map((Plugin) => {
          return new Plugin(eventHandler, eventFilter);
        });
        this.started = false;
      }
      start() {
        if (!this.started) {
          this.plugins.forEach((p) => p.configure({ enabled: true }));
          this.started = true;
        }
      }
      stop() {
        if (this.started) {
          this.plugins.forEach((p) => p.configure({ enabled: false }));
          this.started = false;
        }
      }
    };
    function createPoissonProcessSamplingFilter(samplingIntervalMillis) {
      const poissonFilter = new PoissonProcessSamplingFilter({
        samplingInterval: samplingIntervalMillis,
        resetInterval: samplingIntervalMillis * POISSON_RESET_FACTOR,
        now: performance2.now.bind(performance2)
      });
      return poissonFilter.filter.bind(poissonFilter);
    }
    var EventsProfiler = class {
      #maxSamples = 0;
      #timelineSamplingEnabled = false;
      #eventSerializer;
      #eventSources;
      get type() {
        return "events";
      }
      constructor(options = {}) {
        this.#maxSamples = getMaxSamples(options);
        this.#timelineSamplingEnabled = !!options.timelineSamplingEnabled;
        this.#eventSerializer = new EventSerializer(this.#maxSamples);
        const eventHandler = (event) => this.#eventSerializer.addEvent(event);
        const eventFilter = this.#timelineSamplingEnabled ? createPoissonProcessSamplingFilter(options.samplingInterval) : () => true;
        const filteringEventHandler = (event) => {
          if (eventFilter(event)) {
            eventHandler(event);
          }
        };
        this.#eventSources = options.codeHotspotsEnabled ? [
          new DatadogInstrumentationEventSource(eventHandler, eventFilter),
          new NodeApiEventSource(filteringEventHandler, ["gc"])
        ] : [
          new NodeApiEventSource(filteringEventHandler)
        ];
      }
      start() {
        this.#eventSources.forEach((s) => s.start());
      }
      stop() {
        this.#eventSources.forEach((s) => s.stop());
      }
      profile(restart, startDate, endDate) {
        if (!restart) {
          this.stop();
        }
        const thatEventSerializer = this.#eventSerializer;
        this.#eventSerializer = new EventSerializer(this.#maxSamples);
        return () => thatEventSerializer.createProfile(startDate, endDate);
      }
      getInfo() {
        return {
          maxSamples: this.#maxSamples
        };
      }
      encode(profile) {
        return encodeProfileAsync(profile());
      }
    };
    module2.exports = EventsProfiler;
  }
});

// ../../packages/dd-trace/src/profiling/tagger.js
var require_tagger3 = __commonJS({
  "../../packages/dd-trace/src/profiling/tagger.js"(exports2, module2) {
    "use strict";
    var tagger = {
      parse(tags) {
        if (!tags) return {};
        switch (typeof tags) {
          case "object": {
            if (Array.isArray(tags)) {
              const tagObject = {};
              for (const tag of tags) {
                const colon = tag.indexOf(":");
                if (colon === -1) continue;
                const key = tag.slice(0, colon).trim();
                const value = tag.slice(colon + 1).trim();
                if (key.length !== 0 && value.length !== 0) {
                  tagObject[key] = value;
                }
              }
              return tagObject;
            }
            const tagsArray = [];
            for (const [key, value] of Object.entries(tags)) {
              if (value != null) {
                tagsArray.push(`${key}:${value}`);
              }
            }
            return tagger.parse(tagsArray);
          }
          case "string":
            return tagger.parse(tags.split(","));
          default:
            return {};
        }
      }
    };
    module2.exports = { tagger };
  }
});

// ../../packages/dd-trace/src/azure_metadata.js
var require_azure_metadata = __commonJS({
  "../../packages/dd-trace/src/azure_metadata.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var { getIsAzureFunction } = require_serverless();
    var { getEnvironmentVariable, getEnvironmentVariables } = require_config_helper();
    function extractSubscriptionID(ownerName) {
      if (ownerName !== void 0) {
        const subId = ownerName.split("+")[0].trim();
        if (subId.length > 0) {
          return subId;
        }
      }
    }
    function extractResourceGroup(ownerName) {
      return /.+\+(.+)-.+webspace(-Linux)?/.exec(ownerName)?.[1];
    }
    function buildResourceID(subscriptionID, siteName, resourceGroup) {
      if (subscriptionID === void 0 || siteName === void 0 || resourceGroup === void 0) {
        return;
      }
      return `/subscriptions/${subscriptionID}/resourcegroups/${resourceGroup}/providers/microsoft.web/sites/${siteName}`.toLowerCase();
    }
    function trimObject(obj) {
      Object.entries(obj).filter(([_2, value]) => value === void 0).forEach(([key, _2]) => {
        delete obj[key];
      });
      return obj;
    }
    function buildMetadata() {
      const {
        COMPUTERNAME,
        DD_AAS_DOTNET_EXTENSION_VERSION,
        FUNCTIONS_EXTENSION_VERSION,
        FUNCTIONS_WORKER_RUNTIME,
        FUNCTIONS_WORKER_RUNTIME_VERSION,
        WEBSITE_INSTANCE_ID,
        WEBSITE_OWNER_NAME,
        WEBSITE_OS,
        WEBSITE_RESOURCE_GROUP,
        WEBSITE_SITE_NAME
      } = getEnvironmentVariables();
      const subscriptionID = extractSubscriptionID(WEBSITE_OWNER_NAME);
      const siteName = WEBSITE_SITE_NAME;
      const [siteKind, siteType] = getIsAzureFunction() ? ["functionapp", "function"] : ["app", "app"];
      const resourceGroup = WEBSITE_RESOURCE_GROUP ?? extractResourceGroup(WEBSITE_OWNER_NAME);
      return trimObject({
        extensionVersion: DD_AAS_DOTNET_EXTENSION_VERSION,
        functionRuntimeVersion: FUNCTIONS_EXTENSION_VERSION,
        instanceID: WEBSITE_INSTANCE_ID,
        instanceName: COMPUTERNAME,
        operatingSystem: WEBSITE_OS ?? os.platform(),
        resourceGroup,
        resourceID: buildResourceID(subscriptionID, siteName, resourceGroup),
        runtime: FUNCTIONS_WORKER_RUNTIME,
        runtimeVersion: FUNCTIONS_WORKER_RUNTIME_VERSION,
        siteKind,
        siteName,
        siteType,
        subscriptionID
      });
    }
    function getAzureAppMetadata() {
      if (getEnvironmentVariable("WEBSITE_SITE_NAME") !== void 0) {
        return buildMetadata();
      }
    }
    function getAzureFunctionMetadata() {
      if (getIsAzureFunction()) {
        return buildMetadata();
      }
    }
    function getAzureTagsFromMetadata(metadata) {
      if (metadata === void 0) {
        return {};
      }
      return trimObject({
        "aas.environment.extension_version": metadata.extensionVersion,
        "aas.environment.function_runtime": metadata.functionRuntimeVersion,
        "aas.environment.instance_id": metadata.instanceID,
        "aas.environment.instance_name": metadata.instanceName,
        "aas.environment.os": metadata.operatingSystem,
        "aas.environment.runtime": metadata.runtime,
        "aas.environment.runtime_version": metadata.runtimeVersion,
        "aas.resource.group": metadata.resourceGroup,
        "aas.resource.id": metadata.resourceID,
        "aas.site.kind": metadata.siteKind,
        "aas.site.name": metadata.siteName,
        "aas.site.type": metadata.siteType,
        "aas.subscription.id": metadata.subscriptionID
      });
    }
    module2.exports = {
      getAzureAppMetadata,
      getAzureFunctionMetadata,
      getAzureTagsFromMetadata
    };
  }
});

// ../../packages/dd-trace/src/profiling/config.js
var require_config4 = __commonJS({
  "../../packages/dd-trace/src/profiling/config.js"(exports2, module2) {
    "use strict";
    var os = __require("os");
    var path = __require("path");
    var { URL: URL2, format, pathToFileURL } = __require("url");
    var satisfies = require_semifies();
    var { AgentExporter } = require_agent2();
    var { FileExporter } = require_file2();
    var { ConsoleLogger } = require_console();
    var WallProfiler = require_wall();
    var SpaceProfiler = require_space();
    var EventsProfiler = require_events();
    var { oomExportStrategies, snapshotKinds } = require_constants5();
    var { GIT_REPOSITORY_URL, GIT_COMMIT_SHA } = require_tags2();
    var { tagger } = require_tagger3();
    var { isFalse, isTrue } = require_util();
    var { getAzureTagsFromMetadata, getAzureAppMetadata } = require_azure_metadata();
    var { getEnvironmentVariables } = require_config_helper();
    var defaults = require_config_defaults();
    var Config = class {
      constructor(options = {}) {
        const {
          AWS_LAMBDA_FUNCTION_NAME: functionname,
          DD_AGENT_HOST,
          DD_ENV,
          DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED,
          // used for testing
          DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED,
          DD_PROFILING_CODEHOTSPOTS_ENABLED,
          DD_PROFILING_CPU_ENABLED,
          DD_PROFILING_DEBUG_SOURCE_MAPS,
          DD_PROFILING_DEBUG_UPLOAD_COMPRESSION,
          DD_PROFILING_ENDPOINT_COLLECTION_ENABLED,
          DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES,
          DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE,
          DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT,
          DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED,
          DD_PROFILING_HEAP_ENABLED,
          DD_PROFILING_HEAP_SAMPLING_INTERVAL,
          DD_PROFILING_PPROF_PREFIX,
          DD_PROFILING_PROFILERS,
          DD_PROFILING_SOURCE_MAP,
          DD_PROFILING_TIMELINE_ENABLED,
          DD_PROFILING_UPLOAD_PERIOD,
          DD_PROFILING_UPLOAD_TIMEOUT,
          DD_PROFILING_V8_PROFILER_BUG_WORKAROUND,
          DD_PROFILING_WALLTIME_ENABLED,
          DD_SERVICE,
          DD_TAGS,
          DD_TRACE_AGENT_PORT,
          DD_TRACE_AGENT_URL,
          DD_VERSION,
          NODE_OPTIONS
        } = getEnvironmentVariables();
        const env = options.env ?? DD_ENV;
        const service = options.service || DD_SERVICE || "node";
        const host = os.hostname();
        const version = options.version ?? DD_VERSION;
        const flushInterval = options.interval ?? (Number(DD_PROFILING_UPLOAD_PERIOD) * 1e3 || 65 * 1e3);
        const uploadTimeout = options.uploadTimeout ?? (Number(DD_PROFILING_UPLOAD_TIMEOUT) || 60 * 1e3);
        const sourceMap = options.sourceMap ?? DD_PROFILING_SOURCE_MAP ?? true;
        const pprofPrefix = options.pprofPrefix ?? DD_PROFILING_PPROF_PREFIX ?? "";
        this.service = service;
        this.env = env;
        this.host = host;
        this.functionname = functionname;
        this.version = version;
        this.tags = Object.assign(
          tagger.parse(DD_TAGS),
          tagger.parse(options.tags),
          tagger.parse({ env, host, service, version, functionname }),
          getAzureTagsFromMetadata(getAzureAppMetadata())
        );
        if (options.repositoryUrl && options.commitSHA) {
          this.tags[GIT_REPOSITORY_URL] = options.repositoryUrl;
          this.tags[GIT_COMMIT_SHA] = options.commitSHA;
        }
        this.logger = ensureLogger(options.logger);
        const samplingContextsAvailable = process.platform !== "win32";
        function checkOptionAllowed(option, description, condition) {
          if (option && !condition) {
            throw new Error(`${description} not supported on ${process.platform}.`);
          }
        }
        function checkOptionWithSamplingContextAllowed(option, description) {
          checkOptionAllowed(option, description, samplingContextsAvailable);
        }
        this.flushInterval = flushInterval;
        this.uploadTimeout = uploadTimeout;
        this.sourceMap = sourceMap;
        this.debugSourceMaps = isTrue(options.debugSourceMaps ?? DD_PROFILING_DEBUG_SOURCE_MAPS);
        this.endpointCollectionEnabled = isTrue(options.endpointCollection ?? DD_PROFILING_ENDPOINT_COLLECTION_ENABLED ?? samplingContextsAvailable);
        checkOptionWithSamplingContextAllowed(this.endpointCollectionEnabled, "Endpoint collection");
        this.pprofPrefix = pprofPrefix;
        this.v8ProfilerBugWorkaroundEnabled = isTrue(options.v8ProfilerBugWorkaround ?? DD_PROFILING_V8_PROFILER_BUG_WORKAROUND ?? true);
        const hostname = (options.hostname ?? DD_AGENT_HOST) || defaults.hostname;
        const port = (options.port ?? DD_TRACE_AGENT_PORT) || defaults.port;
        this.url = new URL2(options.url ?? DD_TRACE_AGENT_URL ?? format({
          protocol: "http:",
          hostname,
          port
        }));
        this.libraryInjected = options.libraryInjected;
        this.activation = options.activation;
        this.exporters = ensureExporters(options.exporters || [
          new AgentExporter(this)
        ], this);
        const oomMonitoringSupported = process.platform !== "win32";
        const oomMonitoringEnabled = isTrue(options.oomMonitoring ?? DD_PROFILING_EXPERIMENTAL_OOM_MONITORING_ENABLED ?? oomMonitoringSupported);
        checkOptionAllowed(oomMonitoringEnabled, "OOM monitoring", oomMonitoringSupported);
        const heapLimitExtensionSize = options.oomHeapLimitExtensionSize ?? (Number(DD_PROFILING_EXPERIMENTAL_OOM_HEAP_LIMIT_EXTENSION_SIZE) || 0);
        const maxHeapExtensionCount = options.oomMaxHeapExtensionCount ?? (Number(DD_PROFILING_EXPERIMENTAL_OOM_MAX_HEAP_EXTENSION_COUNT) || 0);
        const exportStrategies = oomMonitoringEnabled ? ensureOOMExportStrategies(options.oomExportStrategies ?? DD_PROFILING_EXPERIMENTAL_OOM_EXPORT_STRATEGIES ?? [oomExportStrategies.PROCESS], this) : [];
        const exportCommand = oomMonitoringEnabled ? buildExportCommand(this) : void 0;
        this.oomMonitoring = {
          enabled: oomMonitoringEnabled,
          heapLimitExtensionSize,
          maxHeapExtensionCount,
          exportStrategies,
          exportCommand
        };
        const profilers = options.profilers || getProfilers({
          DD_PROFILING_HEAP_ENABLED,
          DD_PROFILING_WALLTIME_ENABLED,
          DD_PROFILING_PROFILERS
        });
        this.timelineEnabled = isTrue(
          options.timelineEnabled ?? DD_PROFILING_TIMELINE_ENABLED ?? samplingContextsAvailable
        );
        checkOptionWithSamplingContextAllowed(this.timelineEnabled, "Timeline view");
        this.timelineSamplingEnabled = isTrue(
          options.timelineSamplingEnabled ?? DD_INTERNAL_PROFILING_TIMELINE_SAMPLING_ENABLED ?? true
        );
        this.codeHotspotsEnabled = isTrue(
          options.codeHotspotsEnabled ?? DD_PROFILING_CODEHOTSPOTS_ENABLED ?? samplingContextsAvailable
        );
        checkOptionWithSamplingContextAllowed(this.codeHotspotsEnabled, "Code hotspots");
        this.cpuProfilingEnabled = isTrue(
          options.cpuProfilingEnabled ?? DD_PROFILING_CPU_ENABLED ?? samplingContextsAvailable
        );
        checkOptionWithSamplingContextAllowed(this.cpuProfilingEnabled, "CPU profiling");
        this.samplingInterval = options.samplingInterval || 1e3 / 99;
        this.heapSamplingInterval = options.heapSamplingInterval ?? (Number(DD_PROFILING_HEAP_SAMPLING_INTERVAL) || 512 * 1024);
        const uploadCompression0 = options.uploadCompression ?? DD_PROFILING_DEBUG_UPLOAD_COMPRESSION ?? "on";
        let [uploadCompression, level0] = uploadCompression0.split("-");
        if (!["on", "off", "gzip", "zstd"].includes(uploadCompression)) {
          this.logger.warn(`Invalid profile upload compression method "${uploadCompression0}". Will use "on".`);
          uploadCompression = "on";
        }
        let level = level0 ? Number.parseInt(level0, 10) : void 0;
        if (level !== void 0) {
          if (["on", "off"].includes(uploadCompression)) {
            this.logger.warn(`Compression levels are not supported for "${uploadCompression}".`);
            level = void 0;
          } else if (Number.isNaN(level)) {
            this.logger.warn(
              `Invalid compression level "${level0}". Will use default level.`
            );
            level = void 0;
          } else if (level < 1) {
            this.logger.warn(`Invalid compression level ${level}. Will use 1.`);
            level = 1;
          } else {
            const maxLevel = { gzip: 9, zstd: 22 }[uploadCompression];
            if (level > maxLevel) {
              this.logger.warn(`Invalid compression level ${level}. Will use ${maxLevel}.`);
              level = maxLevel;
            }
          }
        }
        if (uploadCompression === "on") {
          uploadCompression = "gzip";
        }
        this.uploadCompression = { method: uploadCompression, level };
        const that = this;
        function turnOffAsyncContextFrame(msg) {
          that.logger.warn(
            `DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED was set ${msg}, it will have no effect.`
          );
          that.asyncContextFrameEnabled = false;
        }
        const hasExecArg = (arg) => process.execArgv.includes(arg) || String(NODE_OPTIONS).includes(arg);
        this.asyncContextFrameEnabled = isTrue(options.useAsyncContextFrame ?? DD_PROFILING_ASYNC_CONTEXT_FRAME_ENABLED);
        if (this.asyncContextFrameEnabled) {
          if (satisfies(process.versions.node, ">=24.0.0")) {
            if (hasExecArg("--no-async-context-frame")) {
              turnOffAsyncContextFrame("with --no-async-context-frame");
            }
          } else if (satisfies(process.versions.node, ">=23.0.0")) {
            if (!hasExecArg("--experimental-async-context-frame")) {
              turnOffAsyncContextFrame("without --experimental-async-context-frame");
            }
          } else {
            turnOffAsyncContextFrame("but it requires at least Node.js 23");
          }
        }
        this.heartbeatInterval = options.heartbeatInterval || 60 * 1e3;
        this.profilers = ensureProfilers(profilers, this);
      }
      get systemInfoReport() {
        const report = {
          asyncContextFrameEnabled: this.asyncContextFrameEnabled,
          codeHotspotsEnabled: this.codeHotspotsEnabled,
          cpuProfilingEnabled: this.cpuProfilingEnabled,
          debugSourceMaps: this.debugSourceMaps,
          endpointCollectionEnabled: this.endpointCollectionEnabled,
          heapSamplingInterval: this.heapSamplingInterval,
          oomMonitoring: { ...this.oomMonitoring },
          profilerTypes: this.profilers.map((p) => p.type),
          sourceMap: this.sourceMap,
          timelineEnabled: this.timelineEnabled,
          timelineSamplingEnabled: this.timelineSamplingEnabled,
          uploadCompression: { ...this.uploadCompression },
          v8ProfilerBugWorkaroundEnabled: this.v8ProfilerBugWorkaroundEnabled
        };
        delete report.oomMonitoring.exportCommand;
        return report;
      }
    };
    module2.exports = { Config };
    function getProfilers({
      DD_PROFILING_HEAP_ENABLED,
      DD_PROFILING_WALLTIME_ENABLED,
      DD_PROFILING_PROFILERS
    }) {
      const profilers = new Set((DD_PROFILING_PROFILERS ?? "wall,space").split(","));
      if (DD_PROFILING_WALLTIME_ENABLED != null) {
        if (isTrue(DD_PROFILING_WALLTIME_ENABLED)) {
          profilers.add("wall");
        } else if (isFalse(DD_PROFILING_WALLTIME_ENABLED)) {
          profilers.delete("wall");
        }
      }
      if (DD_PROFILING_HEAP_ENABLED != null) {
        if (isTrue(DD_PROFILING_HEAP_ENABLED)) {
          profilers.add("space");
        } else if (isFalse(DD_PROFILING_HEAP_ENABLED)) {
          profilers.delete("space");
        }
      }
      return [...profilers];
    }
    function getExportStrategy(name, options) {
      const strategy = Object.values(oomExportStrategies).find((value) => value === name);
      if (strategy === void 0) {
        options.logger.error(`Unknown oom export strategy "${name}"`);
      }
      return strategy;
    }
    function ensureOOMExportStrategies(strategies, options) {
      if (!strategies) {
        return [];
      }
      if (typeof strategies === "string") {
        strategies = strategies.split(",");
      }
      for (let i = 0; i < strategies.length; i++) {
        const strategy = strategies[i];
        if (typeof strategy === "string") {
          strategies[i] = getExportStrategy(strategy, options);
        }
      }
      return [...new Set(strategies)];
    }
    function getExporter(name, options) {
      switch (name) {
        case "agent":
          return new AgentExporter(options);
        case "file":
          return new FileExporter(options);
      }
    }
    function ensureExporters(exporters, options) {
      if (typeof exporters === "string") {
        exporters = exporters.split(",");
      }
      for (let i = 0; i < exporters.length; i++) {
        const exporter = exporters[i];
        if (typeof exporter === "string") {
          exporters[i] = getExporter(exporter, options);
        }
      }
      return exporters;
    }
    function getProfiler(name, options) {
      switch (name) {
        case "cpu":
        case "wall":
          return new WallProfiler(options);
        case "space":
          return new SpaceProfiler(options);
        default:
          options.logger.error(`Unknown profiler "${name}"`);
      }
    }
    function ensureProfilers(profilers, options) {
      if (typeof profilers === "string") {
        profilers = profilers.split(",");
      }
      for (let i = 0; i < profilers.length; i++) {
        const profiler = profilers[i];
        if (typeof profiler === "string") {
          profilers[i] = getProfiler(profiler, options);
        }
      }
      if (options.timelineEnabled && profilers.some((p) => p instanceof WallProfiler)) {
        profilers.push(new EventsProfiler(options));
      }
      return profilers.filter(Boolean);
    }
    function ensureLogger(logger) {
      if (typeof logger !== "object" || typeof logger.debug !== "function" || typeof logger.info !== "function" || typeof logger.warn !== "function" || typeof logger.error !== "function") {
        return new ConsoleLogger();
      }
      return logger;
    }
    function buildExportCommand(options) {
      const tags = [
        ...Object.entries(options.tags),
        ["snapshot", snapshotKinds.ON_OUT_OF_MEMORY]
      ].map(([key, value]) => `${key}:${value}`).join(",");
      const urls = [];
      for (const exporter of options.exporters) {
        if (exporter instanceof AgentExporter) {
          urls.push(options.url.toString());
        } else if (exporter instanceof FileExporter) {
          urls.push(pathToFileURL(options.pprofPrefix).toString());
        }
      }
      return [
        process.execPath,
        path.join(__dirname, "exporter_cli.js"),
        urls.join(","),
        tags,
        "space"
      ];
    }
  }
});

// ../../packages/dd-trace/src/profiling/profiler.js
var require_profiler = __commonJS({
  "../../packages/dd-trace/src/profiling/profiler.js"(exports2, module2) {
    "use strict";
    var { EventEmitter } = __require("events");
    var { Config } = require_config4();
    var { snapshotKinds } = require_constants5();
    var { threadNamePrefix } = require_shared();
    var { isWebServerSpan, endpointNameFromTags, getStartedSpans } = require_webspan_utils();
    var dc = require_dc_polyfill();
    var crashtracker = require_crashtracking();
    var { promisify } = __require("util");
    var zlib = __require("zlib");
    var profileSubmittedChannel = dc.channel("datadog:profiling:profile-submitted");
    var spanFinishedChannel = dc.channel("dd-trace:span:finish");
    function maybeSourceMap(sourceMap, SourceMapper, debug) {
      if (!sourceMap) return;
      return SourceMapper.create([
        process.cwd()
      ], debug);
    }
    function logError(logger, ...args) {
      if (logger) {
        logger.error(...args);
      }
    }
    function findWebSpan(startedSpans, spanId) {
      for (let i = startedSpans.length; --i >= 0; ) {
        const ispan = startedSpans[i];
        const context2 = ispan.context();
        if (context2._spanId === spanId) {
          if (isWebServerSpan(context2._tags)) {
            return true;
          }
          spanId = context2._parentId;
        }
      }
      return false;
    }
    function processInfo(infos, info, type) {
      if (Object.keys(info).length > 0) {
        infos[type] = info;
      }
    }
    var Profiler = class extends EventEmitter {
      #compressionFn;
      #compressionOptions;
      #config;
      #enabled = false;
      #endpointCounts = /* @__PURE__ */ new Map();
      #lastStart;
      #logger;
      #profileSeq = 0;
      #spanFinishListener;
      #timer;
      constructor() {
        super();
        this._timeoutInterval = void 0;
      }
      get flushInterval() {
        return this.#config?.flushInterval;
      }
      start(options) {
        return this._start(options).catch((err) => {
          logError(options.logger, "Error starting profiler. For troubleshooting tips, see <https://dtdg.co/nodejs-profiler-troubleshooting>", err);
          return false;
        });
      }
      get enabled() {
        return this.#enabled;
      }
      #logError(err) {
        logError(this.#logger, err);
      }
      async _start(options) {
        if (this.enabled) return true;
        const config = this.#config = new Config(options);
        this.#logger = config.logger;
        this.#enabled = true;
        this._setInterval();
        let mapper;
        try {
          const { setLogger, SourceMapper } = __require("@datadog/pprof");
          setLogger(config.logger);
          mapper = await maybeSourceMap(config.sourceMap, SourceMapper, config.debugSourceMaps);
          if (config.sourceMap && config.debugSourceMaps) {
            this.#logger.debug(() => {
              return mapper.infoMap.size === 0 ? "Found no source maps" : `Found source maps for following files: [${[...mapper.infoMap.keys()].join(", ")}]`;
            });
          }
          const clevel = config.uploadCompression.level;
          switch (config.uploadCompression.method) {
            case "gzip":
              this.#compressionFn = promisify(zlib.gzip);
              if (clevel !== void 0) {
                this.#compressionOptions = {
                  level: clevel
                };
              }
              break;
            case "zstd":
              if (typeof zlib.zstdCompress === "function") {
                this.#compressionFn = promisify(zlib.zstdCompress);
                if (clevel !== void 0) {
                  this.#compressionOptions = {
                    params: {
                      // eslint-disable-next-line n/no-unsupported-features/node-builtins
                      [zlib.constants.ZSTD_c_compressionLevel]: clevel
                    }
                  };
                }
              } else {
                const zstdCompress = require_libdatadog().load("datadog-js-zstd").zstd_compress;
                const level = clevel ?? 0;
                this.#compressionFn = (buffer) => Promise.resolve(Buffer.from(zstdCompress(buffer, level)));
              }
              break;
          }
        } catch (err) {
          this.#logError(err);
        }
        try {
          const start = /* @__PURE__ */ new Date();
          const nearOOMCallback = this.#nearOOMExport.bind(this);
          for (const profiler of config.profilers) {
            profiler.start({
              mapper,
              nearOOMCallback
            });
            this.#logger.debug(`Started ${profiler.type} profiler in ${threadNamePrefix} thread`);
          }
          if (config.endpointCollectionEnabled) {
            this.#spanFinishListener = this.#onSpanFinish.bind(this);
            spanFinishedChannel.subscribe(this.#spanFinishListener);
          }
          this._capture(this._timeoutInterval, start);
          return true;
        } catch (e) {
          this.#logError(e);
          this.#stop();
          return false;
        }
      }
      #nearOOMExport(profileType, encodedProfile, info) {
        const start = this.#lastStart;
        const end = /* @__PURE__ */ new Date();
        const infos = this.#createInitialInfos();
        processInfo(infos, info, profileType);
        this.#submit({
          [profileType]: encodedProfile
        }, infos, start, end, snapshotKinds.ON_OUT_OF_MEMORY);
      }
      _setInterval() {
        this._timeoutInterval = this.#config.flushInterval;
      }
      stop() {
        if (!this.enabled) return;
        this._collect(snapshotKinds.ON_SHUTDOWN, false);
        this.#stop();
      }
      #stop() {
        if (!this.enabled) return;
        this.#enabled = false;
        if (this.#spanFinishListener !== void 0) {
          spanFinishedChannel.unsubscribe(this.#spanFinishListener);
          this.#spanFinishListener = void 0;
        }
        for (const profiler of this.#config.profilers) {
          profiler.stop();
          this.#logger.debug(`Stopped ${profiler.type} profiler in ${threadNamePrefix} thread`);
        }
        clearTimeout(this.#timer);
        this.#timer = void 0;
      }
      _capture(timeout, start) {
        if (!this.enabled) return;
        this.#lastStart = start;
        if (!this.#timer || timeout !== this._timeoutInterval) {
          this.#timer = setTimeout(() => this._collect(snapshotKinds.PERIODIC), timeout);
          this.#timer.unref();
        } else {
          this.#timer.refresh();
        }
      }
      #onSpanFinish(span) {
        const context2 = span.context();
        const tags = context2._tags;
        if (!isWebServerSpan(tags)) return;
        const endpointName = endpointNameFromTags(tags);
        if (!endpointName) return;
        if (findWebSpan(getStartedSpans(context2), context2._parentId)) return;
        let counter = this.#endpointCounts.get(endpointName);
        if (counter === void 0) {
          counter = { count: 1 };
          this.#endpointCounts.set(endpointName, counter);
        } else {
          counter.count++;
        }
      }
      #createInitialInfos() {
        return {
          settings: this.#config.systemInfoReport
        };
      }
      async _collect(snapshotKind, restart = true) {
        if (!this.enabled) return;
        try {
          if (this.#config.profilers.length === 0) {
            throw new Error("No profile types configured.");
          }
          const startDate = this.#lastStart;
          const endDate = /* @__PURE__ */ new Date();
          const profiles = [];
          crashtracker.withProfilerSerializing(() => {
            for (const profiler of this.#config.profilers) {
              const info = profiler.getInfo();
              const profile = profiler.profile(restart, startDate, endDate);
              if (!restart) {
                this.#logger.debug(`Stopped ${profiler.type} profiler in ${threadNamePrefix} thread`);
              }
              if (!profile) continue;
              profiles.push({ profiler, profile, info });
            }
          });
          if (restart) {
            this._capture(this._timeoutInterval, endDate);
          }
          let hasEncoded = false;
          const encodedProfiles = {};
          const infos = this.#createInitialInfos();
          await Promise.all(profiles.map(async ({ profiler, profile, info }) => {
            try {
              const encoded = await profiler.encode(profile);
              const compressed = encoded instanceof Buffer && this.#compressionFn !== void 0 ? await this.#compressionFn(encoded, this.#compressionOptions) : encoded;
              encodedProfiles[profiler.type] = compressed;
              processInfo(infos, info, profiler.type);
              this.#logger.debug(() => {
                const profileJson = JSON.stringify(profile, (_2, value) => {
                  return typeof value === "bigint" ? value.toString() : value;
                });
                return `Collected ${profiler.type} profile: ` + profileJson;
              });
              hasEncoded = true;
            } catch (err) {
              this.#logError(err);
            }
          }));
          if (hasEncoded) {
            await this.#submit(encodedProfiles, infos, startDate, endDate, snapshotKind);
            profileSubmittedChannel.publish();
            this.#logger.debug("Submitted profiles");
          }
        } catch (err) {
          this.#logError(err);
          this.#stop();
        }
      }
      #submit(profiles, infos, start, end, snapshotKind) {
        const { tags } = this.#config;
        const endpointCounts = {};
        for (const [endpoint, { count }] of this.#endpointCounts) {
          endpointCounts[endpoint] = count;
        }
        this.#endpointCounts.clear();
        tags.snapshot = snapshotKind;
        tags.profile_seq = this.#profileSeq++;
        const exportSpec = { profiles, infos, start, end, tags, endpointCounts };
        const tasks = this.#config.exporters.map(
          (exporter) => exporter.export(exportSpec).catch((err) => {
            if (this.#logger) {
              this.#logger.warn(err);
            }
          })
        );
        return Promise.all(tasks);
      }
    };
    var ServerlessProfiler = class extends Profiler {
      #profiledIntervals = 0;
      #interval = 1;
      // seconds
      #flushAfterIntervals;
      constructor() {
        super();
        this.#profiledIntervals = 0;
        this.#interval = 1;
        this.#flushAfterIntervals = void 0;
      }
      get profiledIntervals() {
        return this.#profiledIntervals;
      }
      _setInterval() {
        this._timeoutInterval = this.#interval * 1e3;
        this.#flushAfterIntervals = this.flushInterval / 1e3;
      }
      async _collect(snapshotKind, restart = true) {
        if (this.#profiledIntervals >= this.#flushAfterIntervals || !restart) {
          this.#profiledIntervals = 0;
          await super._collect(snapshotKind, restart);
        } else {
          this.#profiledIntervals += 1;
          this._capture(this._timeoutInterval, /* @__PURE__ */ new Date());
        }
      }
    };
    module2.exports = { Profiler, ServerlessProfiler };
  }
});

// ../../packages/dd-trace/src/profiling/index.js
var require_profiling = __commonJS({
  "../../packages/dd-trace/src/profiling/index.js"(exports2, module2) {
    "use strict";
    var { Profiler, ServerlessProfiler } = require_profiler();
    var WallProfiler = require_wall();
    var SpaceProfiler = require_space();
    var { AgentExporter } = require_agent2();
    var { FileExporter } = require_file2();
    var { ConsoleLogger } = require_console();
    var { getEnvironmentVariable } = require_config_helper();
    var profiler = getEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") ? new ServerlessProfiler() : new Profiler();
    module2.exports = {
      profiler,
      AgentExporter,
      FileExporter,
      WallProfiler,
      SpaceProfiler,
      ConsoleLogger
    };
  }
});

// ../../packages/dd-trace/src/profiler.js
var require_profiler2 = __commonJS({
  "../../packages/dd-trace/src/profiler.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { profiler } = require_profiling();
    process.once("beforeExit", () => {
      profiler.stop();
    });
    module2.exports = {
      start: (config) => {
        const { service, version, env, url, hostname, port, tags, repositoryUrl, commitSHA, injectionEnabled } = config;
        const { enabled, sourceMap, exporters } = config.profiling;
        const { heartbeatInterval } = config.telemetry;
        const logger = {
          debug: (message) => log.debug(message),
          info: (message) => log.info(message),
          warn: (message) => log.warn(message),
          error: (...args) => log.error(...args)
        };
        const libraryInjected = injectionEnabled.length > 0;
        let activation;
        if (enabled === "auto") {
          activation = "auto";
        } else if (enabled === "true") {
          activation = "manual";
        }
        return profiler.start({
          service,
          version,
          env,
          logger,
          sourceMap,
          exporters,
          url,
          hostname,
          port,
          tags,
          repositoryUrl,
          commitSHA,
          libraryInjected,
          activation,
          heartbeatInterval
        });
      },
      stop: () => {
        profiler.stop();
      }
    };
  }
});

// ../../packages/dd-trace/src/standalone/tracesource.js
var require_tracesource = __commonJS({
  "../../packages/dd-trace/src/standalone/tracesource.js"(exports2, module2) {
    "use strict";
    var { TRACE_SOURCE_PROPAGATION_KEY } = require_constants3();
    function addTraceSourceTag(tags, product) {
      if (tags && product) {
        const actual = tags[TRACE_SOURCE_PROPAGATION_KEY] ? Number.parseInt(String(tags[TRACE_SOURCE_PROPAGATION_KEY]), 16) : 0;
        tags[TRACE_SOURCE_PROPAGATION_KEY] = ((actual | product.id) >>> 0).toString(16).padStart(2, "0");
      }
      return tags;
    }
    function hasTraceSourcePropagationTag(tags) {
      return Object.hasOwn(tags, TRACE_SOURCE_PROPAGATION_KEY);
    }
    module2.exports = {
      addTraceSourceTag,
      hasTraceSourcePropagationTag
    };
  }
});

// ../../packages/dd-trace/src/standalone/tracesource_priority_sampler.js
var require_tracesource_priority_sampler = __commonJS({
  "../../packages/dd-trace/src/standalone/tracesource_priority_sampler.js"(exports2, module2) {
    "use strict";
    var PrioritySampler = require_priority_sampler();
    var { MANUAL_KEEP } = require_tags();
    var { USER_KEEP, AUTO_KEEP, AUTO_REJECT } = require_priority();
    var { SAMPLING_MECHANISM_DEFAULT } = require_constants3();
    var { addTraceSourceTag, hasTraceSourcePropagationTag } = require_tracesource();
    var { getProductRateLimiter } = require_product();
    var TraceSourcePrioritySampler = class extends PrioritySampler {
      /**
       * @override
       */
      configure(env, sampler, config) {
        this._env = env;
        this._limiter = getProductRateLimiter(config);
      }
      /**
       * @override
       * @returns {import('../priority_sampler').SamplingPriority|undefined}
       */
      _getPriorityFromTags(tags, context2) {
        if (Object.hasOwn(tags, MANUAL_KEEP) && tags[MANUAL_KEEP] !== false && hasTraceSourcePropagationTag(context2._trace.tags)) {
          return USER_KEEP;
        }
      }
      /**
       * @override
       */
      _getPriorityFromAuto(span) {
        const context2 = this._getContext(span);
        context2._sampling.mechanism = SAMPLING_MECHANISM_DEFAULT;
        if (hasTraceSourcePropagationTag(context2._trace.tags)) {
          return USER_KEEP;
        }
        return this._isSampledByRateLimit(context2) ? AUTO_KEEP : AUTO_REJECT;
      }
      /**
       * @override
       */
      setPriority(span, samplingPriority, product) {
        super.setPriority(span, samplingPriority, product);
        const context2 = this._getContext(span);
        addTraceSourceTag(context2?._trace?.tags, product);
      }
    };
    module2.exports = TraceSourcePrioritySampler;
  }
});

// ../../packages/dd-trace/src/standalone/index.js
var require_standalone = __commonJS({
  "../../packages/dd-trace/src/standalone/index.js"(exports2, module2) {
    "use strict";
    var { channel } = require_dc_polyfill();
    var TraceSourcePrioritySampler = require_tracesource_priority_sampler();
    var { USER_KEEP } = require_priority();
    var TraceState = require_tracestate();
    var { APM_TRACING_ENABLED_KEY } = require_constants3();
    var { hasTraceSourcePropagationTag } = require_tracesource();
    var startCh = channel("dd-trace:span:start");
    var injectCh = channel("dd-trace:span:inject");
    var extractCh = channel("dd-trace:span:extract");
    function configure(config) {
      if (startCh.hasSubscribers) startCh.unsubscribe(onSpanStart);
      if (injectCh.hasSubscribers) injectCh.unsubscribe(onSpanInject);
      if (extractCh.hasSubscribers) extractCh.unsubscribe(onSpanExtract);
      if (config.apmTracingEnabled !== false) return;
      startCh.subscribe(onSpanStart);
      injectCh.subscribe(onSpanInject);
      extractCh.subscribe(onSpanExtract);
      return new TraceSourcePrioritySampler(config.env);
    }
    function onSpanStart({ span, fields }) {
      const tags = span.context?.()?._tags;
      if (!tags) return;
      const { parent } = fields;
      if (!parent || parent._isRemote) {
        tags[APM_TRACING_ENABLED_KEY] = 0;
      }
    }
    function onSpanInject({ spanContext, carrier }) {
      if (!spanContext?._trace?.tags || !carrier) return;
      if (!hasTraceSourcePropagationTag(spanContext._trace.tags)) {
        for (const key in carrier) {
          const lKey = key.toLowerCase();
          if (lKey.startsWith("x-datadog") || lKey.startsWith("x-b3") || lKey === "traceparent") {
            delete carrier[key];
          } else if (lKey === "tracestate") {
            const tracestate = TraceState.fromString(carrier[key]);
            tracestate.forVendor("dd", (state) => state.clear());
            carrier[key] = tracestate.toString();
          }
        }
      }
    }
    function onSpanExtract({ spanContext = {} }) {
      if (!spanContext._trace?.tags || !spanContext._sampling) return;
      if (!hasTraceSourcePropagationTag(spanContext._trace.tags)) {
        spanContext._sampling.priority = void 0;
      } else if (spanContext._sampling.priority !== USER_KEEP) {
        spanContext._sampling.priority = USER_KEEP;
      }
    }
    module2.exports = {
      configure,
      hasTraceSourcePropagationTag
    };
  }
});

// ../../packages/dd-trace/src/appsec/sdk/utils.js
var require_utils12 = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/utils.js"(exports2, module2) {
    "use strict";
    function getRootSpan(tracer2) {
      let span = tracer2.scope().active();
      if (!span) return;
      const context2 = span.context();
      const started = context2._trace.started;
      let parentId = context2._parentId;
      while (parentId) {
        const parent = started.find((s) => s.context()._spanId === parentId);
        const pContext = parent?.context();
        if (!pContext) break;
        parentId = pContext._parentId;
        if (!pContext._tags?._inferred_span) {
          span = parent;
        }
      }
      return span;
    }
    module2.exports = {
      getRootSpan
    };
  }
});

// ../../packages/dd-trace/src/appsec/sdk/set_user.js
var require_set_user = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/set_user.js"(exports2, module2) {
    "use strict";
    var { getRootSpan } = require_utils12();
    var log = require_log2();
    var waf = require_waf2();
    var addresses = require_addresses();
    function setUserTags(user, rootSpan) {
      for (const k of Object.keys(user)) {
        rootSpan.setTag(`usr.${k}`, String(user[k]));
      }
      rootSpan.setTag("_dd.appsec.user.collection_mode", "sdk");
    }
    function setUser(tracer2, user) {
      if (!user || !user.id) {
        log.warn("[ASM] Invalid user provided to setUser");
        return;
      }
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in setUser");
        return;
      }
      setUserTags(user, rootSpan);
      const persistent = {
        [addresses.USER_ID]: String(user.id)
      };
      if (user.session_id && typeof user.session_id === "string") {
        persistent[addresses.USER_SESSION_ID] = user.session_id;
      }
      waf.run({ persistent });
    }
    module2.exports = {
      setUserTags,
      setUser
    };
  }
});

// ../../packages/dd-trace/src/appsec/sdk/track_event.js
var require_track_event = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/track_event.js"(exports2, module2) {
    "use strict";
    var log = require_log2();
    var { getRootSpan } = require_utils12();
    var { setUserTags } = require_set_user();
    var waf = require_waf2();
    var { keepTrace } = require_priority_sampler();
    var addresses = require_addresses();
    var { ASM } = require_product();
    var { incrementSdkEventMetric } = require_telemetry6();
    function trackUserLoginSuccessEvent(tracer2, user, metadata) {
      if (!user || !user.id) {
        log.warn("[ASM] Invalid user provided to trackUserLoginSuccessEvent");
        return;
      }
      incrementSdkEventMetric("login_success", "v1");
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in trackUserLoginSuccessEvent");
        return;
      }
      setUserTags(user, rootSpan);
      const login = user.login ?? user.id;
      metadata = { "usr.login": login, ...metadata };
      trackEvent("users.login.success", metadata, "trackUserLoginSuccessEvent", rootSpan);
      runWaf("users.login.success", { id: user.id, login });
    }
    function trackUserLoginFailureEvent(tracer2, userId, exists, metadata) {
      if (!userId || typeof userId !== "string") {
        log.warn("[ASM] Invalid userId provided to trackUserLoginFailureEvent");
        return;
      }
      const fields = {
        "usr.id": userId,
        "usr.login": userId,
        "usr.exists": exists ? "true" : "false",
        ...metadata
      };
      trackEvent("users.login.failure", fields, "trackUserLoginFailureEvent", getRootSpan(tracer2));
      runWaf("users.login.failure", { login: userId });
      incrementSdkEventMetric("login_failure", "v1");
    }
    function trackCustomEvent(tracer2, eventName, metadata) {
      if (!eventName || typeof eventName !== "string") {
        log.warn("[ASM] Invalid eventName provided to trackCustomEvent");
        return;
      }
      trackEvent(eventName, metadata, "trackCustomEvent", getRootSpan(tracer2));
      incrementSdkEventMetric("custom", "v1");
      if (eventName === "users.login.success" || eventName === "users.login.failure") {
        runWaf(eventName);
      }
    }
    function trackUserLoginSuccessV2(tracer2, login, user, metadata) {
      if (!login || typeof login !== "string") {
        log.warn("[ASM] Invalid login provided to eventTrackingV2.trackUserLoginSuccess");
        return;
      }
      incrementSdkEventMetric("login_success", "v2");
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in eventTrackingV2.trackUserLoginSuccess");
        return;
      }
      const wafData = { login };
      metadata = {
        "usr.login": login,
        ...metadata
      };
      if (user) {
        if (typeof user !== "object") {
          user = { id: user };
        }
        if (user.id) {
          wafData.id = user.id;
          setUserTags(user, rootSpan);
          metadata.usr = user;
        }
      }
      trackEvent("users.login.success", metadata, "eventTrackingV2.trackUserLoginSuccess", rootSpan);
      runWaf("users.login.success", wafData);
    }
    function trackUserLoginFailureV2(tracer2, login, exists, metadata) {
      if (!login || typeof login !== "string") {
        log.warn("[ASM] Invalid login provided to eventTrackingV2.trackUserLoginFailure");
        return;
      }
      incrementSdkEventMetric("login_failure", "v2");
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in eventTrackingV2.trackUserLoginFailure");
        return;
      }
      const wafData = { login };
      if (exists !== null && typeof exists === "object" && metadata === void 0) {
        metadata = exists;
        exists = false;
      }
      metadata = {
        "usr.login": login,
        "usr.exists": exists ? "true" : "false",
        ...metadata
      };
      trackEvent("users.login.failure", metadata, "eventTrackingV2.trackUserLoginFailure", rootSpan);
      runWaf("users.login.failure", wafData);
    }
    function flattenFields(fields, depth = 0) {
      if (depth > 4) {
        return {
          truncated: true
        };
      }
      const result = {};
      let truncated = false;
      for (const key of Object.keys(fields)) {
        const value = fields[key];
        if (value && typeof value === "object") {
          const { result: flatValue, truncated: inheritTruncated } = flattenFields(value, depth + 1);
          truncated = truncated || inheritTruncated;
          if (flatValue) {
            for (const flatKey of Object.keys(flatValue)) {
              result[`${key}.${flatKey}`] = flatValue[flatKey];
            }
          }
        } else if (value !== void 0) {
          result[key] = value;
        }
      }
      return { result, truncated };
    }
    function trackEvent(eventName, fields, sdkMethodName, rootSpan) {
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in %s", sdkMethodName);
        return;
      }
      const tags = {
        [`appsec.events.${eventName}.track`]: "true",
        [`_dd.appsec.events.${eventName}.sdk`]: "true"
      };
      if (fields) {
        const { result: flatFields, truncated } = flattenFields(fields);
        if (truncated) {
          log.warn("[ASM] Too deep object provided in the SDK method %s, object truncated", sdkMethodName);
        }
        for (const metadataKey of Object.keys(flatFields)) {
          tags[`appsec.events.${eventName}.${metadataKey}`] = String(flatFields[metadataKey]);
        }
      }
      rootSpan.addTags(tags);
      keepTrace(rootSpan, ASM);
    }
    function runWaf(eventName, user) {
      const persistent = {
        [`server.business_logic.${eventName}`]: null
      };
      if (user?.id) {
        persistent[addresses.USER_ID] = String(user.id);
      }
      if (user?.login) {
        persistent[addresses.USER_LOGIN] = String(user.login);
      }
      waf.run({ persistent });
    }
    module2.exports = {
      trackUserLoginSuccessEvent,
      trackUserLoginFailureEvent,
      trackCustomEvent,
      trackUserLoginSuccessV2,
      trackUserLoginFailureV2,
      trackEvent,
      runWaf
    };
  }
});

// ../../packages/dd-trace/src/appsec/sdk/user_blocking.js
var require_user_blocking = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/user_blocking.js"(exports2, module2) {
    "use strict";
    var { USER_ID } = require_addresses();
    var waf = require_waf2();
    var { getRootSpan } = require_utils12();
    var { block, getBlockingAction } = require_blocking();
    var { storage } = require_datadog_core();
    var { setUserTags } = require_set_user();
    var log = require_log2();
    function isUserBlocked(user) {
      const results = waf.run({ persistent: { [USER_ID]: user.id } });
      return !!getBlockingAction(results?.actions);
    }
    function checkUserAndSetUser(tracer2, user) {
      if (!user || !user.id) {
        log.warn("[ASM] Invalid user provided to isUserBlocked");
        return false;
      }
      const rootSpan = getRootSpan(tracer2);
      if (rootSpan) {
        if (!rootSpan.context()._tags["usr.id"]) {
          setUserTags(user, rootSpan);
        }
      } else {
        log.warn("[ASM] Root span not available in isUserBlocked");
      }
      return isUserBlocked(user);
    }
    function blockRequest(tracer2, req, res) {
      if (!req || !res) {
        const store = storage("legacy").getStore();
        if (store) {
          req = req || store.req;
          res = res || store.res;
        }
      }
      if (!req || !res) {
        log.warn("[ASM] Requests or response object not available in blockRequest");
        return false;
      }
      const rootSpan = getRootSpan(tracer2);
      if (!rootSpan) {
        log.warn("[ASM] Root span not available in blockRequest");
        return false;
      }
      return block(req, res, rootSpan);
    }
    module2.exports = {
      checkUserAndSetUser,
      blockRequest
    };
  }
});

// ../../packages/dd-trace/src/appsec/sdk/index.js
var require_sdk = __commonJS({
  "../../packages/dd-trace/src/appsec/sdk/index.js"(exports2, module2) {
    "use strict";
    var {
      trackUserLoginSuccessEvent,
      trackUserLoginFailureEvent,
      trackCustomEvent,
      trackUserLoginSuccessV2,
      trackUserLoginFailureV2
    } = require_track_event();
    var { checkUserAndSetUser, blockRequest } = require_user_blocking();
    var { setTemplates } = require_blocking();
    var { setUser } = require_set_user();
    var EventTrackingV2 = class {
      constructor(tracer2) {
        this._tracer = tracer2;
      }
      trackUserLoginSuccess(login, user, metadata) {
        trackUserLoginSuccessV2(this._tracer, login, user, metadata);
      }
      trackUserLoginFailure(login, exists, metadata) {
        trackUserLoginFailureV2(this._tracer, login, exists, metadata);
      }
    };
    var AppsecSdk = class {
      constructor(tracer2, config) {
        this._tracer = tracer2;
        if (config) {
          setTemplates(config);
        }
        this.eventTrackingV2 = new EventTrackingV2(tracer2);
      }
      trackUserLoginSuccessEvent(user, metadata) {
        return trackUserLoginSuccessEvent(this._tracer, user, metadata);
      }
      trackUserLoginFailureEvent(userId, exists, metadata) {
        return trackUserLoginFailureEvent(this._tracer, userId, exists, metadata);
      }
      trackCustomEvent(eventName, metadata) {
        return trackCustomEvent(this._tracer, eventName, metadata);
      }
      isUserBlocked(user) {
        return checkUserAndSetUser(this._tracer, user);
      }
      blockRequest(req, res) {
        return blockRequest(this._tracer, req, res);
      }
      setUser(user) {
        return setUser(this._tracer, user);
      }
    };
    module2.exports = AppsecSdk;
  }
});

// ../../packages/dd-trace/src/llmobs/sdk.js
var require_sdk2 = __commonJS({
  "../../packages/dd-trace/src/llmobs/sdk.js"(exports2, module2) {
    "use strict";
    var { SPAN_KIND, OUTPUT_VALUE, INPUT_VALUE } = require_tags3();
    var {
      getFunctionArguments,
      validateKind
    } = require_util8();
    var { isTrue, isError } = require_util();
    var { storage } = require_storage4();
    var Span = require_span2();
    var tracerVersion = require_package().version;
    var logger = require_log2();
    var { getEnvironmentVariable } = require_config_helper();
    var telemetry = require_telemetry4();
    var LLMObsTagger = require_tagger2();
    var { channel } = require_dc_polyfill();
    var evalMetricAppendCh = channel("llmobs:eval-metric:append");
    var flushCh = channel("llmobs:writers:flush");
    var registerUserSpanProcessorCh = channel("llmobs:register-processor");
    var NoopLLMObs = require_noop2();
    var LLMObs = class extends NoopLLMObs {
      /**
       * flag representing if a user span processor has been registered
       * @type {boolean}
       */
      #hasUserSpanProcessor = false;
      constructor(tracer2, llmobsModule, config) {
        super(tracer2);
        this._config = config;
        this._llmobsModule = llmobsModule;
        this._tagger = new LLMObsTagger(config);
      }
      get enabled() {
        return this._config.llmobs.enabled;
      }
      enable(options = {}) {
        if (this.enabled) {
          logger.debug("LLMObs is already enabled.");
          return;
        }
        logger.debug("Enabling LLMObs");
        const { mlApp, agentlessEnabled } = options;
        const DD_LLMOBS_ENABLED = getEnvironmentVariable("DD_LLMOBS_ENABLED");
        const llmobsConfig = {
          mlApp,
          agentlessEnabled
        };
        const enabled = DD_LLMOBS_ENABLED == null || isTrue(DD_LLMOBS_ENABLED);
        if (!enabled) {
          logger.debug("LLMObs.enable() called when DD_LLMOBS_ENABLED is false. No action taken.");
          return;
        }
        this._config.llmobs.enabled = true;
        this._config.configure({ ...this._config, llmobs: llmobsConfig });
        this._llmobsModule.enable(this._config);
      }
      disable() {
        if (!this.enabled) {
          logger.debug("LLMObs is already disabled.");
          return;
        }
        logger.debug("Disabling LLMObs");
        this._config.llmobs.enabled = false;
        this._llmobsModule.disable();
      }
      trace(options = {}, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        const kind = validateKind(options.kind);
        telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: false, kind });
        const name = options.name || kind;
        if (!name) {
          throw new Error("No span name provided for `trace`.");
        }
        const {
          spanOptions,
          ...llmobsOptions
        } = this._extractOptions(options);
        if (fn.length > 1) {
          return this._tracer.trace(
            name,
            spanOptions,
            (span, cb) => this._activate(span, { kind, ...llmobsOptions }, () => fn(span, cb))
          );
        }
        return this._tracer.trace(
          name,
          spanOptions,
          (span) => this._activate(span, { kind, ...llmobsOptions }, () => fn(span))
        );
      }
      wrap(options = {}, fn) {
        if (typeof options === "function") {
          fn = options;
          options = {};
        }
        const kind = validateKind(options.kind);
        let name = options.name || fn?.name || kind;
        if (!name) {
          logger.warn('No span name provided for `wrap`. Defaulting to "unnamed-anonymous-function".');
          name = "unnamed-anonymous-function";
        }
        const {
          spanOptions,
          ...llmobsOptions
        } = this._extractOptions(options);
        const llmobs = this;
        function wrapped() {
          telemetry.incrementLLMObsSpanStartCount({ autoinstrumented: false, kind });
          const span = llmobs._tracer.scope().active();
          const fnArgs = arguments;
          const lastArgId = fnArgs.length - 1;
          const cb = fnArgs[lastArgId];
          const hasCallback = typeof cb === "function";
          if (hasCallback) {
            const scopeBoundCb = llmobs._bind(cb);
            fnArgs[lastArgId] = function() {
              const maybeError = arguments[0];
              const maybeResult = arguments[1];
              llmobs._autoAnnotate(
                span,
                kind,
                getFunctionArguments(fn, fnArgs),
                isError(maybeError) || maybeError == null ? maybeResult : maybeError
              );
              return scopeBoundCb.apply(this, arguments);
            };
          }
          try {
            const result = llmobs._activate(span, { kind, ...llmobsOptions }, () => fn.apply(this, fnArgs));
            if (result && typeof result.then === "function") {
              return result.then(
                (value) => {
                  if (!hasCallback) {
                    llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs), value);
                  }
                  return value;
                },
                (err) => {
                  llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs));
                  throw err;
                }
              );
            }
            if (!hasCallback) {
              llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs), result);
            }
            return result;
          } catch (e) {
            llmobs._autoAnnotate(span, kind, getFunctionArguments(fn, fnArgs));
            throw e;
          }
        }
        return this._tracer.wrap(name, spanOptions, wrapped);
      }
      annotate(span, options, autoinstrumented = false) {
        if (!this.enabled) return;
        if (!span) {
          span = this._active();
        }
        if (span && !options && !(span instanceof Span)) {
          options = span;
          span = this._active();
        }
        let err = "";
        try {
          if (!span) {
            err = "invalid_span_no_active_spans";
            throw new Error("No span provided and no active LLMObs-generated span found");
          }
          if (!options) {
            err = "invalid_options";
            throw new Error("No options provided for annotation.");
          }
          if (!LLMObsTagger.tagMap.has(span)) {
            err = "invalid_span_type";
            throw new Error("Span must be an LLMObs-generated span");
          }
          if (span._duration !== void 0) {
            err = "invalid_finished_span";
            throw new Error("Cannot annotate a finished span");
          }
          const spanKind = LLMObsTagger.tagMap.get(span)[SPAN_KIND];
          if (!spanKind) {
            err = "invalid_no_span_kind";
            throw new Error("LLMObs span must have a span kind specified");
          }
          const { inputData, outputData, metadata, metrics: metrics2, tags } = options;
          if (inputData || outputData) {
            if (spanKind === "llm") {
              this._tagger.tagLLMIO(span, inputData, outputData);
            } else if (spanKind === "embedding") {
              this._tagger.tagEmbeddingIO(span, inputData, outputData);
            } else if (spanKind === "retrieval") {
              this._tagger.tagRetrievalIO(span, inputData, outputData);
            } else {
              this._tagger.tagTextIO(span, inputData, outputData);
            }
          }
          if (metadata) {
            this._tagger.tagMetadata(span, metadata);
          }
          if (metrics2) {
            this._tagger.tagMetrics(span, metrics2);
          }
          if (tags) {
            this._tagger.tagSpanTags(span, tags);
          }
        } catch (e) {
          if (e.ddErrorTag) {
            err = e.ddErrorTag;
          }
          throw e;
        } finally {
          if (autoinstrumented === false) {
            telemetry.recordLLMObsAnnotate(span, err);
          }
        }
      }
      exportSpan(span) {
        span = span || this._active();
        let err = "";
        try {
          if (!span) {
            err = "no_active_span";
            throw new Error("No span provided and no active LLMObs-generated span found");
          }
          if (!(span instanceof Span)) {
            err = "invalid_span";
            throw new TypeError("Span must be a valid Span object.");
          }
          if (!LLMObsTagger.tagMap.has(span)) {
            err = "invalid_span";
            throw new Error("Span must be an LLMObs-generated span");
          }
        } catch (e) {
          telemetry.recordExportSpan(span, err);
          throw e;
        }
        try {
          return {
            traceId: span.context().toTraceId(true),
            spanId: span.context().toSpanId()
          };
        } catch {
          err = "invalid_span";
          logger.warn("Failed to export span. Span must be a valid Span object.");
        } finally {
          telemetry.recordExportSpan(span, err);
        }
      }
      registerProcessor(processor) {
        if (!this.enabled) return;
        if (this.#hasUserSpanProcessor) {
          throw new Error(
            "[LLMObs] Only one user span processor can be registered. To register a new processor, deregister the existing processor first using `llmobs.deregisterProcessor()`."
          );
        }
        this.#hasUserSpanProcessor = true;
        registerUserSpanProcessorCh.publish(processor);
      }
      deregisterProcessor() {
        if (!this.enabled) return;
        this.#hasUserSpanProcessor = false;
        registerUserSpanProcessorCh.publish(null);
      }
      submitEvaluation(llmobsSpanContext, options = {}) {
        if (!this.enabled) return;
        let err = "";
        const { traceId, spanId } = llmobsSpanContext;
        try {
          if (!traceId || !spanId) {
            err = "invalid_span";
            throw new Error(
              "spanId and traceId must both be specified for the given evaluation metric to be submitted."
            );
          }
          const mlApp = options.mlApp || this._config.llmobs.mlApp;
          if (!mlApp) {
            err = "missing_ml_app";
            throw new Error(
              "ML App name is required for sending evaluation metrics. Evaluation metric data will not be sent."
            );
          }
          const timestampMs = options.timestampMs || Date.now();
          if (typeof timestampMs !== "number" || timestampMs < 0) {
            err = "invalid_timestamp";
            throw new Error("timestampMs must be a non-negative integer. Evaluation metric data will not be sent");
          }
          const { label, value, tags } = options;
          const metricType = options.metricType?.toLowerCase();
          if (!label) {
            err = "invalid_metric_label";
            throw new Error("label must be the specified name of the evaluation metric");
          }
          if (!metricType || !["categorical", "score"].includes(metricType)) {
            err = "invalid_metric_type";
            throw new Error('metricType must be one of "categorical" or "score"');
          }
          if (metricType === "categorical" && typeof value !== "string") {
            err = "invalid_metric_value";
            throw new Error("value must be a string for a categorical metric.");
          }
          if (metricType === "score" && typeof value !== "number") {
            err = "invalid_metric_value";
            throw new Error("value must be a number for a score metric.");
          }
          const evaluationTags = {
            "ddtrace.version": tracerVersion,
            ml_app: mlApp
          };
          if (tags) {
            for (const key in tags) {
              const tag = tags[key];
              if (typeof tag === "string") {
                evaluationTags[key] = tag;
              } else if (typeof tag.toString === "function") {
                evaluationTags[key] = tag.toString();
              } else if (tag == null) {
                evaluationTags[key] = Object.prototype.toString.call(tag);
              } else {
                err = "invalid_tags";
                throw new Error("Failed to parse tags. Tags for evaluation metrics must be strings");
              }
            }
          }
          const payload = {
            span_id: spanId,
            trace_id: traceId,
            label,
            metric_type: metricType,
            ml_app: mlApp,
            [`${metricType}_value`]: value,
            timestamp_ms: timestampMs,
            tags: Object.entries(evaluationTags).map(([key, value2]) => `${key}:${value2}`)
          };
          evalMetricAppendCh.publish(payload);
        } finally {
          telemetry.recordSubmitEvaluation(options, err);
        }
      }
      annotationContext(options, fn) {
        if (!this.enabled) return fn();
        const currentStore = storage.getStore();
        const store = {
          ...currentStore,
          annotationContext: {
            ...currentStore?.annotationContext,
            ...options
          }
        };
        return storage.run(store, fn);
      }
      flush() {
        if (!this.enabled) return;
        flushCh.publish();
      }
      _autoAnnotate(span, kind, input, output) {
        const annotations = {};
        if (input && !["llm", "embedding"].includes(kind) && !LLMObsTagger.tagMap.get(span)?.[INPUT_VALUE]) {
          annotations.inputData = input;
        }
        if (output && !["llm", "retrieval"].includes(kind) && !LLMObsTagger.tagMap.get(span)?.[OUTPUT_VALUE]) {
          annotations.outputData = output;
        }
        this.annotate(span, annotations, true);
      }
      _active() {
        const store = storage.getStore();
        return store?.span;
      }
      _activate(span, options, fn) {
        const parentStore = storage.getStore();
        if (this.enabled) storage.enterWith({ ...parentStore, span });
        if (options) {
          this._tagger.registerLLMObsSpan(span, {
            ...options,
            parent: parentStore?.span
          });
        }
        try {
          return fn();
        } finally {
          if (this.enabled) storage.enterWith(parentStore);
        }
      }
      // bind function to active LLMObs span
      _bind(fn) {
        if (typeof fn !== "function") return fn;
        const llmobs = this;
        const activeSpan = llmobs._active();
        const bound = function() {
          return llmobs._activate(activeSpan, null, () => {
            return fn.apply(this, arguments);
          });
        };
        return bound;
      }
      _extractOptions(options) {
        const {
          modelName,
          modelProvider,
          sessionId,
          mlApp,
          _decorator,
          ...spanOptions
        } = options;
        return {
          mlApp,
          modelName,
          modelProvider,
          sessionId,
          _decorator,
          spanOptions
        };
      }
    };
    module2.exports = LLMObs;
  }
});

// ../../packages/dd-trace/src/aiguard/client.js
var require_client13 = __commonJS({
  "../../packages/dd-trace/src/aiguard/client.js"(exports2, module2) {
    "use strict";
    async function executeRequest(body, opts) {
      const postData = JSON.stringify(body);
      const headers = {
        "Content-Type": "application/json",
        "Content-Length": Buffer.byteLength(postData),
        ...opts.headers
      };
      const response = await fetch(opts.url, {
        method: "POST",
        headers,
        body: postData,
        signal: AbortSignal.timeout(opts.timeout)
      });
      const responseBody = await response.json();
      return {
        status: response.status,
        body: responseBody
      };
    }
    module2.exports = executeRequest;
  }
});

// ../../packages/dd-trace/src/aiguard/tags.js
var require_tags5 = __commonJS({
  "../../packages/dd-trace/src/aiguard/tags.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      AI_GUARD_RESOURCE: "ai_guard",
      AI_GUARD_TARGET_TAG_KEY: "ai_guard.target",
      AI_GUARD_TOOL_NAME_TAG_KEY: "ai_guard.tool_name",
      AI_GUARD_ACTION_TAG_KEY: "ai_guard.action",
      AI_GUARD_REASON_TAG_KEY: "ai_guard.reason",
      AI_GUARD_BLOCKED_TAG_KEY: "ai_guard.blocked",
      AI_GUARD_META_STRUCT_KEY: "ai_guard"
    };
  }
});

// ../../packages/dd-trace/src/aiguard/sdk.js
var require_sdk3 = __commonJS({
  "../../packages/dd-trace/src/aiguard/sdk.js"(exports2, module2) {
    "use strict";
    var NoopAIGuard = require_noop4();
    var executeRequest = require_client13();
    var {
      AI_GUARD_RESOURCE,
      AI_GUARD_TARGET_TAG_KEY,
      AI_GUARD_REASON_TAG_KEY,
      AI_GUARD_ACTION_TAG_KEY,
      AI_GUARD_BLOCKED_TAG_KEY,
      AI_GUARD_META_STRUCT_KEY,
      AI_GUARD_TOOL_NAME_TAG_KEY
    } = require_tags5();
    var log = require_log2();
    var ALLOW = "ALLOW";
    var AIGuardAbortError = class extends Error {
      constructor(reason) {
        super(reason);
        this.name = "AIGuardAbortError";
        this.reason = reason;
      }
    };
    var AIGuardClientError = class extends Error {
      constructor(message, opts = {}) {
        super(message);
        this.name = "AIGuardClientError";
        if (opts.errors) {
          this.errors = opts.errors;
        }
        if (opts.cause) {
          this.cause = opts.cause;
        }
      }
    };
    var AIGuard = class extends NoopAIGuard {
      #initialized;
      #tracer;
      #headers;
      #evaluateUrl;
      #timeout;
      #maxMessagesLength;
      #maxContentSize;
      #meta;
      constructor(tracer2, config) {
        super();
        if (!config.apiKey || !config.appKey) {
          log.error("AIGuard: missing api and/or app keys, use env DD_API_KEY and DD_APP_KEY");
          this.#initialized = false;
          return;
        }
        this.#tracer = tracer2;
        this.#headers = {
          "DD-API-KEY": config.apiKey,
          "DD-APPLICATION-KEY": config.appKey
        };
        const endpoint = config.experimental.aiguard.endpoint || `https://app.${config.site}/api/v2/ai-guard`;
        this.#evaluateUrl = `${endpoint}/evaluate`;
        this.#timeout = config.experimental.aiguard.timeout;
        this.#maxMessagesLength = config.experimental.aiguard.maxMessagesLength;
        this.#maxContentSize = config.experimental.aiguard.maxContentSize;
        this.#meta = { service: config.service, env: config.env };
        this.#initialized = true;
      }
      #truncate(messages) {
        const size = Math.min(messages.length, this.#maxMessagesLength);
        const result = messages.slice(-size);
        for (let i = 0; i < size; i++) {
          const message = result[i];
          if (message.content?.length > this.#maxContentSize) {
            result[i] = { ...message, content: message.content.slice(0, this.#maxContentSize) };
          }
        }
        return result;
      }
      #isToolCall(message) {
        return message.tool_calls || message.tool_call_id;
      }
      #getToolName(message, history) {
        if (message.tool_calls) {
          const names = message.tool_calls.map((tool) => tool.function.name);
          return names.length === 0 ? null : names.join(",");
        }
        const id = message.tool_call_id;
        for (let i = history.length - 2; i >= 0; i--) {
          const item = history[i];
          if (item.tool_calls) {
            for (const toolCall of item.tool_calls) {
              if (toolCall.id === id) {
                return toolCall.function.name;
              }
            }
          }
        }
        return null;
      }
      evaluate(messages, opts) {
        if (!this.#initialized) {
          return super.evaluate(messages, opts);
        }
        const { block = false } = opts ?? {};
        return this.#tracer.trace(AI_GUARD_RESOURCE, {}, async (span) => {
          const last = messages[messages.length - 1];
          const target = this.#isToolCall(last) ? "tool" : "prompt";
          span.setTag(AI_GUARD_TARGET_TAG_KEY, target);
          if (target === "tool") {
            const name = this.#getToolName(last, messages);
            if (name) {
              span.setTag(AI_GUARD_TOOL_NAME_TAG_KEY, name);
            }
          }
          span.meta_struct = {
            [AI_GUARD_META_STRUCT_KEY]: {
              messages: this.#truncate(messages)
            }
          };
          let response;
          try {
            const payload = {
              data: {
                attributes: {
                  messages,
                  meta: this.#meta
                }
              }
            };
            response = await executeRequest(
              payload,
              { url: this.#evaluateUrl, headers: this.#headers, timeout: this.#timeout }
            );
          } catch (e) {
            throw new AIGuardClientError("Unexpected error calling AI Guard service", { cause: e });
          }
          if (response.status !== 200) {
            throw new AIGuardClientError(
              `AI Guard service call failed, status ${response.status}`,
              { errors: response.body?.errors }
            );
          }
          let action, reason, blockingEnabled;
          try {
            const attr = response.body.data.attributes;
            if (!attr.action) {
              throw new Error("Action missing from response");
            }
            action = attr.action;
            reason = attr.reason;
            blockingEnabled = attr.is_blocking_enabled ?? false;
          } catch (e) {
            throw new AIGuardClientError(`AI Guard service returned unexpected response : ${response.body}`, { cause: e });
          }
          span.setTag(AI_GUARD_ACTION_TAG_KEY, action);
          span.setTag(AI_GUARD_REASON_TAG_KEY, reason);
          if (block && blockingEnabled && action !== ALLOW) {
            span.setTag(AI_GUARD_BLOCKED_TAG_KEY, "true");
            throw new AIGuardAbortError(reason);
          }
          return { action, reason };
        });
      }
    };
    module2.exports = AIGuard;
  }
});

// ../../node_modules/spark-md5/spark-md5.js
var require_spark_md5 = __commonJS({
  "../../node_modules/spark-md5/spark-md5.js"(exports2, module2) {
    (function(factory) {
      if (typeof exports2 === "object") {
        module2.exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define(factory);
      } else {
        var glob;
        try {
          glob = window;
        } catch (e) {
          glob = self;
        }
        glob.SparkMD5 = factory();
      }
    })(function(undefined2) {
      "use strict";
      var add32 = function(a, b) {
        return a + b & 4294967295;
      }, hex_chr = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
      function cmn(q, a, b, x, s, t) {
        a = add32(add32(a, q), add32(x, t));
        return add32(a << s | a >>> 32 - s, b);
      }
      function md5cycle(x, k) {
        var a = x[0], b = x[1], c = x[2], d = x[3];
        a += (b & c | ~b & d) + k[0] - 680876936 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[1] - 389564586 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[2] + 606105819 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[3] - 1044525330 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[4] - 176418897 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[5] + 1200080426 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[6] - 1473231341 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[7] - 45705983 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[8] + 1770035416 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[9] - 1958414417 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[10] - 42063 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[11] - 1990404162 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & c | ~b & d) + k[12] + 1804603682 | 0;
        a = (a << 7 | a >>> 25) + b | 0;
        d += (a & b | ~a & c) + k[13] - 40341101 | 0;
        d = (d << 12 | d >>> 20) + a | 0;
        c += (d & a | ~d & b) + k[14] - 1502002290 | 0;
        c = (c << 17 | c >>> 15) + d | 0;
        b += (c & d | ~c & a) + k[15] + 1236535329 | 0;
        b = (b << 22 | b >>> 10) + c | 0;
        a += (b & d | c & ~d) + k[1] - 165796510 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[6] - 1069501632 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[11] + 643717713 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[0] - 373897302 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[5] - 701558691 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[10] + 38016083 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[15] - 660478335 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[4] - 405537848 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[9] + 568446438 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[14] - 1019803690 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[3] - 187363961 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[8] + 1163531501 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b & d | c & ~d) + k[13] - 1444681467 | 0;
        a = (a << 5 | a >>> 27) + b | 0;
        d += (a & c | b & ~c) + k[2] - 51403784 | 0;
        d = (d << 9 | d >>> 23) + a | 0;
        c += (d & b | a & ~b) + k[7] + 1735328473 | 0;
        c = (c << 14 | c >>> 18) + d | 0;
        b += (c & a | d & ~a) + k[12] - 1926607734 | 0;
        b = (b << 20 | b >>> 12) + c | 0;
        a += (b ^ c ^ d) + k[5] - 378558 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[8] - 2022574463 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[11] + 1839030562 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[14] - 35309556 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[1] - 1530992060 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[4] + 1272893353 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[7] - 155497632 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[10] - 1094730640 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[13] + 681279174 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[0] - 358537222 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[3] - 722521979 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[6] + 76029189 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (b ^ c ^ d) + k[9] - 640364487 | 0;
        a = (a << 4 | a >>> 28) + b | 0;
        d += (a ^ b ^ c) + k[12] - 421815835 | 0;
        d = (d << 11 | d >>> 21) + a | 0;
        c += (d ^ a ^ b) + k[15] + 530742520 | 0;
        c = (c << 16 | c >>> 16) + d | 0;
        b += (c ^ d ^ a) + k[2] - 995338651 | 0;
        b = (b << 23 | b >>> 9) + c | 0;
        a += (c ^ (b | ~d)) + k[0] - 198630844 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[7] + 1126891415 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[14] - 1416354905 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[5] - 57434055 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[12] + 1700485571 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[3] - 1894986606 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[10] - 1051523 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[1] - 2054922799 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[8] + 1873313359 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[15] - 30611744 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[6] - 1560198380 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[13] + 1309151649 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        a += (c ^ (b | ~d)) + k[4] - 145523070 | 0;
        a = (a << 6 | a >>> 26) + b | 0;
        d += (b ^ (a | ~c)) + k[11] - 1120210379 | 0;
        d = (d << 10 | d >>> 22) + a | 0;
        c += (a ^ (d | ~b)) + k[2] + 718787259 | 0;
        c = (c << 15 | c >>> 17) + d | 0;
        b += (d ^ (c | ~a)) + k[9] - 343485551 | 0;
        b = (b << 21 | b >>> 11) + c | 0;
        x[0] = a + x[0] | 0;
        x[1] = b + x[1] | 0;
        x[2] = c + x[2] | 0;
        x[3] = d + x[3] | 0;
      }
      function md5blk(s) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = s.charCodeAt(i) + (s.charCodeAt(i + 1) << 8) + (s.charCodeAt(i + 2) << 16) + (s.charCodeAt(i + 3) << 24);
        }
        return md5blks;
      }
      function md5blk_array(a) {
        var md5blks = [], i;
        for (i = 0; i < 64; i += 4) {
          md5blks[i >> 2] = a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24);
        }
        return md5blks;
      }
      function md51(s) {
        var n = s.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk(s.substring(i - 64, i)));
        }
        s = s.substring(i - 64);
        length = s.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function md51_array(a) {
        var n = a.length, state = [1732584193, -271733879, -1732584194, 271733878], i, length, tail, tmp, lo, hi;
        for (i = 64; i <= n; i += 64) {
          md5cycle(state, md5blk_array(a.subarray(i - 64, i)));
        }
        a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0);
        length = a.length;
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= a[i] << (i % 4 << 3);
        }
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(state, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = n * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(state, tail);
        return state;
      }
      function rhex(n) {
        var s = "", j;
        for (j = 0; j < 4; j += 1) {
          s += hex_chr[n >> j * 8 + 4 & 15] + hex_chr[n >> j * 8 & 15];
        }
        return s;
      }
      function hex(x) {
        var i;
        for (i = 0; i < x.length; i += 1) {
          x[i] = rhex(x[i]);
        }
        return x.join("");
      }
      if (hex(md51("hello")) !== "5d41402abc4b2a76b9719d911017c592") {
        add32 = function(x, y) {
          var lsw = (x & 65535) + (y & 65535), msw = (x >> 16) + (y >> 16) + (lsw >> 16);
          return msw << 16 | lsw & 65535;
        };
      }
      if (typeof ArrayBuffer !== "undefined" && !ArrayBuffer.prototype.slice) {
        (function() {
          function clamp(val, length) {
            val = val | 0 || 0;
            if (val < 0) {
              return Math.max(val + length, 0);
            }
            return Math.min(val, length);
          }
          ArrayBuffer.prototype.slice = function(from, to) {
            var length = this.byteLength, begin = clamp(from, length), end = length, num, target, targetArray, sourceArray;
            if (to !== undefined2) {
              end = clamp(to, length);
            }
            if (begin > end) {
              return new ArrayBuffer(0);
            }
            num = end - begin;
            target = new ArrayBuffer(num);
            targetArray = new Uint8Array(target);
            sourceArray = new Uint8Array(this, begin, num);
            targetArray.set(sourceArray);
            return target;
          };
        })();
      }
      function toUtf8(str) {
        if (/[\u0080-\uFFFF]/.test(str)) {
          str = unescape(encodeURIComponent(str));
        }
        return str;
      }
      function utf8Str2ArrayBuffer(str, returnUInt8Array) {
        var length = str.length, buff = new ArrayBuffer(length), arr = new Uint8Array(buff), i;
        for (i = 0; i < length; i += 1) {
          arr[i] = str.charCodeAt(i);
        }
        return returnUInt8Array ? arr : buff;
      }
      function arrayBuffer2Utf8Str(buff) {
        return String.fromCharCode.apply(null, new Uint8Array(buff));
      }
      function concatenateArrayBuffers(first, second, returnUInt8Array) {
        var result = new Uint8Array(first.byteLength + second.byteLength);
        result.set(new Uint8Array(first));
        result.set(new Uint8Array(second), first.byteLength);
        return returnUInt8Array ? result : result.buffer;
      }
      function hexToBinaryString(hex2) {
        var bytes = [], length = hex2.length, x;
        for (x = 0; x < length - 1; x += 2) {
          bytes.push(parseInt(hex2.substr(x, 2), 16));
        }
        return String.fromCharCode.apply(String, bytes);
      }
      function SparkMD5() {
        this.reset();
      }
      SparkMD5.prototype.append = function(str) {
        this.appendBinary(toUtf8(str));
        return this;
      };
      SparkMD5.prototype.appendBinary = function(contents) {
        this._buff += contents;
        this._length += contents.length;
        var length = this._buff.length, i;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)));
        }
        this._buff = this._buff.substring(i - 64);
        return this;
      };
      SparkMD5.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, i, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.prototype.reset = function() {
        this._buff = "";
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.prototype.getState = function() {
        return {
          buff: this._buff,
          length: this._length,
          hash: this._hash.slice()
        };
      };
      SparkMD5.prototype.setState = function(state) {
        this._buff = state.buff;
        this._length = state.length;
        this._hash = state.hash;
        return this;
      };
      SparkMD5.prototype.destroy = function() {
        delete this._hash;
        delete this._buff;
        delete this._length;
      };
      SparkMD5.prototype._finish = function(tail, length) {
        var i = length, tmp, lo, hi;
        tail[i >> 2] |= 128 << (i % 4 << 3);
        if (i > 55) {
          md5cycle(this._hash, tail);
          for (i = 0; i < 16; i += 1) {
            tail[i] = 0;
          }
        }
        tmp = this._length * 8;
        tmp = tmp.toString(16).match(/(.*?)(.{0,8})$/);
        lo = parseInt(tmp[2], 16);
        hi = parseInt(tmp[1], 16) || 0;
        tail[14] = lo;
        tail[15] = hi;
        md5cycle(this._hash, tail);
      };
      SparkMD5.hash = function(str, raw) {
        return SparkMD5.hashBinary(toUtf8(str), raw);
      };
      SparkMD5.hashBinary = function(content, raw) {
        var hash = md51(content), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      SparkMD5.ArrayBuffer = function() {
        this.reset();
      };
      SparkMD5.ArrayBuffer.prototype.append = function(arr) {
        var buff = concatenateArrayBuffers(this._buff.buffer, arr, true), length = buff.length, i;
        this._length += arr.byteLength;
        for (i = 64; i <= length; i += 64) {
          md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)));
        }
        this._buff = i - 64 < length ? new Uint8Array(buff.buffer.slice(i - 64)) : new Uint8Array(0);
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.end = function(raw) {
        var buff = this._buff, length = buff.length, tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], i, ret;
        for (i = 0; i < length; i += 1) {
          tail[i >> 2] |= buff[i] << (i % 4 << 3);
        }
        this._finish(tail, length);
        ret = hex(this._hash);
        if (raw) {
          ret = hexToBinaryString(ret);
        }
        this.reset();
        return ret;
      };
      SparkMD5.ArrayBuffer.prototype.reset = function() {
        this._buff = new Uint8Array(0);
        this._length = 0;
        this._hash = [1732584193, -271733879, -1732584194, 271733878];
        return this;
      };
      SparkMD5.ArrayBuffer.prototype.getState = function() {
        var state = SparkMD5.prototype.getState.call(this);
        state.buff = arrayBuffer2Utf8Str(state.buff);
        return state;
      };
      SparkMD5.ArrayBuffer.prototype.setState = function(state) {
        state.buff = utf8Str2ArrayBuffer(state.buff, true);
        return SparkMD5.prototype.setState.call(this, state);
      };
      SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy;
      SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish;
      SparkMD5.ArrayBuffer.hash = function(arr, raw) {
        var hash = md51_array(new Uint8Array(arr)), ret = hex(hash);
        return raw ? hexToBinaryString(ret) : ret;
      };
      return SparkMD5;
    });
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/obfuscation.js
var require_obfuscation = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/obfuscation.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getMD5Hash = getMD5Hash;
    exports2.buildStorageKeySuffix = buildStorageKeySuffix;
    var spark_md5_1 = __importDefault(require_spark_md5());
    function getMD5Hash(input, salt = "") {
      return new spark_md5_1.default().append(salt).append(input).end();
    }
    function buildStorageKeySuffix(apiKey) {
      const hashed = getMD5Hash(apiKey);
      return hashed.slice(0, 16);
    }
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/cache/abstract-assignment-cache.js
var require_abstract_assignment_cache = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/cache/abstract-assignment-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractAssignmentCache = void 0;
    exports2.assignmentCacheKeyToString = assignmentCacheKeyToString;
    exports2.assignmentCacheValueToString = assignmentCacheValueToString;
    var obfuscation_1 = require_obfuscation();
    function assignmentCacheKeyToString(exposureEvent) {
      const key = {
        flag: {
          key: exposureEvent.flag.key
        },
        subject: {
          id: exposureEvent.subject.id,
          attributes: exposureEvent.subject.attributes
        }
      };
      return (0, obfuscation_1.getMD5Hash)(JSON.stringify(key));
    }
    function assignmentCacheValueToString(cacheValue) {
      return (0, obfuscation_1.getMD5Hash)(JSON.stringify(cacheValue));
    }
    var AbstractAssignmentCache = class {
      // key -> variation value hash
      constructor(delegate) {
        this.delegate = delegate;
      }
      init() {
        return Promise.resolve();
      }
      /** Returns whether the provided {@link AssignmentCacheEntry} is present in the cache. */
      has(entry) {
        return this.get(entry) === assignmentCacheValueToString(entry);
      }
      get(key) {
        return this.delegate.get(assignmentCacheKeyToString(key));
      }
      /**
       * Stores the provided {@link AssignmentCacheEntry} in the cache. If the key already exists, it
       * will be overwritten.
       */
      set(entry) {
        this.delegate.set(assignmentCacheKeyToString(entry), assignmentCacheValueToString(entry));
      }
      /**
       * Returns an array with all {@link AssignmentCacheEntry} entries in the cache as an array of
       * {@link string}s.
       */
      entries() {
        return this.delegate.entries();
      }
      /** Clears all entries from the cache. */
      clear() {
        this.delegate.clear();
      }
    };
    exports2.AbstractAssignmentCache = AbstractAssignmentCache;
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/cache/lru-cache.js
var require_lru_cache2 = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/cache/lru-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = void 0;
    var LRUCache = class {
      constructor(capacity) {
        this.capacity = capacity;
        this.cache = /* @__PURE__ */ new Map();
        this.size = this.cache.size;
      }
      [(Symbol.toStringTag, Symbol.iterator)]() {
        return this.cache[Symbol.iterator]();
      }
      forEach(callbackFn) {
        this.cache.forEach(callbackFn);
      }
      entries() {
        return this.cache.entries();
      }
      clear() {
        this.cache.clear();
      }
      delete(key) {
        return this.cache.delete(key);
      }
      keys() {
        return this.cache.keys();
      }
      values() {
        return this.cache.values();
      }
      has(key) {
        return this.cache.has(key);
      }
      get(key) {
        if (!this.has(key)) {
          return void 0;
        }
        const value = this.cache.get(key);
        if (value !== void 0) {
          this.delete(key);
          this.cache.set(key, value);
        }
        return value;
      }
      set(key, value) {
        if (this.capacity === 0) {
          return this;
        }
        if (this.cache.has(key)) {
          this.cache.delete(key);
        } else if (this.cache.size >= this.capacity) {
          const oldestKey = this.cache.keys().next().value;
          if (oldestKey) {
            this.delete(oldestKey);
          }
        }
        this.cache.set(key, value);
        return this;
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/cache/lru-in-memory-assignment-cache.js
var require_lru_in_memory_assignment_cache = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/cache/lru-in-memory-assignment-cache.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUInMemoryAssignmentCache = void 0;
    var abstract_assignment_cache_1 = require_abstract_assignment_cache();
    var lru_cache_1 = require_lru_cache2();
    var LRUInMemoryAssignmentCache = class extends abstract_assignment_cache_1.AbstractAssignmentCache {
      constructor(maxSize) {
        super(new lru_cache_1.LRUCache(maxSize));
      }
    };
    exports2.LRUInMemoryAssignmentCache = LRUInMemoryAssignmentCache;
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/cache/non-expiring-in-memory-cache-assignment.js
var require_non_expiring_in_memory_cache_assignment = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/cache/non-expiring-in-memory-cache-assignment.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NonExpiringInMemoryAssignmentCache = void 0;
    var abstract_assignment_cache_1 = require_abstract_assignment_cache();
    var NonExpiringInMemoryAssignmentCache = class extends abstract_assignment_cache_1.AbstractAssignmentCache {
      constructor(store = /* @__PURE__ */ new Map()) {
        super(store);
      }
    };
    exports2.NonExpiringInMemoryAssignmentCache = NonExpiringInMemoryAssignmentCache;
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/cache/index.js
var require_cache2 = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/cache/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_abstract_assignment_cache(), exports2);
    __exportStar(require_lru_in_memory_assignment_cache(), exports2);
    __exportStar(require_non_expiring_in_memory_cache_assignment(), exports2);
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/configuration/configuration.js
var require_configuration = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/configuration/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/configuration/exposureEvent.js
var require_exposureEvent = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/configuration/exposureEvent.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createExposureEvent = createExposureEvent;
    function createExposureEvent(context2, details) {
      var _a, _b;
      if (!((_a = details.flagMetadata) === null || _a === void 0 ? void 0 : _a.doLog)) {
        return;
      }
      const allocationKey = (_b = details.flagMetadata) === null || _b === void 0 ? void 0 : _b.allocationKey;
      const variantKey = details.variant;
      if (!allocationKey || !variantKey) {
        return;
      }
      const { targetingKey: id = "", ...attributes } = context2;
      return {
        allocation: {
          key: allocationKey
        },
        flag: {
          key: details.flagKey
        },
        variant: {
          key: variantKey
        },
        subject: {
          id,
          attributes
        }
      };
    }
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/configuration/exposureEvent.types.js
var require_exposureEvent_types = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/configuration/exposureEvent.types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/configuration/wire.js
var require_wire = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/configuration/wire.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.configurationFromString = configurationFromString;
    exports2.configurationToString = configurationToString;
    function configurationFromString(s) {
      try {
        const wire = JSON.parse(s);
        if (wire.version !== 1) {
          return {};
        }
        const configuration = {};
        if (wire.precomputed) {
          configuration.precomputed = {
            ...wire.precomputed,
            response: JSON.parse(wire.precomputed.response)
          };
        }
        return configuration;
      } catch (_a) {
        return {};
      }
    }
    function configurationToString(configuration) {
      const wire = {
        version: 1
      };
      if (configuration.precomputed) {
        wire.precomputed = {
          ...configuration.precomputed,
          response: JSON.stringify(configuration.precomputed)
        };
      }
      return JSON.stringify(wire);
    }
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/configuration/index.js
var require_configuration2 = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/configuration/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_configuration(), exports2);
    __exportStar(require_exposureEvent(), exports2);
    __exportStar(require_exposureEvent_types(), exports2);
    __exportStar(require_wire(), exports2);
  }
});

// ../../node_modules/@datadog/flagging-core/cjs/index.js
var require_cjs = __commonJS({
  "../../node_modules/@datadog/flagging-core/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_cache2(), exports2);
    __exportStar(require_configuration2(), exports2);
    __exportStar(require_obfuscation(), exports2);
  }
});

// ../../node_modules/@openfeature/core/dist/cjs/index.js
var require_cjs2 = __commonJS({
  "../../node_modules/@openfeature/core/dist/cjs/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var index_exports = {};
    __export2(index_exports, {
      AllProviderEvents: () => ClientProviderEvents,
      AllProviderStatus: () => ClientProviderStatus,
      ClientProviderEvents: () => ClientProviderEvents,
      ClientProviderStatus: () => ClientProviderStatus,
      DefaultLogger: () => DefaultLogger,
      ErrorCode: () => ErrorCode,
      FlagNotFoundError: () => FlagNotFoundError,
      GeneralError: () => GeneralError,
      GenericEventEmitter: () => GenericEventEmitter,
      InvalidContextError: () => InvalidContextError,
      LOG_LEVELS: () => LOG_LEVELS,
      MapHookData: () => MapHookData,
      OpenFeatureCommonAPI: () => OpenFeatureCommonAPI,
      OpenFeatureError: () => OpenFeatureError,
      ParseError: () => ParseError,
      ProviderFatalError: () => ProviderFatalError,
      ProviderNotReadyError: () => ProviderNotReadyError,
      ProviderWrapper: () => ProviderWrapper,
      SafeLogger: () => SafeLogger,
      ServerProviderEvents: () => ServerProviderEvents,
      ServerProviderStatus: () => ServerProviderStatus,
      StandardResolutionReasons: () => StandardResolutionReasons,
      TargetingKeyMissingError: () => TargetingKeyMissingError,
      TelemetryAttribute: () => TelemetryAttribute,
      TelemetryFlagMetadata: () => TelemetryFlagMetadata,
      TypeMismatchError: () => TypeMismatchError,
      createEvaluationEvent: () => createEvaluationEvent,
      instantiateErrorByErrorCode: () => instantiateErrorByErrorCode,
      isObject: () => isObject,
      isString: () => isString,
      objectOrUndefined: () => objectOrUndefined,
      statusMatchesEvent: () => statusMatchesEvent,
      stringOrUndefined: () => stringOrUndefined
    });
    module2.exports = __toCommonJS2(index_exports);
    var MapHookData = class {
      constructor() {
        this.data = /* @__PURE__ */ new Map();
      }
      set(key, value) {
        this.data.set(key, value);
      }
      get(key) {
        return this.data.get(key);
      }
      has(key) {
        return this.data.has(key);
      }
      delete(key) {
        return this.data.delete(key);
      }
      clear() {
        this.data.clear();
      }
    };
    var StandardResolutionReasons = {
      /**
       * The resolved value is static (no dynamic evaluation).
       */
      STATIC: "STATIC",
      /**
       *  The resolved value was configured statically, or otherwise fell back to a pre-configured value.
       */
      DEFAULT: "DEFAULT",
      /**
       * The resolved value was the result of a dynamic evaluation, such as a rule or specific user-targeting.
       */
      TARGETING_MATCH: "TARGETING_MATCH",
      /**
       * The resolved value was the result of pseudorandom assignment.
       */
      SPLIT: "SPLIT",
      /**
       * The resolved value was retrieved from cache.
       */
      CACHED: "CACHED",
      /**
       * The resolved value was the result of the flag being disabled in the management system.
       */
      DISABLED: "DISABLED",
      /**
       * The reason for the resolved value could not be determined.
       */
      UNKNOWN: "UNKNOWN",
      /**
       * The resolved value is non-authoritative or possibly out of date.
       */
      STALE: "STALE",
      /**
       * The resolved value was the result of an error.
       *
       * Note: The `errorCode` and `errorMessage` fields may contain additional details of this error.
       */
      ERROR: "ERROR"
    };
    var ErrorCode = /* @__PURE__ */ ((ErrorCode2) => {
      ErrorCode2["PROVIDER_NOT_READY"] = "PROVIDER_NOT_READY";
      ErrorCode2["PROVIDER_FATAL"] = "PROVIDER_FATAL";
      ErrorCode2["FLAG_NOT_FOUND"] = "FLAG_NOT_FOUND";
      ErrorCode2["PARSE_ERROR"] = "PARSE_ERROR";
      ErrorCode2["TYPE_MISMATCH"] = "TYPE_MISMATCH";
      ErrorCode2["TARGETING_KEY_MISSING"] = "TARGETING_KEY_MISSING";
      ErrorCode2["INVALID_CONTEXT"] = "INVALID_CONTEXT";
      ErrorCode2["GENERAL"] = "GENERAL";
      return ErrorCode2;
    })(ErrorCode || {});
    var OpenFeatureError = class _OpenFeatureError extends Error {
      constructor(message, options) {
        super(message);
        Object.setPrototypeOf(this, _OpenFeatureError.prototype);
        this.name = "OpenFeatureError";
        this.cause = options == null ? void 0 : options.cause;
      }
    };
    var FlagNotFoundError = class _FlagNotFoundError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _FlagNotFoundError.prototype);
        this.name = "FlagNotFoundError";
        this.code = "FLAG_NOT_FOUND";
      }
    };
    var GeneralError = class _GeneralError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _GeneralError.prototype);
        this.name = "GeneralError";
        this.code = "GENERAL";
      }
    };
    var InvalidContextError = class _InvalidContextError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _InvalidContextError.prototype);
        this.name = "InvalidContextError";
        this.code = "INVALID_CONTEXT";
      }
    };
    var ParseError = class _ParseError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _ParseError.prototype);
        this.name = "ParseError";
        this.code = "PARSE_ERROR";
      }
    };
    var ProviderFatalError = class _ProviderFatalError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _ProviderFatalError.prototype);
        this.name = "ProviderFatalError";
        this.code = "PROVIDER_FATAL";
      }
    };
    var ProviderNotReadyError = class _ProviderNotReadyError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _ProviderNotReadyError.prototype);
        this.name = "ProviderNotReadyError";
        this.code = "PROVIDER_NOT_READY";
      }
    };
    var TargetingKeyMissingError = class _TargetingKeyMissingError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _TargetingKeyMissingError.prototype);
        this.name = "TargetingKeyMissingError";
        this.code = "TARGETING_KEY_MISSING";
      }
    };
    var TypeMismatchError = class _TypeMismatchError extends OpenFeatureError {
      constructor(message, options) {
        super(message, options);
        Object.setPrototypeOf(this, _TypeMismatchError.prototype);
        this.name = "TypeMismatchError";
        this.code = "TYPE_MISMATCH";
      }
    };
    var instantiateErrorByErrorCode = (errorCode, message) => {
      switch (errorCode) {
        case "FLAG_NOT_FOUND":
          return new FlagNotFoundError(message);
        case "PARSE_ERROR":
          return new ParseError(message);
        case "TYPE_MISMATCH":
          return new TypeMismatchError(message);
        case "TARGETING_KEY_MISSING":
          return new TargetingKeyMissingError(message);
        case "INVALID_CONTEXT":
          return new InvalidContextError(message);
        case "PROVIDER_NOT_READY":
          return new ProviderNotReadyError(message);
        case "PROVIDER_FATAL":
          return new ProviderFatalError(message);
        default:
          return new GeneralError(message);
      }
    };
    var ServerProviderStatus = /* @__PURE__ */ ((ServerProviderStatus2) => {
      ServerProviderStatus2["NOT_READY"] = "NOT_READY";
      ServerProviderStatus2["READY"] = "READY";
      ServerProviderStatus2["ERROR"] = "ERROR";
      ServerProviderStatus2["STALE"] = "STALE";
      ServerProviderStatus2["FATAL"] = "FATAL";
      return ServerProviderStatus2;
    })(ServerProviderStatus || {});
    var ClientProviderStatus = /* @__PURE__ */ ((ClientProviderStatus2) => {
      ClientProviderStatus2["NOT_READY"] = "NOT_READY";
      ClientProviderStatus2["READY"] = "READY";
      ClientProviderStatus2["ERROR"] = "ERROR";
      ClientProviderStatus2["STALE"] = "STALE";
      ClientProviderStatus2["FATAL"] = "FATAL";
      ClientProviderStatus2["RECONCILING"] = "RECONCILING";
      return ClientProviderStatus2;
    })(ClientProviderStatus || {});
    var ServerProviderEvents = /* @__PURE__ */ ((ServerProviderEvents2) => {
      ServerProviderEvents2["Ready"] = "PROVIDER_READY";
      ServerProviderEvents2["Error"] = "PROVIDER_ERROR";
      ServerProviderEvents2["ConfigurationChanged"] = "PROVIDER_CONFIGURATION_CHANGED";
      ServerProviderEvents2["Stale"] = "PROVIDER_STALE";
      return ServerProviderEvents2;
    })(ServerProviderEvents || {});
    var ClientProviderEvents = /* @__PURE__ */ ((ClientProviderEvents2) => {
      ClientProviderEvents2["Ready"] = "PROVIDER_READY";
      ClientProviderEvents2["Error"] = "PROVIDER_ERROR";
      ClientProviderEvents2["ConfigurationChanged"] = "PROVIDER_CONFIGURATION_CHANGED";
      ClientProviderEvents2["ContextChanged"] = "PROVIDER_CONTEXT_CHANGED";
      ClientProviderEvents2["Reconciling"] = "PROVIDER_RECONCILING";
      ClientProviderEvents2["Stale"] = "PROVIDER_STALE";
      return ClientProviderEvents2;
    })(ClientProviderEvents || {});
    var eventStatusMap = {
      [
        "READY"
        /* READY */
      ]: "PROVIDER_READY",
      [
        "ERROR"
        /* ERROR */
      ]: "PROVIDER_ERROR",
      [
        "FATAL"
        /* FATAL */
      ]: "PROVIDER_ERROR",
      [
        "STALE"
        /* STALE */
      ]: "PROVIDER_STALE",
      [
        "RECONCILING"
        /* RECONCILING */
      ]: "PROVIDER_RECONCILING",
      [
        "NOT_READY"
        /* NOT_READY */
      ]: void 0
    };
    var statusMatchesEvent = (event, status) => {
      return !status && event === "PROVIDER_READY" || eventStatusMap[status] === event;
    };
    var DefaultLogger = class {
      error(...args) {
        console.error(...args);
      }
      warn(...args) {
        console.warn(...args);
      }
      info() {
      }
      debug() {
      }
    };
    var LOG_LEVELS = ["error", "warn", "info", "debug"];
    var SafeLogger = class {
      constructor(logger) {
        this.fallbackLogger = new DefaultLogger();
        try {
          for (const level of LOG_LEVELS) {
            if (!logger[level] || typeof logger[level] !== "function") {
              throw new Error(`The provided logger is missing the ${level} method.`);
            }
          }
          this.logger = logger;
        } catch (err) {
          console.error(err);
          console.error("Falling back to the default logger.");
          this.logger = this.fallbackLogger;
        }
      }
      error(...args) {
        this.log("error", ...args);
      }
      warn(...args) {
        this.log("warn", ...args);
      }
      info(...args) {
        this.log("info", ...args);
      }
      debug(...args) {
        this.log("debug", ...args);
      }
      log(level, ...args) {
        try {
          this.logger[level](...args);
        } catch (error) {
          this.fallbackLogger[level](...args);
        }
      }
    };
    var GenericEventEmitter = class {
      constructor(globalLogger) {
        this.globalLogger = globalLogger;
        this._handlers = {
          [
            "PROVIDER_CONFIGURATION_CHANGED"
            /* ConfigurationChanged */
          ]: /* @__PURE__ */ new WeakMap(),
          [
            "PROVIDER_CONTEXT_CHANGED"
            /* ContextChanged */
          ]: /* @__PURE__ */ new WeakMap(),
          [
            "PROVIDER_READY"
            /* Ready */
          ]: /* @__PURE__ */ new WeakMap(),
          [
            "PROVIDER_ERROR"
            /* Error */
          ]: /* @__PURE__ */ new WeakMap(),
          [
            "PROVIDER_STALE"
            /* Stale */
          ]: /* @__PURE__ */ new WeakMap(),
          [
            "PROVIDER_RECONCILING"
            /* Reconciling */
          ]: /* @__PURE__ */ new WeakMap()
        };
      }
      // here we use E, to restrict the events a provider can manually emit (PROVIDER_CONTEXT_CHANGED is emitted by the SDK)
      emit(eventType, context2) {
        this.eventEmitter.emit(eventType, context2);
      }
      addHandler(eventType, handler) {
        const asyncHandler = (details) => __async(this, null, function* () {
          var _a;
          try {
            yield handler(details);
          } catch (err) {
            (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
          }
        });
        const existingAsyncHandlers = this._handlers[eventType].get(handler);
        this._handlers[eventType].set(handler, [...existingAsyncHandlers || [], asyncHandler]);
        this.eventEmitter.on(eventType, asyncHandler);
      }
      removeHandler(eventType, handler) {
        const existingAsyncHandlers = this._handlers[eventType].get(handler);
        if (existingAsyncHandlers) {
          const removedAsyncHandler = existingAsyncHandlers.pop();
          if (removedAsyncHandler) {
            this.eventEmitter.removeListener(eventType, removedAsyncHandler);
          }
        }
      }
      removeAllHandlers(eventType) {
        if (eventType) {
          this.eventEmitter.removeAllListeners(eventType);
        } else {
          this.eventEmitter.removeAllListeners();
        }
      }
      getHandlers(eventType) {
        return this.eventEmitter.listeners(eventType);
      }
      setLogger(logger) {
        this._eventLogger = new SafeLogger(logger);
        return this;
      }
      get _logger() {
        var _a, _b;
        return (_b = this._eventLogger) != null ? _b : (_a = this.globalLogger) == null ? void 0 : _a.call(this);
      }
    };
    var TelemetryAttribute = {
      /**
       * The lookup key of the feature flag.
       *
       * - type: `string`
       * - requirement level: `required`
       * - example: `logo-color`
       */
      KEY: "feature_flag.key",
      /**
       * Describes a class of error the operation ended with.
       *
       * - type: `string`
       * - requirement level: `conditionally required`
       * - condition: `reason` is `error`
       * - example: `flag_not_found`
       */
      ERROR_CODE: "error.type",
      /**
       * A message explaining the nature of an error occurring during flag evaluation.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `Flag not found`
       */
      ERROR_MESSAGE: "error.message",
      /**
       * A semantic identifier for an evaluated flag value.
       *
       * - type: `string`
       * - requirement level: `conditionally required`
       * - condition: variant is defined on the evaluation details
       * - example: `blue`; `on`; `true`
       */
      VARIANT: "feature_flag.result.variant",
      /**
       * The evaluated value of the feature flag.
       *
       * - type: `undefined`
       * - requirement level: `conditionally required`
       * - example: `#ff0000`; `1`; `true`
       */
      VALUE: "feature_flag.result.value",
      /**
       * The unique identifier for the flag evaluation context. For example, the targeting key.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `5157782b-2203-4c80-a857-dbbd5e7761db`
       */
      CONTEXT_ID: "feature_flag.context.id",
      /**
       * The reason code which shows how a feature flag value was determined.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `targeting_match`
       */
      REASON: "feature_flag.result.reason",
      /**
       * Describes a class of error the operation ended with.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `flag_not_found`
       */
      PROVIDER: "feature_flag.provider.name",
      /**
       * The identifier of the flag set to which the feature flag belongs.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `proj-1`; `ab98sgs`; `service1/dev`
       */
      FLAG_SET_ID: "feature_flag.set.id",
      /**
       * The version of the ruleset used during the evaluation. This may be any stable value which uniquely identifies the ruleset.
       *
       * - type: `string`
       * - requirement level: `recommended`
       * - example: `1.0.0`; `2021-01-01`
       */
      VERSION: "feature_flag.version"
    };
    var TelemetryFlagMetadata = {
      /**
       * The context identifier returned in the flag metadata uniquely identifies
       * the subject of the flag evaluation. If not available, the targeting key
       * should be used.
       */
      CONTEXT_ID: "contextId",
      /**
       * 	A logical identifier for the flag set.
       */
      FLAG_SET_ID: "flagSetId",
      /**
       * 	A version string (format unspecified) for the flag or flag set.
       */
      VERSION: "version"
    };
    var FLAG_EVALUATION_EVENT_NAME = "feature_flag.evaluation";
    function createEvaluationEvent(hookContext, evaluationDetails) {
      var _a, _b, _c;
      const attributes = {
        [TelemetryAttribute.KEY]: hookContext.flagKey,
        [TelemetryAttribute.PROVIDER]: hookContext.providerMetadata.name,
        [TelemetryAttribute.REASON]: ((_a = evaluationDetails.reason) != null ? _a : StandardResolutionReasons.UNKNOWN).toLowerCase()
      };
      if (evaluationDetails.variant) {
        attributes[TelemetryAttribute.VARIANT] = evaluationDetails.variant;
      }
      if (evaluationDetails.value !== null) {
        if (typeof evaluationDetails.value !== "object") {
          attributes[TelemetryAttribute.VALUE] = evaluationDetails.value;
        } else {
          try {
            attributes[TelemetryAttribute.VALUE] = JSON.stringify(evaluationDetails.value);
          } catch (e) {
          }
        }
      }
      const contextId = (_b = evaluationDetails.flagMetadata[TelemetryFlagMetadata.CONTEXT_ID]) != null ? _b : hookContext.context.targetingKey;
      if (contextId) {
        attributes[TelemetryAttribute.CONTEXT_ID] = contextId;
      }
      const setId = evaluationDetails.flagMetadata[TelemetryFlagMetadata.FLAG_SET_ID];
      if (setId) {
        attributes[TelemetryAttribute.FLAG_SET_ID] = setId;
      }
      const version = evaluationDetails.flagMetadata[TelemetryFlagMetadata.VERSION];
      if (version) {
        attributes[TelemetryAttribute.VERSION] = version;
      }
      if (evaluationDetails.reason === StandardResolutionReasons.ERROR) {
        attributes[TelemetryAttribute.ERROR_CODE] = ((_c = evaluationDetails.errorCode) != null ? _c : "GENERAL").toLowerCase();
        if (evaluationDetails.errorMessage) {
          attributes[TelemetryAttribute.ERROR_MESSAGE] = evaluationDetails.errorMessage;
        }
      }
      return {
        name: FLAG_EVALUATION_EVENT_NAME,
        attributes
      };
    }
    function isString(value) {
      return typeof value === "string";
    }
    function stringOrUndefined(value) {
      return isString(value) ? value : void 0;
    }
    function isObject(value) {
      return typeof value === "object";
    }
    function objectOrUndefined(value) {
      return isObject(value) ? value : void 0;
    }
    function isDefined(input) {
      return typeof input !== "undefined" && input !== null;
    }
    var ProviderWrapper = class {
      constructor(_provider, _status, _statusEnumType) {
        this._provider = _provider;
        this._status = _status;
        this._pendingContextChanges = 0;
        var _a, _b, _c;
        (_a = _provider.events) == null ? void 0 : _a.addHandler("PROVIDER_READY", () => {
          this._status = _statusEnumType.READY;
        });
        (_b = _provider.events) == null ? void 0 : _b.addHandler("PROVIDER_STALE", () => {
          this._status = _statusEnumType.STALE;
        });
        (_c = _provider.events) == null ? void 0 : _c.addHandler("PROVIDER_ERROR", (details) => {
          if ((details == null ? void 0 : details.errorCode) === "PROVIDER_FATAL") {
            this._status = _statusEnumType.FATAL;
          } else {
            this._status = _statusEnumType.ERROR;
          }
        });
      }
      get provider() {
        return this._provider;
      }
      set provider(provider) {
        this._provider = provider;
      }
      get status() {
        return this._status;
      }
      set status(status) {
        this._status = status;
      }
      get allContextChangesSettled() {
        return this._pendingContextChanges === 0;
      }
      incrementPendingContextChanges() {
        this._pendingContextChanges++;
      }
      decrementPendingContextChanges() {
        this._pendingContextChanges--;
      }
    };
    var OpenFeatureCommonAPI = class {
      constructor(category) {
        this._hooks = [];
        this._context = {};
        this._logger = new DefaultLogger();
        this._clientEventHandlers = /* @__PURE__ */ new Map();
        this._domainScopedContext = /* @__PURE__ */ new Map();
        this._clientEvents = /* @__PURE__ */ new Map();
        this._runsOn = category;
      }
      addHooks(...hooks) {
        this._hooks = [...this._hooks, ...hooks];
        return this;
      }
      getHooks() {
        return this._hooks;
      }
      clearHooks() {
        this._hooks = [];
        return this;
      }
      setLogger(logger) {
        this._logger = new SafeLogger(logger);
        return this;
      }
      /**
       * Get metadata about the default provider.
       * @returns {ProviderMetadata} Provider Metadata
       */
      get providerMetadata() {
        return this.getProviderMetadata();
      }
      /**
       * Get metadata about a registered provider using the client name.
       * An unbound or empty client name will return metadata from the default provider.
       * @param {string} domain An identifier which logically binds clients with providers
       * @returns {ProviderMetadata} Provider Metadata
       */
      getProviderMetadata(domain) {
        return this.getProviderForClient(domain).metadata;
      }
      /**
       * Adds a handler for the given provider event type.
       * The handlers are called in the order they have been added.
       * API (global) events run for all providers.
       * @param {AnyProviderEvent} eventType The provider event type to listen to
       * @param {EventHandler} handler The handler to run on occurrence of the event type
       * @param {EventOptions} options Optional options such as signal for aborting
       */
      addHandler(eventType, handler, options) {
        [.../* @__PURE__ */ new Map([[void 0, this._defaultProvider]]), ...this._domainScopedProviders].forEach((keyProviderTuple) => {
          var _a;
          const domain = keyProviderTuple[0];
          const provider = keyProviderTuple[1].provider;
          const status = keyProviderTuple[1].status;
          const shouldRunNow = statusMatchesEvent(eventType, status);
          if (shouldRunNow) {
            try {
              handler({ domain, providerName: provider.metadata.name });
            } catch (err) {
              (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
            }
          }
        });
        this._apiEmitter.addHandler(eventType, handler);
        if ((options == null ? void 0 : options.signal) && typeof options.signal.addEventListener === "function") {
          options.signal.addEventListener("abort", () => {
            this.removeHandler(eventType, handler);
          });
        }
      }
      /**
       * Removes a handler for the given provider event type.
       * @param {AnyProviderEvent} eventType The provider event type to remove the listener for
       * @param {EventHandler} handler The handler to remove for the provider event type
       */
      removeHandler(eventType, handler) {
        this._apiEmitter.removeHandler(eventType, handler);
      }
      /**
       * Removes all event handlers.
       */
      clearHandlers() {
        this._apiEmitter.removeAllHandlers();
      }
      /**
       * Gets the current handlers for the given provider event type.
       * @param {AnyProviderEvent} eventType The provider event type to get the current handlers for
       * @returns {EventHandler[]} The handlers currently attached to the given provider event type
       */
      getHandlers(eventType) {
        return this._apiEmitter.getHandlers(eventType);
      }
      setAwaitableProvider(domainOrProvider, providerOrUndefined) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const domain = stringOrUndefined(domainOrProvider);
        const provider = (_a = objectOrUndefined(domainOrProvider)) != null ? _a : objectOrUndefined(providerOrUndefined);
        if (!provider) {
          this._logger.debug("No provider defined, ignoring setProvider call");
          return;
        }
        const oldProvider = this.getProviderForClient(domain);
        const providerName = provider.metadata.name;
        if (oldProvider === provider) {
          this._logger.debug("Provider is already set, ignoring setProvider call");
          return;
        }
        if (!provider.runsOn) {
          this._logger.debug(`Provider '${provider.metadata.name}' has not defined its intended use.`);
        } else if (provider.runsOn !== this._runsOn) {
          throw new GeneralError(`Provider '${provider.metadata.name}' is intended for use on the ${provider.runsOn}.`);
        }
        const emitters = this.getAssociatedEventEmitters(domain);
        let initializationPromise = void 0;
        const wrappedProvider = new ProviderWrapper(
          provider,
          this._statusEnumType.NOT_READY,
          this._statusEnumType
        );
        if (typeof provider.initialize === "function" && !this.allProviders.includes(provider)) {
          initializationPromise = (_e = (_d = (_c = provider.initialize) == null ? void 0 : _c.call(provider, domain ? (_b = this._domainScopedContext.get(domain)) != null ? _b : this._context : this._context)) == null ? void 0 : _d.then(() => {
            var _a2;
            wrappedProvider.status = this._statusEnumType.READY;
            this.getAssociatedEventEmitters(domain).forEach((emitter) => {
              emitter == null ? void 0 : emitter.emit("PROVIDER_READY", { clientName: domain, domain, providerName });
            });
            (_a2 = this._apiEmitter) == null ? void 0 : _a2.emit("PROVIDER_READY", { clientName: domain, domain, providerName });
          })) == null ? void 0 : _e.catch((error) => {
            var _a2;
            if ((error == null ? void 0 : error.code) === "PROVIDER_FATAL") {
              wrappedProvider.status = this._statusEnumType.FATAL;
            } else {
              wrappedProvider.status = this._statusEnumType.ERROR;
            }
            this.getAssociatedEventEmitters(domain).forEach((emitter) => {
              emitter == null ? void 0 : emitter.emit("PROVIDER_ERROR", {
                clientName: domain,
                domain,
                providerName,
                message: error == null ? void 0 : error.message
              });
            });
            (_a2 = this._apiEmitter) == null ? void 0 : _a2.emit("PROVIDER_ERROR", {
              clientName: domain,
              domain,
              providerName,
              message: error == null ? void 0 : error.message
            });
            throw error;
          });
        } else {
          wrappedProvider.status = this._statusEnumType.READY;
          emitters.forEach((emitter) => {
            emitter == null ? void 0 : emitter.emit("PROVIDER_READY", { clientName: domain, domain, providerName });
          });
          (_f = this._apiEmitter) == null ? void 0 : _f.emit("PROVIDER_READY", { clientName: domain, domain, providerName });
        }
        if (domain) {
          this._domainScopedProviders.set(domain, wrappedProvider);
        } else {
          this._defaultProvider = wrappedProvider;
        }
        this.transferListeners(oldProvider, provider, domain, emitters);
        if (!this.allProviders.includes(oldProvider)) {
          (_h = (_g = oldProvider == null ? void 0 : oldProvider.onClose) == null ? void 0 : _g.call(oldProvider)) == null ? void 0 : _h.catch((err) => {
            this._logger.error(`error closing provider: ${err == null ? void 0 : err.message}, ${err == null ? void 0 : err.stack}`);
          });
        }
        return initializationPromise;
      }
      getProviderForClient(domain) {
        var _a, _b;
        if (!domain) {
          return this._defaultProvider.provider;
        }
        return (_b = (_a = this._domainScopedProviders.get(domain)) == null ? void 0 : _a.provider) != null ? _b : this._defaultProvider.provider;
      }
      buildAndCacheEventEmitterForClient(domain) {
        const emitter = this._clientEvents.get(domain);
        if (emitter) {
          return emitter;
        }
        const newEmitter = this._createEventEmitter();
        this._clientEvents.set(domain, newEmitter);
        const clientProvider = this.getProviderForClient(domain);
        Object.values(ClientProviderEvents).forEach(
          (eventType) => {
            var _a;
            return (_a = clientProvider.events) == null ? void 0 : _a.addHandler(eventType, (details) => __async(this, null, function* () {
              newEmitter.emit(eventType, __spreadProps(__spreadValues({}, details), {
                clientName: domain,
                domain,
                providerName: clientProvider.metadata.name
              }));
            }));
          }
        );
        return newEmitter;
      }
      getUnboundEmitters() {
        const domainScopedProviders = [...this._domainScopedProviders.keys()];
        const eventEmitterNames = [...this._clientEvents.keys()].filter(isDefined);
        const unboundEmitterNames = eventEmitterNames.filter((name) => !domainScopedProviders.includes(name));
        return [
          // all unbound, named emitters
          ...unboundEmitterNames.map((name) => this._clientEvents.get(name)),
          // the default emitter
          this._clientEvents.get(void 0)
        ].filter(isDefined);
      }
      getAssociatedEventEmitters(domain) {
        return domain ? [this.buildAndCacheEventEmitterForClient(domain)] : this.getUnboundEmitters();
      }
      transferListeners(oldProvider, newProvider, domain, emitters) {
        var _a;
        (_a = this._clientEventHandlers.get(domain)) == null ? void 0 : _a.forEach((eventHandler) => {
          var _a2;
          return (_a2 = oldProvider.events) == null ? void 0 : _a2.removeHandler(...eventHandler);
        });
        const newClientHandlers = Object.values(ClientProviderEvents).map((eventType) => {
          const handler = (details) => __async(this, null, function* () {
            emitters.forEach((emitter) => {
              emitter == null ? void 0 : emitter.emit(eventType, __spreadProps(__spreadValues({}, details), { clientName: domain, domain, providerName: newProvider.metadata.name }));
            });
            this._apiEmitter.emit(eventType, __spreadProps(__spreadValues({}, details), {
              clientName: domain,
              domain,
              providerName: newProvider.metadata.name
            }));
          });
          return [eventType, handler];
        });
        this._clientEventHandlers.set(domain, newClientHandlers);
        newClientHandlers.forEach((eventHandler) => {
          var _a2;
          return (_a2 = newProvider.events) == null ? void 0 : _a2.addHandler(...eventHandler);
        });
      }
      close() {
        return __async(this, null, function* () {
          var _a, _b;
          try {
            yield (_b = (_a = this == null ? void 0 : this._defaultProvider.provider) == null ? void 0 : _a.onClose) == null ? void 0 : _b.call(_a);
          } catch (err) {
            this.handleShutdownError(this._defaultProvider.provider, err);
          }
          const wrappers = Array.from(this._domainScopedProviders);
          yield Promise.all(
            wrappers.map((_0) => __async(this, [_0], function* ([, wrapper]) {
              var _a2, _b2;
              try {
                yield (_b2 = wrapper == null ? void 0 : (_a2 = wrapper.provider).onClose) == null ? void 0 : _b2.call(_a2);
              } catch (err) {
                this.handleShutdownError(wrapper == null ? void 0 : wrapper.provider, err);
              }
            }))
          );
        });
      }
      clearProvidersAndSetDefault(defaultProvider) {
        return __async(this, null, function* () {
          try {
            yield this.close();
          } catch (err) {
            this._logger.error("Unable to cleanly close providers. Resetting to the default configuration.");
          } finally {
            this._domainScopedProviders.clear();
            this._defaultProvider = new ProviderWrapper(
              defaultProvider,
              this._statusEnumType.NOT_READY,
              this._statusEnumType
            );
          }
        });
      }
      get allProviders() {
        return [
          ...[...this._domainScopedProviders.values()].map((wrappers) => wrappers.provider),
          this._defaultProvider.provider
        ];
      }
      handleShutdownError(provider, err) {
        this._logger.error(`Error during shutdown of provider ${provider.metadata.name}: ${err}`);
        this._logger.error(err == null ? void 0 : err.stack);
      }
    };
  }
});

// ../../node_modules/@datadog/openfeature-node-server/node_modules/@openfeature/server-sdk/dist/cjs/index.js
var require_cjs3 = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/node_modules/@openfeature/server-sdk/dist/cjs/index.js"(exports2, module2) {
    "use strict";
    var __defProp2 = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames2 = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __hasOwnProp2 = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp2.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __reExport = (target, mod2, secondTarget) => (__copyProps2(target, mod2, "default"), secondTarget && __copyProps2(secondTarget, mod2, "default"));
    var __toCommonJS2 = (mod2) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod2);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var index_exports = {};
    __export2(index_exports, {
      AsyncLocalStorageTransactionContextPropagator: () => AsyncLocalStorageTransactionContextPropagator,
      InMemoryProvider: () => InMemoryProvider,
      NOOP_PROVIDER: () => NOOP_PROVIDER,
      NOOP_TRANSACTION_CONTEXT_PROPAGATOR: () => NOOP_TRANSACTION_CONTEXT_PROPAGATOR,
      OpenFeature: () => OpenFeature,
      OpenFeatureAPI: () => OpenFeatureAPI,
      OpenFeatureEventEmitter: () => OpenFeatureEventEmitter,
      ProviderEvents: () => import_core6.ServerProviderEvents,
      ProviderStatus: () => import_core.ServerProviderStatus
    });
    module2.exports = __toCommonJS2(index_exports);
    var import_core = require_cjs2();
    var REASON_NO_OP = "No-op";
    var NoopFeatureProvider = class {
      constructor() {
        this.metadata = {
          name: "No-op Provider"
        };
      }
      resolveBooleanEvaluation(_2, defaultValue) {
        return this.noOp(defaultValue);
      }
      resolveStringEvaluation(_2, defaultValue) {
        return this.noOp(defaultValue);
      }
      resolveNumberEvaluation(_2, defaultValue) {
        return this.noOp(defaultValue);
      }
      resolveObjectEvaluation(_2, defaultValue) {
        return this.noOp(defaultValue);
      }
      noOp(defaultValue) {
        return Promise.resolve({
          value: defaultValue,
          reason: REASON_NO_OP
        });
      }
    };
    var NOOP_PROVIDER = new NoopFeatureProvider();
    var import_core3 = require_cjs2();
    var import_core2 = require_cjs2();
    var VariantFoundError = class _VariantFoundError extends import_core2.OpenFeatureError {
      constructor(message) {
        super(message);
        Object.setPrototypeOf(this, _VariantFoundError.prototype);
        this.name = "VariantFoundError";
        this.code = import_core2.ErrorCode.GENERAL;
      }
    };
    var InMemoryProvider = class {
      constructor(flagConfiguration = {}) {
        this.events = new OpenFeatureEventEmitter();
        this.runsOn = "server";
        this.metadata = {
          name: "in-memory"
        };
        this._flagConfiguration = __spreadValues({}, flagConfiguration);
      }
      /**
       * Overwrites the configured flags.
       * @param { FlagConfiguration } flagConfiguration new flag configuration
       */
      putConfiguration(flagConfiguration) {
        const flagsChanged = Object.entries(flagConfiguration).filter(([key, value]) => this._flagConfiguration[key] !== value).map(([key]) => key);
        this._flagConfiguration = __spreadValues({}, flagConfiguration);
        this.events.emit(import_core6.ServerProviderEvents.ConfigurationChanged, { flagsChanged });
      }
      resolveBooleanEvaluation(flagKey, defaultValue, context2, logger) {
        return this.resolveFlagWithReason(flagKey, defaultValue, context2, logger);
      }
      resolveNumberEvaluation(flagKey, defaultValue, context2, logger) {
        return this.resolveFlagWithReason(flagKey, defaultValue, context2, logger);
      }
      resolveStringEvaluation(flagKey, defaultValue, context2, logger) {
        return __async(this, null, function* () {
          return this.resolveFlagWithReason(flagKey, defaultValue, context2, logger);
        });
      }
      resolveObjectEvaluation(flagKey, defaultValue, context2, logger) {
        return __async(this, null, function* () {
          return this.resolveFlagWithReason(flagKey, defaultValue, context2, logger);
        });
      }
      resolveFlagWithReason(flagKey, defaultValue, ctx, logger) {
        return __async(this, null, function* () {
          try {
            const resolutionResult = this.lookupFlagValue(flagKey, defaultValue, ctx, logger);
            if (typeof (resolutionResult == null ? void 0 : resolutionResult.value) != typeof defaultValue) {
              throw new import_core3.TypeMismatchError();
            }
            return resolutionResult;
          } catch (error) {
            if (!(error instanceof import_core3.OpenFeatureError)) {
              throw new import_core3.GeneralError((error == null ? void 0 : error.message) || "unknown error");
            }
            throw error;
          }
        });
      }
      lookupFlagValue(flagKey, defaultValue, ctx, logger) {
        var _a;
        if (!(flagKey in this._flagConfiguration)) {
          const message = `no flag found with key ${flagKey}`;
          logger == null ? void 0 : logger.debug(message);
          throw new import_core3.FlagNotFoundError(message);
        }
        const flagSpec = this._flagConfiguration[flagKey];
        if (flagSpec.disabled) {
          return { value: defaultValue, reason: import_core3.StandardResolutionReasons.DISABLED };
        }
        const isContextEval = ctx && (flagSpec == null ? void 0 : flagSpec.contextEvaluator);
        const variant = isContextEval ? (_a = flagSpec.contextEvaluator) == null ? void 0 : _a.call(flagSpec, ctx) : flagSpec.defaultVariant;
        const value = variant && (flagSpec == null ? void 0 : flagSpec.variants[variant]);
        if (value === void 0) {
          const message = `no value associated with variant ${variant}`;
          logger == null ? void 0 : logger.error(message);
          throw new VariantFoundError(message);
        }
        return __spreadProps(__spreadValues({
          value
        }, variant && { variant }), {
          reason: isContextEval ? import_core3.StandardResolutionReasons.TARGETING_MATCH : import_core3.StandardResolutionReasons.STATIC
        });
      }
    };
    var import_core7 = require_cjs2();
    var import_core4 = require_cjs2();
    var OpenFeatureClient = class {
      constructor(providerAccessor, providerStatusAccessor, emitterAccessor, apiContextAccessor, apiHooksAccessor, transactionContextAccessor, globalLogger, options, context2 = {}) {
        this.providerAccessor = providerAccessor;
        this.providerStatusAccessor = providerStatusAccessor;
        this.emitterAccessor = emitterAccessor;
        this.apiContextAccessor = apiContextAccessor;
        this.apiHooksAccessor = apiHooksAccessor;
        this.transactionContextAccessor = transactionContextAccessor;
        this.globalLogger = globalLogger;
        this.options = options;
        this._hooks = [];
        this._context = context2;
      }
      get metadata() {
        var _a, _b;
        return {
          // Use domain if name is not provided
          name: (_a = this.options.domain) != null ? _a : this.options.name,
          domain: (_b = this.options.domain) != null ? _b : this.options.name,
          version: this.options.version,
          providerMetadata: this.providerAccessor().metadata
        };
      }
      get providerStatus() {
        return this.providerStatusAccessor();
      }
      addHandler(eventType, handler, options) {
        var _a;
        this.emitterAccessor().addHandler(eventType, handler);
        const shouldRunNow = (0, import_core4.statusMatchesEvent)(eventType, this._providerStatus);
        if (shouldRunNow) {
          try {
            handler({
              clientName: this.metadata.name,
              domain: this.metadata.domain,
              providerName: this._provider.metadata.name
            });
          } catch (err) {
            (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
          }
        }
        if ((options == null ? void 0 : options.signal) && typeof options.signal.addEventListener === "function") {
          options.signal.addEventListener("abort", () => {
            this.removeHandler(eventType, handler);
          });
        }
      }
      removeHandler(eventType, handler) {
        this.emitterAccessor().removeHandler(eventType, handler);
      }
      getHandlers(eventType) {
        return this.emitterAccessor().getHandlers(eventType);
      }
      setLogger(logger) {
        this._clientLogger = new import_core4.SafeLogger(logger);
        return this;
      }
      setContext(context2) {
        this._context = context2;
        return this;
      }
      getContext() {
        return this._context;
      }
      addHooks(...hooks) {
        this._hooks = [...this._hooks, ...hooks];
        return this;
      }
      getHooks() {
        return this._hooks;
      }
      clearHooks() {
        this._hooks = [];
        return this;
      }
      getBooleanValue(flagKey, defaultValue, context2, options) {
        return __async(this, null, function* () {
          return (yield this.getBooleanDetails(flagKey, defaultValue, context2, options)).value;
        });
      }
      getBooleanDetails(flagKey, defaultValue, context2, options) {
        return this.evaluate(
          flagKey,
          this._provider.resolveBooleanEvaluation,
          defaultValue,
          "boolean",
          context2,
          options
        );
      }
      getStringValue(flagKey, defaultValue, context2, options) {
        return __async(this, null, function* () {
          return (yield this.getStringDetails(flagKey, defaultValue, context2, options)).value;
        });
      }
      getStringDetails(flagKey, defaultValue, context2, options) {
        return this.evaluate(
          flagKey,
          // this isolates providers from our restricted string generic argument.
          this._provider.resolveStringEvaluation,
          defaultValue,
          "string",
          context2,
          options
        );
      }
      getNumberValue(flagKey, defaultValue, context2, options) {
        return __async(this, null, function* () {
          return (yield this.getNumberDetails(flagKey, defaultValue, context2, options)).value;
        });
      }
      getNumberDetails(flagKey, defaultValue, context2, options) {
        return this.evaluate(
          flagKey,
          // this isolates providers from our restricted number generic argument.
          this._provider.resolveNumberEvaluation,
          defaultValue,
          "number",
          context2,
          options
        );
      }
      getObjectValue(flagKey, defaultValue, context2, options) {
        return __async(this, null, function* () {
          return (yield this.getObjectDetails(flagKey, defaultValue, context2, options)).value;
        });
      }
      getObjectDetails(flagKey, defaultValue, context2, options) {
        return this.evaluate(flagKey, this._provider.resolveObjectEvaluation, defaultValue, "object", context2, options);
      }
      track(occurrenceKey, context2 = {}, occurrenceDetails = {}) {
        var _a, _b;
        try {
          this.shortCircuitIfNotReady();
          if (typeof this._provider.track === "function") {
            const frozenContext = Object.freeze(this.mergeContexts(context2));
            return (_b = (_a = this._provider).track) == null ? void 0 : _b.call(_a, occurrenceKey, frozenContext, occurrenceDetails);
          } else {
            this._logger.debug("Provider does not support the track function; will no-op.");
          }
        } catch (err) {
          this._logger.debug("Error recording tracking event.", err);
        }
      }
      evaluate(_0, _1, _2, _3) {
        return __async(this, arguments, function* (flagKey, resolver, defaultValue, flagType, invocationContext = {}, options = {}) {
          var _a;
          const allHooks = [
            ...this.apiHooksAccessor(),
            ...this.getHooks(),
            ...options.hooks || [],
            ...this._provider.hooks || []
          ];
          const allHooksReversed = [...allHooks].reverse();
          const mergedContext = this.mergeContexts(invocationContext);
          const hookContext = {
            flagKey,
            defaultValue,
            flagValueType: flagType,
            clientMetadata: this.metadata,
            providerMetadata: this._provider.metadata,
            context: mergedContext,
            logger: this._logger
          };
          let evaluationDetails;
          try {
            const frozenContext = yield this.beforeHooks(allHooks, hookContext, options);
            this.shortCircuitIfNotReady();
            const resolution = yield resolver.call(this._provider, flagKey, defaultValue, frozenContext, this._logger);
            const resolutionDetails = __spreadProps(__spreadValues({}, resolution), {
              flagMetadata: Object.freeze((_a = resolution.flagMetadata) != null ? _a : {}),
              flagKey
            });
            if (resolutionDetails.errorCode) {
              const err = (0, import_core4.instantiateErrorByErrorCode)(resolutionDetails.errorCode, resolutionDetails.errorMessage);
              yield this.errorHooks(allHooksReversed, hookContext, err, options);
              evaluationDetails = this.getErrorEvaluationDetails(flagKey, defaultValue, err, resolutionDetails.flagMetadata);
            } else {
              yield this.afterHooks(allHooksReversed, hookContext, resolutionDetails, options);
              evaluationDetails = resolutionDetails;
            }
          } catch (err) {
            yield this.errorHooks(allHooksReversed, hookContext, err, options);
            evaluationDetails = this.getErrorEvaluationDetails(flagKey, defaultValue, err);
          }
          yield this.finallyHooks(allHooksReversed, hookContext, evaluationDetails, options);
          return evaluationDetails;
        });
      }
      beforeHooks(hooks, hookContext, options) {
        return __async(this, null, function* () {
          var _a;
          for (const hook of hooks) {
            Object.freeze(hookContext);
            Object.assign(hookContext.context, __spreadValues(__spreadValues({}, hookContext.context), yield (_a = hook == null ? void 0 : hook.before) == null ? void 0 : _a.call(hook, hookContext, Object.freeze(options.hookHints))));
          }
          return Object.freeze(hookContext.context);
        });
      }
      afterHooks(hooks, hookContext, evaluationDetails, options) {
        return __async(this, null, function* () {
          var _a;
          for (const hook of hooks) {
            yield (_a = hook == null ? void 0 : hook.after) == null ? void 0 : _a.call(hook, hookContext, evaluationDetails, options.hookHints);
          }
        });
      }
      errorHooks(hooks, hookContext, err, options) {
        return __async(this, null, function* () {
          var _a;
          for (const hook of hooks) {
            try {
              yield (_a = hook == null ? void 0 : hook.error) == null ? void 0 : _a.call(hook, hookContext, err, options.hookHints);
            } catch (err2) {
              this._logger.error(`Unhandled error during 'error' hook: ${err2}`);
              if (err2 instanceof Error) {
                this._logger.error(err2.stack);
              }
              this._logger.error(err2 == null ? void 0 : err2.stack);
            }
          }
        });
      }
      finallyHooks(hooks, hookContext, evaluationDetails, options) {
        return __async(this, null, function* () {
          var _a;
          for (const hook of hooks) {
            try {
              yield (_a = hook == null ? void 0 : hook.finally) == null ? void 0 : _a.call(hook, hookContext, evaluationDetails, options.hookHints);
            } catch (err) {
              this._logger.error(`Unhandled error during 'finally' hook: ${err}`);
              if (err instanceof Error) {
                this._logger.error(err.stack);
              }
              this._logger.error(err == null ? void 0 : err.stack);
            }
          }
        });
      }
      get _provider() {
        return this.providerAccessor();
      }
      get _providerStatus() {
        return this.providerStatusAccessor();
      }
      get _logger() {
        return this._clientLogger || this.globalLogger();
      }
      mergeContexts(invocationContext) {
        return __spreadValues(__spreadValues(__spreadValues(__spreadValues({}, this.apiContextAccessor()), this.transactionContextAccessor()), this._context), invocationContext);
      }
      shortCircuitIfNotReady() {
        if (this.providerStatus === import_core.ServerProviderStatus.NOT_READY) {
          throw new import_core4.ProviderNotReadyError("provider has not yet initialized");
        } else if (this.providerStatus === import_core.ServerProviderStatus.FATAL) {
          throw new import_core4.ProviderFatalError("provider is in an irrecoverable error state");
        }
      }
      getErrorEvaluationDetails(flagKey, defaultValue, err, flagMetadata = {}) {
        const errorMessage = err == null ? void 0 : err.message;
        const errorCode = (err == null ? void 0 : err.code) || import_core4.ErrorCode.GENERAL;
        return {
          errorCode,
          errorMessage,
          value: defaultValue,
          reason: import_core4.StandardResolutionReasons.ERROR,
          flagMetadata: Object.freeze(flagMetadata),
          flagKey
        };
      }
    };
    var import_core5 = require_cjs2();
    var import_node_events = __require("node:events");
    var OpenFeatureEventEmitter = class extends import_core5.GenericEventEmitter {
      constructor() {
        super();
        this.eventEmitter = new import_node_events.EventEmitter({ captureRejections: true });
        this.eventEmitter.on("error", (err) => {
          var _a;
          (_a = this._logger) == null ? void 0 : _a.error("Error running event handler:", err);
        });
      }
    };
    var import_core6 = require_cjs2();
    var NoopTransactionContextPropagator = class {
      getTransactionContext() {
        return {};
      }
      setTransactionContext(_2, callback, ...args) {
        callback(...args);
      }
    };
    var NOOP_TRANSACTION_CONTEXT_PROPAGATOR = new NoopTransactionContextPropagator();
    var import_async_hooks = __require("async_hooks");
    var AsyncLocalStorageTransactionContextPropagator = class {
      constructor() {
        this.asyncLocalStorage = new import_async_hooks.AsyncLocalStorage();
      }
      getTransactionContext() {
        var _a;
        return (_a = this.asyncLocalStorage.getStore()) != null ? _a : {};
      }
      setTransactionContext(transactionContext, callback, ...args) {
        this.asyncLocalStorage.run(transactionContext, callback, ...args);
      }
    };
    var GLOBAL_OPENFEATURE_API_KEY = Symbol.for("@openfeature/js-sdk/api");
    var _globalThis2 = globalThis;
    var OpenFeatureAPI = class _OpenFeatureAPI extends import_core7.OpenFeatureCommonAPI {
      constructor() {
        super("server");
        this._statusEnumType = import_core.ServerProviderStatus;
        this._apiEmitter = new OpenFeatureEventEmitter();
        this._defaultProvider = new import_core7.ProviderWrapper(
          NOOP_PROVIDER,
          import_core.ServerProviderStatus.NOT_READY,
          this._statusEnumType
        );
        this._domainScopedProviders = /* @__PURE__ */ new Map();
        this._createEventEmitter = () => new OpenFeatureEventEmitter();
        this._transactionContextPropagator = NOOP_TRANSACTION_CONTEXT_PROPAGATOR;
      }
      /**
       * Gets a singleton instance of the OpenFeature API.
       * @ignore
       * @returns {OpenFeatureAPI} OpenFeature API
       */
      static getInstance() {
        const globalApi = _globalThis2[GLOBAL_OPENFEATURE_API_KEY];
        if (globalApi) {
          return globalApi;
        }
        const instance = new _OpenFeatureAPI();
        _globalThis2[GLOBAL_OPENFEATURE_API_KEY] = instance;
        return instance;
      }
      getProviderStatus(domain) {
        var _a, _b;
        if (!domain) {
          return this._defaultProvider.status;
        }
        return (_b = (_a = this._domainScopedProviders.get(domain)) == null ? void 0 : _a.status) != null ? _b : this._defaultProvider.status;
      }
      setProviderAndWait(domainOrProvider, providerOrUndefined) {
        return __async(this, null, function* () {
          const domain = (0, import_core7.stringOrUndefined)(domainOrProvider);
          const provider = domain ? (0, import_core7.objectOrUndefined)(providerOrUndefined) : (0, import_core7.objectOrUndefined)(domainOrProvider);
          yield this.setAwaitableProvider(domain, provider);
        });
      }
      setProvider(clientOrProvider, providerOrUndefined) {
        const domain = (0, import_core7.stringOrUndefined)(clientOrProvider);
        const provider = domain ? (0, import_core7.objectOrUndefined)(providerOrUndefined) : (0, import_core7.objectOrUndefined)(clientOrProvider);
        const maybePromise = this.setAwaitableProvider(domain, provider);
        Promise.resolve(maybePromise).catch((err) => {
          this._logger.error("Error during provider initialization:", err);
        });
        return this;
      }
      getProvider(domain) {
        return this.getProviderForClient(domain);
      }
      setContext(context2) {
        this._context = context2;
        return this;
      }
      getContext() {
        return this._context;
      }
      getClient(domainOrContext, versionOrContext, contextOrUndefined) {
        var _a, _b;
        const domain = (0, import_core7.stringOrUndefined)(domainOrContext);
        const version = (0, import_core7.stringOrUndefined)(versionOrContext);
        const context2 = (_b = (_a = (0, import_core7.objectOrUndefined)(domainOrContext)) != null ? _a : (0, import_core7.objectOrUndefined)(versionOrContext)) != null ? _b : (0, import_core7.objectOrUndefined)(contextOrUndefined);
        return new OpenFeatureClient(
          () => this.getProviderForClient(domain),
          () => this.getProviderStatus(domain),
          () => this.buildAndCacheEventEmitterForClient(domain),
          () => this.getContext(),
          () => this.getHooks(),
          () => this.getTransactionContext(),
          () => this._logger,
          { domain, version },
          context2
        );
      }
      /**
       * Clears all registered providers and resets the default provider.
       * @returns {Promise<void>}
       */
      clearProviders() {
        return super.clearProvidersAndSetDefault(NOOP_PROVIDER);
      }
      setTransactionContextPropagator(transactionContextPropagator) {
        const baseMessage = "Invalid TransactionContextPropagator, will not be set: ";
        if (typeof (transactionContextPropagator == null ? void 0 : transactionContextPropagator.getTransactionContext) !== "function") {
          this._logger.error(`${baseMessage}: getTransactionContext is not a function.`);
        } else if (typeof (transactionContextPropagator == null ? void 0 : transactionContextPropagator.setTransactionContext) !== "function") {
          this._logger.error(`${baseMessage}: setTransactionContext is not a function.`);
        } else {
          this._transactionContextPropagator = transactionContextPropagator;
        }
        return this;
      }
      setTransactionContext(transactionContext, callback, ...args) {
        this._transactionContextPropagator.setTransactionContext(transactionContext, callback, ...args);
      }
      getTransactionContext() {
        try {
          return this._transactionContextPropagator.getTransactionContext();
        } catch (err) {
          const error = err;
          this._logger.error(`Error getting transaction context: ${error == null ? void 0 : error.message}, returning empty context.`);
          this._logger.error(error == null ? void 0 : error.stack);
          return {};
        }
      }
    };
    var OpenFeature = OpenFeatureAPI.getInstance();
    __reExport(index_exports, require_cjs2(), module2.exports);
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/rules/rules.js
var require_rules = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/rules/rules.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.OperatorType = void 0;
    exports2.matchesRule = matchesRule;
    var OperatorType;
    (function(OperatorType2) {
      OperatorType2["MATCHES"] = "MATCHES";
      OperatorType2["NOT_MATCHES"] = "NOT_MATCHES";
      OperatorType2["GTE"] = "GTE";
      OperatorType2["GT"] = "GT";
      OperatorType2["LTE"] = "LTE";
      OperatorType2["LT"] = "LT";
      OperatorType2["ONE_OF"] = "ONE_OF";
      OperatorType2["NOT_ONE_OF"] = "NOT_ONE_OF";
      OperatorType2["IS_NULL"] = "IS_NULL";
    })(OperatorType || (exports2.OperatorType = OperatorType = {}));
    function matchesRule(rule, subjectAttributes) {
      const conditionEvaluations = evaluateRuleConditions(subjectAttributes, rule.conditions);
      return !conditionEvaluations.includes(false);
    }
    function evaluateRuleConditions(subjectAttributes, conditions) {
      return conditions.map((condition) => evaluateCondition(subjectAttributes, condition));
    }
    function evaluateCondition(subjectAttributes, condition) {
      const value = subjectAttributes[condition.attribute];
      if (condition.operator === OperatorType.IS_NULL) {
        if (condition.value) {
          return value === null || value === void 0;
        }
        return value !== null && value !== void 0;
      }
      if (value !== null && value !== void 0) {
        switch (condition.operator) {
          case OperatorType.GTE:
          case OperatorType.GT:
          case OperatorType.LTE:
          case OperatorType.LT: {
            const comparator = (a, b) => condition.operator === OperatorType.GTE ? a >= b : condition.operator === OperatorType.GT ? a > b : condition.operator === OperatorType.LTE ? a <= b : a < b;
            return compareNumber(value, condition.value, comparator);
          }
          case OperatorType.MATCHES:
            return new RegExp(condition.value).test(String(value));
          // dd-iac-scan ignore-line
          case OperatorType.NOT_MATCHES:
            return !new RegExp(condition.value).test(String(value));
          // dd-iac-scan ignore-line
          case OperatorType.ONE_OF:
            return isOneOf(value.toString(), condition.value);
          case OperatorType.NOT_ONE_OF:
            return isNotOneOf(value.toString(), condition.value);
        }
      }
      return false;
    }
    function isOneOf(attributeValue, conditionValues) {
      return conditionValues.includes(attributeValue);
    }
    function isNotOneOf(attributeValue, conditionValues) {
      return !isOneOf(attributeValue, conditionValues);
    }
    function compareNumber(attributeValue, conditionValue, compareFn) {
      return compareFn(Number(attributeValue), Number(conditionValue));
    }
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/shards/sharders.js
var require_sharders = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/shards/sharders.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeterministicSharder = exports2.MD5Sharder = exports2.Sharder = void 0;
    var flagging_core_1 = require_cjs();
    var Sharder = class {
    };
    exports2.Sharder = Sharder;
    var MD5Sharder = class extends Sharder {
      getShard(input, totalShards) {
        const hashOutput = (0, flagging_core_1.getMD5Hash)(input);
        const intFromHash = parseInt(hashOutput.slice(0, 8), 16);
        return intFromHash % totalShards;
      }
    };
    exports2.MD5Sharder = MD5Sharder;
    var DeterministicSharder = class extends Sharder {
      constructor(lookup) {
        super();
        this.lookup = lookup;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      getShard(input, _totalShards) {
        var _a;
        return (_a = this.lookup[input]) !== null && _a !== void 0 ? _a : 0;
      }
    };
    exports2.DeterministicSharder = DeterministicSharder;
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/shards/matchesShard.js
var require_matchesShard = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/shards/matchesShard.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchesShard = matchesShard;
    var sharders_1 = require_sharders();
    function matchesShard(shard, subjectKey, customSharder) {
      const sharder = customSharder !== null && customSharder !== void 0 ? customSharder : new sharders_1.MD5Sharder();
      const assignedShard = sharder.getShard(hashKey(shard.salt, subjectKey), shard.totalShards);
      return shard.ranges.some((range) => isInShardRange(assignedShard, range));
    }
    function isInShardRange(shard, range) {
      return range.start <= shard && shard < range.end;
    }
    function hashKey(salt, subjectKey) {
      return `${salt}-${subjectKey}`;
    }
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/configuration/ufc-v1.js
var require_ufc_v1 = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/configuration/ufc-v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.variantTypeToFlagValueType = variantTypeToFlagValueType;
    function variantTypeToFlagValueType(variantType) {
      if (variantType === "BOOLEAN") {
        return "boolean";
      }
      if (variantType === "STRING") {
        return "string";
      }
      if (variantType === "INTEGER" || variantType === "NUMERIC") {
        return "number";
      }
      if (variantType === "JSON") {
        return "object";
      }
      throw new Error(`Cannot convert variant type to flag value type: ${variantType}`);
    }
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/configuration/evaluateForSubject.js
var require_evaluateForSubject = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/configuration/evaluateForSubject.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluateForSubject = evaluateForSubject;
    exports2.containsMatchingRule = containsMatchingRule;
    var server_sdk_1 = require_cjs3();
    var rules_1 = require_rules();
    var matchesShard_1 = require_matchesShard();
    var ufc_v1_1 = require_ufc_v1();
    function evaluateForSubject(flag, type, subjectKey, subjectAttributes, defaultValue, logger) {
      if (!(flag === null || flag === void 0 ? void 0 : flag.enabled)) {
        logger.debug(`returning default assignment because flag is disabled`, {
          flagKey: flag ? flag.key : "undefined",
          subjectKey
        });
        return {
          value: defaultValue,
          reason: server_sdk_1.StandardResolutionReasons.DISABLED
        };
      }
      const isValid = validateTypeMatch(type, flag.variationType);
      if (!isValid) {
        logger.debug(`variant value type mismatch, returning default value`, {
          flagKey: flag.key,
          subjectKey,
          expectedType: type,
          variantType: flag.variationType
        });
        return {
          value: defaultValue,
          reason: server_sdk_1.StandardResolutionReasons.ERROR,
          errorCode: server_sdk_1.ErrorCode.TYPE_MISMATCH
        };
      }
      const now = /* @__PURE__ */ new Date();
      for (const allocation of flag.allocations) {
        if (allocation.startAt && now < new Date(allocation.startAt)) {
          logger.debug(`allocation before start date`, {
            flagKey: flag.key,
            subjectKey,
            allocationKey: allocation.key,
            startAt: allocation.startAt
          });
          continue;
        }
        if (allocation.endAt && now >= new Date(allocation.endAt)) {
          logger.debug(`allocation after end date`, {
            flagKey: flag.key,
            subjectKey,
            allocationKey: allocation.key,
            endAt: allocation.endAt
          });
          continue;
        }
        const matched = containsMatchingRule(allocation.rules, subjectAttributes, logger);
        if (!matched) {
          continue;
        }
        const selectedSplit = selectSplitUsingSharding(allocation.splits, subjectKey, flag.key, logger);
        if (selectedSplit) {
          const variant = flag.variations[selectedSplit.variationKey];
          if (variant) {
            logger.debug(`evaluated a flag`, {
              flagKey: flag.key,
              subjectKey,
              assignment: variant.value
            });
            return {
              value: variant.value,
              reason: server_sdk_1.StandardResolutionReasons.TARGETING_MATCH,
              variant: variant.key,
              flagMetadata: {
                allocationKey: allocation.key,
                variationType: (0, ufc_v1_1.variantTypeToFlagValueType)(flag.variationType),
                doLog: !!allocation.doLog
              }
            };
          }
        } else {
          logger.debug(`no matching split found for subject`, {
            flagKey: flag.key,
            subjectKey,
            allocationKey: allocation.key
          });
        }
      }
      logger.debug(`returning default assignment because no allocation matched`, {
        flagKey: flag.key,
        subjectKey
      });
      return {
        value: defaultValue,
        reason: server_sdk_1.StandardResolutionReasons.DEFAULT
      };
    }
    function validateTypeMatch(expectedType, variantType) {
      if (expectedType === "boolean") {
        return variantType === "BOOLEAN";
      }
      if (expectedType === "string") {
        return variantType === "STRING";
      }
      if (expectedType === "number") {
        return variantType === "INTEGER" || variantType === "NUMERIC";
      }
      if (expectedType === "object") {
        return variantType === "JSON";
      }
      throw new Error(`Invalid expected type: ${expectedType}`);
    }
    function containsMatchingRule(rules, subjectAttributes, logger) {
      if (!(rules === null || rules === void 0 ? void 0 : rules.length)) {
        return true;
      }
      logger.debug(`evaluating rules`, {
        rules: JSON.stringify(rules),
        subjectAttributes
      });
      return rules.some((rule) => (0, rules_1.matchesRule)(rule, subjectAttributes));
    }
    function selectSplitUsingSharding(splits, subjectKey, flagKey, logger) {
      if (!splits || splits.length === 0) {
        return null;
      }
      for (const split of splits) {
        logger.debug(`evaluating split sharding`, {
          flagKey,
          subjectKey,
          variationKey: split.variationKey,
          shards: split.shards
        });
        const matches = split.shards.every((shard) => {
          const shardMatches = (0, matchesShard_1.matchesShard)(shard, subjectKey);
          logger.debug(`shard match result`, {
            flagKey,
            subjectKey,
            variationKey: split.variationKey,
            shard,
            matches: shardMatches
          });
          return shardMatches;
        });
        if (matches) {
          logger.debug(`subject matches split`, {
            flagKey,
            subjectKey,
            variationKey: split.variationKey
          });
          return split;
        }
      }
      logger.debug(`subject matches no splits`, {
        flagKey,
        subjectKey
      });
      return null;
    }
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/configuration/evaluation.js
var require_evaluation = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/configuration/evaluation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.evaluate = evaluate;
    var server_sdk_1 = require_cjs3();
    var evaluateForSubject_1 = require_evaluateForSubject();
    function evaluate(config, type, flagKey, defaultValue, context2, logger) {
      if (!config) {
        return {
          value: defaultValue,
          reason: "ERROR",
          errorCode: server_sdk_1.ErrorCode.PROVIDER_NOT_READY
        };
      }
      const { targetingKey: subjectKey, ...remainingContext } = context2;
      if (!subjectKey) {
        return {
          value: defaultValue,
          reason: "ERROR",
          errorCode: server_sdk_1.ErrorCode.TARGETING_KEY_MISSING
        };
      }
      const subjectAttributes = {
        id: subjectKey,
        ...remainingContext
      };
      try {
        const resultWithDetails = (0, evaluateForSubject_1.evaluateForSubject)(config.flags[flagKey], type, subjectKey, subjectAttributes, defaultValue, logger);
        return resultWithDetails;
      } catch (error) {
        logger.error("Error evaluating flag", { error });
        return {
          value: defaultValue,
          reason: server_sdk_1.StandardResolutionReasons.ERROR,
          errorCode: server_sdk_1.ErrorCode.GENERAL
        };
      }
    }
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/provider.js
var require_provider = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DatadogNodeServerProvider = void 0;
    var flagging_core_1 = require_cjs();
    var server_sdk_1 = require_cjs3();
    var evaluation_1 = require_evaluation();
    var DatadogNodeServerProvider = class {
      constructor(options) {
        this.options = options;
        this.metadata = {
          name: "datadog-node-server"
        };
        this.runsOn = "server";
        this.hooks = [];
        this.events = new server_sdk_1.OpenFeatureEventEmitter();
        this.exposureCache = new flagging_core_1.LRUInMemoryAssignmentCache(5e4);
      }
      /**
       * Used by dd-source-js
       */
      getConfiguration() {
        return this.configuration;
      }
      /**
       * Used by dd-source-js
       */
      setConfiguration(configuration) {
        var _a, _b;
        const prevCreatedAt = (_a = this.configuration) === null || _a === void 0 ? void 0 : _a.createdAt;
        if (this.configuration && this.configuration !== configuration) {
          this.events.emit(server_sdk_1.ProviderEvents.ConfigurationChanged);
          const newCreatedAt = configuration === null || configuration === void 0 ? void 0 : configuration.createdAt;
          if (prevCreatedAt !== newCreatedAt) {
            (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.clear();
          }
          this.configuration = configuration;
          return;
        }
        this.configuration = configuration;
        if (this.resolveInitialization) {
          this.resolveInitialization();
          this.resolveInitialization = void 0;
          this.rejectInitialization = void 0;
        }
      }
      /**
       * Used by dd-source-js
       */
      setError(error) {
        if (this.rejectInitialization) {
          this.rejectInitialization(error);
          this.resolveInitialization = void 0;
          this.rejectInitialization = void 0;
        } else {
          this.events.emit(server_sdk_1.ProviderEvents.Error, { error });
        }
      }
      /**
       * Used by the OpenFeature SDK to set the status based on initialization.
       * Status of 'PROVIDER_READY' is emitted with a resolved promise.
       * Status of 'PROVIDER_ERROR' is emitted with a rejected promise.
       *
       * Since we aren't loading the configuration in this Provider, we will simulate
       * loading functionality via resolveInitialization and rejectInitialization.
       * See setConfiguration and setError for more details.
       */
      async initialize() {
        var _a;
        if (this.configuration) {
          return;
        }
        await new Promise((resolve, reject) => {
          this.resolveInitialization = resolve;
          this.rejectInitialization = reject;
        });
        await ((_a = this.exposureCache) === null || _a === void 0 ? void 0 : _a.init());
      }
      async resolveBooleanEvaluation(flagKey, defaultValue, context2, _logger) {
        const resolutionDetails = (0, evaluation_1.evaluate)(this.configuration, "boolean", flagKey, defaultValue, context2, _logger);
        this.handleExposure(flagKey, context2, resolutionDetails);
        return resolutionDetails;
      }
      async resolveStringEvaluation(flagKey, defaultValue, context2, _logger) {
        const resolutionDetails = (0, evaluation_1.evaluate)(this.configuration, "string", flagKey, defaultValue, context2, _logger);
        this.handleExposure(flagKey, context2, resolutionDetails);
        return resolutionDetails;
      }
      async resolveNumberEvaluation(flagKey, defaultValue, context2, _logger) {
        const resolutionDetails = (0, evaluation_1.evaluate)(this.configuration, "number", flagKey, defaultValue, context2, _logger);
        this.handleExposure(flagKey, context2, resolutionDetails);
        return resolutionDetails;
      }
      async resolveObjectEvaluation(flagKey, defaultValue, context2, _logger) {
        const resolutionDetails = (0, evaluation_1.evaluate)(this.configuration, "object", flagKey, defaultValue, context2, _logger);
        this.handleExposure(flagKey, context2, resolutionDetails);
        return resolutionDetails;
      }
      handleExposure(flagKey, context2, resolutionDetails) {
        var _a, _b, _c;
        const timestamp = Date.now();
        const evalutationDetails = {
          ...resolutionDetails,
          flagKey,
          flagMetadata: (_a = resolutionDetails.flagMetadata) !== null && _a !== void 0 ? _a : {}
        };
        const exposureEvent = (0, flagging_core_1.createExposureEvent)(context2, evalutationDetails);
        if (!exposureEvent) {
          return;
        }
        const hasLoggedAssignment = (_b = this.exposureCache) === null || _b === void 0 ? void 0 : _b.has(exposureEvent);
        if (hasLoggedAssignment) {
          return;
        }
        if (this.options.exposureChannel.hasSubscribers) {
          this.options.exposureChannel.publish({ ...exposureEvent, timestamp });
          (_c = this.exposureCache) === null || _c === void 0 ? void 0 : _c.set(exposureEvent);
        }
      }
    };
    exports2.DatadogNodeServerProvider = DatadogNodeServerProvider;
  }
});

// ../../node_modules/@datadog/openfeature-node-server/cjs/index.js
var require_cjs4 = __commonJS({
  "../../node_modules/@datadog/openfeature-node-server/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_provider(), exports2);
  }
});

// ../../packages/dd-trace/src/openfeature/flagging_provider.js
var require_flagging_provider = __commonJS({
  "../../packages/dd-trace/src/openfeature/flagging_provider.js"(exports2, module2) {
    "use strict";
    var { DatadogNodeServerProvider } = require_cjs4();
    var { channel } = require_dc_polyfill();
    var log = require_log2();
    var { EXPOSURE_CHANNEL } = require_constants();
    var FlaggingProvider = class extends DatadogNodeServerProvider {
      /**
       * @param {import('../tracer')} tracer - Datadog tracer instance
       * @param {import('../config')} config - Tracer configuration object
       */
      constructor(tracer2, config) {
        super({
          exposureChannel: channel(EXPOSURE_CHANNEL)
        });
        this._tracer = tracer2;
        this._config = config;
        log.debug(this.constructor.name + " created");
      }
      /**
       * Internal method to update flag configuration from Remote Config.
       * This method is called automatically when Remote Config delivers UFC updates.
       *
       * @internal
       * @param {import('@datadog/openfeature-node-server').UniversalFlagConfigurationV1} ufc
       * - Universal Flag Configuration object
       */
      _setConfiguration(ufc) {
        if (typeof this.setConfiguration === "function") {
          this.setConfiguration(ufc);
        }
        log.debug(this.constructor.name + " provider configuration updated");
      }
    };
    module2.exports = FlaggingProvider;
  }
});

// ../../packages/dd-trace/src/proxy.js
var require_proxy2 = __commonJS({
  "../../packages/dd-trace/src/proxy.js"(exports2, module2) {
    "use strict";
    var NoopProxy = require_proxy();
    var DatadogTracer = require_tracer4();
    var Config = require_config2();
    var runtimeMetrics = require_runtime_metrics2();
    var log = require_log2();
    var { setStartupLogPluginManager } = require_startup_log();
    var DynamicInstrumentation = require_debugger();
    var telemetry = require_telemetry3();
    var nomenclature = require_service_naming();
    var PluginManager = require_plugin_manager();
    var NoopDogStatsDClient = require_dogstatsd();
    var { getEnvironmentVariable } = require_config_helper();
    var {
      setBaggageItem,
      getBaggageItem,
      getAllBaggageItems,
      removeBaggageItem,
      removeAllBaggageItems
    } = require_baggage();
    var LazyModule = class {
      constructor(provider) {
        this.provider = provider;
      }
      enable(...args) {
        this.module = this.provider();
        this.module.enable(...args);
      }
      disable() {
        this.module?.disable();
      }
    };
    function lazyProxy(obj, property, config, getClass, ...args) {
      if (config?._isInServerlessEnvironment?.() === false) {
        defineEagerly(obj, property, getClass, ...args);
      } else {
        defineLazily(obj, property, getClass, ...args);
      }
    }
    function defineEagerly(obj, property, getClass, ...args) {
      const RealClass = getClass();
      obj[property] = new RealClass(...args);
    }
    function defineLazily(obj, property, getClass, ...args) {
      Reflect.defineProperty(obj, property, {
        get() {
          const RealClass = getClass();
          const value = new RealClass(...args);
          Reflect.defineProperty(obj, property, { value, configurable: true, enumerable: true });
          return value;
        },
        configurable: true,
        enumerable: true
      });
    }
    var Tracer = class extends NoopProxy {
      constructor() {
        super();
        this._initialized = false;
        this._nomenclature = nomenclature;
        this._pluginManager = new PluginManager(this);
        this.dogstatsd = new NoopDogStatsDClient();
        this._tracingInitialized = false;
        this._flare = new LazyModule(() => require_flare());
        this.setBaggageItem = setBaggageItem;
        this.getBaggageItem = getBaggageItem;
        this.getAllBaggageItems = getAllBaggageItems;
        this.removeBaggageItem = removeBaggageItem;
        this.removeAllBaggageItems = removeAllBaggageItems;
        this._modules = {
          appsec: new LazyModule(() => require_appsec()),
          iast: new LazyModule(() => require_iast()),
          llmobs: new LazyModule(() => require_llmobs()),
          rewriter: new LazyModule(() => require_rewriter()),
          openfeature: new LazyModule(() => require_openfeature())
        };
      }
      /**
       * @override
       */
      init(options) {
        if (this._initialized) return this;
        this._initialized = true;
        try {
          const config = new Config(options);
          if (config.crashtracking.enabled) {
            require_crashtracking().start(config);
          }
          if (config.heapSnapshot.count > 0) {
            require_heap_snapshots().start(config);
          }
          telemetry.start(config, this._pluginManager);
          if (config.dogstatsd) {
            lazyProxy(this, "dogstatsd", config, () => require_dogstatsd2().CustomMetrics, config);
          }
          if (config.spanLeakDebug > 0) {
            const spanleak = require_spanleak();
            if (config.spanLeakDebug === spanleak.MODES.LOG) {
              spanleak.enableLogging();
            } else if (config.spanLeakDebug === spanleak.MODES.GC_AND_LOG) {
              spanleak.enableGarbageCollection();
            }
            spanleak.startScrubber();
          }
          if (config.remoteConfig.enabled && !config.isCiVisibility) {
            const rc = require_remote_config().enable(config, this._modules.appsec);
            rc.setProductHandler("APM_TRACING", (action, conf) => {
              if (action === "unapply") {
                config.configure({}, true);
              } else {
                config.configure(conf.lib_config, true);
              }
              this._enableOrDisableTracing(config);
            });
            rc.setProductHandler("AGENT_CONFIG", (action, conf) => {
              if (!conf?.name?.startsWith("flare-log-level.")) return;
              if (action === "unapply") {
                this._flare.disable();
              } else if (conf.config?.log_level) {
                this._flare.enable(config);
                this._flare.module.prepare(conf.config.log_level);
              }
            });
            rc.setProductHandler("AGENT_TASK", (action, conf) => {
              if (action === "unapply" || !conf) return;
              if (conf.task_type !== "tracer_flare" || !conf.args) return;
              this._flare.enable(config);
              this._flare.module.send(conf.args);
            });
            if (config.dynamicInstrumentation.enabled) {
              DynamicInstrumentation.start(config, rc);
            }
            if (config.experimental.flaggingProvider.enabled) {
              rc.setProductHandler("FFE_FLAGS", (action, conf) => {
                if (action === "apply" || action === "modify") {
                  this.openfeature._setConfiguration(conf);
                }
              });
            }
          }
          if (config.profiling.enabled === "true") {
            this._profilerStarted = this._startProfiler(config);
          } else {
            this._profilerStarted = Promise.resolve(false);
            if (config.profiling.enabled === "auto") {
              const { SSIHeuristics } = require_ssi_heuristics();
              const ssiHeuristics = new SSIHeuristics(config);
              ssiHeuristics.start();
              ssiHeuristics.onTriggered(() => {
                this._startProfiler(config);
                ssiHeuristics.onTriggered();
              });
            }
          }
          if (config.runtimeMetrics.enabled) {
            runtimeMetrics.start(config);
          }
          this._enableOrDisableTracing(config);
          this._modules.rewriter.enable(config);
          if (config.tracing && config.isManualApiEnabled) {
            const TestApiManualPlugin = require_test_api_manual_plugin();
            this._testApiManualPlugin = new TestApiManualPlugin(this);
            this._testApiManualPlugin.configure({ ...config, enabled: true }, false);
          }
          if (config.ciVisAgentlessLogSubmissionEnabled) {
            if (getEnvironmentVariable("DD_API_KEY")) {
              const LogSubmissionPlugin = require_log_submission_plugin();
              const automaticLogPlugin = new LogSubmissionPlugin(this);
              automaticLogPlugin.configure({ ...config, enabled: true });
            } else {
              log.warn(
                // eslint-disable-next-line @stylistic/max-len
                "DD_AGENTLESS_LOG_SUBMISSION_ENABLED is set, but DD_API_KEY is undefined, so no automatic log submission will be performed."
              );
            }
          }
          if (config.otelLogsEnabled) {
            const { initializeOpenTelemetryLogs } = require_logs3();
            initializeOpenTelemetryLogs(config);
          }
          if (config.isTestDynamicInstrumentationEnabled) {
            const getDynamicInstrumentationClient = require_dynamic_instrumentation();
            getDynamicInstrumentationClient(config);
          }
        } catch (e) {
          log.error("Error initialising tracer", e);
        }
        return this;
      }
      _startProfiler(config) {
        try {
          return require_profiler2().start(config);
        } catch (e) {
          log.error(
            "Error starting profiler. For troubleshooting tips, see <https://dtdg.co/nodejs-profiler-troubleshooting>",
            e
          );
        }
      }
      _enableOrDisableTracing(config) {
        if (config.tracing !== false) {
          if (config.appsec.enabled) {
            this._modules.appsec.enable(config);
          }
          if (config.llmobs.enabled) {
            this._modules.llmobs.enable(config);
          }
          if (!this._tracingInitialized) {
            const prioritySampler = config.apmTracingEnabled === false ? require_standalone().configure(config) : void 0;
            this._tracer = new DatadogTracer(config, prioritySampler);
            this.dataStreamsCheckpointer = this._tracer.dataStreamsCheckpointer;
            lazyProxy(this, "appsec", config, () => require_sdk(), this._tracer, config);
            lazyProxy(this, "llmobs", config, () => require_sdk2(), this._tracer, this._modules.llmobs, config);
            if (config.experimental?.aiguard?.enabled) {
              lazyProxy(this, "aiguard", config, () => require_sdk3(), this._tracer, config);
            }
            this._tracingInitialized = true;
          }
          if (config.experimental.flaggingProvider.enabled) {
            this._modules.openfeature.enable(config);
            lazyProxy(this, "openfeature", config, () => require_flagging_provider(), this._tracer, config);
          }
          if (config.iast.enabled) {
            this._modules.iast.enable(config, this._tracer);
          }
        } else if (this._tracingInitialized) {
          this._modules.appsec.disable();
          this._modules.iast.disable();
          this._modules.llmobs.disable();
          this._modules.openfeature.disable();
        }
        if (this._tracingInitialized) {
          this._tracer.configure(config);
          this._pluginManager.configure(config);
          DynamicInstrumentation.configure(config);
          setStartupLogPluginManager(this._pluginManager);
        }
      }
      /**
       * @override
       */
      profilerStarted() {
        if (!this._profilerStarted) {
          throw new Error("profilerStarted() must be called after init()");
        }
        return this._profilerStarted;
      }
      /**
       * @override
       */
      use() {
        this._pluginManager.configurePlugin(...arguments);
        return this;
      }
      /**
       * @override
       */
      get TracerProvider() {
        return require_tracer_provider();
      }
    };
    module2.exports = Tracer;
  }
});

// ../../packages/dd-trace/src/index.js
var require_src77 = __commonJS({
  "../../packages/dd-trace/src/index.js"(exports2, module2) {
    "use strict";
    var { isFalse } = require_util();
    var { getEnvironmentVariable } = require_config_helper();
    var inJestWorker = typeof jest !== "undefined";
    var ddTraceDisabled = getEnvironmentVariable("DD_TRACE_ENABLED") ? isFalse(getEnvironmentVariable("DD_TRACE_ENABLED")) : String(getEnvironmentVariable("OTEL_TRACES_EXPORTER")).toLowerCase() === "none";
    module2.exports = ddTraceDisabled || inJestWorker ? require_proxy() : require_proxy2();
  }
});

// ../../packages/dd-trace/index.js
var require_dd_trace = __commonJS({
  "../../packages/dd-trace/index.js"(exports2, module2) {
    "use strict";
    if (!global._ddtrace) {
      const TracerProxy = require_src77();
      Object.defineProperty(global, "_ddtrace", {
        value: new TracerProxy(),
        enumerable: false,
        configurable: true,
        writable: true
      });
      global._ddtrace.default = global._ddtrace;
      global._ddtrace.tracer = global._ddtrace;
    }
    module2.exports = global._ddtrace;
  }
});

// ../../index.js
var require_index = __commonJS({
  "../../index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_dd_trace();
  }
});

// init.mjs
var import_dd_trace = __toESM(require_index(), 1);
import_dd_trace.default.init({ flushInterval: 0 });

// ../../../../../../../../_dd_esm_internal_/http._dd_esbuild_intercepted
var import_register = __toESM(require_register());
import * as namespace from "http";
var _ = Object.create(null, { [Symbol.toStringTag]: { value: "Module" } });
var set = {};
var get2 = {};
var $Agent;
try {
  $Agent = _["Agent"] = namespace["Agent"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["Agent"] = (v) => {
  $Agent = v;
  return true;
};
get2["Agent"] = () => $Agent;
var $ClientRequest;
try {
  $ClientRequest = _["ClientRequest"] = namespace["ClientRequest"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["ClientRequest"] = (v) => {
  $ClientRequest = v;
  return true;
};
get2["ClientRequest"] = () => $ClientRequest;
var $CloseEvent;
try {
  $CloseEvent = _["CloseEvent"] = namespace["CloseEvent"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["CloseEvent"] = (v) => {
  $CloseEvent = v;
  return true;
};
get2["CloseEvent"] = () => $CloseEvent;
var $IncomingMessage;
try {
  $IncomingMessage = _["IncomingMessage"] = namespace["IncomingMessage"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["IncomingMessage"] = (v) => {
  $IncomingMessage = v;
  return true;
};
get2["IncomingMessage"] = () => $IncomingMessage;
var $METHODS;
try {
  $METHODS = _["METHODS"] = namespace["METHODS"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["METHODS"] = (v) => {
  $METHODS = v;
  return true;
};
get2["METHODS"] = () => $METHODS;
var $MessageEvent;
try {
  $MessageEvent = _["MessageEvent"] = namespace["MessageEvent"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["MessageEvent"] = (v) => {
  $MessageEvent = v;
  return true;
};
get2["MessageEvent"] = () => $MessageEvent;
var $OutgoingMessage;
try {
  $OutgoingMessage = _["OutgoingMessage"] = namespace["OutgoingMessage"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["OutgoingMessage"] = (v) => {
  $OutgoingMessage = v;
  return true;
};
get2["OutgoingMessage"] = () => $OutgoingMessage;
var $STATUS_CODES;
try {
  $STATUS_CODES = _["STATUS_CODES"] = namespace["STATUS_CODES"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["STATUS_CODES"] = (v) => {
  $STATUS_CODES = v;
  return true;
};
get2["STATUS_CODES"] = () => $STATUS_CODES;
var $Server;
try {
  $Server = _["Server"] = namespace["Server"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["Server"] = (v) => {
  $Server = v;
  return true;
};
get2["Server"] = () => $Server;
var $ServerResponse;
try {
  $ServerResponse = _["ServerResponse"] = namespace["ServerResponse"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["ServerResponse"] = (v) => {
  $ServerResponse = v;
  return true;
};
get2["ServerResponse"] = () => $ServerResponse;
var $WebSocket;
try {
  $WebSocket = _["WebSocket"] = namespace["WebSocket"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["WebSocket"] = (v) => {
  $WebSocket = v;
  return true;
};
get2["WebSocket"] = () => $WebSocket;
var $_connectionListener;
try {
  $_connectionListener = _["_connectionListener"] = namespace["_connectionListener"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["_connectionListener"] = (v) => {
  $_connectionListener = v;
  return true;
};
get2["_connectionListener"] = () => $_connectionListener;
var $createServer;
try {
  $createServer = _["createServer"] = namespace["createServer"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["createServer"] = (v) => {
  $createServer = v;
  return true;
};
get2["createServer"] = () => $createServer;
var $default;
try {
  $default = _["default"] = namespace["default"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["default"] = (v) => {
  $default = v;
  return true;
};
get2["default"] = () => $default;
var $get;
try {
  $get = _["get"] = namespace["get"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["get"] = (v) => {
  $get = v;
  return true;
};
get2["get"] = () => $get;
var $globalAgent;
try {
  $globalAgent = _["globalAgent"] = namespace["globalAgent"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["globalAgent"] = (v) => {
  $globalAgent = v;
  return true;
};
get2["globalAgent"] = () => $globalAgent;
var $maxHeaderSize;
try {
  $maxHeaderSize = _["maxHeaderSize"] = namespace["maxHeaderSize"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["maxHeaderSize"] = (v) => {
  $maxHeaderSize = v;
  return true;
};
get2["maxHeaderSize"] = () => $maxHeaderSize;
var $request;
try {
  $request = _["request"] = namespace["request"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["request"] = (v) => {
  $request = v;
  return true;
};
get2["request"] = () => $request;
var $setMaxIdleHTTPParsers;
try {
  $setMaxIdleHTTPParsers = _["setMaxIdleHTTPParsers"] = namespace["setMaxIdleHTTPParsers"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["setMaxIdleHTTPParsers"] = (v) => {
  $setMaxIdleHTTPParsers = v;
  return true;
};
get2["setMaxIdleHTTPParsers"] = () => $setMaxIdleHTTPParsers;
var $validateHeaderName;
try {
  $validateHeaderName = _["validateHeaderName"] = namespace["validateHeaderName"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["validateHeaderName"] = (v) => {
  $validateHeaderName = v;
  return true;
};
get2["validateHeaderName"] = () => $validateHeaderName;
var $validateHeaderValue;
try {
  $validateHeaderValue = _["validateHeaderValue"] = namespace["validateHeaderValue"];
} catch (err) {
  if (!(err instanceof ReferenceError)) throw err;
}
set["validateHeaderValue"] = (v) => {
  $validateHeaderValue = v;
  return true;
};
get2["validateHeaderValue"] = () => $validateHeaderValue;
(0, import_register.register)("http", _, set, get2, "http");

// esm-http-test.mjs
process.env.DD_TRACE_DEBUG = "true";
var server = $default.createServer((req, res) => {
  res.end("Egun on!");
});
server.listen(0, () => {
  const port = server.address().port;
  process.send({ port });
});
/*! Bundled license information:

pprof-format/dist/commonjs/index.js:
  (*!
   * Private helpers. These are only used by other helpers.
   *)
*/
