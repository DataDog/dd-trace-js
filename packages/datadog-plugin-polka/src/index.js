// AUTO-GENERATED by dd-compile from polka.analysis.json
// To customize plugin behavior, edit this file directly.
// Re-running dd-compile will show a diff but won't overwrite without confirmation.

'use strict'

const ServerPlugin = require('../../dd-trace/src/plugins/server')
const Extractors = require('./extractors')

class PolkaServerPlugin extends ServerPlugin {
  static get id () {
    return 'polka'
  }

  static get prefix () {
    return 'tracing:apm:polka:polka:handler'
  }

  constructor (...args) {
    super(...args)
    this.subscribe()
  }

  subscribe () {
    // Subscribe to diagnostic channels for each instrumented operation
    // For tracePromise: :start, :error, :asyncEnd channels
    // Note: :error may not always fire; fallback error handling in finish()
    this.addBind('tracing:apm:polka:polka:handler:start', (ctx) => this.polkaHandlerStart(ctx))
    this.addBind('tracing:apm:polka:polka:handler:error', (ctx) => this.error(ctx))
    // this.addBind('tracing:apm:polka:polka:handler:end', (ctx) => this.finish(ctx))
    this.addSub('tracing:apm:polka:polka:handler:end', (ctx) => this.finish(ctx))
  }

  polkaHandlerStart (ctx) {
    const tags = Extractors.polkaHandlerServer(ctx)
    const options = {
      kind: tags['span.kind'],
      type: 'web',
      meta: tags,
      resource: tags['resource.name'] || 'handler'
    }

    // Start the span first
    const result = this.startSpan('polka.handler', options, ctx)

    // Now set up response finish listener to finish span when response completes
    const args = ctx.arguments || ctx.args || []
    const req = args[0]
    const res = args[1]
    const span = ctx?.currentStore?.span

    if (res && res.on && span && !res._ddPolkaFinishAttached) {
      res._ddPolkaFinishAttached = true

      // Mark on the context that we should defer finishing
      // Store it in the context so it's accessible in finish()
      ctx._ddShouldDeferFinish = true
      // Also mark on the request as a backup
      if (req) {
        req._ddShouldDeferFinish = true
      }

      res.on('finish', () => {
        // Update status code when response finishes
        if (res.statusCode) {
          span.setTag('http.status_code', String(res.statusCode))
          // Mark span as error if status code is 5xx
          if (res.statusCode >= 500) {
            span.setTag('error', 1)
          }
        }
        // Now finish the span
        span.finish()
      })
    }

    return result
  }

  error (ctx) {
    const span = ctx?.currentStore?.span
    if (span && ctx.error) {
      this.addError(ctx.error, span)
    }
    return ctx.parentStore
  }

  finish (ctx) {
    const span = ctx?.currentStore?.span
    if (span) {
      // If there's an error in the context, add it to the span
      // This handles cases where :error channel wasn't published but ctx.error exists
      // (e.g., with tracePromise when promise rejects)
      if (ctx.error) {
        this.addError(ctx.error, span)
      }

      // Check if we should defer finishing until response completes
      // Check the request and response objects for the defer flag (set in polkaHandlerStart)
      const args = ctx.arguments || ctx.args || []
      const req = args[0]
      const res = args[1]

      // Check if we've attached the finish listener - if so, defer finishing
      const shouldDefer = (res && res._ddPolkaFinishAttached) || (req && req._ddShouldDeferFinish)

      // If _ddShouldDeferFinish is set, the span will be finished in the response 'finish' event
      if (!shouldDefer) {
        super.finish(ctx)
      }
      // If deferred, the span.finish() is called directly in the response event handler
    }
    return ctx.parentStore
  }
}

module.exports = PolkaServerPlugin
