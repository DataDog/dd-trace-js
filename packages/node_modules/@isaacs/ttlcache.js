(()=>{"use strict";var t={};t.d=(e,i)=>{for(var s in i)t.o(i,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:i[s]})},t.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),t.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var e={};t.r(e),t.d(e,{TTLCache:()=>a});let i="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,s=()=>i.now(),r=t=>t===1/0||!!t&&t===Math.floor(t)&&t>0&&isFinite(t);class a{expirations=Object.create(null);data=new Map;expirationMap=new Map;ttl;max;updateAgeOnGet;updateAgeOnHas;noUpdateTTL;noDisposeOnSet;checkAgeOnGet;checkAgeOnHas;dispose;timer;timerExpiration;immortalKeys=new Set;constructor({max:t=1/0,ttl:e,updateAgeOnGet:i=!1,checkAgeOnGet:s=!1,updateAgeOnHas:a=!1,checkAgeOnHas:o=!1,noUpdateTTL:h=!1,dispose:n,noDisposeOnSet:l=!1}={}){if(void 0!==e&&!r(e))throw TypeError("ttl must be positive integer or Infinity if set");if(!r(t))throw TypeError("max must be positive integer or Infinity");if(this.ttl=e,this.max=t,this.updateAgeOnGet=!!i,this.checkAgeOnGet=!!s,this.updateAgeOnHas=!!a,this.checkAgeOnHas=!!o,this.noUpdateTTL=!!h,this.noDisposeOnSet=!!l,void 0!==n){if("function"!=typeof n)throw TypeError("dispose must be function if set");this.dispose=n}else this.dispose=(t,e,i)=>{};this.timer=void 0,this.timerExpiration=void 0}setTimer(t,e){if(this.timerExpiration&&this.timerExpiration<t)return;this.timer&&clearTimeout(this.timer);let i=setTimeout(()=>{for(let t in this.timer=void 0,this.timerExpiration=void 0,this.purgeStale(),this.expirations){let e=Number(t);this.setTimer(e,e-s());break}},Math.max(0,e));i.unref&&i.unref(),this.timerExpiration=t,this.timer=i}cancelTimer(){this.timer&&(clearTimeout(this.timer),this.timerExpiration=void 0,this.timer=void 0)}cancelTimers(){return process.emitWarning('TTLCache.cancelTimers has been renamed to TTLCache.cancelTimer (no "s"), and will be removed in the next major version update'),this.cancelTimer()}clear(){let t=this.dispose!==a.prototype.dispose?[...this]:[];for(let[e,i]of(this.data.clear(),this.expirationMap.clear(),this.cancelTimer(),this.expirations=Object.create(null),t))this.dispose(i,e,"delete")}setTTL(t,e=this.ttl){let i=this.expirationMap.get(t);if(void 0!==i){let e=this.expirations[i];!e||e.length<=1?delete this.expirations[i]:this.expirations[i]=e.filter(e=>e!==t)}if(e&&e!==1/0){this.immortalKeys.delete(t);let i=Math.floor(s()+e);this.expirationMap.set(t,i),this.expirations[i]||(this.expirations[i]=[],this.setTimer(i,e)),this.expirations[i].push(t)}else this.immortalKeys.add(t),this.expirationMap.set(t,1/0)}set(t,e,{ttl:i=this.ttl,noUpdateTTL:s=this.noUpdateTTL,noDisposeOnSet:a=this.noDisposeOnSet}={}){if(!r(i))throw TypeError("ttl must be positive integer or Infinity");if(this.expirationMap.has(t)){s||this.setTTL(t,i);let r=this.data.get(t),o=!a&&this.data.has(t);r!==e&&(this.data.set(t,e),o&&this.dispose(r,t,"set"))}else this.setTTL(t,i),this.data.set(t,e);for(;this.size>this.max;)this.purgeToCapacity();return this}has(t,{checkAgeOnHas:e=this.checkAgeOnHas,ttl:i=this.ttl,updateAgeOnHas:s=this.updateAgeOnHas}={}){return!!this.data.has(t)&&(e&&0===this.getRemainingTTL(t)?(this.delete(t),!1):(s&&this.setTTL(t,i),!0))}getRemainingTTL(t){let e=this.expirationMap.get(t);return e===1/0?e:void 0!==e?Math.max(0,Math.ceil(e-s())):0}get(t,{updateAgeOnGet:e=this.updateAgeOnGet,ttl:i=this.ttl,checkAgeOnGet:s=this.checkAgeOnGet}={}){let r=this.data.get(t);return s&&0===this.getRemainingTTL(t)?void this.delete(t):(e&&this.setTTL(t,i),r)}delete(t){let e=this.expirationMap.get(t);if(void 0!==e){let i=this.data.get(t);this.data.delete(t),this.expirationMap.delete(t),this.immortalKeys.delete(t);let s=this.expirations[e];return s&&(s.length<=1?delete this.expirations[e]:this.expirations[e]=s.filter(e=>e!==t)),this.dispose(i,t,"delete"),0===this.size&&this.cancelTimer(),!0}return!1}purgeToCapacity(){for(let t in this.expirations){let e=this.expirations[t];if(this.size-e.length>=this.max){delete this.expirations[t];let i=[];for(let t of e)i.push([t,this.data.get(t)]),this.data.delete(t),this.expirationMap.delete(t);for(let[t,e]of i)this.dispose(e,t,"evict")}else{let t=this.size-this.max,i=[];for(let s of e.splice(0,t))i.push([s,this.data.get(s)]),this.data.delete(s),this.expirationMap.delete(s);for(let[t,e]of i)this.dispose(e,t,"evict");return}}}get size(){return this.data.size}purgeStale(){let t=Math.ceil(s());for(let e in this.expirations){if("Infinity"===e||Number(e)>t)return;let i=[...this.expirations[e]||[]],s=[];for(let t of(delete this.expirations[e],i))s.push([t,this.data.get(t)]),this.data.delete(t),this.expirationMap.delete(t);for(let[t,e]of s)this.dispose(e,t,"stale")}0===this.size&&this.cancelTimer()}*entries(){for(let t in this.expirations)for(let e of this.expirations[t])yield[e,this.data.get(e)];for(let t of this.immortalKeys)yield[t,this.data.get(t)]}*keys(){for(let t in this.expirations)for(let e of this.expirations[t])yield e;for(let t of this.immortalKeys)yield t}*values(){for(let t in this.expirations)for(let e of this.expirations[t])yield this.data.get(e);for(let t of this.immortalKeys)yield this.data.get(t)}[Symbol.iterator](){return this.entries()}}module.exports=e})();