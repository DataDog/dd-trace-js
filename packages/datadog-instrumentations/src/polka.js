// AUTO-GENERATED by dd-compile from polka.analysis.json
// To customize instrumentation behavior, edit this file directly.
// Re-running dd-compile will show a diff but won't overwrite without confirmation.

'use strict'

const { addHook, tracingChannel } = require('./helpers/instrument')
const shimmer = require('../../datadog-shimmer')
const { createWrapper } = require('./helpers/wrappers')

const handleChannel = tracingChannel('apm:polka:polka:handler')

addHook({ name: 'polka', versions: ['>=0.0.0'] }, (exports) => {
  // Wrap the factory function itself
  const original = exports
  return function wrappedFactory (...args) {
    // Call original factory to get the instance
    const instance = original.apply(this, args)

    // Wrap the handler method to trace requests
    if (instance && instance.handler) {
      // Capture the polka instance for later use
      const polkaInstance = instance
      shimmer.wrap(instance, 'handler', originalHandler => {
        return function (req, res, info) {
          // Parse info if not provided (use captured polka instance)
          // polkaInstance.parse is a function assigned from @polka/url parser
          if (!info && polkaInstance.parse && typeof polkaInstance.parse === 'function') {
            info = polkaInstance.parse(req)
          }

          // Extract route pattern for tracing
          // Polka extends trouter's Router class which has find() and handlers
          if (polkaInstance.find) {
            const pathname = info ? info.pathname : req.url.split('?')[0]
            const method = req.method

            // Try to find the matched route
            const matchResult = polkaInstance.find(method, pathname)

            // If we got a match, extract the pattern from the matchResult
            if (matchResult && matchResult.handlers && matchResult.handlers.length > 0) {
              // trouter stores the pattern in the matchResult
              // Check if pattern is directly available
              if (matchResult.pattern) {
                req._ddRoute = matchResult.pattern
              } else if (matchResult.params && Object.keys(matchResult.params).length > 0) {
                // Reconstruct the route pattern from pathname and params
                // e.g., pathname="/users/123" and params={id:"123"} => "/users/:id"
                let pattern = pathname
                for (const [key, value] of Object.entries(matchResult.params)) {
                  pattern = pattern.replace(String(value), `:${key}`)
                }
                req._ddRoute = pattern
              } else {
                // Fallback: search through routes to find matching handler reference
                // The routes array contains { keys, pattern, method, handlers } objects
                if (polkaInstance.routes && Array.isArray(polkaInstance.routes)) {
                  for (const route of polkaInstance.routes) {
                    if (route.method === method && route.handlers === matchResult.handlers) {
                      req._ddRoute = route.pattern
                      break
                    }
                  }
                }
              }
            }
          }

          // Now call the handler using traceSync with the updated req object
          const ctx = {
            self: polkaInstance,
            arguments: [req, res, info],
            args: [req, res, info]
          }

          return handleChannel.traceSync(originalHandler, ctx, polkaInstance, req, res, info)
        }
      })
    }

    return instance
  }
})
