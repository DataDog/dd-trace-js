// AUTO-GENERATED by dd-compile from bee-queue.analysis.json
// To customize plugin behavior, edit this file directly.
// Re-running dd-compile will show a diff but won't overwrite without confirmation.

'use strict'

const ConsumerPlugin = require('../../dd-trace/src/plugins/consumer')
const Extractors = require('./extractors')

class BeeQueueConsumerPlugin extends ConsumerPlugin {
  static get id () {
    return 'bee-queue'
  }

  constructor (...args) {
    super(...args)
    this.subscribe()
  }

  subscribe () {
    // Subscribe to diagnostic channels for each instrumented operation
    // For traceHandler: :asyncStart, :error, :asyncEnd channels
    // Note: :error may not always fire; fallback error handling in finish()
    // TracingChannel from dc-polyfill adds 'tracing:' prefix automatically
    this.addBind('tracing:apm:bee-queue:queue:process:asyncStart', (ctx) => this.queueProcessStart(ctx))
    this.addSub('tracing:apm:bee-queue:queue:process:error', (ctx) => this.error(ctx))
    this.addSub('tracing:apm:bee-queue:queue:process:asyncEnd', (ctx) => this.finish(ctx))
  }

  queueProcessStart (ctx) {
    const tags = Extractors.queueProcessConsumer(ctx)
    const options = {
      meta: tags,
      resource: tags['resource.name'] || 'process'
    }
    return this.startSpan(options, ctx)
  }

  error (ctx) {
    const span = ctx?.currentStore?.span
    if (span && ctx.error) {
      this.addError(ctx.error, span)
    }
    return ctx.parentStore
  }

  finish (ctx) {
    const span = ctx?.currentStore?.span
    if (span) {
      // If there's an error in the context, add it to the span
      // This handles cases where :error channel wasn't published but ctx.error exists
      // (e.g., with tracePromise when promise rejects)
      if (ctx.error) {
        this.addError(ctx.error, span)
      }
      super.finish(ctx)
    }
    return ctx.parentStore
  }
}

module.exports = BeeQueueConsumerPlugin
