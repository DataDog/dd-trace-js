// AUTO-GENERATED by dd-compile from nats-io-nats-core.analysis.json
// To customize plugin behavior, edit this file directly.
// Re-running dd-compile will show a diff but won't overwrite without confirmation.

'use strict'

const ConsumerPlugin = require('../../dd-trace/src/plugins/consumer')
const Extractors = require('./extractors')
const { getMessageSize } = require('../../dd-trace/src/datastreams')

class NatsIoNatsCoreConsumerPlugin extends ConsumerPlugin {
  static get id () {
    return '@nats-io/nats-core'
  }

  static get prefix () {
    return 'apm:@nats-io/nats-core:protocolhandler:prototype:processmsg'
  }

  static get operation () {
    return 'processMsg'
  }

  static peerServicePrecursors = ['messaging.destination.name']

  bindStart (ctx) {
    const msg = ctx.msg || {}
    const subject = msg.subject || 'unknown'

    // Context Propagation: Extract parent context from NATS headers
    let childOf
    if (msg.headers) {
      const headerAdapter = this._createHeaderAdapter(msg.headers)
      childOf = this.tracer.extract('text_map', headerAdapter)
    }

    const span = this.startSpan({
      childOf,
      resource: 'processMsg',
      type: 'messaging',
      meta: {
        component: '@nats-io/nats-core',
        'span.kind': 'consumer',
        'messaging.system': '@nats-io/nats-core',
        'messaging.destination.name': subject
      }
    }, ctx)

    // DSM: Decode pathway context from NATS headers and set checkpoint
    if (this.config.dsmEnabled && span && msg.headers) {
      const payloadSize = getMessageSize({ value: msg.data })

      // Create an adapter for NATS headers to work with DsmPathwayCodec
      const headerAdapter = this._createHeaderAdapter(msg.headers)
      this.tracer.decodeDataStreamsContext(headerAdapter)

      const edgeTags = ['direction:in', `topic:${subject}`, 'type:nats']
      this.tracer.setCheckpoint(edgeTags, span, payloadSize)
    }

    return ctx.currentStore
  }

  // Creates an adapter that allows DsmPathwayCodec to work with NATS MsgHdrs
  _createHeaderAdapter (natsHeaders) {
    return new Proxy({}, {
      get (target, prop) {
        // DsmPathwayCodec reads headers like: carrier['dd-pathway-ctx-base64']
        // We need to call natsHeaders.get(key)
        if (natsHeaders && typeof natsHeaders.get === 'function') {
          try {
            return natsHeaders.get(String(prop))
          } catch {
            // If header doesn't exist, NATS might throw
            return
          }
        }
        return target[prop]
      },
      has (target, prop) {
        if (natsHeaders && typeof natsHeaders.has === 'function') {
          return natsHeaders.has(String(prop))
        }
        return prop in target
      }
    })
  }

  // asyncEnd and end delegate to finish() which has the required guard
  asyncEnd (ctx) {
    this.finish(ctx)
  }

  end (ctx) {
    this.finish(ctx)
  }

  // You may modify this method, but the guard below is REQUIRED and MUST NOT be removed!
  finish (ctx) {
    // CRITICAL GUARD - DO NOT REMOVE: Ensures span only finishes when operation completes
    if (!ctx.hasOwnProperty('result') && !ctx.hasOwnProperty('error')) return

    const span = ctx?.currentStore?.span
    if (span) {
      super.finish(ctx)
    }
  }
}

module.exports = NatsIoNatsCoreConsumerPlugin
