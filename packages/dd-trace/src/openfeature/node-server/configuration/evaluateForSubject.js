'use strict'

const {
  ErrorCode,
  StandardResolutionReasons,
} = require('@openfeature/server-sdk')
const { matchesRule } = require('../rules/rules')
const { matchesShard } = require('../shards/matchesShard')
const { variantTypeToFlagValueType } = require('./ufc-v1')

function evaluateForSubject(flag, type, subjectKey, subjectAttributes, defaultValue, logger) {
  if (!flag?.enabled) {
    logger.debug(`returning default assignment because flag is disabled`, {
      flagKey: flag ? flag.key : 'undefined',
      subjectKey,
    })
    return {
      value: defaultValue,
      reason: StandardResolutionReasons.DISABLED,
    }
  }

  const isValid = validateTypeMatch(type, flag.variationType)
  if (!isValid) {
    logger.debug(`variant value type mismatch, returning default value`, {
      flagKey: flag.key,
      subjectKey,
      expectedType: type,
      variantType: flag.variationType,
    })
    return {
      value: defaultValue,
      reason: StandardResolutionReasons.ERROR,
      errorCode: ErrorCode.TYPE_MISMATCH,
    }
  }

  const now = new Date()
  for (const allocation of flag.allocations) {
    if (allocation.startAt && now < new Date(allocation.startAt)) {
      logger.debug(`allocation before start date`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
        startAt: allocation.startAt,
      })
      continue
    }

    if (allocation.endAt && now >= new Date(allocation.endAt)) {
      logger.debug(`allocation after end date`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
        endAt: allocation.endAt,
      })
      continue
    }

    const matched = containsMatchingRule(allocation.rules, subjectAttributes, logger)
    if (!matched) {
      continue
    }

    const selectedSplit = selectSplitUsingSharding(allocation.splits, subjectKey, flag.key, logger)
    if (selectedSplit) {
      const variant = flag.variations[selectedSplit.variationKey]
      if (variant) {
        logger.debug(`evaluated a flag`, {
          flagKey: flag.key,
          subjectKey,
          assignment: variant.value,
        })

        return {
          value: variant.value,
          reason: StandardResolutionReasons.TARGETING_MATCH,
          variant: variant.key,
          flagMetadata: {
            allocationKey: allocation.key,
            variationType: variantTypeToFlagValueType(flag.variationType),
            doLog: !!allocation.doLog,
          },
        }
      }
    } else {
      logger.debug(`no matching split found for subject`, {
        flagKey: flag.key,
        subjectKey,
        allocationKey: allocation.key,
      })
    }
  }

  // This shouldn't happen since a default allocation is generated by the server
  logger.debug(`returning default assignment because no allocation matched`, {
    flagKey: flag.key,
    subjectKey,
  })

  return {
    value: defaultValue,
    reason: StandardResolutionReasons.DEFAULT,
  }
}

function validateTypeMatch(expectedType, variantType) {
  if (expectedType === 'boolean') {
    return variantType === 'BOOLEAN'
  }
  if (expectedType === 'string') {
    return variantType === 'STRING'
  }
  if (expectedType === 'number') {
    return variantType === 'INTEGER' || variantType === 'NUMERIC'
  }
  if (expectedType === 'object') {
    return variantType === 'JSON'
  }
  throw new Error(`Invalid expected type: ${expectedType}`)
}

function containsMatchingRule(rules, subjectAttributes, logger) {
  if (!rules?.length) {
    return true
  }
  logger.debug(`evaluating rules`, {
    rules: JSON.stringify(rules),
    subjectAttributes,
  })
  return rules.some((rule) => matchesRule(rule, subjectAttributes))
}

function selectSplitUsingSharding(splits, subjectKey, flagKey, logger) {
  if (!splits || splits.length === 0) {
    return null
  }

  for (const split of splits) {
    logger.debug(`evaluating split sharding`, {
      flagKey,
      subjectKey,
      variationKey: split.variationKey,
      shards: split.shards,
    })

    const matches = split.shards.every((shard) => {
      const shardMatches = matchesShard(shard, subjectKey)
      logger.debug(`shard match result`, {
        flagKey,
        subjectKey,
        variationKey: split.variationKey,
        shard: shard,
        matches: shardMatches,
      })
      return shardMatches
    })

    if (matches) {
      logger.debug(`subject matches split`, {
        flagKey,
        subjectKey,
        variationKey: split.variationKey,
      })
      return split
    }
  }

  logger.debug(`subject matches no splits`, {
    flagKey,
    subjectKey,
  })

  return null
}

module.exports = {
  evaluateForSubject,
  containsMatchingRule
}