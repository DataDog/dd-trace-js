const { MANUAL_KEEP } = require('../../../../../ext/tags')
const LRU = require('lru-cache')
const VULNERABILITIES_KEY = 'vulnerabilities'
const IAST_JSON_TAG_KEY = '_dd.iast.json'
const VULNERABILITY_HASHES_MAX_SIZE = 1000
const VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE })

function createVulnerability (type, evidence, spanId, location) {
  if (type && evidence && spanId) {
    return {
      type,
      evidence,
      location: {
        spanId,
        ...location
      },
      hash: createHash(type, location)
    }
  }
  return null
}

function createHash (type, location) {
  let hashSource
  if (location) {
    hashSource = `${type}:${location.path}:${location.line}`
  } else {
    hashSource = type
  }
  let hash = 0
  let offset = 0
  const size = hashSource.length
  for (let i = 0; i < size; i++) {
    hash = ((hash << 5) - hash) + hashSource.charCodeAt(offset++)
  }
  return hash
}

function addVulnerability (iastContext, vulnerability) {
  if (iastContext && vulnerability && vulnerability.evidence && vulnerability.type &&
    vulnerability.location && vulnerability.location.spanId) {
    iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || []
    iastContext[VULNERABILITIES_KEY].push(vulnerability)
  }
}

function isValidVulnerability (vulnerability) {
  return vulnerability && vulnerability.type &&
    vulnerability.evidence && vulnerability.evidence.value &&
    vulnerability.location && vulnerability.location.spanId
}

function formatEvidence (evidence) {
  if (!evidence.ranges) {
    return { value: evidence.value }
  }

  const valueParts = []
  let fromIndex = 0
  for (const range of evidence.ranges) {
    if (fromIndex < range.start) {
      valueParts.push({ value: evidence.value.substring(fromIndex, range.start) })
    }
    valueParts.push({ value: evidence.value.substring(range.start, range.end), source: 0 })
    fromIndex = range.end
  }
  if (fromIndex < evidence.value.length - 1) {
    valueParts.push({ value: evidence.value.substring(fromIndex) })
  }
  return { valueParts }
}

function jsonVulnerabilityFromVulnerability (vulnerability) {
  const jsonVulnerability = {
    type: vulnerability.type,
    hash: vulnerability.hash,
    evidence: formatEvidence(vulnerability.evidence),
    location: {
      spanId: vulnerability.location.spanId
    }
  }
  if (vulnerability.location.path) {
    jsonVulnerability.location.path = vulnerability.location.path
  }
  if (vulnerability.location.line) {
    jsonVulnerability.location.line = vulnerability.location.line
  }
  return jsonVulnerability
}

function sendVulnerabilities (iastContext) {
  if (iastContext && iastContext.rootSpan && iastContext[VULNERABILITIES_KEY] &&
    iastContext[VULNERABILITIES_KEY].length && iastContext.rootSpan.addTags) {
    const span = iastContext.rootSpan
    const allVulnerabilities = iastContext[VULNERABILITIES_KEY]
    // TODO support sources and ranges
    const jsonToSend = {
      vulnerabilities: []
    }

    deduplicateVulnerabilities(allVulnerabilities).forEach((vulnerability) => {
      if (isValidVulnerability(vulnerability)) {
        jsonToSend.vulnerabilities.push(jsonVulnerabilityFromVulnerability(vulnerability))
      }
    })

    if (jsonToSend.vulnerabilities.length > 0) {
      const tags = {}
      // TODO: Store this outside of the span and set the tag in the exporter.
      tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend)
      tags[MANUAL_KEEP] = 'true'
      span.addTags(tags)
    }
  }
  return IAST_JSON_TAG_KEY
}

function clearCache () { // only for test purposes
  VULNERABILITY_HASHES.clear()
}

function deduplicateVulnerabilities (vulnerabilities) {
  const deduplicated = vulnerabilities.filter((vulnerability) => {
    const key = `${vulnerability.type}${vulnerability.hash}`
    if (!VULNERABILITY_HASHES.get(key)) {
      VULNERABILITY_HASHES.set(key, true)
      return true
    }
    return false
  })
  return deduplicated
}

module.exports = {
  createVulnerability,
  addVulnerability,
  sendVulnerabilities,
  clearCache
}
