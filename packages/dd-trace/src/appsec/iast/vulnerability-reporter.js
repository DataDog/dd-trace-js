const { MANUAL_KEEP } = require('../../../../../ext/tags')
const LRU = require('lru-cache')
const VULNERABILITIES_KEY = 'vulnerabilities'
const IAST_JSON_TAG_KEY = '_dd.iast.json'
const VULNERABILITY_HASHES_MAX_SIZE = 1000
const VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE })

let tracer

function createVulnerability (type, evidence, spanId, location) {
  if (type && evidence) {
    const _spanId = spanId || 0
    return {
      type,
      evidence,
      location: {
        spanId: _spanId,
        ...location
      },
      hash: createHash(type, location)
    }
  }
  return null
}

function createHash (type, location) {
  let hashSource
  if (location) {
    hashSource = `${type}:${location.path}:${location.line}`
  } else {
    hashSource = type
  }
  let hash = 0
  let offset = 0
  const size = hashSource.length
  for (let i = 0; i < size; i++) {
    hash = ((hash << 5) - hash) + hashSource.charCodeAt(offset++)
  }
  return hash
}

function addVulnerability (iastContext, vulnerability) {
  if (vulnerability && vulnerability.evidence && vulnerability.type &&
    vulnerability.location) {
    if (iastContext && iastContext.rootSpan) {
      iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || []
      iastContext[VULNERABILITIES_KEY].push(vulnerability)
    } else {
      sendVulnerabilities([vulnerability])
    }
  }
}

function isValidVulnerability (vulnerability) {
  return vulnerability && vulnerability.type &&
    vulnerability.evidence && vulnerability.evidence.value &&
    vulnerability.location && vulnerability.location.spanId
}

function formatEvidence (evidence, sourcesIndexes) {
  if (!evidence.ranges) {
    return { value: evidence.value }
  }

  const valueParts = []
  let fromIndex = 0
  evidence.ranges.forEach((range, rangeIndex) => {
    if (fromIndex < range.start) {
      valueParts.push({ value: evidence.value.substring(fromIndex, range.start) })
    }
    valueParts.push({ value: evidence.value.substring(range.start, range.end), source: sourcesIndexes[rangeIndex] })
    fromIndex = range.end
  })
  if (fromIndex < evidence.value.length) {
    valueParts.push({ value: evidence.value.substring(fromIndex) })
  }
  return { valueParts }
}

function extractSourcesFromVulnerability (vulnerability) {
  if (!vulnerability.evidence.ranges) {
    return []
  }
  return vulnerability.evidence.ranges.map(range => (
    {
      origin: range.iinfo.type,
      name: range.iinfo.parameterName,
      value: range.iinfo.parameterValue
    }
  ))
}

function jsonVulnerabilityFromVulnerability (vulnerability, sourcesIndexes) {
  const jsonVulnerability = {
    type: vulnerability.type,
    hash: vulnerability.hash,
    evidence: formatEvidence(vulnerability.evidence, sourcesIndexes),
    location: {
      spanId: vulnerability.location.spanId
    }
  }
  if (vulnerability.location.path) {
    jsonVulnerability.location.path = vulnerability.location.path
  }
  if (vulnerability.location.line) {
    jsonVulnerability.location.line = vulnerability.location.line
  }
  return jsonVulnerability
}

function sendVulnerabilities (vulnerabilities, rootSpan) {
  if (vulnerabilities && vulnerabilities.length) {
    let span = rootSpan
    if (!span && tracer) {
      span = tracer.startSpan('vulnerability', {
        type: 'vulnerability'
      })
      vulnerabilities.forEach((vulnerability) => {
        vulnerability.location.spanId = span.context().toSpanId()
      })
    }

    if (span && span.addTags) {
      const jsonToSend = {
        sources: [],
        vulnerabilities: []
      }

      deduplicateVulnerabilities(vulnerabilities).forEach((vulnerability) => {
        if (isValidVulnerability(vulnerability)) {
          const sourcesIndexes = []
          const vulnerabilitySources = extractSourcesFromVulnerability(vulnerability)
          vulnerabilitySources.forEach((source) => {
            let sourceIndex = jsonToSend.sources.findIndex(
              existingSource =>
                existingSource.origin === source.origin &&
                existingSource.name === source.name &&
                existingSource.value === source.value
            )
            if (sourceIndex === -1) {
              sourceIndex = jsonToSend.sources.length
              jsonToSend.sources.push(source)
            }
            sourcesIndexes.push(sourceIndex)
          })
          jsonToSend.vulnerabilities.push(jsonVulnerabilityFromVulnerability(vulnerability, sourcesIndexes))
        }
      })

      if (jsonToSend.vulnerabilities.length > 0) {
        const tags = {}
        // TODO: Store this outside of the span and set the tag in the exporter.
        tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend)
        tags[MANUAL_KEEP] = 'true'
        span.addTags(tags)
        if (!rootSpan) span.finish()
      }
    }
  }
  return IAST_JSON_TAG_KEY
}

function clearCache () { // only for test purposes
  VULNERABILITY_HASHES.clear()
}

function deduplicateVulnerabilities (vulnerabilities) {
  const deduplicated = vulnerabilities.filter((vulnerability) => {
    const key = `${vulnerability.type}${vulnerability.hash}`
    if (!VULNERABILITY_HASHES.get(key)) {
      VULNERABILITY_HASHES.set(key, true)
      return true
    }
    return false
  })
  return deduplicated
}

function setTracer (_tracer) {
  tracer = _tracer
}

module.exports = {
  createVulnerability,
  addVulnerability,
  sendVulnerabilities,
  clearCache,
  setTracer
}
