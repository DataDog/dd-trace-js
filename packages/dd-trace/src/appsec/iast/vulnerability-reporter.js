'use strict'

const LRU = require('lru-cache')
const vulnerabilitiesFormatter = require('./vulnerabilities-formatter')
const { IAST_ENABLED_TAG_KEY, IAST_JSON_TAG_KEY } = require('./tags')
const standalone = require('../standalone')
const { SAMPLING_MECHANISM_APPSEC } = require('../../constants')
const { keepTrace } = require('../../priority_sampler')

const VULNERABILITIES_KEY = 'vulnerabilities'
const VULNERABILITY_HASHES_MAX_SIZE = 1000
const VULNERABILITY_HASHES = new LRU({ max: VULNERABILITY_HASHES_MAX_SIZE })
const RESET_VULNERABILITY_CACHE_INTERVAL = 60 * 60 * 1000 // 1 hour

let tracer
let resetVulnerabilityCacheTimer
let deduplicationEnabled = true

function addVulnerability (iastContext, vulnerability) {
  if (vulnerability?.evidence && vulnerability?.type && vulnerability?.location) {
    if (deduplicationEnabled && isDuplicatedVulnerability(vulnerability)) return

    VULNERABILITY_HASHES.set(`${vulnerability.type}${vulnerability.hash}`, true)

    let span = iastContext?.rootSpan

    if (!span && tracer) {
      span = tracer.startSpan('vulnerability', {
        type: 'vulnerability'
      })

      vulnerability.location.spanId = span.context().toSpanId()

      span.addTags({
        [IAST_ENABLED_TAG_KEY]: 1
      })
    }

    if (!span) return

    keepTrace(span, SAMPLING_MECHANISM_APPSEC)
    standalone.sample(span)

    if (iastContext?.rootSpan) {
      iastContext[VULNERABILITIES_KEY] = iastContext[VULNERABILITIES_KEY] || []
      iastContext[VULNERABILITIES_KEY].push(vulnerability)
    } else {
      sendVulnerabilities([vulnerability], span)
      span.finish()
    }
  }
}

function isValidVulnerability (vulnerability) {
  return vulnerability && vulnerability.type &&
    vulnerability.evidence &&
    vulnerability.location && vulnerability.location.spanId
}

function sendVulnerabilities (vulnerabilities, span) {
  if (vulnerabilities && vulnerabilities.length) {
    if (span && span.addTags) {
      const validatedVulnerabilities = vulnerabilities.filter(isValidVulnerability)
      const jsonToSend = vulnerabilitiesFormatter.toJson(validatedVulnerabilities)

      if (jsonToSend.vulnerabilities.length > 0) {
        const tags = {}
        // TODO: Store this outside of the span and set the tag in the exporter.
        tags[IAST_JSON_TAG_KEY] = JSON.stringify(jsonToSend)
        span.addTags(tags)
      }
    }
  }
  return IAST_JSON_TAG_KEY
}

function clearCache () { // only for test purposes
  VULNERABILITY_HASHES.clear()
}

function startClearCacheTimer () {
  resetVulnerabilityCacheTimer = setInterval(clearCache, RESET_VULNERABILITY_CACHE_INTERVAL)
  resetVulnerabilityCacheTimer.unref()
}

function stopClearCacheTimer () {
  if (resetVulnerabilityCacheTimer) {
    clearInterval(resetVulnerabilityCacheTimer)
    resetVulnerabilityCacheTimer = null
  }
}

function isDuplicatedVulnerability (vulnerability) {
  return VULNERABILITY_HASHES.get(`${vulnerability.type}${vulnerability.hash}`)
}

function start (config, _tracer) {
  deduplicationEnabled = config.iast.deduplicationEnabled
  vulnerabilitiesFormatter.setRedactVulnerabilities(
    config.iast.redactionEnabled,
    config.iast.redactionNamePattern,
    config.iast.redactionValuePattern
  )
  if (deduplicationEnabled) {
    startClearCacheTimer()
  }
  tracer = _tracer
}

function stop () {
  stopClearCacheTimer()
}

module.exports = {
  addVulnerability,
  sendVulnerabilities,
  clearCache,
  start,
  stop
}
