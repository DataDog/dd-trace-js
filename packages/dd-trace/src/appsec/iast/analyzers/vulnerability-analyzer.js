'use strict'

const { storage } = require('../../../../../datadog-core')
const { getNonDDCallSiteFrames } = require('../path-line')
const { addVulnerability, canAddVulnerability, getVulnerabilityCallSiteFrames } = require('../vulnerability-reporter')
const { getIastContext, getIastStackTraceId } = require('../iast-context')
const overheadController = require('../overhead-controller')
const { SinkIastPlugin } = require('../iast-plugin')
const { getOriginalPathAndLineFromSourceMap } = require('../taint-tracking/rewriter')

class Analyzer extends SinkIastPlugin {
  constructor (type) {
    super()
    this._type = type
  }

  _isVulnerable (value, context) {
    return false
  }

  _isExcluded (location) {
    return false
  }

  _report (value, context, meta) {
    const evidence = this._getEvidence(value, context, meta)
    this._reportEvidence(value, context, evidence)
  }

  _reportEvidence (value, context, evidence) {
    const callSiteFrames = getVulnerabilityCallSiteFrames()
    const nonDDCallSiteFrames = getNonDDCallSiteFrames(callSiteFrames, this._getExcludedPaths())

    const location = this._getLocation(value, nonDDCallSiteFrames)

    if (!this._isExcluded(location)) {
      const originalLocation = this._getOriginalLocation(location)
      const spanId = context && context.rootSpan && context.rootSpan.context().toSpanId()
      const stackId = getIastStackTraceId(context)
      const vulnerability = this._createVulnerability(
        this._type,
        evidence,
        spanId,
        originalLocation,
        stackId
      )

      if (canAddVulnerability(vulnerability)) {
        const originalCallSiteList = nonDDCallSiteFrames.map(callsite => this._replaceCallsiteFromSourceMap(callsite))

        addVulnerability(context, vulnerability, originalCallSiteList, stackId)
      }
    }
  }

  _reportIfVulnerable (value, context, meta) {
    if (this._isVulnerable(value, context) && this._checkOCE(context, value)) {
      this._report(value, context, meta)
      return true
    }
    return false
  }

  _getEvidence (value) {
    return { value }
  }

  _getLocation (value, callSiteFrames) {
    return callSiteFrames[0]
  }

  _getOriginalLocation (location) {
    const locationFromSourceMap = this._replaceCallsiteFromSourceMap(location)
    const originalLocation = {}

    if (locationFromSourceMap?.path) {
      originalLocation.path = locationFromSourceMap.path
    }
    if (locationFromSourceMap?.line) {
      originalLocation.line = locationFromSourceMap.line
    }
    if (locationFromSourceMap?.column) {
      originalLocation.column = locationFromSourceMap.column
    }

    return originalLocation
  }

  _replaceCallsiteFromSourceMap (callsite) {
    if (callsite) {
      const { path, line, column } = getOriginalPathAndLineFromSourceMap(callsite)
      if (path) {
        callsite.file = path
        callsite.path = path
      }
      if (line) {
        callsite.line = line
      }
      if (column) {
        callsite.column = column
      }
    }

    return callsite
  }

  _getExcludedPaths () {}

  _isInvalidContext (store, iastContext) {
    return store && !iastContext
  }

  analyze (value, store = storage.getStore(), meta) {
    const iastContext = getIastContext(store)
    if (this._isInvalidContext(store, iastContext)) return

    this._reportIfVulnerable(value, iastContext, meta)
  }

  analyzeAll (...values) {
    const store = storage.getStore()
    const iastContext = getIastContext(store)
    if (this._isInvalidContext(store, iastContext)) return

    for (let i = 0; i < values.length; i++) {
      const value = values[i]
      if (this._isVulnerable(value, iastContext)) {
        if (this._checkOCE(iastContext, value)) {
          this._report(value, iastContext)
        }
        break
      }
    }
  }

  _checkOCE (context) {
    return overheadController.hasQuota(overheadController.OPERATIONS.REPORT_VULNERABILITY, context)
  }

  _createVulnerability (type, evidence, spanId, location, stackId) {
    if (type && evidence) {
      const _spanId = spanId || 0
      return {
        type,
        evidence,
        stackId,
        location: {
          spanId: _spanId,
          ...location
        },
        hash: this._createHash(this._createHashSource(type, evidence, location))
      }
    }
    return null
  }

  _createHashSource (type, evidence, location) {
    return location ? `${type}:${location.path}:${location.line}` : type
  }

  _createHash (hashSource) {
    let hash = 0
    let offset = 0
    const size = hashSource.length
    for (let i = 0; i < size; i++) {
      hash = ((hash << 5) - hash) + hashSource.charCodeAt(offset++)
    }
    return hash
  }

  addSub (iastSubOrChannelName, handler) {
    const iastSub = typeof iastSubOrChannelName === 'string'
      ? { channelName: iastSubOrChannelName }
      : iastSubOrChannelName

    super.addSub({ tag: this._type, ...iastSub }, handler)
  }
}

module.exports = Analyzer
