'use strict'

const vulnerabilityFormatter = require('../../../../src/appsec/iast/vulnerabilities-formatter')
const sensitiveHandler =
  require('../../../../src/appsec/iast/vulnerabilities-formatter/evidence-redaction/sensitive-handler')

const { suite } = require('./resources/evidence-redaction-suite.json')

function doTest (testCase, parameters) {
  let { description, input, expected } = testCase
  if (parameters) {
    parameters.forEach(parameter => {
      description = description.split(parameter.name).join(parameter.value)
      input = JSON.parse(JSON.stringify(input).split(parameter.name).join(parameter.value))
      expected = JSON.parse(JSON.stringify(expected).split(parameter.name).join(parameter.value))
    })
  }

  it(description, () => {
    const testInput = input.map(i => (
      {
        ...i,
        location: {}
      }
    ))
    const formattedVulnerabilities = vulnerabilityFormatter.toJson(testInput)
    const vulnerabilitiesToCompare = formattedVulnerabilities.vulnerabilities.map(v => (
      {
        type: v.type,
        evidence: v.evidence
      }
    ))
    expect(vulnerabilitiesToCompare).to.deep.equal(expected.vulnerabilities, 'Vulnerabilities does not match')

    if (expected.sources) {
      expect(formattedVulnerabilities.sources).to.deep.equal(expected.sources, 'Sources does not match')
    }
  })
}

function extractTestParameters (testCase) {
  let testsParameters = []
  for (const name in testCase.parameters) {
    const params = []
    testCase.parameters[name].forEach(value => {
      params.push({ name, value })
    })

    if (testsParameters.length === 0) {
      testsParameters.push(...params.map(p => [p]))
    } else {
      const newTestsParameter = []
      params.forEach(param => {
        testsParameters.forEach(testParameters => {
          newTestsParameter.push([param, ...testParameters])
        })
      })
      testsParameters = newTestsParameter
    }
  }
  return testsParameters
}

describe('Vulnerability formatter', () => {
  describe('Vulnerability redaction', () => {
    suite.filter(testCase => testCase.type === 'VULNERABILITIES' && testCase.input[0]?.type !== 'XSS')
      .forEach((testCase) => {
        if (!testCase.parameters) {
          doTest(testCase)
        } else {
          const testsParameters = extractTestParameters(testCase)
          testsParameters.forEach(testParameters => {
            doTest(testCase, testParameters)
          })
        }
      })
  })

  describe('toJson', () => {
    it('should filter out column property from location', () => {
      const vulnerabilities = [{
        type: 'test-vulnerability',
        evidence: {
          value: 'payload'
        },
        location: {
          path: 'path',
          line: 42,
          column: 3
        }
      }]

      const json = vulnerabilityFormatter.toJson(vulnerabilities)
      expect(json.vulnerabilities[0].location.column).to.be.undefined
    })
  })

  describe('Custom redaction patterns', () => {
    beforeEach(() => {
      sinon.stub(sensitiveHandler, 'setRedactionPatterns')
    })

    afterEach(() => {
      sinon.restore()
    })

    it('should set custom redaction patterns', () => {
      vulnerabilityFormatter.setRedactVulnerabilities(true, 'customNamePattern', 'customValuePattern')

      expect(sensitiveHandler.setRedactionPatterns)
        .to.have.been.calledOnceWithExactly('customNamePattern', 'customValuePattern')
    })
  })
})
